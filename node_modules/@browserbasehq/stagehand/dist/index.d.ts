import { EventEmitter } from 'events';
import { ZodTypeAny, z, ZodObject, ZodRawShape, ZodError } from 'zod';
import * as z3 from 'zod/v3';
import { ClientOptions as ClientOptions$2 } from '@anthropic-ai/sdk';
import { GoogleVertexProviderSettings as GoogleVertexProviderSettings$1 } from '@ai-sdk/google-vertex';
import { LanguageModelV2 } from '@ai-sdk/provider';
import { ClientOptions as ClientOptions$1 } from 'openai';
import { Client, ClientOptions as ClientOptions$3 } from '@modelcontextprotocol/sdk/client/index.js';
import * as ai from 'ai';
import { ToolSet, ModelMessage, PrepareStepFunction, GenerateTextOnStepFinishCallback, StreamTextOnStepFinishCallback, StreamTextOnErrorCallback, StreamTextOnChunkCallback, StreamTextOnFinishCallback, StepResult, StreamTextResult, wrapLanguageModel, generateObject, generateText, streamText, streamObject, experimental_generateImage, embed, embedMany, experimental_transcribe, experimental_generateSpeech, InferUITools } from 'ai';
export { ModelMessage } from 'ai';
import { Page as Page$1 } from 'playwright-core';
export { Page as PlaywrightPage } from 'playwright-core';
import { Page as Page$2 } from 'puppeteer-core';
export { Page as PuppeteerPage } from 'puppeteer-core';
import { Page as Page$3 } from 'patchright-core';
export { Page as PatchrightPage } from 'patchright-core';
import { Protocol } from 'devtools-protocol';
import { Buffer as Buffer$1 } from 'buffer';
import { z as z$1 } from 'zod/v4';
import { ChatCompletion } from 'openai/resources';
import { ToolSet as ToolSet$1 } from 'ai/dist';
import { Schema } from '@google/genai';

type StagehandZodSchema = ZodTypeAny | z3.ZodTypeAny;
type StagehandZodObject = ZodObject<ZodRawShape> | z3.ZodObject<z3.ZodRawShape>;
type InferStagehandSchema<T extends StagehandZodSchema> = T extends z3.ZodTypeAny ? z3.infer<T> : T extends ZodTypeAny ? z.infer<T> : never;
declare const isZod4Schema: (schema: StagehandZodSchema) => schema is ZodTypeAny & {
    _zod: unknown;
};
declare const isZod3Schema: (schema: StagehandZodSchema) => schema is z3.ZodTypeAny;
type JsonSchemaDocument = Record<string, unknown>;
declare function toJsonSchema(schema: StagehandZodSchema): JsonSchemaDocument;

type LogLevel = 0 | 1 | 2;
/**
 * Mapping between numeric log levels and their names
 *
 * 0 - error/warn - Critical issues or important warnings
 * 1 - info - Standard information messages
 * 2 - debug - Detailed information for debugging
 */
declare const LOG_LEVEL_NAMES: Record<LogLevel, string>;
type LogLine = {
    id?: string;
    category?: string;
    message: string;
    level?: LogLevel;
    timestamp?: string;
    auxiliary?: {
        [key: string]: {
            value: string;
            type: "object" | "string" | "html" | "integer" | "float" | "boolean";
        };
    };
};
type Logger = (logLine: LogLine) => void;

/**
 * CDP transport & session multiplexer
 *
 * Owns the browser WebSocket and multiplexes flattened Target sessions.
 * Tracks inflight CDP calls, routes responses to the right session, and forwards events.
 *
 * This does not interpret Page/DOM/Runtime semantics — callers own that logic.
 */
interface CDPSessionLike {
    send<R = unknown>(method: string, params?: object): Promise<R>;
    on<P = unknown>(event: string, handler: (params: P) => void): void;
    off<P = unknown>(event: string, handler: (params: P) => void): void;
    close(): Promise<void>;
    readonly id: string | null;
}
type EventHandler = (params: unknown) => void;
declare class CdpConnection implements CDPSessionLike {
    private ws;
    private nextId;
    private inflight;
    private eventHandlers;
    private sessions;
    /** Maps sessionId -> targetId (1:1 mapping) */
    private sessionToTarget;
    readonly id: string | null;
    private transportCloseHandlers;
    /** Optional CDP logger - set this to receive all outgoing CDP method calls */
    cdpLogger?: (info: {
        method: string;
        params?: object;
        targetId?: string | null;
    }) => void;
    /** Optional CDP event logger - set this to receive all incoming CDP events */
    cdpEventLogger?: (info: {
        method: string;
        params?: unknown;
        targetId?: string | null;
    }) => void;
    onTransportClosed(handler: (why: string) => void): void;
    offTransportClosed(handler: (why: string) => void): void;
    private emitTransportClosed;
    private constructor();
    static connect(wsUrl: string): Promise<CdpConnection>;
    enableAutoAttach(): Promise<void>;
    send<R = unknown>(method: string, params?: object): Promise<R>;
    on<P = unknown>(event: string, handler: (params: P) => void): void;
    off<P = unknown>(event: string, handler: (params: P) => void): void;
    close(): Promise<void>;
    getSession(sessionId: string): CdpSession | undefined;
    attachToTarget(targetId: string): Promise<CdpSession>;
    getTargets(): Promise<Protocol.Target.TargetInfo[]>;
    private onMessage;
    _sendViaSession<R = unknown>(sessionId: string, method: string, params?: object): Promise<R>;
    _onSessionEvent(sessionId: string, event: string, handler: EventHandler): void;
    _offSessionEvent(sessionId: string, event: string, handler: EventHandler): void;
    _dispatchToSession(sessionId: string, event: string, params: unknown): void;
}
declare class CdpSession implements CDPSessionLike {
    private readonly root;
    readonly id: string;
    constructor(root: CdpConnection, id: string);
    send<R = unknown>(method: string, params?: object): Promise<R>;
    on<P = unknown>(event: string, handler: (params: P) => void): void;
    off<P = unknown>(event: string, handler: (params: P) => void): void;
    close(): Promise<void>;
    dispatch(event: string, params: unknown): void;
}

interface FrameManager {
    session: CDPSessionLike;
    frameId: string;
    pageId: string;
}
/**
 * Frame
 *
 * A thin, session-bound handle to a specific DOM frame (by frameId).
 * All CDP calls in this class go through `this.session`, which MUST be the
 * owning session for `this.frameId`. Page is responsible for constructing
 * Frames with the correct session.
 */
declare class Frame implements FrameManager {
    session: CDPSessionLike;
    frameId: string;
    pageId: string;
    private readonly remoteBrowser;
    /** Owning CDP session id (useful for logs); null for root connection (should not happen for targets) */
    readonly sessionId: string | null;
    constructor(session: CDPSessionLike, frameId: string, pageId: string, remoteBrowser: boolean);
    /** True when the controlled browser runs on a different machine. */
    isBrowserRemote(): boolean;
    /** DOM.getNodeForLocation → DOM.describeNode */
    getNodeAtLocation(x: number, y: number): Promise<Protocol.DOM.Node>;
    /** CSS selector → DOM.querySelector → DOM.getBoxModel */
    getLocationForSelector(selector: string): Promise<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    /** Accessibility.getFullAXTree (+ recurse into child frames if requested) */
    getAccessibilityTree(withFrames?: boolean): Promise<Protocol.Accessibility.AXNode[]>;
    /**
     * Evaluate a function or expression in this frame's main world.
     * - If a string is provided, treated as a JS expression.
     * - If a function is provided, it is stringified and invoked with the optional argument.
     */
    evaluate<R = unknown, Arg = unknown>(pageFunctionOrExpression: string | ((arg: Arg) => R | Promise<R>), arg?: Arg): Promise<R>;
    /** Page.captureScreenshot (frame-scoped session) */
    screenshot(options?: {
        fullPage?: boolean;
        clip?: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        type?: "png" | "jpeg";
        quality?: number;
        scale?: number;
    }): Promise<Buffer>;
    /** Child frames via Page.getFrameTree */
    childFrames(): Promise<Frame[]>;
    /** Wait for a lifecycle state (load/domcontentloaded/networkidle) */
    waitForLoadState(state?: "load" | "domcontentloaded" | "networkidle", timeoutMs?: number): Promise<void>;
    /** Simple placeholder for your own locator abstraction */
    locator(selector: string, options?: {
        deep?: boolean;
        depth?: number;
    }): Locator;
    /** Resolve the main-world execution context id for this frame. */
    private getMainWorldExecutionContextId;
}

interface SetInputFilePayload {
    name: string;
    mimeType?: string;
    buffer: ArrayBuffer | Uint8Array | Buffer$1 | string;
    lastModified?: number;
}
type SetInputFilesArgument = string | string[] | SetInputFilePayload | SetInputFilePayload[];

type MouseButton = "left" | "right" | "middle";
/**
 * Locator
 *
 * Purpose:
 * A small, CDP-based element interaction helper scoped to a specific `Frame`.
 * It resolves a CSS/XPath selector inside the frame’s **isolated world**, and then
 * performs low-level actions (click, type, select) using DOM/Runtime/Input
 * protocol domains with minimal abstraction.
 *
 * Key change:
 * - Prefer **objectId**-based CDP calls (scroll, geometry) to avoid brittle
 *   frontend nodeId mappings. nodeId is resolved on a best-effort basis and
 *   returned for compatibility, but actions do not depend on it.
 *
 * Notes:
 * - Resolution is lazy: every action resolves the selector again.
 * - Uses `Page.createIsolatedWorld` so evaluation is isolated from page scripts.
 * - Releases remote objects (`Runtime.releaseObject`) where appropriate.
 */
declare class Locator {
    private readonly frame;
    private readonly selector;
    private readonly options?;
    private readonly selectorResolver;
    private readonly selectorQuery;
    private readonly nthIndex;
    constructor(frame: Frame, selector: string, options?: {
        deep?: boolean;
        depth?: number;
    }, nthIndex?: number);
    /** Return the owning Frame for this locator (typed accessor, no private access). */
    getFrame(): Frame;
    /**
     * Set files on an <input type="file"> element.
     *
     * Mirrors Playwright's Locator.setInputFiles basics:
     * - Accepts file path(s) or payload object(s) { name, mimeType, buffer }.
     * - Uses CDP DOM.setFileInputFiles under the hood.
     * - Best‑effort dispatches change/input via CDP (Chrome does by default).
     * - Passing an empty array clears the selection.
     */
    setInputFiles(files: SetInputFilesArgument): Promise<void>;
    /**
     * Remote browser fallback: build File objects inside the page and attach them via JS.
     *
     * When Stagehand is driving a browser that cannot see the local filesystem (Browserbase,
     * remote CDP, etc.), CDP's DOM.setFileInputFiles would fail because Chrome can't reach
     * our temp files. Instead we base64-encode the payloads, send them into the page, and
     * let a DOM helper create File objects + dispatch change/input events.
     */
    private assignFilesViaPayloadInjection;
    /**
     * Return the DOM backendNodeId for this locator's target element.
     * Useful for identity comparisons without needing element handles.
     */
    backendNodeId(): Promise<Protocol.DOM.BackendNodeId>;
    /** Return how many nodes the current selector resolves to. */
    count(): Promise<number>;
    /**
     * Return the center of the element's bounding box in the owning frame's viewport
     * (CSS pixels), rounded to integers. Scrolls into view best-effort.
     */
    centroid(): Promise<{
        x: number;
        y: number;
    }>;
    /**
     * Highlight the element's bounding box using the CDP Overlay domain.
     * - Scrolls element into view best-effort.
     * - Shows a semi-transparent overlay briefly, then hides it.
     */
    highlight(options?: {
        durationMs?: number;
        borderColor?: {
            r: number;
            g: number;
            b: number;
            a?: number;
        };
        contentColor?: {
            r: number;
            g: number;
            b: number;
            a?: number;
        };
    }): Promise<void>;
    /**
     * Move the mouse cursor to the element's visual center without clicking.
     * - Scrolls into view best-effort, resolves geometry, then dispatches a mouse move.
     */
    hover(): Promise<void>;
    /**
     * Click the element at its visual center.
     * Steps:
     *  1) Resolve selector to { objectId } in the frame world.
     *  2) Scroll into view via `DOM.scrollIntoViewIfNeeded({ objectId })`.
     *  3) Read geometry via `DOM.getBoxModel({ objectId })` → compute a center point.
     *  4) Synthesize mouse press + release via `Input.dispatchMouseEvent`.
     */
    click(options?: {
        button?: MouseButton;
        clickCount?: number;
    }): Promise<void>;
    /**
     * Dispatch a DOM 'click' MouseEvent on the element itself.
     * - Does not synthesize real pointer input; directly dispatches an event.
     * - Useful for elements that rely on click handlers without needing hit-testing.
     */
    sendClickEvent(options?: {
        bubbles?: boolean;
        cancelable?: boolean;
        composed?: boolean;
        detail?: number;
    }): Promise<void>;
    /**
     * Scroll the element vertically to a given percentage (0–100).
     * - If the element is <html> or <body>, scrolls the window/document.
     * - Otherwise, scrolls the element itself via element.scrollTo.
     */
    scrollTo(percent: number | string): Promise<void>;
    /**
     * Fill an input/textarea/contenteditable element.
     * Mirrors Playwright semantics: the DOM helper either applies the native
     * value setter (for special input types) or asks us to type text via the CDP
     * Input domain after focusing/selecting.
     */
    fill(value: string): Promise<void>;
    /**
     * Type text into the element (focuses first).
     * - Focus via element.focus() in page JS (no DOM.focus(nodeId)).
     * - If no delay, uses `Input.insertText` for efficiency.
     * - With delay, synthesizes `keyDown`/`keyUp` per character.
     */
    type(text: string, options?: {
        delay?: number;
    }): Promise<void>;
    /**
     * Select one or more options on a `<select>` element.
     * Returns the values actually selected after the operation.
     */
    selectOption(values: string | string[]): Promise<string[]>;
    /**
     * Return true if the element is attached and visible (rough heuristic).
     */
    isVisible(): Promise<boolean>;
    /**
     * Return true if the element is an input[type=checkbox|radio] and is checked.
     * Also considers aria-checked for ARIA widgets.
     */
    isChecked(): Promise<boolean>;
    /**
     * Return the element's input value (for input/textarea/select/contenteditable).
     */
    inputValue(): Promise<string>;
    /**
     * Return the element's textContent (raw, not innerText).
     */
    textContent(): Promise<string>;
    /**
     * Return the element's innerHTML string.
     */
    innerHtml(): Promise<string>;
    /**
     * Return the element's innerText (layout-aware, visible text).
     */
    innerText(): Promise<string>;
    /**
     * For API parity, returns the same locator (querySelector already returns the first match).
     */
    first(): Locator;
    /** Return a locator narrowed to the element at the given zero-based index. */
    nth(index: number): Locator;
    /**
     * Resolve `this.selector` within the frame to `{ objectId, nodeId? }`:
     * Delegates to a shared selector resolver so all selector logic stays in sync.
     */
    resolveNode(): Promise<{
        nodeId: Protocol.DOM.NodeId | null;
        objectId: Protocol.Runtime.RemoteObjectId;
    }>;
    /** Compute a center point from a BoxModel content quad */
    private centerFromBoxContent;
}

/**
 * DeepLocatorDelegate: a lightweight wrapper that looks like a Locator and
 * resolves to the correct frame/element on each call using hop/deep-XPath logic.
 *
 * Returned by `page.deepLocator()` for ergonomic, await-free chaining:
 *   page.deepLocator('iframe#ifrA >> #btn').click()
 */
declare class DeepLocatorDelegate {
    private readonly page;
    private readonly root;
    private readonly selector;
    private readonly nthIndex;
    constructor(page: Page, root: Frame, selector: string, nthIndex?: number);
    private real;
    click(options?: {
        button?: "left" | "right" | "middle";
        clickCount?: number;
    }): Promise<void>;
    count(): Promise<number>;
    hover(): Promise<void>;
    fill(value: string): Promise<void>;
    type(text: string, options?: {
        delay?: number;
    }): Promise<void>;
    selectOption(values: string | string[]): Promise<string[]>;
    scrollTo(percent: number | string): Promise<void>;
    isVisible(): Promise<boolean>;
    isChecked(): Promise<boolean>;
    inputValue(): Promise<string>;
    textContent(): Promise<string>;
    innerHtml(): Promise<string>;
    innerText(): Promise<string>;
    centroid(): Promise<{
        x: number;
        y: number;
    }>;
    backendNodeId(): Promise<number>;
    highlight(options?: {
        durationMs?: number;
        borderColor?: {
            r: number;
            g: number;
            b: number;
            a?: number;
        };
        contentColor?: {
            r: number;
            g: number;
            b: number;
            a?: number;
        };
    }): Promise<void>;
    sendClickEvent(options?: {
        bubbles?: boolean;
        cancelable?: boolean;
        composed?: boolean;
        detail?: number;
    }): Promise<void>;
    setInputFiles(files: string | string[] | {
        name: string;
        mimeType: string;
        buffer: ArrayBuffer | Uint8Array | Buffer | string;
    } | Array<{
        name: string;
        mimeType: string;
        buffer: ArrayBuffer | Uint8Array | Buffer | string;
    }>): Promise<void>;
    first(): DeepLocatorDelegate;
    nth(index: number): DeepLocatorDelegate;
}

/**
 * FrameLocator: resolves iframe elements to their child Frames and allows
 * creating locators scoped to that frame. Supports chaining.
 */
declare class FrameLocator {
    private readonly parent?;
    private readonly selector;
    private readonly page;
    private readonly root?;
    constructor(page: Page, selector: string, parent?: FrameLocator, root?: Frame);
    /** Create a nested FrameLocator under this one. */
    frameLocator(selector: string): FrameLocator;
    /** Resolve to the concrete Frame for this FrameLocator chain. */
    resolveFrame(): Promise<Frame>;
    /** Return a Locator scoped to this frame. Methods delegate to the frame lazily. */
    locator(selector: string): LocatorDelegate;
}
/** A small delegating wrapper that resolves the frame lazily per call. */
declare class LocatorDelegate {
    private readonly fl;
    private readonly sel;
    constructor(fl: FrameLocator, sel: string);
    private real;
    click(options?: {
        button?: "left" | "right" | "middle";
        clickCount?: number;
    }): Promise<void>;
    hover(): Promise<void>;
    fill(value: string): Promise<void>;
    type(text: string, options?: {
        delay?: number;
    }): Promise<void>;
    selectOption(values: string | string[]): Promise<string[]>;
    scrollTo(percent: number | string): Promise<void>;
    isVisible(): Promise<boolean>;
    isChecked(): Promise<boolean>;
    inputValue(): Promise<string>;
    textContent(): Promise<string>;
    innerHtml(): Promise<string>;
    innerText(): Promise<string>;
    count(): Promise<number>;
    first(): LocatorDelegate;
}

type RemoteObject = Protocol.Runtime.RemoteObject;
type ConsoleListener = (message: ConsoleMessage) => void;
declare class ConsoleMessage {
    private readonly event;
    private readonly pageRef?;
    constructor(event: Protocol.Runtime.ConsoleAPICalledEvent, pageRef?: Page);
    type(): Protocol.Runtime.ConsoleAPICalledEvent["type"];
    text(): string;
    args(): RemoteObject[];
    location(): {
        url?: string;
        lineNumber?: number;
        columnNumber?: number;
    };
    page(): Page | undefined;
    timestamp(): number | undefined;
    raw(): Protocol.Runtime.ConsoleAPICalledEvent;
    toString(): string;
}

interface SerializableResponse {
    requestId: string;
    frameId?: string;
    loaderId?: string;
    response: Protocol.Network.Response;
    fromServiceWorkerFlag?: boolean;
    finishedSettled?: boolean;
    extraInfoHeaders?: Protocol.Network.Headers | null;
    extraInfoHeadersText?: string;
}

/**
 * Represents a path through a Zod schema from the root object down to a
 * particular field. The `segments` array describes the chain of keys/indices.
 *
 * - **String** segments indicate object property names.
 * - **Number** segments indicate array indices.
 *
 * For example, `["users", 0, "homepage"]` might describe reaching
 * the `homepage` field in `schema.users[0].homepage`.
 */
interface ZodPathSegments {
    /**
     * The ordered list of keys/indices leading from the schema root
     * to the targeted field.
     */
    segments: Array<string | number>;
}
type InitScriptSource<Arg> = string | {
    path?: string;
    content?: string;
} | ((arg: Arg) => unknown);

type EvaluateOptions = {
    /** The question to ask about the task state */
    question: string;
    /** The answer to the question */
    answer?: string;
    /** Whether to take a screenshot of the task state, or array of screenshots to evaluate */
    screenshot?: boolean | Buffer[];
    /** Custom system prompt for the evaluator */
    systemPrompt?: string;
    /** Delay in milliseconds before taking the screenshot @default 250 */
    screenshotDelayMs?: number;
    /** The agent's reasoning/thought process for completing the task */
    agentReasoning?: string;
};
type BatchAskOptions = {
    /** Array of questions with optional answers */
    questions: Array<{
        question: string;
        answer?: string;
    }>;
    /** Whether to take a screenshot of the task state */
    screenshot?: boolean;
    /** Custom system prompt for the evaluator */
    systemPrompt?: string;
    /** Delay in milliseconds before taking the screenshot @default 1000 */
    screenshotDelayMs?: number;
};
/**
 * Result of an evaluation
 */
interface EvaluationResult {
    /**
     * The evaluation result ('YES', 'NO', or 'INVALID' if parsing failed or value was unexpected)
     */
    evaluation: "YES" | "NO" | "INVALID";
    /**
     * The reasoning behind the evaluation
     */
    reasoning: string;
}

/**
 * Centralized Zod schemas for Stagehand Server API
 *
 * Naming conventions:
 * - `*RequestSchema` - Request body schemas (zod4), `*Request` is the inferred type
 * - `*ResultSchema` - Inner response data (unwrapped), `*Result` is the inferred type
 * - `*ResponseSchema` - Full response with success wrapper: { success: true, data: *Result }, `*Response` is the inferred type
 *
 * All TypeScript types are inferred from the Zod4 *Schemas using z.infer<>
 */

/** Browser launch options for local browsers */
declare const LocalBrowserLaunchOptionsSchema: z$1.ZodObject<{
    args: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
    executablePath: z$1.ZodOptional<z$1.ZodString>;
    userDataDir: z$1.ZodOptional<z$1.ZodString>;
    preserveUserDataDir: z$1.ZodOptional<z$1.ZodBoolean>;
    headless: z$1.ZodOptional<z$1.ZodBoolean>;
    devtools: z$1.ZodOptional<z$1.ZodBoolean>;
    chromiumSandbox: z$1.ZodOptional<z$1.ZodBoolean>;
    ignoreDefaultArgs: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodBoolean, z$1.ZodArray<z$1.ZodString>]>>;
    proxy: z$1.ZodOptional<z$1.ZodObject<{
        server: z$1.ZodString;
        bypass: z$1.ZodOptional<z$1.ZodString>;
        username: z$1.ZodOptional<z$1.ZodString>;
        password: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>>;
    locale: z$1.ZodOptional<z$1.ZodString>;
    viewport: z$1.ZodOptional<z$1.ZodObject<{
        width: z$1.ZodNumber;
        height: z$1.ZodNumber;
    }, z$1.core.$strip>>;
    deviceScaleFactor: z$1.ZodOptional<z$1.ZodNumber>;
    hasTouch: z$1.ZodOptional<z$1.ZodBoolean>;
    ignoreHTTPSErrors: z$1.ZodOptional<z$1.ZodBoolean>;
    cdpUrl: z$1.ZodOptional<z$1.ZodString>;
    connectTimeoutMs: z$1.ZodOptional<z$1.ZodNumber>;
    downloadsPath: z$1.ZodOptional<z$1.ZodString>;
    acceptDownloads: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strict>;
/** Simple model name string */
declare const ModelNameSchema: z$1.ZodString;
/** Detailed model configuration object */
declare const ModelConfigObjectSchema: z$1.ZodObject<{
    provider: z$1.ZodOptional<z$1.ZodEnum<{
        openai: "openai";
        anthropic: "anthropic";
        google: "google";
        microsoft: "microsoft";
    }>>;
    modelName: z$1.ZodString;
    apiKey: z$1.ZodOptional<z$1.ZodString>;
    baseURL: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
/** Model configuration - string model name or detailed config */
declare const ModelConfigSchema: z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
    provider: z$1.ZodOptional<z$1.ZodEnum<{
        openai: "openai";
        anthropic: "anthropic";
        google: "google";
        microsoft: "microsoft";
    }>>;
    modelName: z$1.ZodString;
    apiKey: z$1.ZodOptional<z$1.ZodString>;
    baseURL: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>]>;
/** Action object returned by observe and used by act */
declare const ActionSchema: z$1.ZodObject<{
    selector: z$1.ZodString;
    description: z$1.ZodString;
    backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
    method: z$1.ZodOptional<z$1.ZodString>;
    arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
}, z$1.core.$strip>;
/** Session ID path parameter */
declare const SessionIdParamsSchema: z$1.ZodObject<{
    id: z$1.ZodString;
}, z$1.core.$strict>;
/** Browser configuration for session start */
declare const BrowserConfigSchema: z$1.ZodObject<{
    type: z$1.ZodOptional<z$1.ZodEnum<{
        local: "local";
        browserbase: "browserbase";
    }>>;
    cdpUrl: z$1.ZodOptional<z$1.ZodString>;
    launchOptions: z$1.ZodOptional<z$1.ZodObject<{
        args: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
        executablePath: z$1.ZodOptional<z$1.ZodString>;
        userDataDir: z$1.ZodOptional<z$1.ZodString>;
        preserveUserDataDir: z$1.ZodOptional<z$1.ZodBoolean>;
        headless: z$1.ZodOptional<z$1.ZodBoolean>;
        devtools: z$1.ZodOptional<z$1.ZodBoolean>;
        chromiumSandbox: z$1.ZodOptional<z$1.ZodBoolean>;
        ignoreDefaultArgs: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodBoolean, z$1.ZodArray<z$1.ZodString>]>>;
        proxy: z$1.ZodOptional<z$1.ZodObject<{
            server: z$1.ZodString;
            bypass: z$1.ZodOptional<z$1.ZodString>;
            username: z$1.ZodOptional<z$1.ZodString>;
            password: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>>;
        locale: z$1.ZodOptional<z$1.ZodString>;
        viewport: z$1.ZodOptional<z$1.ZodObject<{
            width: z$1.ZodNumber;
            height: z$1.ZodNumber;
        }, z$1.core.$strip>>;
        deviceScaleFactor: z$1.ZodOptional<z$1.ZodNumber>;
        hasTouch: z$1.ZodOptional<z$1.ZodBoolean>;
        ignoreHTTPSErrors: z$1.ZodOptional<z$1.ZodBoolean>;
        cdpUrl: z$1.ZodOptional<z$1.ZodString>;
        connectTimeoutMs: z$1.ZodOptional<z$1.ZodNumber>;
        downloadsPath: z$1.ZodOptional<z$1.ZodString>;
        acceptDownloads: z$1.ZodOptional<z$1.ZodBoolean>;
    }, z$1.core.$strict>>;
}, z$1.core.$strip>;
/** Operational headers for all session requests (auth handled via security schemes) */
declare const SessionHeadersSchema: z$1.ZodObject<{
    "x-stream-response": z$1.ZodOptional<z$1.ZodEnum<{
        true: "true";
        false: "false";
    }>>;
    "x-language": z$1.ZodOptional<z$1.ZodEnum<{
        typescript: "typescript";
        python: "python";
        playground: "playground";
    }>>;
    "x-sdk-version": z$1.ZodOptional<z$1.ZodString>;
    "x-sent-at": z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
/** Standard error response */
declare const ErrorResponseSchema: z$1.ZodObject<{
    success: z$1.ZodLiteral<false>;
    error: z$1.ZodString;
    code: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strict>;
/** Browserbase viewport configuration */
declare const BrowserbaseViewportSchema: z$1.ZodObject<{
    width: z$1.ZodOptional<z$1.ZodNumber>;
    height: z$1.ZodOptional<z$1.ZodNumber>;
}, z$1.core.$strip>;
/** Browserbase fingerprint screen configuration */
declare const BrowserbaseFingerprintScreenSchema: z$1.ZodObject<{
    maxHeight: z$1.ZodOptional<z$1.ZodNumber>;
    maxWidth: z$1.ZodOptional<z$1.ZodNumber>;
    minHeight: z$1.ZodOptional<z$1.ZodNumber>;
    minWidth: z$1.ZodOptional<z$1.ZodNumber>;
}, z$1.core.$strip>;
/** Browserbase fingerprint configuration for stealth mode */
declare const BrowserbaseFingerprintSchema: z$1.ZodObject<{
    browsers: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
        chrome: "chrome";
        edge: "edge";
        firefox: "firefox";
        safari: "safari";
    }>>>;
    devices: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
        desktop: "desktop";
        mobile: "mobile";
    }>>>;
    httpVersion: z$1.ZodOptional<z$1.ZodEnum<{
        1: "1";
        2: "2";
    }>>;
    locales: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
    operatingSystems: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
        android: "android";
        ios: "ios";
        linux: "linux";
        macos: "macos";
        windows: "windows";
    }>>>;
    screen: z$1.ZodOptional<z$1.ZodObject<{
        maxHeight: z$1.ZodOptional<z$1.ZodNumber>;
        maxWidth: z$1.ZodOptional<z$1.ZodNumber>;
        minHeight: z$1.ZodOptional<z$1.ZodNumber>;
        minWidth: z$1.ZodOptional<z$1.ZodNumber>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
/** Browserbase context configuration for session persistence */
declare const BrowserbaseContextSchema: z$1.ZodObject<{
    id: z$1.ZodString;
    persist: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
/** Browserbase browser settings for session creation */
declare const BrowserbaseBrowserSettingsSchema: z$1.ZodObject<{
    advancedStealth: z$1.ZodOptional<z$1.ZodBoolean>;
    blockAds: z$1.ZodOptional<z$1.ZodBoolean>;
    context: z$1.ZodOptional<z$1.ZodObject<{
        id: z$1.ZodString;
        persist: z$1.ZodOptional<z$1.ZodBoolean>;
    }, z$1.core.$strip>>;
    extensionId: z$1.ZodOptional<z$1.ZodString>;
    fingerprint: z$1.ZodOptional<z$1.ZodObject<{
        browsers: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
            chrome: "chrome";
            edge: "edge";
            firefox: "firefox";
            safari: "safari";
        }>>>;
        devices: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
            desktop: "desktop";
            mobile: "mobile";
        }>>>;
        httpVersion: z$1.ZodOptional<z$1.ZodEnum<{
            1: "1";
            2: "2";
        }>>;
        locales: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
        operatingSystems: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
            android: "android";
            ios: "ios";
            linux: "linux";
            macos: "macos";
            windows: "windows";
        }>>>;
        screen: z$1.ZodOptional<z$1.ZodObject<{
            maxHeight: z$1.ZodOptional<z$1.ZodNumber>;
            maxWidth: z$1.ZodOptional<z$1.ZodNumber>;
            minHeight: z$1.ZodOptional<z$1.ZodNumber>;
            minWidth: z$1.ZodOptional<z$1.ZodNumber>;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>>;
    logSession: z$1.ZodOptional<z$1.ZodBoolean>;
    recordSession: z$1.ZodOptional<z$1.ZodBoolean>;
    solveCaptchas: z$1.ZodOptional<z$1.ZodBoolean>;
    viewport: z$1.ZodOptional<z$1.ZodObject<{
        width: z$1.ZodOptional<z$1.ZodNumber>;
        height: z$1.ZodOptional<z$1.ZodNumber>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
/** Browserbase managed proxy geolocation configuration */
declare const BrowserbaseProxyGeolocationSchema: z$1.ZodObject<{
    country: z$1.ZodString;
    city: z$1.ZodOptional<z$1.ZodString>;
    state: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
/** Browserbase managed proxy configuration */
declare const BrowserbaseProxyConfigSchema: z$1.ZodObject<{
    type: z$1.ZodLiteral<"browserbase">;
    domainPattern: z$1.ZodOptional<z$1.ZodString>;
    geolocation: z$1.ZodOptional<z$1.ZodObject<{
        country: z$1.ZodString;
        city: z$1.ZodOptional<z$1.ZodString>;
        state: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
/** External proxy configuration */
declare const ExternalProxyConfigSchema: z$1.ZodObject<{
    type: z$1.ZodLiteral<"external">;
    server: z$1.ZodString;
    domainPattern: z$1.ZodOptional<z$1.ZodString>;
    username: z$1.ZodOptional<z$1.ZodString>;
    password: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
/** Union of proxy configuration types */
declare const ProxyConfigSchema: z$1.ZodDiscriminatedUnion<[z$1.ZodObject<{
    type: z$1.ZodLiteral<"browserbase">;
    domainPattern: z$1.ZodOptional<z$1.ZodString>;
    geolocation: z$1.ZodOptional<z$1.ZodObject<{
        country: z$1.ZodString;
        city: z$1.ZodOptional<z$1.ZodString>;
        state: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>, z$1.ZodObject<{
    type: z$1.ZodLiteral<"external">;
    server: z$1.ZodString;
    domainPattern: z$1.ZodOptional<z$1.ZodString>;
    username: z$1.ZodOptional<z$1.ZodString>;
    password: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>], "type">;
/** Browserbase session creation parameters */
declare const BrowserbaseSessionCreateParamsSchema: z$1.ZodObject<{
    projectId: z$1.ZodOptional<z$1.ZodString>;
    browserSettings: z$1.ZodOptional<z$1.ZodObject<{
        advancedStealth: z$1.ZodOptional<z$1.ZodBoolean>;
        blockAds: z$1.ZodOptional<z$1.ZodBoolean>;
        context: z$1.ZodOptional<z$1.ZodObject<{
            id: z$1.ZodString;
            persist: z$1.ZodOptional<z$1.ZodBoolean>;
        }, z$1.core.$strip>>;
        extensionId: z$1.ZodOptional<z$1.ZodString>;
        fingerprint: z$1.ZodOptional<z$1.ZodObject<{
            browsers: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                chrome: "chrome";
                edge: "edge";
                firefox: "firefox";
                safari: "safari";
            }>>>;
            devices: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                desktop: "desktop";
                mobile: "mobile";
            }>>>;
            httpVersion: z$1.ZodOptional<z$1.ZodEnum<{
                1: "1";
                2: "2";
            }>>;
            locales: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
            operatingSystems: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                android: "android";
                ios: "ios";
                linux: "linux";
                macos: "macos";
                windows: "windows";
            }>>>;
            screen: z$1.ZodOptional<z$1.ZodObject<{
                maxHeight: z$1.ZodOptional<z$1.ZodNumber>;
                maxWidth: z$1.ZodOptional<z$1.ZodNumber>;
                minHeight: z$1.ZodOptional<z$1.ZodNumber>;
                minWidth: z$1.ZodOptional<z$1.ZodNumber>;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>>;
        logSession: z$1.ZodOptional<z$1.ZodBoolean>;
        recordSession: z$1.ZodOptional<z$1.ZodBoolean>;
        solveCaptchas: z$1.ZodOptional<z$1.ZodBoolean>;
        viewport: z$1.ZodOptional<z$1.ZodObject<{
            width: z$1.ZodOptional<z$1.ZodNumber>;
            height: z$1.ZodOptional<z$1.ZodNumber>;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>>;
    extensionId: z$1.ZodOptional<z$1.ZodString>;
    keepAlive: z$1.ZodOptional<z$1.ZodBoolean>;
    proxies: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodBoolean, z$1.ZodArray<z$1.ZodDiscriminatedUnion<[z$1.ZodObject<{
        type: z$1.ZodLiteral<"browserbase">;
        domainPattern: z$1.ZodOptional<z$1.ZodString>;
        geolocation: z$1.ZodOptional<z$1.ZodObject<{
            country: z$1.ZodString;
            city: z$1.ZodOptional<z$1.ZodString>;
            state: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>, z$1.ZodObject<{
        type: z$1.ZodLiteral<"external">;
        server: z$1.ZodString;
        domainPattern: z$1.ZodOptional<z$1.ZodString>;
        username: z$1.ZodOptional<z$1.ZodString>;
        password: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>], "type">>]>>;
    region: z$1.ZodOptional<z$1.ZodEnum<{
        "us-west-2": "us-west-2";
        "us-east-1": "us-east-1";
        "eu-central-1": "eu-central-1";
        "ap-southeast-1": "ap-southeast-1";
    }>>;
    timeout: z$1.ZodOptional<z$1.ZodNumber>;
    userMetadata: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
}, z$1.core.$strip>;
declare const SessionStartRequestSchema: z$1.ZodObject<{
    modelName: z$1.ZodString;
    domSettleTimeoutMs: z$1.ZodOptional<z$1.ZodNumber>;
    verbose: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodLiteral<0>, z$1.ZodLiteral<1>, z$1.ZodLiteral<2>]>>;
    systemPrompt: z$1.ZodOptional<z$1.ZodString>;
    browserbaseSessionCreateParams: z$1.ZodOptional<z$1.ZodObject<{
        projectId: z$1.ZodOptional<z$1.ZodString>;
        browserSettings: z$1.ZodOptional<z$1.ZodObject<{
            advancedStealth: z$1.ZodOptional<z$1.ZodBoolean>;
            blockAds: z$1.ZodOptional<z$1.ZodBoolean>;
            context: z$1.ZodOptional<z$1.ZodObject<{
                id: z$1.ZodString;
                persist: z$1.ZodOptional<z$1.ZodBoolean>;
            }, z$1.core.$strip>>;
            extensionId: z$1.ZodOptional<z$1.ZodString>;
            fingerprint: z$1.ZodOptional<z$1.ZodObject<{
                browsers: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                    chrome: "chrome";
                    edge: "edge";
                    firefox: "firefox";
                    safari: "safari";
                }>>>;
                devices: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                    desktop: "desktop";
                    mobile: "mobile";
                }>>>;
                httpVersion: z$1.ZodOptional<z$1.ZodEnum<{
                    1: "1";
                    2: "2";
                }>>;
                locales: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
                operatingSystems: z$1.ZodOptional<z$1.ZodArray<z$1.ZodEnum<{
                    android: "android";
                    ios: "ios";
                    linux: "linux";
                    macos: "macos";
                    windows: "windows";
                }>>>;
                screen: z$1.ZodOptional<z$1.ZodObject<{
                    maxHeight: z$1.ZodOptional<z$1.ZodNumber>;
                    maxWidth: z$1.ZodOptional<z$1.ZodNumber>;
                    minHeight: z$1.ZodOptional<z$1.ZodNumber>;
                    minWidth: z$1.ZodOptional<z$1.ZodNumber>;
                }, z$1.core.$strip>>;
            }, z$1.core.$strip>>;
            logSession: z$1.ZodOptional<z$1.ZodBoolean>;
            recordSession: z$1.ZodOptional<z$1.ZodBoolean>;
            solveCaptchas: z$1.ZodOptional<z$1.ZodBoolean>;
            viewport: z$1.ZodOptional<z$1.ZodObject<{
                width: z$1.ZodOptional<z$1.ZodNumber>;
                height: z$1.ZodOptional<z$1.ZodNumber>;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>>;
        extensionId: z$1.ZodOptional<z$1.ZodString>;
        keepAlive: z$1.ZodOptional<z$1.ZodBoolean>;
        proxies: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodBoolean, z$1.ZodArray<z$1.ZodDiscriminatedUnion<[z$1.ZodObject<{
            type: z$1.ZodLiteral<"browserbase">;
            domainPattern: z$1.ZodOptional<z$1.ZodString>;
            geolocation: z$1.ZodOptional<z$1.ZodObject<{
                country: z$1.ZodString;
                city: z$1.ZodOptional<z$1.ZodString>;
                state: z$1.ZodOptional<z$1.ZodString>;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>, z$1.ZodObject<{
            type: z$1.ZodLiteral<"external">;
            server: z$1.ZodString;
            domainPattern: z$1.ZodOptional<z$1.ZodString>;
            username: z$1.ZodOptional<z$1.ZodString>;
            password: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>], "type">>]>>;
        region: z$1.ZodOptional<z$1.ZodEnum<{
            "us-west-2": "us-west-2";
            "us-east-1": "us-east-1";
            "eu-central-1": "eu-central-1";
            "ap-southeast-1": "ap-southeast-1";
        }>>;
        timeout: z$1.ZodOptional<z$1.ZodNumber>;
        userMetadata: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
    }, z$1.core.$strip>>;
    browser: z$1.ZodOptional<z$1.ZodObject<{
        type: z$1.ZodOptional<z$1.ZodEnum<{
            local: "local";
            browserbase: "browserbase";
        }>>;
        cdpUrl: z$1.ZodOptional<z$1.ZodString>;
        launchOptions: z$1.ZodOptional<z$1.ZodObject<{
            args: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
            executablePath: z$1.ZodOptional<z$1.ZodString>;
            userDataDir: z$1.ZodOptional<z$1.ZodString>;
            preserveUserDataDir: z$1.ZodOptional<z$1.ZodBoolean>;
            headless: z$1.ZodOptional<z$1.ZodBoolean>;
            devtools: z$1.ZodOptional<z$1.ZodBoolean>;
            chromiumSandbox: z$1.ZodOptional<z$1.ZodBoolean>;
            ignoreDefaultArgs: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodBoolean, z$1.ZodArray<z$1.ZodString>]>>;
            proxy: z$1.ZodOptional<z$1.ZodObject<{
                server: z$1.ZodString;
                bypass: z$1.ZodOptional<z$1.ZodString>;
                username: z$1.ZodOptional<z$1.ZodString>;
                password: z$1.ZodOptional<z$1.ZodString>;
            }, z$1.core.$strip>>;
            locale: z$1.ZodOptional<z$1.ZodString>;
            viewport: z$1.ZodOptional<z$1.ZodObject<{
                width: z$1.ZodNumber;
                height: z$1.ZodNumber;
            }, z$1.core.$strip>>;
            deviceScaleFactor: z$1.ZodOptional<z$1.ZodNumber>;
            hasTouch: z$1.ZodOptional<z$1.ZodBoolean>;
            ignoreHTTPSErrors: z$1.ZodOptional<z$1.ZodBoolean>;
            cdpUrl: z$1.ZodOptional<z$1.ZodString>;
            connectTimeoutMs: z$1.ZodOptional<z$1.ZodNumber>;
            downloadsPath: z$1.ZodOptional<z$1.ZodString>;
            acceptDownloads: z$1.ZodOptional<z$1.ZodBoolean>;
        }, z$1.core.$strict>>;
    }, z$1.core.$strip>>;
    selfHeal: z$1.ZodOptional<z$1.ZodBoolean>;
    browserbaseSessionID: z$1.ZodOptional<z$1.ZodString>;
    experimental: z$1.ZodOptional<z$1.ZodBoolean>;
    waitForCaptchaSolves: z$1.ZodOptional<z$1.ZodBoolean>;
    actTimeoutMs: z$1.ZodOptional<z$1.ZodNumber>;
}, z$1.core.$strip>;
declare const SessionStartResultSchema: z$1.ZodObject<{
    sessionId: z$1.ZodString;
    cdpUrl: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
    available: z$1.ZodBoolean;
}, z$1.core.$strip>;
declare const SessionStartResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        sessionId: z$1.ZodString;
        cdpUrl: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
        available: z$1.ZodBoolean;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const SessionEndResultSchema: z$1.ZodObject<{}, z$1.core.$strict>;
/** Session end response - just success flag, no data wrapper */
declare const SessionEndResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
}, z$1.core.$strict>;
declare const ActOptionsSchema: z$1.ZodOptional<z$1.ZodObject<{
    model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
        provider: z$1.ZodOptional<z$1.ZodEnum<{
            openai: "openai";
            anthropic: "anthropic";
            google: "google";
            microsoft: "microsoft";
        }>>;
        modelName: z$1.ZodString;
        apiKey: z$1.ZodOptional<z$1.ZodString>;
        baseURL: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>]>>;
    variables: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodString>>;
    timeout: z$1.ZodOptional<z$1.ZodNumber>;
}, z$1.core.$strip>>;
declare const ActRequestSchema: z$1.ZodObject<{
    input: z$1.ZodUnion<[z$1.ZodString, z$1.ZodObject<{
        selector: z$1.ZodString;
        description: z$1.ZodString;
        backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
        method: z$1.ZodOptional<z$1.ZodString>;
        arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
    }, z$1.core.$strip>]>;
    options: z$1.ZodOptional<z$1.ZodObject<{
        model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
            provider: z$1.ZodOptional<z$1.ZodEnum<{
                openai: "openai";
                anthropic: "anthropic";
                google: "google";
                microsoft: "microsoft";
            }>>;
            modelName: z$1.ZodString;
            apiKey: z$1.ZodOptional<z$1.ZodString>;
            baseURL: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>]>>;
        variables: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodString>>;
        timeout: z$1.ZodOptional<z$1.ZodNumber>;
    }, z$1.core.$strip>>;
    frameId: z$1.ZodOptional<z$1.ZodString>;
    streamResponse: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
/** Inner act result data */
declare const ActResultDataSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    message: z$1.ZodString;
    actionDescription: z$1.ZodString;
    actions: z$1.ZodArray<z$1.ZodObject<{
        selector: z$1.ZodString;
        description: z$1.ZodString;
        backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
        method: z$1.ZodOptional<z$1.ZodString>;
        arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
declare const ActResultSchema: z$1.ZodObject<{
    result: z$1.ZodObject<{
        success: z$1.ZodBoolean;
        message: z$1.ZodString;
        actionDescription: z$1.ZodString;
        actions: z$1.ZodArray<z$1.ZodObject<{
            selector: z$1.ZodString;
            description: z$1.ZodString;
            backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
            method: z$1.ZodOptional<z$1.ZodString>;
            arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>;
    actionId: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
declare const ActResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        result: z$1.ZodObject<{
            success: z$1.ZodBoolean;
            message: z$1.ZodString;
            actionDescription: z$1.ZodString;
            actions: z$1.ZodArray<z$1.ZodObject<{
                selector: z$1.ZodString;
                description: z$1.ZodString;
                backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
                method: z$1.ZodOptional<z$1.ZodString>;
                arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>;
        actionId: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const ExtractOptionsSchema: z$1.ZodOptional<z$1.ZodObject<{
    model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
        provider: z$1.ZodOptional<z$1.ZodEnum<{
            openai: "openai";
            anthropic: "anthropic";
            google: "google";
            microsoft: "microsoft";
        }>>;
        modelName: z$1.ZodString;
        apiKey: z$1.ZodOptional<z$1.ZodString>;
        baseURL: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>]>>;
    timeout: z$1.ZodOptional<z$1.ZodNumber>;
    selector: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>>;
declare const ExtractRequestSchema: z$1.ZodObject<{
    instruction: z$1.ZodOptional<z$1.ZodString>;
    schema: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
    options: z$1.ZodOptional<z$1.ZodObject<{
        model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
            provider: z$1.ZodOptional<z$1.ZodEnum<{
                openai: "openai";
                anthropic: "anthropic";
                google: "google";
                microsoft: "microsoft";
            }>>;
            modelName: z$1.ZodString;
            apiKey: z$1.ZodOptional<z$1.ZodString>;
            baseURL: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>]>>;
        timeout: z$1.ZodOptional<z$1.ZodNumber>;
        selector: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>>;
    frameId: z$1.ZodOptional<z$1.ZodString>;
    streamResponse: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
declare const ExtractResultSchema: z$1.ZodObject<{
    result: z$1.ZodUnknown;
    actionId: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
declare const ExtractResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        result: z$1.ZodUnknown;
        actionId: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const ObserveOptionsSchema: z$1.ZodOptional<z$1.ZodObject<{
    model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
        provider: z$1.ZodOptional<z$1.ZodEnum<{
            openai: "openai";
            anthropic: "anthropic";
            google: "google";
            microsoft: "microsoft";
        }>>;
        modelName: z$1.ZodString;
        apiKey: z$1.ZodOptional<z$1.ZodString>;
        baseURL: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>]>>;
    timeout: z$1.ZodOptional<z$1.ZodNumber>;
    selector: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>>;
declare const ObserveRequestSchema: z$1.ZodObject<{
    instruction: z$1.ZodOptional<z$1.ZodString>;
    options: z$1.ZodOptional<z$1.ZodObject<{
        model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
            provider: z$1.ZodOptional<z$1.ZodEnum<{
                openai: "openai";
                anthropic: "anthropic";
                google: "google";
                microsoft: "microsoft";
            }>>;
            modelName: z$1.ZodString;
            apiKey: z$1.ZodOptional<z$1.ZodString>;
            baseURL: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>]>>;
        timeout: z$1.ZodOptional<z$1.ZodNumber>;
        selector: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>>;
    frameId: z$1.ZodOptional<z$1.ZodString>;
    streamResponse: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
declare const ObserveResultSchema: z$1.ZodObject<{
    result: z$1.ZodArray<z$1.ZodObject<{
        selector: z$1.ZodString;
        description: z$1.ZodString;
        backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
        method: z$1.ZodOptional<z$1.ZodString>;
        arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
    }, z$1.core.$strip>>;
    actionId: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
declare const ObserveResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        result: z$1.ZodArray<z$1.ZodObject<{
            selector: z$1.ZodString;
            description: z$1.ZodString;
            backendNodeId: z$1.ZodOptional<z$1.ZodNumber>;
            method: z$1.ZodOptional<z$1.ZodString>;
            arguments: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString>>;
        }, z$1.core.$strip>>;
        actionId: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const AgentConfigSchema: z$1.ZodObject<{
    provider: z$1.ZodOptional<z$1.ZodEnum<{
        openai: "openai";
        anthropic: "anthropic";
        google: "google";
        microsoft: "microsoft";
    }>>;
    model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
        provider: z$1.ZodOptional<z$1.ZodEnum<{
            openai: "openai";
            anthropic: "anthropic";
            google: "google";
            microsoft: "microsoft";
        }>>;
        modelName: z$1.ZodString;
        apiKey: z$1.ZodOptional<z$1.ZodString>;
        baseURL: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>]>>;
    systemPrompt: z$1.ZodOptional<z$1.ZodString>;
    cua: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
/** Action taken by the agent during execution */
declare const AgentActionSchema: z$1.ZodObject<{
    type: z$1.ZodString;
    reasoning: z$1.ZodOptional<z$1.ZodString>;
    taskCompleted: z$1.ZodOptional<z$1.ZodBoolean>;
    action: z$1.ZodOptional<z$1.ZodString>;
    timeMs: z$1.ZodOptional<z$1.ZodNumber>;
    pageText: z$1.ZodOptional<z$1.ZodString>;
    pageUrl: z$1.ZodOptional<z$1.ZodString>;
    instruction: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$loose>;
/** Token usage statistics for agent execution */
declare const AgentUsageSchema: z$1.ZodObject<{
    input_tokens: z$1.ZodNumber;
    output_tokens: z$1.ZodNumber;
    reasoning_tokens: z$1.ZodOptional<z$1.ZodNumber>;
    cached_input_tokens: z$1.ZodOptional<z$1.ZodNumber>;
    inference_time_ms: z$1.ZodNumber;
}, z$1.core.$strip>;
/** Result data from agent execution */
declare const AgentResultDataSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    message: z$1.ZodString;
    actions: z$1.ZodArray<z$1.ZodObject<{
        type: z$1.ZodString;
        reasoning: z$1.ZodOptional<z$1.ZodString>;
        taskCompleted: z$1.ZodOptional<z$1.ZodBoolean>;
        action: z$1.ZodOptional<z$1.ZodString>;
        timeMs: z$1.ZodOptional<z$1.ZodNumber>;
        pageText: z$1.ZodOptional<z$1.ZodString>;
        pageUrl: z$1.ZodOptional<z$1.ZodString>;
        instruction: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$loose>>;
    completed: z$1.ZodBoolean;
    metadata: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
    usage: z$1.ZodOptional<z$1.ZodObject<{
        input_tokens: z$1.ZodNumber;
        output_tokens: z$1.ZodNumber;
        reasoning_tokens: z$1.ZodOptional<z$1.ZodNumber>;
        cached_input_tokens: z$1.ZodOptional<z$1.ZodNumber>;
        inference_time_ms: z$1.ZodNumber;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
declare const AgentExecuteOptionsSchema: z$1.ZodObject<{
    instruction: z$1.ZodString;
    maxSteps: z$1.ZodOptional<z$1.ZodNumber>;
    highlightCursor: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
declare const AgentExecuteRequestSchema: z$1.ZodObject<{
    agentConfig: z$1.ZodObject<{
        provider: z$1.ZodOptional<z$1.ZodEnum<{
            openai: "openai";
            anthropic: "anthropic";
            google: "google";
            microsoft: "microsoft";
        }>>;
        model: z$1.ZodOptional<z$1.ZodUnion<readonly [z$1.ZodString, z$1.ZodObject<{
            provider: z$1.ZodOptional<z$1.ZodEnum<{
                openai: "openai";
                anthropic: "anthropic";
                google: "google";
                microsoft: "microsoft";
            }>>;
            modelName: z$1.ZodString;
            apiKey: z$1.ZodOptional<z$1.ZodString>;
            baseURL: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$strip>]>>;
        systemPrompt: z$1.ZodOptional<z$1.ZodString>;
        cua: z$1.ZodOptional<z$1.ZodBoolean>;
    }, z$1.core.$strip>;
    executeOptions: z$1.ZodObject<{
        instruction: z$1.ZodString;
        maxSteps: z$1.ZodOptional<z$1.ZodNumber>;
        highlightCursor: z$1.ZodOptional<z$1.ZodBoolean>;
    }, z$1.core.$strip>;
    frameId: z$1.ZodOptional<z$1.ZodString>;
    streamResponse: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
declare const AgentExecuteResultSchema: z$1.ZodObject<{
    result: z$1.ZodObject<{
        success: z$1.ZodBoolean;
        message: z$1.ZodString;
        actions: z$1.ZodArray<z$1.ZodObject<{
            type: z$1.ZodString;
            reasoning: z$1.ZodOptional<z$1.ZodString>;
            taskCompleted: z$1.ZodOptional<z$1.ZodBoolean>;
            action: z$1.ZodOptional<z$1.ZodString>;
            timeMs: z$1.ZodOptional<z$1.ZodNumber>;
            pageText: z$1.ZodOptional<z$1.ZodString>;
            pageUrl: z$1.ZodOptional<z$1.ZodString>;
            instruction: z$1.ZodOptional<z$1.ZodString>;
        }, z$1.core.$loose>>;
        completed: z$1.ZodBoolean;
        metadata: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
        usage: z$1.ZodOptional<z$1.ZodObject<{
            input_tokens: z$1.ZodNumber;
            output_tokens: z$1.ZodNumber;
            reasoning_tokens: z$1.ZodOptional<z$1.ZodNumber>;
            cached_input_tokens: z$1.ZodOptional<z$1.ZodNumber>;
            inference_time_ms: z$1.ZodNumber;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const AgentExecuteResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        result: z$1.ZodObject<{
            success: z$1.ZodBoolean;
            message: z$1.ZodString;
            actions: z$1.ZodArray<z$1.ZodObject<{
                type: z$1.ZodString;
                reasoning: z$1.ZodOptional<z$1.ZodString>;
                taskCompleted: z$1.ZodOptional<z$1.ZodBoolean>;
                action: z$1.ZodOptional<z$1.ZodString>;
                timeMs: z$1.ZodOptional<z$1.ZodNumber>;
                pageText: z$1.ZodOptional<z$1.ZodString>;
                pageUrl: z$1.ZodOptional<z$1.ZodString>;
                instruction: z$1.ZodOptional<z$1.ZodString>;
            }, z$1.core.$loose>>;
            completed: z$1.ZodBoolean;
            metadata: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
            usage: z$1.ZodOptional<z$1.ZodObject<{
                input_tokens: z$1.ZodNumber;
                output_tokens: z$1.ZodNumber;
                reasoning_tokens: z$1.ZodOptional<z$1.ZodNumber>;
                cached_input_tokens: z$1.ZodOptional<z$1.ZodNumber>;
                inference_time_ms: z$1.ZodNumber;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
declare const NavigateOptionsSchema: z$1.ZodOptional<z$1.ZodObject<{
    referer: z$1.ZodOptional<z$1.ZodString>;
    timeout: z$1.ZodOptional<z$1.ZodNumber>;
    waitUntil: z$1.ZodOptional<z$1.ZodEnum<{
        load: "load";
        domcontentloaded: "domcontentloaded";
        networkidle: "networkidle";
    }>>;
}, z$1.core.$strip>>;
declare const NavigateRequestSchema: z$1.ZodObject<{
    url: z$1.ZodString;
    options: z$1.ZodOptional<z$1.ZodObject<{
        referer: z$1.ZodOptional<z$1.ZodString>;
        timeout: z$1.ZodOptional<z$1.ZodNumber>;
        waitUntil: z$1.ZodOptional<z$1.ZodEnum<{
            load: "load";
            domcontentloaded: "domcontentloaded";
            networkidle: "networkidle";
        }>>;
    }, z$1.core.$strip>>;
    frameId: z$1.ZodOptional<z$1.ZodString>;
    streamResponse: z$1.ZodOptional<z$1.ZodBoolean>;
}, z$1.core.$strip>;
declare const NavigateResultSchema: z$1.ZodObject<{
    result: z$1.ZodNullable<z$1.ZodUnknown>;
    actionId: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
declare const NavigateResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        result: z$1.ZodNullable<z$1.ZodUnknown>;
        actionId: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
/** Token usage for a single action */
declare const TokenUsageSchema: z$1.ZodObject<{
    inputTokens: z$1.ZodOptional<z$1.ZodNumber>;
    outputTokens: z$1.ZodOptional<z$1.ZodNumber>;
    reasoningTokens: z$1.ZodOptional<z$1.ZodNumber>;
    cachedInputTokens: z$1.ZodOptional<z$1.ZodNumber>;
    timeMs: z$1.ZodOptional<z$1.ZodNumber>;
}, z$1.core.$strip>;
/** Action entry in replay metrics */
declare const ReplayActionSchema: z$1.ZodObject<{
    method: z$1.ZodOptional<z$1.ZodString>;
    tokenUsage: z$1.ZodOptional<z$1.ZodObject<{
        inputTokens: z$1.ZodOptional<z$1.ZodNumber>;
        outputTokens: z$1.ZodOptional<z$1.ZodNumber>;
        reasoningTokens: z$1.ZodOptional<z$1.ZodNumber>;
        cachedInputTokens: z$1.ZodOptional<z$1.ZodNumber>;
        timeMs: z$1.ZodOptional<z$1.ZodNumber>;
    }, z$1.core.$strip>>;
}, z$1.core.$strip>;
/** Page entry in replay metrics */
declare const ReplayPageSchema: z$1.ZodObject<{
    actions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
        method: z$1.ZodOptional<z$1.ZodString>;
        tokenUsage: z$1.ZodOptional<z$1.ZodObject<{
            inputTokens: z$1.ZodOptional<z$1.ZodNumber>;
            outputTokens: z$1.ZodOptional<z$1.ZodNumber>;
            reasoningTokens: z$1.ZodOptional<z$1.ZodNumber>;
            cachedInputTokens: z$1.ZodOptional<z$1.ZodNumber>;
            timeMs: z$1.ZodOptional<z$1.ZodNumber>;
        }, z$1.core.$strip>>;
    }, z$1.core.$strip>>>;
}, z$1.core.$strip>;
/** Inner result data for replay */
declare const ReplayResultSchema: z$1.ZodObject<{
    pages: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
        actions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
            method: z$1.ZodOptional<z$1.ZodString>;
            tokenUsage: z$1.ZodOptional<z$1.ZodObject<{
                inputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                outputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                reasoningTokens: z$1.ZodOptional<z$1.ZodNumber>;
                cachedInputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                timeMs: z$1.ZodOptional<z$1.ZodNumber>;
            }, z$1.core.$strip>>;
        }, z$1.core.$strip>>>;
    }, z$1.core.$strip>>>;
}, z$1.core.$strip>;
declare const ReplayResponseSchema: z$1.ZodObject<{
    success: z$1.ZodBoolean;
    data: z$1.ZodObject<{
        pages: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
            actions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
                method: z$1.ZodOptional<z$1.ZodString>;
                tokenUsage: z$1.ZodOptional<z$1.ZodObject<{
                    inputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                    outputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                    reasoningTokens: z$1.ZodOptional<z$1.ZodNumber>;
                    cachedInputTokens: z$1.ZodOptional<z$1.ZodNumber>;
                    timeMs: z$1.ZodOptional<z$1.ZodNumber>;
                }, z$1.core.$strip>>;
            }, z$1.core.$strip>>>;
        }, z$1.core.$strip>>>;
    }, z$1.core.$strip>;
}, z$1.core.$strip>;
/** Status values for SSE stream events */
declare const StreamEventStatusSchema: z$1.ZodEnum<{
    error: "error";
    starting: "starting";
    connected: "connected";
    running: "running";
    finished: "finished";
}>;
/** Type discriminator for SSE stream events */
declare const StreamEventTypeSchema: z$1.ZodEnum<{
    system: "system";
    log: "log";
}>;
/** Data payload for system stream events */
declare const StreamEventSystemDataSchema: z$1.ZodObject<{
    status: z$1.ZodEnum<{
        error: "error";
        starting: "starting";
        connected: "connected";
        running: "running";
        finished: "finished";
    }>;
    result: z$1.ZodOptional<z$1.ZodUnknown>;
    error: z$1.ZodOptional<z$1.ZodString>;
}, z$1.core.$strip>;
/** Data payload for log stream events */
declare const StreamEventLogDataSchema: z$1.ZodObject<{
    status: z$1.ZodLiteral<"running">;
    message: z$1.ZodString;
}, z$1.core.$strip>;
/**
 * SSE stream event sent during streaming responses.
 *
 * IMPORTANT: Key ordering matters for Stainless SDK generation.
 * The `data` field MUST be serialized first, with `status` as the first key within it.
 * This allows Stainless to use `data_starts_with: '{"data":{"status":"finished"'` for event handling.
 *
 * Expected serialization order: {"data":{"status":...},"type":...,"id":...}
 */
declare const StreamEventSchema: z$1.ZodObject<{
    data: z$1.ZodUnion<readonly [z$1.ZodObject<{
        status: z$1.ZodEnum<{
            error: "error";
            starting: "starting";
            connected: "connected";
            running: "running";
            finished: "finished";
        }>;
        result: z$1.ZodOptional<z$1.ZodUnknown>;
        error: z$1.ZodOptional<z$1.ZodString>;
    }, z$1.core.$strip>, z$1.ZodObject<{
        status: z$1.ZodLiteral<"running">;
        message: z$1.ZodString;
    }, z$1.core.$strip>]>;
    type: z$1.ZodEnum<{
        system: "system";
        log: "log";
    }>;
    id: z$1.ZodString;
}, z$1.core.$strip>;
/** OpenAPI security schemes for authentication */
declare const openApiSecuritySchemes: {
    readonly BrowserbaseApiKey: {
        readonly type: "apiKey";
        readonly in: "header";
        readonly name: "x-bb-api-key";
        readonly description: "Browserbase API key for authentication";
    };
    readonly BrowserbaseProjectId: {
        readonly type: "apiKey";
        readonly in: "header";
        readonly name: "x-bb-project-id";
        readonly description: "Browserbase project ID";
    };
    readonly ModelApiKey: {
        readonly type: "apiKey";
        readonly in: "header";
        readonly name: "x-model-api-key";
        readonly description: "API key for the AI model provider (OpenAI, Anthropic, etc.)";
    };
};
/** OpenAPI links for session operations (used in SessionStart response) */
declare const openApiLinks: {
    readonly SessionAct: {
        readonly operationId: "SessionAct";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Perform an action on the session";
    };
    readonly SessionExtract: {
        readonly operationId: "SessionExtract";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Extract data from the session";
    };
    readonly SessionObserve: {
        readonly operationId: "SessionObserve";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Observe available actions on the session";
    };
    readonly SessionNavigate: {
        readonly operationId: "SessionNavigate";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Navigate to a URL in the session";
    };
    readonly SessionAgentExecute: {
        readonly operationId: "SessionAgentExecute";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Execute an agent on the session";
    };
    readonly SessionReplay: {
        readonly operationId: "SessionReplay";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "Replay session metrics";
    };
    readonly SessionEnd: {
        readonly operationId: "SessionEnd";
        readonly parameters: {
            readonly id: "$response.body#/data/sessionId";
        };
        readonly description: "End the session and release resources";
    };
};
/** OpenAPI operation metadata for each endpoint */
declare const Operations: {
    readonly SessionStart: {
        readonly operationId: "SessionStart";
        readonly summary: "Start a new browser session";
        readonly description: "Creates a new browser session with the specified configuration. Returns a session ID used for all subsequent operations.";
    };
    readonly SessionEnd: {
        readonly operationId: "SessionEnd";
        readonly summary: "End a browser session";
        readonly description: "Terminates the browser session and releases all associated resources.";
    };
    readonly SessionAct: {
        readonly operationId: "SessionAct";
        readonly summary: "Perform an action";
        readonly description: "Executes a browser action using natural language instructions or a predefined Action object.";
    };
    readonly SessionExtract: {
        readonly operationId: "SessionExtract";
        readonly summary: "Extract data from the page";
        readonly description: "Extracts structured data from the current page using AI-powered analysis.";
    };
    readonly SessionObserve: {
        readonly operationId: "SessionObserve";
        readonly summary: "Observe available actions";
        readonly description: "Identifies and returns available actions on the current page that match the given instruction.";
    };
    readonly SessionNavigate: {
        readonly operationId: "SessionNavigate";
        readonly summary: "Navigate to a URL";
        readonly description: "Navigates the browser to the specified URL.";
    };
    readonly SessionAgentExecute: {
        readonly operationId: "SessionAgentExecute";
        readonly summary: "Execute an AI agent";
        readonly description: "Runs an autonomous AI agent that can perform complex multi-step browser tasks.";
    };
    readonly SessionReplay: {
        readonly operationId: "SessionReplay";
        readonly summary: "Replay session metrics";
        readonly description: "Retrieves replay metrics for a session.";
    };
};
type Action$1 = z$1.infer<typeof ActionSchema>;
type ModelConfig = z$1.infer<typeof ModelConfigSchema>;
type BrowserConfig = z$1.infer<typeof BrowserConfigSchema>;
type SessionIdParams = z$1.infer<typeof SessionIdParamsSchema>;
type SessionHeaders = z$1.infer<typeof SessionHeadersSchema>;
type BrowserbaseViewport = z$1.infer<typeof BrowserbaseViewportSchema>;
type BrowserbaseFingerprintScreen = z$1.infer<typeof BrowserbaseFingerprintScreenSchema>;
type BrowserbaseFingerprint = z$1.infer<typeof BrowserbaseFingerprintSchema>;
type BrowserbaseContext = z$1.infer<typeof BrowserbaseContextSchema>;
type BrowserbaseBrowserSettings = z$1.infer<typeof BrowserbaseBrowserSettingsSchema>;
type BrowserbaseProxyGeolocation = z$1.infer<typeof BrowserbaseProxyGeolocationSchema>;
type BrowserbaseProxyConfig = z$1.infer<typeof BrowserbaseProxyConfigSchema>;
type ExternalProxyConfig = z$1.infer<typeof ExternalProxyConfigSchema>;
type BrowserbaseSessionCreateParams = z$1.infer<typeof BrowserbaseSessionCreateParamsSchema>;
type SessionStartRequest = z$1.infer<typeof SessionStartRequestSchema>;
type SessionStartResult = z$1.infer<typeof SessionStartResultSchema>;
type SessionStartResponse = z$1.infer<typeof SessionStartResponseSchema>;
type SessionEndResult = z$1.infer<typeof SessionEndResultSchema>;
type SessionEndResponse = z$1.infer<typeof SessionEndResponseSchema>;
type ActRequest = z$1.infer<typeof ActRequestSchema>;
type ActResultData = z$1.infer<typeof ActResultDataSchema>;
type ActResult$1 = z$1.infer<typeof ActResultSchema>;
type ActResponse = z$1.infer<typeof ActResponseSchema>;
type ExtractRequest = z$1.infer<typeof ExtractRequestSchema>;
type ExtractResult$1 = z$1.infer<typeof ExtractResultSchema>;
type ExtractResponse = z$1.infer<typeof ExtractResponseSchema>;
type ObserveRequest = z$1.infer<typeof ObserveRequestSchema>;
type ObserveResult = z$1.infer<typeof ObserveResultSchema>;
type ObserveResponse = z$1.infer<typeof ObserveResponseSchema>;
type AgentAction$1 = z$1.infer<typeof AgentActionSchema>;
type AgentUsage = z$1.infer<typeof AgentUsageSchema>;
type AgentResultData = z$1.infer<typeof AgentResultDataSchema>;
type AgentExecuteRequest = z$1.infer<typeof AgentExecuteRequestSchema>;
type AgentExecuteResult = z$1.infer<typeof AgentExecuteResultSchema>;
type AgentExecuteResponse = z$1.infer<typeof AgentExecuteResponseSchema>;
type NavigateRequest = z$1.infer<typeof NavigateRequestSchema>;
type NavigateResult = z$1.infer<typeof NavigateResultSchema>;
type NavigateResponse = z$1.infer<typeof NavigateResponseSchema>;
type TokenUsage = z$1.infer<typeof TokenUsageSchema>;
type ReplayAction = z$1.infer<typeof ReplayActionSchema>;
type ReplayPage = z$1.infer<typeof ReplayPageSchema>;
type ReplayResult = z$1.infer<typeof ReplayResultSchema>;
type ReplayResponse = z$1.infer<typeof ReplayResponseSchema>;
type StreamEventStatus = z$1.infer<typeof StreamEventStatusSchema>;
type StreamEventType = z$1.infer<typeof StreamEventTypeSchema>;
type StreamEventSystemData = z$1.infer<typeof StreamEventSystemDataSchema>;
type StreamEventLogData = z$1.infer<typeof StreamEventLogDataSchema>;
type StreamEvent = z$1.infer<typeof StreamEventSchema>;

declare const api_ActOptionsSchema: typeof ActOptionsSchema;
type api_ActRequest = ActRequest;
declare const api_ActRequestSchema: typeof ActRequestSchema;
type api_ActResponse = ActResponse;
declare const api_ActResponseSchema: typeof ActResponseSchema;
type api_ActResultData = ActResultData;
declare const api_ActResultDataSchema: typeof ActResultDataSchema;
declare const api_ActResultSchema: typeof ActResultSchema;
declare const api_ActionSchema: typeof ActionSchema;
declare const api_AgentActionSchema: typeof AgentActionSchema;
declare const api_AgentConfigSchema: typeof AgentConfigSchema;
declare const api_AgentExecuteOptionsSchema: typeof AgentExecuteOptionsSchema;
type api_AgentExecuteRequest = AgentExecuteRequest;
declare const api_AgentExecuteRequestSchema: typeof AgentExecuteRequestSchema;
type api_AgentExecuteResponse = AgentExecuteResponse;
declare const api_AgentExecuteResponseSchema: typeof AgentExecuteResponseSchema;
type api_AgentExecuteResult = AgentExecuteResult;
declare const api_AgentExecuteResultSchema: typeof AgentExecuteResultSchema;
type api_AgentResultData = AgentResultData;
declare const api_AgentResultDataSchema: typeof AgentResultDataSchema;
type api_AgentUsage = AgentUsage;
declare const api_AgentUsageSchema: typeof AgentUsageSchema;
type api_BrowserConfig = BrowserConfig;
declare const api_BrowserConfigSchema: typeof BrowserConfigSchema;
type api_BrowserbaseBrowserSettings = BrowserbaseBrowserSettings;
declare const api_BrowserbaseBrowserSettingsSchema: typeof BrowserbaseBrowserSettingsSchema;
type api_BrowserbaseContext = BrowserbaseContext;
declare const api_BrowserbaseContextSchema: typeof BrowserbaseContextSchema;
type api_BrowserbaseFingerprint = BrowserbaseFingerprint;
declare const api_BrowserbaseFingerprintSchema: typeof BrowserbaseFingerprintSchema;
type api_BrowserbaseFingerprintScreen = BrowserbaseFingerprintScreen;
declare const api_BrowserbaseFingerprintScreenSchema: typeof BrowserbaseFingerprintScreenSchema;
type api_BrowserbaseProxyConfig = BrowserbaseProxyConfig;
declare const api_BrowserbaseProxyConfigSchema: typeof BrowserbaseProxyConfigSchema;
type api_BrowserbaseProxyGeolocation = BrowserbaseProxyGeolocation;
declare const api_BrowserbaseProxyGeolocationSchema: typeof BrowserbaseProxyGeolocationSchema;
type api_BrowserbaseSessionCreateParams = BrowserbaseSessionCreateParams;
declare const api_BrowserbaseSessionCreateParamsSchema: typeof BrowserbaseSessionCreateParamsSchema;
type api_BrowserbaseViewport = BrowserbaseViewport;
declare const api_BrowserbaseViewportSchema: typeof BrowserbaseViewportSchema;
declare const api_ErrorResponseSchema: typeof ErrorResponseSchema;
type api_ExternalProxyConfig = ExternalProxyConfig;
declare const api_ExternalProxyConfigSchema: typeof ExternalProxyConfigSchema;
declare const api_ExtractOptionsSchema: typeof ExtractOptionsSchema;
type api_ExtractRequest = ExtractRequest;
declare const api_ExtractRequestSchema: typeof ExtractRequestSchema;
type api_ExtractResponse = ExtractResponse;
declare const api_ExtractResponseSchema: typeof ExtractResponseSchema;
declare const api_ExtractResultSchema: typeof ExtractResultSchema;
declare const api_LocalBrowserLaunchOptionsSchema: typeof LocalBrowserLaunchOptionsSchema;
type api_ModelConfig = ModelConfig;
declare const api_ModelConfigObjectSchema: typeof ModelConfigObjectSchema;
declare const api_ModelConfigSchema: typeof ModelConfigSchema;
declare const api_ModelNameSchema: typeof ModelNameSchema;
declare const api_NavigateOptionsSchema: typeof NavigateOptionsSchema;
type api_NavigateRequest = NavigateRequest;
declare const api_NavigateRequestSchema: typeof NavigateRequestSchema;
type api_NavigateResponse = NavigateResponse;
declare const api_NavigateResponseSchema: typeof NavigateResponseSchema;
type api_NavigateResult = NavigateResult;
declare const api_NavigateResultSchema: typeof NavigateResultSchema;
declare const api_ObserveOptionsSchema: typeof ObserveOptionsSchema;
type api_ObserveRequest = ObserveRequest;
declare const api_ObserveRequestSchema: typeof ObserveRequestSchema;
type api_ObserveResponse = ObserveResponse;
declare const api_ObserveResponseSchema: typeof ObserveResponseSchema;
type api_ObserveResult = ObserveResult;
declare const api_ObserveResultSchema: typeof ObserveResultSchema;
declare const api_Operations: typeof Operations;
declare const api_ProxyConfigSchema: typeof ProxyConfigSchema;
type api_ReplayAction = ReplayAction;
declare const api_ReplayActionSchema: typeof ReplayActionSchema;
type api_ReplayPage = ReplayPage;
declare const api_ReplayPageSchema: typeof ReplayPageSchema;
type api_ReplayResponse = ReplayResponse;
declare const api_ReplayResponseSchema: typeof ReplayResponseSchema;
type api_ReplayResult = ReplayResult;
declare const api_ReplayResultSchema: typeof ReplayResultSchema;
type api_SessionEndResponse = SessionEndResponse;
declare const api_SessionEndResponseSchema: typeof SessionEndResponseSchema;
type api_SessionEndResult = SessionEndResult;
declare const api_SessionEndResultSchema: typeof SessionEndResultSchema;
type api_SessionHeaders = SessionHeaders;
declare const api_SessionHeadersSchema: typeof SessionHeadersSchema;
type api_SessionIdParams = SessionIdParams;
declare const api_SessionIdParamsSchema: typeof SessionIdParamsSchema;
type api_SessionStartRequest = SessionStartRequest;
declare const api_SessionStartRequestSchema: typeof SessionStartRequestSchema;
type api_SessionStartResponse = SessionStartResponse;
declare const api_SessionStartResponseSchema: typeof SessionStartResponseSchema;
type api_SessionStartResult = SessionStartResult;
declare const api_SessionStartResultSchema: typeof SessionStartResultSchema;
type api_StreamEvent = StreamEvent;
type api_StreamEventLogData = StreamEventLogData;
declare const api_StreamEventLogDataSchema: typeof StreamEventLogDataSchema;
declare const api_StreamEventSchema: typeof StreamEventSchema;
type api_StreamEventStatus = StreamEventStatus;
declare const api_StreamEventStatusSchema: typeof StreamEventStatusSchema;
type api_StreamEventSystemData = StreamEventSystemData;
declare const api_StreamEventSystemDataSchema: typeof StreamEventSystemDataSchema;
type api_StreamEventType = StreamEventType;
declare const api_StreamEventTypeSchema: typeof StreamEventTypeSchema;
type api_TokenUsage = TokenUsage;
declare const api_TokenUsageSchema: typeof TokenUsageSchema;
declare const api_openApiLinks: typeof openApiLinks;
declare const api_openApiSecuritySchemes: typeof openApiSecuritySchemes;
declare namespace api {
  export { api_ActOptionsSchema as ActOptionsSchema, type api_ActRequest as ActRequest, api_ActRequestSchema as ActRequestSchema, type api_ActResponse as ActResponse, api_ActResponseSchema as ActResponseSchema, type ActResult$1 as ActResult, type api_ActResultData as ActResultData, api_ActResultDataSchema as ActResultDataSchema, api_ActResultSchema as ActResultSchema, type Action$1 as Action, api_ActionSchema as ActionSchema, type AgentAction$1 as AgentAction, api_AgentActionSchema as AgentActionSchema, api_AgentConfigSchema as AgentConfigSchema, api_AgentExecuteOptionsSchema as AgentExecuteOptionsSchema, type api_AgentExecuteRequest as AgentExecuteRequest, api_AgentExecuteRequestSchema as AgentExecuteRequestSchema, type api_AgentExecuteResponse as AgentExecuteResponse, api_AgentExecuteResponseSchema as AgentExecuteResponseSchema, type api_AgentExecuteResult as AgentExecuteResult, api_AgentExecuteResultSchema as AgentExecuteResultSchema, type api_AgentResultData as AgentResultData, api_AgentResultDataSchema as AgentResultDataSchema, type api_AgentUsage as AgentUsage, api_AgentUsageSchema as AgentUsageSchema, type api_BrowserConfig as BrowserConfig, api_BrowserConfigSchema as BrowserConfigSchema, type api_BrowserbaseBrowserSettings as BrowserbaseBrowserSettings, api_BrowserbaseBrowserSettingsSchema as BrowserbaseBrowserSettingsSchema, type api_BrowserbaseContext as BrowserbaseContext, api_BrowserbaseContextSchema as BrowserbaseContextSchema, type api_BrowserbaseFingerprint as BrowserbaseFingerprint, api_BrowserbaseFingerprintSchema as BrowserbaseFingerprintSchema, type api_BrowserbaseFingerprintScreen as BrowserbaseFingerprintScreen, api_BrowserbaseFingerprintScreenSchema as BrowserbaseFingerprintScreenSchema, type api_BrowserbaseProxyConfig as BrowserbaseProxyConfig, api_BrowserbaseProxyConfigSchema as BrowserbaseProxyConfigSchema, type api_BrowserbaseProxyGeolocation as BrowserbaseProxyGeolocation, api_BrowserbaseProxyGeolocationSchema as BrowserbaseProxyGeolocationSchema, type api_BrowserbaseSessionCreateParams as BrowserbaseSessionCreateParams, api_BrowserbaseSessionCreateParamsSchema as BrowserbaseSessionCreateParamsSchema, type api_BrowserbaseViewport as BrowserbaseViewport, api_BrowserbaseViewportSchema as BrowserbaseViewportSchema, api_ErrorResponseSchema as ErrorResponseSchema, type api_ExternalProxyConfig as ExternalProxyConfig, api_ExternalProxyConfigSchema as ExternalProxyConfigSchema, api_ExtractOptionsSchema as ExtractOptionsSchema, type api_ExtractRequest as ExtractRequest, api_ExtractRequestSchema as ExtractRequestSchema, type api_ExtractResponse as ExtractResponse, api_ExtractResponseSchema as ExtractResponseSchema, type ExtractResult$1 as ExtractResult, api_ExtractResultSchema as ExtractResultSchema, api_LocalBrowserLaunchOptionsSchema as LocalBrowserLaunchOptionsSchema, type api_ModelConfig as ModelConfig, api_ModelConfigObjectSchema as ModelConfigObjectSchema, api_ModelConfigSchema as ModelConfigSchema, api_ModelNameSchema as ModelNameSchema, api_NavigateOptionsSchema as NavigateOptionsSchema, type api_NavigateRequest as NavigateRequest, api_NavigateRequestSchema as NavigateRequestSchema, type api_NavigateResponse as NavigateResponse, api_NavigateResponseSchema as NavigateResponseSchema, type api_NavigateResult as NavigateResult, api_NavigateResultSchema as NavigateResultSchema, api_ObserveOptionsSchema as ObserveOptionsSchema, type api_ObserveRequest as ObserveRequest, api_ObserveRequestSchema as ObserveRequestSchema, type api_ObserveResponse as ObserveResponse, api_ObserveResponseSchema as ObserveResponseSchema, type api_ObserveResult as ObserveResult, api_ObserveResultSchema as ObserveResultSchema, api_Operations as Operations, api_ProxyConfigSchema as ProxyConfigSchema, type api_ReplayAction as ReplayAction, api_ReplayActionSchema as ReplayActionSchema, type api_ReplayPage as ReplayPage, api_ReplayPageSchema as ReplayPageSchema, type api_ReplayResponse as ReplayResponse, api_ReplayResponseSchema as ReplayResponseSchema, type api_ReplayResult as ReplayResult, api_ReplayResultSchema as ReplayResultSchema, type api_SessionEndResponse as SessionEndResponse, api_SessionEndResponseSchema as SessionEndResponseSchema, type api_SessionEndResult as SessionEndResult, api_SessionEndResultSchema as SessionEndResultSchema, type api_SessionHeaders as SessionHeaders, api_SessionHeadersSchema as SessionHeadersSchema, type api_SessionIdParams as SessionIdParams, api_SessionIdParamsSchema as SessionIdParamsSchema, type api_SessionStartRequest as SessionStartRequest, api_SessionStartRequestSchema as SessionStartRequestSchema, type api_SessionStartResponse as SessionStartResponse, api_SessionStartResponseSchema as SessionStartResponseSchema, type api_SessionStartResult as SessionStartResult, api_SessionStartResultSchema as SessionStartResultSchema, type api_StreamEvent as StreamEvent, type api_StreamEventLogData as StreamEventLogData, api_StreamEventLogDataSchema as StreamEventLogDataSchema, api_StreamEventSchema as StreamEventSchema, type api_StreamEventStatus as StreamEventStatus, api_StreamEventStatusSchema as StreamEventStatusSchema, type api_StreamEventSystemData as StreamEventSystemData, api_StreamEventSystemDataSchema as StreamEventSystemDataSchema, type api_StreamEventType as StreamEventType, api_StreamEventTypeSchema as StreamEventTypeSchema, type api_TokenUsage as TokenUsage, api_TokenUsageSchema as TokenUsageSchema, api_openApiLinks as openApiLinks, api_openApiSecuritySchemes as openApiSecuritySchemes };
}

declare class StagehandAPIError extends Error {
    constructor(message: string);
}
declare class StagehandAPIUnauthorizedError extends StagehandAPIError {
    constructor(message?: string);
}
declare class StagehandHttpError extends StagehandAPIError {
    constructor(message: string);
}
declare class StagehandServerError extends StagehandAPIError {
    constructor(message: string);
}
declare class StagehandResponseBodyError extends StagehandAPIError {
    constructor();
}
declare class StagehandResponseParseError extends StagehandAPIError {
    constructor(message: string);
}

interface ActOptions {
    model?: ModelConfiguration;
    variables?: Record<string, string>;
    timeout?: number;
    page?: Page$1 | Page$2 | Page$3 | Page;
}
interface ActResult {
    success: boolean;
    message: string;
    actionDescription: string;
    actions: Action[];
}
type ExtractResult<T extends StagehandZodSchema> = InferStagehandSchema<T>;
interface Action {
    selector: string;
    description: string;
    method?: string;
    arguments?: string[];
}
interface HistoryEntry {
    method: "act" | "extract" | "observe" | "navigate" | "agent";
    parameters: unknown;
    result: unknown;
    timestamp: string;
}
interface ExtractOptions {
    model?: ModelConfiguration;
    timeout?: number;
    selector?: string;
    page?: Page$1 | Page$2 | Page$3 | Page;
}
declare const defaultExtractSchema: z.ZodObject<{
    extraction: z.ZodString;
}, z.core.$strip>;
declare const pageTextSchema: z.ZodObject<{
    pageText: z.ZodString;
}, z.core.$strip>;
interface ObserveOptions {
    model?: ModelConfiguration;
    timeout?: number;
    selector?: string;
    page?: Page$1 | Page$2 | Page$3 | Page;
}
declare enum V3FunctionName {
    ACT = "ACT",
    EXTRACT = "EXTRACT",
    OBSERVE = "OBSERVE",
    AGENT = "AGENT"
}

interface StagehandMetrics {
    actPromptTokens: number;
    actCompletionTokens: number;
    actReasoningTokens: number;
    actCachedInputTokens: number;
    actInferenceTimeMs: number;
    extractPromptTokens: number;
    extractCompletionTokens: number;
    extractReasoningTokens: number;
    extractCachedInputTokens: number;
    extractInferenceTimeMs: number;
    observePromptTokens: number;
    observeCompletionTokens: number;
    observeReasoningTokens: number;
    observeCachedInputTokens: number;
    observeInferenceTimeMs: number;
    agentPromptTokens: number;
    agentCompletionTokens: number;
    agentReasoningTokens: number;
    agentCachedInputTokens: number;
    agentInferenceTimeMs: number;
    totalPromptTokens: number;
    totalCompletionTokens: number;
    totalReasoningTokens: number;
    totalCachedInputTokens: number;
    totalInferenceTimeMs: number;
}

type V3Env = "LOCAL" | "BROWSERBASE";
declare const localBrowserLaunchOptionsSchema: z.ZodObject<{
    args: z.ZodOptional<z.ZodArray<z.ZodString>>;
    executablePath: z.ZodOptional<z.ZodString>;
    userDataDir: z.ZodOptional<z.ZodString>;
    preserveUserDataDir: z.ZodOptional<z.ZodBoolean>;
    headless: z.ZodOptional<z.ZodBoolean>;
    devtools: z.ZodOptional<z.ZodBoolean>;
    chromiumSandbox: z.ZodOptional<z.ZodBoolean>;
    ignoreDefaultArgs: z.ZodOptional<z.ZodUnion<readonly [z.ZodBoolean, z.ZodArray<z.ZodString>]>>;
    proxy: z.ZodOptional<z.ZodObject<{
        server: z.ZodString;
        bypass: z.ZodOptional<z.ZodString>;
        username: z.ZodOptional<z.ZodString>;
        password: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    locale: z.ZodOptional<z.ZodString>;
    viewport: z.ZodOptional<z.ZodObject<{
        width: z.ZodNumber;
        height: z.ZodNumber;
    }, z.core.$strip>>;
    deviceScaleFactor: z.ZodOptional<z.ZodNumber>;
    hasTouch: z.ZodOptional<z.ZodBoolean>;
    ignoreHTTPSErrors: z.ZodOptional<z.ZodBoolean>;
    cdpUrl: z.ZodOptional<z.ZodString>;
    connectTimeoutMs: z.ZodOptional<z.ZodNumber>;
    downloadsPath: z.ZodOptional<z.ZodString>;
    acceptDownloads: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strict>;
type LocalBrowserLaunchOptions = z.infer<typeof LocalBrowserLaunchOptionsSchema>;
/** Constructor options for V3 */
interface V3Options {
    env: V3Env;
    apiKey?: string;
    projectId?: string;
    /**
     * Optional: fine-tune Browserbase session creation or resume an existing session.
     */
    browserbaseSessionCreateParams?: BrowserbaseSessionCreateParams;
    browserbaseSessionID?: string;
    localBrowserLaunchOptions?: LocalBrowserLaunchOptions;
    model?: ModelConfiguration;
    llmClient?: LLMClient;
    systemPrompt?: string;
    logInferenceToFile?: boolean;
    experimental?: boolean;
    verbose?: 0 | 1 | 2;
    selfHeal?: boolean;
    waitForCaptchaSolves?: boolean;
    actTimeoutMs?: number;
    /** Disable pino logging backend (useful for tests or minimal environments). */
    disablePino?: boolean;
    /** Optional external logger hook for integrating with host apps. */
    logger?: (line: LogLine) => void;
    /** Directory used to persist cached actions for act(). */
    cacheDir?: string;
    domSettleTimeout?: number;
    disableAPI?: boolean;
}

declare class StagehandError extends Error {
    constructor(message: string);
}
declare class StagehandDefaultError extends StagehandError {
    constructor(error?: unknown);
}
declare class StagehandEnvironmentError extends StagehandError {
    constructor(currentEnvironment: string, requiredEnvironment: string, feature: string);
}
declare class MissingEnvironmentVariableError extends StagehandError {
    constructor(missingEnvironmentVariable: string, feature: string);
}
declare class UnsupportedModelError extends StagehandError {
    constructor(supportedModels: string[], feature?: string);
}
declare class UnsupportedModelProviderError extends StagehandError {
    constructor(supportedProviders: string[], feature?: string);
}
declare class UnsupportedAISDKModelProviderError extends StagehandError {
    constructor(provider: string, supportedProviders: string[]);
}
declare class InvalidAISDKModelFormatError extends StagehandError {
    constructor(modelName: string);
}
declare class StagehandNotInitializedError extends StagehandError {
    constructor(prop: string);
}
declare class BrowserbaseSessionNotFoundError extends StagehandError {
    constructor();
}
declare class CaptchaTimeoutError extends StagehandError {
    constructor();
}
declare class MissingLLMConfigurationError extends StagehandError {
    constructor();
}
declare class HandlerNotInitializedError extends StagehandError {
    constructor(handlerType: string);
}
declare class StagehandInvalidArgumentError extends StagehandError {
    constructor(message: string);
}
declare class StagehandElementNotFoundError extends StagehandError {
    constructor(xpaths: string[]);
}
declare class AgentScreenshotProviderError extends StagehandError {
    constructor(message: string);
}
declare class StagehandMissingArgumentError extends StagehandError {
    constructor(message: string);
}
declare class CreateChatCompletionResponseError extends StagehandError {
    constructor(message: string);
}
declare class StagehandEvalError extends StagehandError {
    constructor(message: string);
}
declare class StagehandDomProcessError extends StagehandError {
    constructor(message: string);
}
declare class StagehandClickError extends StagehandError {
    constructor(message: string, selector: string);
}
declare class LLMResponseError extends StagehandError {
    constructor(primitive: string, message: string);
}
declare class StagehandIframeError extends StagehandError {
    constructor(frameUrl: string, message: string);
}
declare class ContentFrameNotFoundError extends StagehandError {
    constructor(selector: string);
}
declare class XPathResolutionError extends StagehandError {
    constructor(xpath: string);
}
declare class ExperimentalApiConflictError extends StagehandError {
    constructor();
}
declare class ExperimentalNotConfiguredError extends StagehandError {
    constructor(featureName: string);
}
declare class CuaModelRequiredError extends StagehandError {
    constructor(availableModels: readonly string[]);
}
declare class ZodSchemaValidationError extends Error {
    readonly received: unknown;
    readonly issues: ReturnType<ZodError["format"]>;
    constructor(received: unknown, issues: ReturnType<ZodError["format"]>);
}
declare class StagehandInitError extends StagehandError {
    constructor(message: string);
}
declare class MCPConnectionError extends StagehandError {
    readonly serverUrl: string;
    readonly originalError: unknown;
    constructor(serverUrl: string, originalError: unknown);
}
declare class StagehandShadowRootMissingError extends StagehandError {
    constructor(detail?: string);
}
declare class StagehandShadowSegmentEmptyError extends StagehandError {
    constructor();
}
declare class StagehandShadowSegmentNotFoundError extends StagehandError {
    constructor(segment: string, hint?: string);
}
declare class ElementNotVisibleError extends StagehandError {
    constructor(selector: string);
}
declare class ResponseBodyError extends StagehandError {
    constructor(message: string);
}
declare class ResponseParseError extends StagehandError {
    constructor(message: string);
}
declare class TimeoutError extends StagehandError {
    constructor(operation: string, timeoutMs: number);
}
declare class ActTimeoutError extends TimeoutError {
    constructor(timeoutMs: number);
}
declare class ExtractTimeoutError extends TimeoutError {
    constructor(timeoutMs: number);
}
declare class ObserveTimeoutError extends TimeoutError {
    constructor(timeoutMs: number);
}
declare class PageNotFoundError extends StagehandError {
    constructor(identifier: string);
}
declare class ConnectionTimeoutError extends StagehandError {
    constructor(message: string);
}
declare class StreamingCallbacksInNonStreamingModeError extends StagehandError {
    readonly invalidCallbacks: string[];
    constructor(invalidCallbacks: string[]);
}
declare class AgentAbortError extends StagehandError {
    readonly reason: string;
    constructor(reason?: string);
}
declare class StagehandClosedError extends StagehandError {
    constructor();
}

declare class AISdkClient extends LLMClient {
    type: "aisdk";
    private model;
    constructor({ model }: {
        model: LanguageModelV2;
    });
    createChatCompletion<T = ChatCompletion>({ options, }: CreateChatCompletionOptions): Promise<T>;
}

/**
 * Constructor parameters for StagehandAPIClient
 */
interface StagehandAPIConstructorParams {
    apiKey: string;
    projectId: string;
    logger: (message: LogLine) => void;
}
/**
 * Parameters for starting a session via the API client.
 * Extends Api.SessionStartRequest with client-specific field (modelApiKey).
 *
 * Wire format: Api.SessionStartRequest (modelApiKey sent via header, not body)
 */
interface ClientSessionStartParams extends SessionStartRequest {
    /** Model API key - sent via x-model-api-key header, not in request body */
    modelApiKey: string;
}
/**
 * Client parameters for act() method.
 * Derives structure from Api.ActRequest but uses SDK's ActOptions (which includes `page`).
 * Before serialization, `page` is stripped to produce Api.ActRequest wire format.
 */
interface ClientActParameters {
    input: ActRequest["input"];
    options?: ActOptions;
    frameId?: ActRequest["frameId"];
}
/**
 * Client parameters for extract() method.
 * Derives structure from Api.ExtractRequest but uses SDK's ExtractOptions (which includes `page`)
 * and accepts Zod schema (converted to JSON schema for wire format).
 */
interface ClientExtractParameters {
    instruction?: ExtractRequest["instruction"];
    schema?: StagehandZodSchema;
    options?: ExtractOptions;
    frameId?: ExtractRequest["frameId"];
}
/**
 * Client parameters for observe() method.
 * Derives structure from Api.ObserveRequest but uses SDK's ObserveOptions (which includes `page`).
 * Before serialization, `page` is stripped to produce Api.ObserveRequest wire format.
 */
interface ClientObserveParameters {
    instruction?: ObserveRequest["instruction"];
    options?: ObserveOptions;
    frameId?: ObserveRequest["frameId"];
}
declare class StagehandAPIClient {
    private apiKey;
    private projectId;
    private sessionId?;
    private modelApiKey;
    private modelProvider?;
    private logger;
    private fetchWithCookies;
    constructor({ apiKey, projectId, logger }: StagehandAPIConstructorParams);
    init({ modelName, modelApiKey, domSettleTimeoutMs, verbose, systemPrompt, selfHeal, browserbaseSessionCreateParams, browserbaseSessionID, }: ClientSessionStartParams): Promise<SessionStartResult>;
    act({ input, options, frameId, }: ClientActParameters): Promise<ActResult>;
    extract<T extends StagehandZodSchema>({ instruction, schema: zodSchema, options, frameId, }: ClientExtractParameters): Promise<ExtractResult<T>>;
    observe({ instruction, options, frameId, }: ClientObserveParameters): Promise<Action[]>;
    goto(url: string, options?: NavigateRequest["options"], frameId?: string): Promise<SerializableResponse | null>;
    agentExecute(agentConfig: AgentConfig, executeOptions: AgentExecuteOptions | string, frameId?: string): Promise<AgentResult>;
    end(): Promise<Response>;
    getReplayMetrics(): Promise<StagehandMetrics>;
    /**
     * Prepares a model configuration for the API payload by ensuring the `apiKey`
     * is included. If the model is passed as a string, converts it to an object
     * with `modelName` and `apiKey`.
     *
     * In API mode, we only attempt to load an API key from env vars when the
     * model provider differs from the one used to init the session.
     */
    private prepareModelConfig;
    private execute;
    private request;
}

/**
 * V3Context
 *
 * Owns the root CDP connection and wires Target/Page events into Page.
 * Maintains one Page per top-level target, adopts OOPIF child sessions into the owner Page,
 * and tracks target→page and (root) frame→target mappings for lookups.
 *
 * IMPORTANT: FrameId → session ownership is managed inside Page (via its FrameRegistry).
 * Context never “guesses” owners; it simply forwards events (with the emitting session)
 * so Page can record the correct owner at event time.
 */
declare class V3Context {
    readonly conn: CdpConnection;
    private readonly env;
    private readonly apiClient;
    private readonly localBrowserLaunchOptions;
    private constructor();
    private readonly _piercerInstalled;
    private _lastPopupSignalAt;
    private sessionKey;
    private readonly _sessionInit;
    private pagesByTarget;
    private mainFrameToTarget;
    private sessionOwnerPage;
    private frameOwnerPage;
    private pendingOopifByMainFrame;
    private createdAtByTarget;
    private typeByTarget;
    private _pageOrder;
    private pendingCreatedTargetUrl;
    private readonly initScripts;
    /**
     * Create a Context for a given CDP websocket URL and bootstrap target wiring.
     */
    static create(wsUrl: string, opts?: {
        env?: "LOCAL" | "BROWSERBASE";
        apiClient?: StagehandAPIClient | null;
        localBrowserLaunchOptions?: LocalBrowserLaunchOptions | null;
    }): Promise<V3Context>;
    /**
     * Wait until at least one top-level Page has been created and registered.
     * We poll internal maps that bootstrap/onAttachedToTarget populate.
     */
    private waitForFirstTopLevelPage;
    private waitForInitialTopLevelTargets;
    private ensurePiercer;
    /** Mark a page target as the most-recent one (active). */
    private _pushActive;
    /** Remove a page target from the recency list (used on close). */
    private _removeFromOrder;
    /** Return the current active Page (most-recent page that still exists). */
    activePage(): Page | undefined;
    /** Explicitly mark a known Page as the most-recent active page (and focus it). */
    setActivePage(page: Page): void;
    addInitScript<Arg>(script: InitScriptSource<Arg>, arg?: Arg): Promise<void>;
    /**
     * Return top-level `Page`s (oldest → newest). OOPIF targets are not included.
     */
    pages(): Page[];
    private applyInitScriptsToPage;
    /**
     * Resolve an owning `Page` by the **top-level main frame id**.
     * Note: child (OOPIF) roots are intentionally not present in this mapping.
     */
    resolvePageByMainFrameId(frameId: string): Page | undefined;
    /**
     * Serialize the full frame tree for a given top-level main frame id.
     */
    getFullFrameTreeByMainFrameId(rootMainFrameId: string): Promise<Protocol.Page.FrameTree>;
    /**
     * Create a new top-level page (tab) with the given URL and return its Page object.
     * Waits until the target is attached and registered.
     */
    newPage(url?: string): Promise<Page>;
    /**
     * Close CDP and clear all mappings. Best-effort cleanup.
     */
    close(): Promise<void>;
    /**
     * Bootstrap target lifecycle:
     * - Attach to existing targets.
     * - Attach on `Target.targetCreated` (fallback for OOPIFs).
     * - Handle auto-attach events.
     * - Clean up on detach/destroy.
     */
    private bootstrap;
    /**
     * Handle a newly attached target (top-level or potential OOPIF):
     * - Enable Page domain and lifecycle events.
     * - If top-level → create Page, wire listeners, resume.
     * - Else → probe child root frame id via `Page.getFrameTree` and adopt immediately
     *   if the parent is known; otherwise stage until parent `frameAttached`.
     * - Resume the target only after listeners are wired.
     */
    private onAttachedToTarget;
    /**
     * Detach handler:
     * - Remove child session ownership and prune its subtree.
     * - If a top-level target, cleanup its `Page` and mappings.
     * - Drop any staged child for this session.
     */
    private onDetachedFromTarget;
    /**
     * Cleanup a top-level Page by target id, removing its root and staged children.
     */
    private cleanupByTarget;
    /**
     * Wire Page-domain frame events for a session into the owning Page & mappings.
     * We forward the *emitting session* with every event so Page can stamp ownership precisely.
     */
    private installFrameEventBridges;
    /**
     * Register that a session belongs to a Page (used by event routing).
     */
    private wireSessionToOwnerPage;
    /**
     * Utility: reverse-lookup the top-level target id that owns a given Page.
     */
    private findTargetIdByPage;
    private _notePopupSignal;
    /**
     * Await the current active page, waiting briefly if a popup/open was just triggered.
     * Normal path returns immediately; popup path waits up to timeoutMs for the new page.
     */
    awaitActivePage(timeoutMs?: number): Promise<Page>;
}

type AgentReplayStep = AgentReplayActStep | AgentReplayFillFormStep | AgentReplayGotoStep | AgentReplayScrollStep | AgentReplayWaitStep | AgentReplayNavBackStep | AgentReplayKeysStep | {
    type: string;
    [key: string]: unknown;
};
interface AgentReplayActStep {
    type: "act";
    instruction: string;
    actions?: Action[];
    actionDescription?: string;
    message?: string;
    timeout?: number;
}
interface AgentReplayFillFormStep {
    type: "fillForm";
    fields?: Array<{
        action: string;
        value: string;
    }>;
    observeResults?: Action[];
    actions?: Action[];
}
interface AgentReplayGotoStep {
    type: "goto";
    url: string;
    waitUntil?: LoadState;
}
interface AgentReplayScrollStep {
    type: "scroll";
    deltaX?: number;
    deltaY?: number;
    anchor?: {
        x: number;
        y: number;
    };
}
interface AgentReplayWaitStep {
    type: "wait";
    timeMs: number;
}
interface AgentReplayNavBackStep {
    type: "navback";
    waitUntil?: LoadState;
}
interface AgentReplayKeysStep {
    type: "keys";
    instruction?: string;
    playwrightArguments: {
        method: "type" | "press";
        text?: string;
        keys?: string;
        times?: number;
    };
}

/**
 * Response
 * -----------------
 *
 * This module implements a Playwright-inspired response wrapper that exposes
 * navigation metadata and helpers for retrieving HTTP response bodies. The
 * abstraction is consumed by navigation routines (e.g. `Page.goto`) so callers
 * can synchronously inspect status codes, lazily fetch body text, or await the
 * network layer finishing the request. The implementation is built directly on
 * Chrome DevTools Protocol primitives – it holds the originating `requestId`
 * so it can request payloads via `Network.getResponseBody`, and it listens for
 * `responseReceivedExtraInfo`, `loadingFinished`, and `loadingFailed` events to
 * hydrate the richer header view and resolve callers waiting on completion.
 */

type ServerAddr = {
    ipAddress: string;
    port: number;
};
/**
 * Thin wrapper around CDP response metadata that mirrors the ergonomics of
 * Playwright's `Response` class. The class intentionally keeps the same method
 * names so upstream integrations can transition with minimal code changes.
 */
declare class Response$1 {
    private readonly page;
    private readonly session;
    private readonly requestId;
    private readonly frameId?;
    private readonly loaderId?;
    private readonly response;
    private readonly fromServiceWorkerFlag;
    private readonly serverAddress?;
    private headersObject;
    private headersArrayCache;
    private allHeadersCache;
    private readonly headerValuesMap;
    private finishedDeferred;
    private finishedSettled;
    private extraInfoHeaders;
    private extraInfoHeadersText;
    /**
     * Build a response wrapper from the CDP notification associated with a
     * navigation. The constructor captures the owning page/session so follow-up
     * methods (body/text/json) can query CDP on-demand. The `response` payload is
     * the raw `Protocol.Network.Response` object emitted by Chrome.
     */
    constructor(params: {
        page: Page;
        session: CDPSessionLike;
        requestId: string;
        frameId?: string;
        loaderId?: string;
        response: Protocol.Network.Response;
        fromServiceWorker: boolean;
    });
    /** URL associated with the navigation request. */
    url(): string;
    /** HTTP status code reported by Chrome. */
    status(): number;
    /** Human-readable status text that accompanied the response. */
    statusText(): string;
    /** Convenience predicate that checks for 2xx statuses. */
    ok(): boolean;
    /** Returns the Stagehand frame object that initiated the navigation. */
    frame(): Frame | null;
    /** Indicates whether the response was serviced by a Service Worker. */
    fromServiceWorker(): boolean;
    /**
     * Returns TLS security metadata when provided by the browser. In practice
     * this includes certificate issuer, protocol, and validity interval.
     */
    securityDetails(): Promise<Protocol.Network.SecurityDetails | null>;
    /** Returns the resolved server address for the navigation when available. */
    serverAddr(): Promise<ServerAddr | null>;
    /**
     * Returns the response headers normalised to lowercase keys. Matches the
     * behaviour of Playwright's `headers()` by eliding duplicate header entries.
     */
    headers(): Record<string, string>;
    /**
     * Returns all headers including those only surfaced through
     * `responseReceivedExtraInfo` such as `set-cookie`. Values are reported as the
     * browser sends them (no further splitting or concatenation).
     */
    allHeaders(): Promise<Record<string, string>>;
    /** Returns a concatenated header string for the supplied header name. */
    headerValue(name: string): Promise<string | null>;
    /** Returns all values for a header (case-insensitive lookup). */
    headerValues(name: string): Promise<string[]>;
    /**
     * Returns header entries preserving their original wire casing and ordering.
     * Falls back to the CDP object when the raw header text is unavailable.
     */
    headersArray(): Promise<Array<{
        name: string;
        value: string;
    }>>;
    /**
     * Requests the raw response body from Chrome DevTools Protocol. The method is
     * intentionally lazy because not every caller needs the payload, and CDP only
     * allows retrieving it once the response completes.
     */
    body(): Promise<Buffer>;
    /** Decodes the response body as UTF-8 text. */
    text(): Promise<string>;
    /** Parses the response body as JSON and throws if parsing fails. */
    json<T = unknown>(): Promise<T>;
    /**
     * Resolves once the underlying network request completes or fails. Mirrors
     * Playwright's behaviour by resolving to `null` on success and to an `Error`
     * instance when Chrome reports `Network.loadingFailed`.
     */
    finished(): Promise<null | Error>;
    /**
     * Internal helper invoked by the navigation tracker when CDP reports extra
     * header information. This keeps the cached header views in sync with the
     * richer metadata.
     */
    applyExtraInfo(event: Protocol.Network.ResponseReceivedExtraInfoEvent): void;
    /**
     * Internal helper for creating a Response object from a Serializable
     * goto response from the Stagehand API
     */
    static fromSerializable(serialized: SerializableResponse, context: {
        page: Page;
        session: CDPSessionLike;
    }): Response$1;
    /** Marks the response as finished and resolves the `finished()` promise. */
    markFinished(error: Error | null): void;
}

type AnyPage = Page$1 | Page$2 | Page$3 | Page;

type LoadState = "load" | "domcontentloaded" | "networkidle";

type ScreenshotAnimationsOption = "disabled" | "allow";
type ScreenshotCaretOption = "hide" | "initial";
type ScreenshotScaleOption = "css" | "device";
interface ScreenshotClip {
    x: number;
    y: number;
    width: number;
    height: number;
}
interface ScreenshotOptions {
    animations?: ScreenshotAnimationsOption;
    caret?: ScreenshotCaretOption;
    clip?: ScreenshotClip;
    fullPage?: boolean;
    mask?: Locator[];
    maskColor?: string;
    omitBackground?: boolean;
    path?: string;
    quality?: number;
    scale?: ScreenshotScaleOption;
    style?: string;
    timeout?: number;
    type?: "png" | "jpeg";
}

declare class Page {
    private readonly conn;
    private readonly mainSession;
    private readonly _targetId;
    /** Every CDP child session this page owns (top-level + adopted OOPIF sessions). */
    private readonly sessions;
    /** Unified truth for frame topology + ownership. */
    private readonly registry;
    /** A convenience wrapper bound to the current main frame id (top-level session). */
    private mainFrameWrapper;
    /** Compact ordinal per frameId (used by snapshot encoding). */
    private frameOrdinals;
    private nextOrdinal;
    /** cache Frames per frameId so everyone uses the same one */
    private readonly frameCache;
    private readonly browserIsRemote;
    /** Stable id for Frames created by this Page (use top-level TargetId). */
    private readonly pageId;
    /** Cached current URL for synchronous page.url() */
    private _currentUrl;
    private navigationCommandSeq;
    private latestNavigationCommandId;
    private readonly networkManager;
    /** Optional API client for routing page operations to the API */
    private readonly apiClient;
    private readonly consoleListeners;
    private readonly consoleHandlers;
    /** Document-start scripts installed across every session this page owns. */
    private readonly initScripts;
    private constructor();
    private installInitScriptOnSession;
    private applyInitScriptsToSession;
    registerInitScript(source: string): Promise<void>;
    private cursorEnabled;
    private ensureCursorScript;
    enableCursorOverlay(): Promise<void>;
    private updateCursor;
    addInitScript<Arg>(script: InitScriptSource<Arg>, arg?: Arg): Promise<void>;
    /**
     * Factory: create Page and seed registry with the shallow tree from Page.getFrameTree.
     * Assumes Page domain is already enabled on the session passed in.
     */
    static create(conn: CdpConnection, session: CDPSessionLike, targetId: string, apiClient?: StagehandAPIClient | null, localBrowserLaunchOptions?: LocalBrowserLaunchOptions | null, browserIsRemote?: boolean): Promise<Page>;
    /**
     * Parent/child session emitted a `frameAttached`.
     * Topology update + ownership stamped to **emitting session**.
     */
    onFrameAttached(frameId: string, parentId: string | null, session: CDPSessionLike): void;
    /**
     * Parent/child session emitted a `frameDetached`.
     */
    onFrameDetached(frameId: string, reason?: "remove" | "swap" | string): void;
    /**
     * Parent/child session emitted a `frameNavigated`.
     * Topology + ownership update. Handles root swaps.
     */
    onFrameNavigated(frame: Protocol.Page.Frame, session: CDPSessionLike): void;
    onNavigatedWithinDocument(frameId: string, url: string, session: CDPSessionLike): void;
    /**
     * An OOPIF child session whose **main** frame id equals the parent iframe’s frameId
     * has been attached; adopt the session into this Page and seed ownership for its subtree.
     */
    adoptOopifSession(childSession: CDPSessionLike, childMainFrameId: string): void;
    /** Detach an adopted child session and prune its subtree */
    detachOopifSession(sessionId: string): void;
    /** Return the owning CDP session for a frameId (falls back to main session) */
    getSessionForFrame(frameId: string): CDPSessionLike;
    /** Always returns a Frame bound to the owning session */
    frameForId(frameId: string): Frame;
    /** Expose a session by id (used by snapshot to resolve session id -> session) */
    getSessionById(id: string): CDPSessionLike | undefined;
    registerSessionForNetwork(session: CDPSessionLike): void;
    unregisterSessionForNetwork(sessionId: string | undefined): void;
    on(event: "console", listener: ConsoleListener): Page;
    once(event: "console", listener: ConsoleListener): Page;
    off(event: "console", listener: ConsoleListener): Page;
    targetId(): string;
    /**
     * Send a CDP command through the main session.
     * Allows external consumers to execute arbitrary Chrome DevTools Protocol commands.
     *
     * @param method - The CDP method name (e.g., "Page.enable", "Runtime.evaluate")
     * @param params - Optional parameters for the CDP command
     * @returns Promise resolving to the typed CDP response
     *
     * @example
     * // Enable the Runtime domain
     * await page.sendCDP("Runtime.enable");
     *
     * @example
     * // Evaluate JavaScript with typed response
     * const result = await page.sendCDP<Protocol.Runtime.EvaluateResponse>(
     *   "Runtime.evaluate",
     *   { expression: "1 + 1" }
     * );
     */
    sendCDP<T = unknown>(method: string, params?: object): Promise<T>;
    /** Seed the cached URL before navigation events converge. */
    seedCurrentUrl(url: string | undefined | null): void;
    mainFrameId(): string;
    mainFrame(): Frame;
    /**
     * Close this top-level page (tab). Best-effort via Target.closeTarget.
     */
    close(): Promise<void>;
    getFullFrameTree(): Protocol.Page.FrameTree;
    asProtocolFrameTree(rootMainFrameId: string): Protocol.Page.FrameTree;
    private ensureOrdinal;
    /** Public getter for snapshot code / handlers. */
    getOrdinal(frameId: string): number;
    listAllFrameIds(): string[];
    private ensureConsoleTaps;
    private installConsoleTap;
    private sessionKey;
    private resolveSessionByKey;
    private teardownConsoleTap;
    private removeAllConsoleTaps;
    private emitConsole;
    /**
     * Navigate the page; optionally wait for a lifecycle state.
     * Waits on the **current** main frame and follows root swaps during navigation.
     */
    goto(url: string, options?: {
        waitUntil?: LoadState;
        timeoutMs?: number;
    }): Promise<Response$1 | null>;
    /**
     * Reload the page; optionally wait for a lifecycle state.
     */
    reload(options?: {
        waitUntil?: LoadState;
        timeoutMs?: number;
        ignoreCache?: boolean;
    }): Promise<Response$1 | null>;
    /**
     * Navigate back in history if possible; optionally wait for a lifecycle state.
     */
    goBack(options?: {
        waitUntil?: LoadState;
        timeoutMs?: number;
    }): Promise<Response$1 | null>;
    /**
     * Navigate forward in history if possible; optionally wait for a lifecycle state.
     */
    goForward(options?: {
        waitUntil?: LoadState;
        timeoutMs?: number;
    }): Promise<Response$1 | null>;
    /**
     * Return the current page URL (synchronous, cached from navigation events).
     */
    url(): string;
    private beginNavigationCommand;
    isCurrentNavigationCommand(id: number): boolean;
    /**
     * Return the current page title.
     * Prefers reading from the active document via Runtime.evaluate to reflect dynamic changes.
     * Falls back to navigation history title if evaluation is unavailable.
     */
    title(): Promise<string>;
    /**
     * Capture a screenshot with Playwright-style options.
     *
     * @param options Optional screenshot configuration.
     * @param options.animations Control CSS/Web animations during capture. Use
     * "disabled" to fast-forward finite animations and pause infinite ones.
     * @param options.caret Either hide the text caret (default) or leave it
     * visible via "initial".
     * @param options.clip Restrict capture to a specific rectangle (in CSS
     * pixels). Cannot be combined with `fullPage`.
     * @param options.fullPage Capture the full scrollable page instead of the
     * current viewport.
     * @param options.mask Array of locators that should be covered with an
     * overlay while the screenshot is taken.
     * @param options.maskColor CSS color used for the mask overlay (default
     * `#FF00FF`).
     * @param options.omitBackground Make the default page background transparent
     * (PNG only).
     * @param options.path File path to write the screenshot to. The file extension
     * determines the image type when `type` is not explicitly provided.
     * @param options.quality JPEG quality (0–100). Only applies when
     * `type === "jpeg"`.
     * @param options.scale Render scale: use "css" for one pixel per CSS pixel,
     * otherwise the default "device" leverages the current device pixel ratio.
     * @param options.style Additional CSS text injected into every frame before
     * capture (removed afterwards).
     * @param options.timeout Maximum capture duration in milliseconds before a
     * timeout error is thrown.
     * @param options.type Image format (`"png"` by default).
     */
    screenshot(options?: ScreenshotOptions): Promise<Buffer>;
    /**
     * Create a locator bound to the current main frame.
     */
    locator(selector: string): ReturnType<Frame["locator"]>;
    /**
     * Deep locator that supports cross-iframe traversal.
     * - Recognizes '>>' hop notation to enter iframe contexts.
     * - Supports deep XPath that includes iframe steps (e.g., '/html/body/iframe[2]//div').
     * Returns a Locator scoped to the appropriate frame.
     */
    deepLocator(selector: string): DeepLocatorDelegate;
    /**
     * Frame locator similar to Playwright: targets iframe elements and scopes
     * subsequent locators to that frame. Supports chaining.
     */
    frameLocator(selector: string): FrameLocator;
    /**
     * List all frames belonging to this page as Frame objects bound to their owning sessions.
     * The list is ordered by a stable ordinal assigned during the page lifetime.
     */
    frames(): Frame[];
    /**
     * Wait until the page reaches a lifecycle state on the current main frame.
     * Mirrors Playwright's API signatures.
     */
    waitForLoadState(state: LoadState, timeoutMs?: number): Promise<void>;
    /**
     * Evaluate a function or expression in the current main frame's main world.
     * - If a string is provided, it is treated as a JS expression.
     * - If a function is provided, it is stringified and invoked with the optional argument.
     * - The return value should be JSON-serializable. Non-serializable objects will
     *   best-effort serialize via JSON.stringify inside the page context.
     */
    evaluate<R = unknown, Arg = unknown>(pageFunctionOrExpression: string | ((arg: Arg) => R | Promise<R>), arg?: Arg): Promise<R>;
    /**
     * Force the page viewport to an exact CSS size and device scale factor.
     * Ensures screenshots match width x height pixels when deviceScaleFactor = 1.
     */
    setViewportSize(width: number, height: number, options?: {
        deviceScaleFactor?: number;
    }): Promise<void>;
    /**
     * Click at absolute page coordinates (CSS pixels).
     * Dispatches mouseMoved → mousePressed → mouseReleased via CDP Input domain
     * on the top-level page target's session. Coordinates are relative to the
     * viewport origin (top-left). Does not scroll.
     */
    click(x: number, y: number, options?: {
        button?: "left" | "right" | "middle";
        clickCount?: number;
        returnXpath?: boolean;
    }): Promise<string>;
    /**
     * Hover at absolute page coordinates (CSS pixels).
     * Dispatches mouseMoved via CDP Input domain on the top-level page target's
     * session.
     */
    hover(x: number, y: number, options?: {
        returnXpath?: boolean;
    }): Promise<string>;
    scroll(x: number, y: number, deltaX: number, deltaY: number, options?: {
        returnXpath?: boolean;
    }): Promise<string>;
    /**
     * Drag from (fromX, fromY) to (toX, toY) using mouse events.
     * Sends mouseMoved → mousePressed → mouseMoved (steps) → mouseReleased.
     */
    dragAndDrop(fromX: number, fromY: number, toX: number, toY: number, options?: {
        button?: "left" | "right" | "middle";
        steps?: number;
        delay?: number;
        returnXpath?: boolean;
    }): Promise<[string, string]>;
    /**
     * Type a string by dispatching keyDown/keyUp events per character.
     * Focus must already be on the desired element. Uses CDP Input.dispatchKeyEvent
     * and never falls back to Input.insertText. Optional delay applies between
     * successive characters.
     */
    type(text: string, options?: {
        delay?: number;
        withMistakes?: boolean;
    }): Promise<void>;
    /**
     * Press a single key or key combination (keyDown then keyUp).
     * For printable characters, uses the text path on keyDown; for named keys, sets key/code/VK.
     * Supports key combinations with modifiers like "Cmd+A", "Ctrl+C", "Shift+Tab", etc.
     */
    keyPress(key: string, options?: {
        delay?: number;
    }): Promise<void>;
    private _pressedModifiers;
    /** Press a key down without releasing it */
    private keyDown;
    /** Release a pressed key */
    private keyUp;
    /** Normalize key names to match CDP expectations */
    private normalizeModifierKey;
    /**
     * Get the map of named keys with their properties
     */
    private getNamedKeys;
    /**
     * Minimal description for printable keys (letters/digits/space) to provide code and VK.
     * Used when non-Shift modifiers are pressed to avoid sending text while keeping accelerator info.
     */
    private describePrintableKey;
    private isMacOS;
    /**
     * Return Chromium mac editing commands (without trailing ':') for a given code like 'KeyA'
     * Only used on macOS to trigger system editing shortcuts (e.g., selectAll, copy, paste...).
     */
    private macCommandsFor;
    /** Resolve the main-world execution context for the current main frame. */
    private mainWorldExecutionContextId;
    /**
     * Wait until the **current** main frame reaches a lifecycle state.
     * - Fast path via `document.readyState`.
     * - Event path listens at the session level and compares incoming `frameId`
     *   to `mainFrameId()` **at event time** to follow root swaps.
     */
    waitForMainLoadState(state: LoadState, timeoutMs?: number): Promise<void>;
}

interface AgentContext {
    options: AgentExecuteOptionsBase;
    maxSteps: number;
    systemPrompt: string;
    allTools: ToolSet;
    messages: ModelMessage[];
    wrappedModel: ReturnType<typeof wrapLanguageModel>;
    initialPageUrl: string;
}
interface AgentState {
    collectedReasoning: string[];
    actions: AgentAction[];
    finalMessage: string;
    completed: boolean;
    currentPageUrl: string;
}
interface AgentAction {
    type: string;
    reasoning?: string;
    taskCompleted?: boolean;
    action?: string;
    timeMs?: number;
    pageText?: string;
    pageUrl?: string;
    instruction?: string;
    [key: string]: unknown;
}
interface AgentResult {
    success: boolean;
    message: string;
    actions: AgentAction[];
    completed: boolean;
    metadata?: Record<string, unknown>;
    usage?: {
        input_tokens: number;
        output_tokens: number;
        reasoning_tokens?: number;
        cached_input_tokens?: number;
        inference_time_ms: number;
    };
    /**
     * The conversation messages from this execution.
     * Pass these to a subsequent execute() call via the `messages` option to continue the conversation.
     * @experimental
     */
    messages?: ModelMessage[];
}
type AgentStreamResult = StreamTextResult<ToolSet, never> & {
    result: Promise<AgentResult>;
};
/**
 * Base callbacks shared between execute (non-streaming) and streaming modes.
 */
interface AgentCallbacks {
    /**
     * Optional function called before each step to modify settings.
     * You can change the model, tool choices, active tools, system prompt,
     * and input messages for each step.
     */
    prepareStep?: PrepareStepFunction<ToolSet>;
    /**
     * Callback called when each step (LLM call) is finished.
     * This is called for intermediate steps as well as the final step.
     */
    onStepFinish?: GenerateTextOnStepFinishCallback<ToolSet> | StreamTextOnStepFinishCallback<ToolSet>;
}
/**
 * Error message type for streaming-only callbacks used in non-streaming mode.
 * This provides a clear error message when users try to use streaming callbacks without stream: true.
 */
type StreamingCallbackNotAvailable = "This callback requires 'stream: true' in AgentConfig. Set stream: true to use streaming callbacks like onChunk, onFinish, onError, and onAbort.";
/**
 * Error message for safety confirmation callback misuse.
 * Safety confirmations are only available for non-streaming CUA agent executions.
 */
type SafetyConfirmationCallbackNotAvailable = "Safety confirmation callbacks are only available via non-streaming AgentExecuteOptions.callbacks when using mode: 'cua'.";
/**
 * Callbacks specific to the non-streaming execute method.
 */
interface AgentExecuteCallbacks extends AgentCallbacks {
    /**
     * Callback called when each step (LLM call) is finished.
     */
    onStepFinish?: GenerateTextOnStepFinishCallback<ToolSet>;
    /**
     * Callback for handling safety confirmation requests from CUA providers.
     * Only available when running an agent configured with mode: "cua".
     */
    onSafetyConfirmation?: SafetyConfirmationHandler;
    /**
     * NOT AVAILABLE in non-streaming mode.
     * This callback requires `stream: true` in AgentConfig.
     *
     * @example
     * ```typescript
     * // Enable streaming to use onChunk:
     * const agent = stagehand.agent({ stream: true });
     * await agent.execute({
     *   instruction: "...",
     *   callbacks: { onChunk: async (chunk) => console.log(chunk) }
     * });
     * ```
     */
    onChunk?: StreamingCallbackNotAvailable;
    /**
     * NOT AVAILABLE in non-streaming mode.
     * This callback requires `stream: true` in AgentConfig.
     *
     * @example
     * ```typescript
     * // Enable streaming to use onFinish:
     * const agent = stagehand.agent({ stream: true });
     * await agent.execute({
     *   instruction: "...",
     *   callbacks: { onFinish: (event) => console.log("Done!", event) }
     * });
     * ```
     */
    onFinish?: StreamingCallbackNotAvailable;
    /**
     * NOT AVAILABLE in non-streaming mode.
     * This callback requires `stream: true` in AgentConfig.
     *
     * @example
     * ```typescript
     * // Enable streaming to use onError:
     * const agent = stagehand.agent({ stream: true });
     * await agent.execute({
     *   instruction: "...",
     *   callbacks: { onError: ({ error }) => console.error(error) }
     * });
     * ```
     */
    onError?: StreamingCallbackNotAvailable;
    /**
     * NOT AVAILABLE in non-streaming mode.
     * This callback requires `stream: true` in AgentConfig.
     *
     * @example
     * ```typescript
     * // Enable streaming to use onAbort:
     * const agent = stagehand.agent({ stream: true });
     * await agent.execute({
     *   instruction: "...",
     *   callbacks: { onAbort: (event) => console.log("Aborted", event.steps) }
     * });
     * ```
     */
    onAbort?: StreamingCallbackNotAvailable;
}
/**
 * Callbacks specific to the streaming mode.
 */
interface AgentStreamCallbacks extends AgentCallbacks {
    /**
     * Callback called when each step (LLM call) is finished during streaming.
     */
    onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
    /**
     * Callback called when an error occurs during streaming.
     * Use this to log errors or handle error states.
     */
    onError?: StreamTextOnErrorCallback;
    /**
     * Callback called for each chunk of the stream.
     * Stream processing will pause until the callback promise resolves.
     */
    onChunk?: StreamTextOnChunkCallback<ToolSet>;
    /**
     * Callback called when the stream finishes.
     */
    onFinish?: StreamTextOnFinishCallback<ToolSet>;
    /**
     * Callback called when the stream is aborted.
     */
    onAbort?: (event: {
        steps: Array<StepResult<ToolSet>>;
    }) => PromiseLike<void> | void;
    /**
     * NOT AVAILABLE in streaming mode.
     * Safety confirmations currently require non-streaming execute() on CUA agents.
     */
    onSafetyConfirmation?: SafetyConfirmationCallbackNotAvailable;
}
/**
 * Base options for agent execution (without callbacks).
 */
interface AgentExecuteOptionsBase {
    instruction: string;
    maxSteps?: number;
    page?: Page$1 | Page$2 | Page$3 | Page;
    highlightCursor?: boolean;
    /**
     * Previous conversation messages to continue from.
     * Pass the `messages` from a previous AgentResult to continue that conversation.
     * @experimental
     */
    messages?: ModelMessage[];
    /**
     * An AbortSignal that can be used to cancel the agent execution.
     * When aborted, the agent will stop and return a partial result.
     * @experimental
     *
     * @example
     * ```typescript
     * const controller = new AbortController();
     * setTimeout(() => controller.abort(), 30000); // 30 second timeout
     *
     * const result = await agent.execute({
     *   instruction: "...",
     *   signal: controller.signal
     * });
     * ```
     */
    signal?: AbortSignal;
    /**
     * Tools to exclude from this execution.
     * Pass an array of tool names to prevent the agent from using those tools.
     *
     * **Note:** Not supported in CUA mode (`mode: "cua"`).
     *
     * **Available tools by mode:**
     *
     * **DOM mode (default):**
     * - `act` - Perform semantic actions (click, type, etc.)
     * - `fillForm` - Fill form fields using DOM selectors
     * - `ariaTree` - Get accessibility tree of the page
     * - `extract` - Extract structured data from page
     * - `goto` - Navigate to a URL
     * - `scroll` - Scroll using semantic directions (up/down/left/right)
     * - `keys` - Press keyboard keys
     * - `navback` - Navigate back in history
     * - `screenshot` - Take a screenshot
     * - `think` - Agent reasoning/planning step
     * - `wait` - Wait for time or condition
     * - `close` - Mark task as complete
     * - `search` - Web search (requires BRAVE_API_KEY)
     *
     * **Hybrid mode:**
     * - `click` - Click at specific coordinates
     * - `type` - Type text at coordinates
     * - `dragAndDrop` - Drag from one point to another
     * - `clickAndHold` - Click and hold at coordinates
     * - `fillFormVision` - Fill forms using vision/coordinates
     * - `act` - Perform semantic actions
     * - `ariaTree` - Get accessibility tree
     * - `extract` - Extract data from page
     * - `goto` - Navigate to URL
     * - `scroll` - Scroll using coordinates
     * - `keys` - Press keyboard keys
     * - `navback` - Navigate back
     * - `screenshot` - Take screenshot
     * - `think` - Agent reasoning step
     * - `wait` - Wait for time/condition
     * - `close` - Mark task complete
     * - `search` - Web search (requires BRAVE_API_KEY)
     *
     * @experimental
     * @example
     * ```typescript
     * // Exclude screenshot and extract tools
     * const result = await agent.execute({
     *   instruction: "Click the submit button",
     *   excludeTools: ["screenshot", "extract"]
     * });
     * ```
     */
    excludeTools?: string[];
}
/**
 * Options for non-streaming agent execution.
 * Only accepts AgentExecuteCallbacks (no streaming-specific callbacks like onChunk, onFinish).
 */
interface AgentExecuteOptions extends AgentExecuteOptionsBase {
    /**
     * Callbacks for non-streaming agent execution.
     * For streaming callbacks (onChunk, onFinish, onError, onAbort), use stream: true in AgentConfig.
     */
    callbacks?: AgentExecuteCallbacks;
}
/**
 * Options for streaming agent execution.
 * Accepts AgentStreamCallbacks including onChunk, onFinish, onError, and onAbort.
 */
interface AgentStreamExecuteOptions extends AgentExecuteOptionsBase {
    /**
     * Callbacks for streaming agent execution.
     * Includes streaming-specific callbacks: onChunk, onFinish, onError, onAbort.
     */
    callbacks?: AgentStreamCallbacks;
}
type AgentType = "openai" | "anthropic" | "google" | "microsoft";
declare const AVAILABLE_CUA_MODELS: readonly ["openai/computer-use-preview", "openai/computer-use-preview-2025-03-11", "anthropic/claude-3-7-sonnet-latest", "anthropic/claude-opus-4-5-20251101", "anthropic/claude-haiku-4-5-20251001", "anthropic/claude-sonnet-4-20250514", "anthropic/claude-sonnet-4-5-20250929", "google/gemini-2.5-computer-use-preview-10-2025", "microsoft/fara-7b"];
type AvailableCuaModel = (typeof AVAILABLE_CUA_MODELS)[number];
interface AgentExecutionOptions<TOptions extends AgentExecuteOptions = AgentExecuteOptions> {
    options: TOptions;
    logger: (message: LogLine) => void;
    retries?: number;
}
interface AgentHandlerOptions {
    modelName: string;
    clientOptions?: ClientOptions;
    userProvidedInstructions?: string;
    experimental?: boolean;
}
interface ActionExecutionResult {
    success: boolean;
    error?: string;
    data?: unknown;
}
/**
 * Represents a safety check that requires user confirmation before proceeding.
 * These are issued by CUA providers (OpenAI, Google) when the agent attempts
 * potentially risky actions.
 */
interface SafetyCheck {
    /** Unique identifier for this safety check */
    id: string;
    /** Code identifying the type of safety concern */
    code: string;
    /** Human-readable description of the safety concern */
    message: string;
}
/**
 * Response from the user for a safety confirmation request.
 */
interface SafetyConfirmationResponse {
    /** Whether the user acknowledged/approved the safety checks */
    acknowledged: boolean;
}
/**
 * Callback for handling safety confirmation requests.
 * Called when the CUA provider issues safety checks that require user confirmation.
 * The callback should return a promise that resolves when the user has made a decision.
 *
 * @param safetyChecks - Array of safety checks requiring confirmation
 * @returns Promise resolving to the user's response
 *
 * @example
 * ```typescript
 * const agent = stagehand.agent({
 *   mode: "cua",
 * });
 * await agent.execute({
 *   instruction: "...",
 *   callbacks: {
 *     onSafetyConfirmation: async (checks) => {
 *       console.log("Safety checks:", checks);
 *       const userApproved = await showConfirmationDialog(checks);
 *       return { acknowledged: userApproved };
 *     },
 *   },
 * });
 * ```
 */
type SafetyConfirmationHandler = (safetyChecks: SafetyCheck[]) => Promise<SafetyConfirmationResponse>;
interface ToolUseItem extends ResponseItem {
    type: "tool_use";
    id: string;
    name: string;
    input: Record<string, unknown>;
}
interface AnthropicMessage {
    role: string;
    content: string | Array<AnthropicContentBlock>;
}
interface AnthropicContentBlock {
    type: string;
    [key: string]: unknown;
}
interface AnthropicTextBlock extends AnthropicContentBlock {
    type: "text";
    text: string;
}
interface AnthropicToolResult {
    type: "tool_result";
    tool_use_id: string;
    content: string | Array<AnthropicContentBlock>;
}
interface ResponseItem {
    type: string;
    id: string;
    [key: string]: unknown;
}
interface ComputerCallItem extends ResponseItem {
    type: "computer_call";
    call_id: string;
    action: {
        type: string;
        [key: string]: unknown;
    };
    pending_safety_checks?: Array<{
        id: string;
        code: string;
        message: string;
    }>;
}
interface FunctionCallItem extends ResponseItem {
    type: "function_call";
    call_id: string;
    name: string;
    arguments: string;
}
type ResponseInputItem = {
    role: string;
    content: string;
} | {
    type: "computer_call_output";
    call_id: string;
    output: {
        type: "input_image";
        image_url: string;
        current_url?: string;
        error?: string;
        [key: string]: unknown;
    } | string;
    acknowledged_safety_checks?: Array<{
        id: string;
        code: string;
        message: string;
    }>;
} | {
    type: "function_call_output";
    call_id: string;
    output: string;
};
interface AgentInstance {
    execute: (instructionOrOptions: string | AgentExecuteOptions) => Promise<AgentResult>;
}
type AgentProviderType = AgentType;
type AgentModelConfig<TModelName extends string = string> = {
    modelName: TModelName;
} & Record<string, unknown>;
/**
 * Agent tool mode determines which set of tools are available to the agent.
 * - 'dom': Uses DOM-based tools (act, fillForm) - better for structured page interactions
 * - 'hybrid': Uses coordinate-based tools (click, type, dragAndDrop, etc.) - better for visual/screenshot-based interactions
 * - 'cua': Uses Computer Use Agent (CUA) providers like Anthropic Claude or Google Gemini for screenshot-based automation
 */
type AgentToolMode = "dom" | "hybrid" | "cua";
type AgentConfig = {
    /**
     * Custom system prompt to provide to the agent. Overrides the default system prompt.
     */
    systemPrompt?: string;
    /**
     * MCP integrations - Array of Client objects
     */
    integrations?: (Client | string)[];
    /**
     * Tools passed to the agent client
     */
    tools?: ToolSet;
    /**
     * @deprecated Use `mode: "cua"` instead. This option will be removed in a future version.
     * Enables Computer Use Agent (CUA) mode.
     */
    cua?: boolean;
    /**
     * The model to use for agent functionality
     */
    model?: string | AgentModelConfig<string>;
    /**
     * The model to use for tool execution (observe/act calls within agent tools).
     * If not specified, inherits from the main model configuration.
     * Format: "provider/model" (e.g., "openai/gpt-4o-mini", "google/gemini-2.0-flash-exp")
     */
    executionModel?: string | AgentModelConfig<string>;
    /**
     * Enable streaming mode for the agent.
     * When true, execute() returns AgentStreamResult with textStream for incremental output.
     * When false (default), execute() returns AgentResult after completion.
     */
    stream?: boolean;
    /**
     * Tool mode for the agent. Determines which set of tools are available.
     * - 'dom' (default): Uses DOM-based tools (act, fillForm) for structured interactions
     * - 'hybrid': Uses coordinate-based tools (click, type, dragAndDrop, clickAndHold, fillFormVision)
     *             for visual/screenshot-based interactions
     * - 'cua': Uses Computer Use Agent (CUA) providers for screenshot-based automation
     */
    mode?: AgentToolMode;
};
/**
 * Agent instance returned when stream: true is set in AgentConfig.
 * execute() returns a streaming result that can be consumed incrementally.
 * Accepts AgentStreamExecuteOptions with streaming-specific callbacks.
 */
interface StreamingAgentInstance {
    execute: (instructionOrOptions: string | AgentStreamExecuteOptions) => Promise<AgentStreamResult>;
}
/**
 * Agent instance returned when stream is false or not set in AgentConfig.
 * execute() returns a result after the agent completes.
 * Accepts AgentExecuteOptions with non-streaming callbacks only.
 */
interface NonStreamingAgentInstance {
    execute: (instructionOrOptions: string | AgentExecuteOptions) => Promise<AgentResult>;
}

type OpenAIClientOptions = Pick<ClientOptions$1, "baseURL" | "apiKey">;
type AnthropicClientOptions = Pick<ClientOptions$2, "baseURL" | "apiKey">;
interface GoogleServiceAccountCredentials {
    type?: string;
    project_id?: string;
    private_key_id?: string;
    private_key?: string;
    client_email?: string;
    client_id?: string;
    auth_uri?: string;
    token_uri?: string;
    auth_provider_x509_cert_url?: string;
    client_x509_cert_url?: string;
    universe_domain?: string;
}
type GoogleVertexProviderSettings = Pick<GoogleVertexProviderSettings$1, "project" | "location"> & {
    googleAuthOptions?: {
        credentials?: GoogleServiceAccountCredentials;
    };
};
type AnthropicJsonSchemaObject = {
    definitions?: {
        MySchema?: {
            properties?: Record<string, unknown>;
            required?: string[];
        };
    };
    properties?: Record<string, unknown>;
    required?: string[];
} & Record<string, unknown>;
interface LLMTool {
    type: "function";
    name: string;
    description: string;
    parameters: Record<string, unknown>;
}
type AISDKProvider = (modelName: string) => LanguageModelV2;
type AISDKCustomProvider = (options: ClientOptions) => AISDKProvider;
type AvailableModel = "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "o4-mini" | "o3" | "o3-mini" | "o1" | "o1-mini" | "gpt-4o" | "gpt-4o-mini" | "gpt-4o-2024-08-06" | "gpt-4.5-preview" | "o1-preview" | "claude-3-5-sonnet-latest" | "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-20240620" | "claude-3-7-sonnet-latest" | "claude-3-7-sonnet-20250219" | "cerebras-llama-3.3-70b" | "cerebras-llama-3.1-8b" | "groq-llama-3.3-70b-versatile" | "groq-llama-3.3-70b-specdec" | "gemini-1.5-flash" | "gemini-1.5-pro" | "gemini-1.5-flash-8b" | "gemini-2.0-flash-lite" | "gemini-2.0-flash" | "gemini-2.5-flash-preview-04-17" | "gemini-2.5-pro-preview-03-25" | string;
type ModelProvider = "openai" | "anthropic" | "cerebras" | "groq" | "google" | "aisdk";
type ClientOptions = (OpenAIClientOptions | AnthropicClientOptions | GoogleVertexProviderSettings) & {
    apiKey?: string;
    provider?: AgentProviderType;
    baseURL?: string;
    /** OpenAI organization ID */
    organization?: string;
    /** Delay between agent actions in ms */
    waitBetweenActions?: number;
    /** Anthropic thinking budget for extended thinking */
    thinkingBudget?: number;
    /** Environment type for CUA agents (browser, mac, windows, ubuntu) */
    environment?: string;
    /** Max images for Microsoft FARA agent */
    maxImages?: number;
    /** Temperature for model inference */
    temperature?: number;
};
type ModelConfiguration = AvailableModel | (ClientOptions & {
    modelName: AvailableModel;
});

interface ChatMessage {
    role: "system" | "user" | "assistant";
    content: ChatMessageContent;
}
type ChatMessageContent = string | (ChatMessageImageContent | ChatMessageTextContent)[];
interface ChatMessageImageContent {
    type: string;
    image_url?: {
        url: string;
    };
    text?: string;
    source?: {
        type: string;
        media_type: string;
        data: string;
    };
}
interface ChatMessageTextContent {
    type: string;
    text: string;
}
declare const AnnotatedScreenshotText = "This is a screenshot of the current page state with the elements annotated on it. Each element id is annotated with a number to the top left of it. Duplicate annotations at the same location are under each other vertically.";
interface ChatCompletionOptions {
    messages: ChatMessage[];
    temperature?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    image?: {
        buffer: Buffer;
        description?: string;
    };
    response_model?: {
        name: string;
        schema: StagehandZodSchema;
    };
    tools?: LLMTool[];
    tool_choice?: "auto" | "none" | "required";
    maxOutputTokens?: number;
    requestId?: string;
}
type LLMResponse = {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: {
        index: number;
        message: {
            role: string;
            content: string | null;
            tool_calls: {
                id: string;
                type: string;
                function: {
                    name: string;
                    arguments: string;
                };
            }[];
        };
        finish_reason: string;
    }[];
    usage: {
        prompt_tokens: number;
        completion_tokens: number;
        total_tokens: number;
    };
};
interface CreateChatCompletionOptions {
    options: ChatCompletionOptions;
    logger: (message: LogLine) => void;
    retries?: number;
}
/** Simple usage shape if your LLM returns usage tokens. */
interface LLMUsage {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
    reasoning_tokens?: number;
    cached_input_tokens?: number;
}
/**
 * For calls that use a schema: the LLMClient may return { data: T; usage?: LLMUsage }
 */
interface LLMParsedResponse<T> {
    data: T;
    usage?: LLMUsage;
}
declare abstract class LLMClient {
    type: "openai" | "anthropic" | "cerebras" | "groq" | (string & {});
    modelName: AvailableModel | (string & {});
    hasVision: boolean;
    clientOptions: ClientOptions;
    userProvidedInstructions?: string;
    constructor(modelName: AvailableModel, userProvidedInstructions?: string);
    abstract createChatCompletion<T>(options: CreateChatCompletionOptions & {
        options: {
            response_model: {
                name: string;
                schema: StagehandZodSchema;
            };
        };
    }): Promise<LLMParsedResponse<T>>;
    abstract createChatCompletion<T = LLMResponse>(options: CreateChatCompletionOptions): Promise<T>;
    generateObject: typeof generateObject;
    generateText: typeof generateText;
    streamText: typeof streamText;
    streamObject: typeof streamObject;
    generateImage: typeof experimental_generateImage;
    embed: typeof embed;
    embedMany: typeof embedMany;
    transcribe: typeof experimental_transcribe;
    generateSpeech: typeof experimental_generateSpeech;
    getLanguageModel?(): LanguageModelV2;
}

/**
 * V3
 *
 * Purpose:
 * A high-level orchestrator for Stagehand V3. Abstracts away whether the browser
 * runs **locally via Chrome** or remotely on **Browserbase**, and exposes simple
 * entrypoints (`act`, `extract`, `observe`) that delegate to the corresponding
 * handler classes.
 *
 * Responsibilities:
 * - Bootstraps Chrome or Browserbase, ensures a working CDP WebSocket, and builds a `V3Context`.
 * - Manages lifecycle: init, context access, cleanup.
 * - Bridges external page objects (Playwright/Puppeteer) into internal frameIds for handlers.
 * - Provides a stable API surface for downstream code regardless of runtime environment.
 */
declare class V3 {
    private readonly opts;
    private state;
    private actHandler;
    private extractHandler;
    private observeHandler;
    private ctx;
    llmClient: LLMClient;
    /**
     * Event bus for internal communication.
     * Emits events like 'screenshot' when screenshots are captured during agent execution.
     */
    readonly bus: EventEmitter;
    private modelName;
    private modelClientOptions;
    private llmProvider;
    private overrideLlmClients;
    private readonly domSettleTimeoutMs?;
    private _isClosing;
    browserbaseSessionId?: string;
    private browserbaseSessionUrl?;
    private browserbaseDebugUrl?;
    get browserbaseSessionID(): string | undefined;
    get browserbaseSessionURL(): string | undefined;
    get browserbaseDebugURL(): string | undefined;
    /**
     * Returns true if the browser is running on Browserbase.
     */
    get isBrowserbase(): boolean;
    private _onCdpClosed;
    readonly experimental: boolean;
    readonly logInferenceToFile: boolean;
    readonly disableAPI: boolean;
    private externalLogger?;
    verbose: 0 | 1 | 2;
    private stagehandLogger;
    private _history;
    private readonly instanceId;
    private static _processGuardsInstalled;
    private static _instances;
    private cacheStorage;
    private actCache;
    private agentCache;
    private apiClient;
    stagehandMetrics: StagehandMetrics;
    constructor(opts: V3Options);
    /**
     * Async property for metrics so callers can `await v3.metrics`.
     * When using API mode, fetches metrics from the API. Otherwise returns local metrics.
     */
    get metrics(): Promise<StagehandMetrics>;
    private resolveLlmClient;
    private beginAgentReplayRecording;
    private endAgentReplayRecording;
    private discardAgentReplayRecording;
    private isAgentReplayRecording;
    isAgentReplayActive(): boolean;
    recordAgentReplayStep(step: AgentReplayStep): void;
    /**
     * Async property for history so callers can `await v3.history`.
     * Returns a frozen copy to avoid external mutation.
     */
    get history(): Promise<ReadonlyArray<HistoryEntry>>;
    addToHistory(method: HistoryEntry["method"], parameters: unknown, result?: unknown): void;
    updateMetrics(functionName: V3FunctionName, promptTokens: number, completionTokens: number, reasoningTokens: number, cachedInputTokens: number, inferenceTimeMs: number): void;
    private updateTotalMetrics;
    private _immediateShutdown;
    private static _installProcessGuards;
    /**
     * Entrypoint: initializes handlers, launches Chrome or Browserbase,
     * and sets up a CDP context.
     */
    init(): Promise<void>;
    /** Apply post-connect local browser options that require CDP. */
    private _applyPostConnectLocalOptions;
    private _ensureBrowserbaseDownloadsEnabled;
    private resetBrowserbaseSessionMetadata;
    /**
     * Run an "act" instruction through the ActHandler.
     *
     * New API:
     * - act(instruction: string, options?: ActOptions)
     * - act(action: Action, options?: ActOptions)
     */
    act(instruction: string, options?: ActOptions): Promise<ActResult>;
    act(action: Action, options?: ActOptions): Promise<ActResult>;
    /**
     * Run an "extract" instruction through the ExtractHandler.
     *
     * Accepted forms:
     * - extract() → pageText
     * - extract(options) → pageText
     * - extract(instruction) → defaultExtractSchema
     * - extract(instruction, schema) → schema-inferred
     * - extract(instruction, schema, options)
     */
    extract(): Promise<z.infer<typeof pageTextSchema>>;
    extract(options: ExtractOptions): Promise<z.infer<typeof pageTextSchema>>;
    extract(instruction: string, options?: ExtractOptions): Promise<z.infer<typeof defaultExtractSchema>>;
    extract<T extends StagehandZodSchema>(instruction: string, schema: T, options?: ExtractOptions): Promise<InferStagehandSchema<T>>;
    /**
     * Run an "observe" instruction through the ObserveHandler.
     */
    observe(): Promise<Action[]>;
    observe(options: ObserveOptions): Promise<Action[]>;
    observe(instruction: string, options?: ObserveOptions): Promise<Action[]>;
    /** Return the browser-level CDP WebSocket endpoint. */
    connectURL(): string;
    /** Expose the current CDP-backed context. */
    get context(): V3Context;
    /** Best-effort cleanup of context and launched resources. */
    close(opts?: {
        force?: boolean;
    }): Promise<void>;
    /** Guard: ensure Browserbase credentials exist in options. */
    private requireBrowserbaseCreds;
    get logger(): (logLine: LogLine) => void;
    /**
     * Normalize a Playwright/Puppeteer page object into its top frame id,
     * so handlers can resolve it to a `Page` within our V3Context.
     */
    private resolveTopFrameId;
    private isPlaywrightPage;
    private isPatchrightPage;
    private isPuppeteerPage;
    /** Resolve an external page reference or fall back to the active V3 page. */
    private resolvePage;
    private normalizeToV3Page;
    private _logBrowserbaseSessionStatus;
    /**
     * Prepares shared context for agent execution (both execute and stream).
     * Extracts duplicated setup logic into a single helper.
     */
    private prepareAgentExecution;
    /**
     * Create a v3 agent instance (AISDK tool-based) with execute().
     * Mirrors the v2 Stagehand.agent() tool mode (no CUA provider here).
     *
     * @overload When stream: true, returns a streaming agent where execute() returns AgentStreamResult
     * @overload When stream is false/undefined, returns a non-streaming agent where execute() returns AgentResult
     */
    agent(options: AgentConfig & {
        stream: true;
    }): {
        execute: (instructionOrOptions: string | AgentStreamExecuteOptions) => Promise<AgentStreamResult>;
    };
    agent(options?: AgentConfig & {
        stream?: false;
    }): {
        execute: (instructionOrOptions: string | AgentExecuteOptions) => Promise<AgentResult>;
    };
}

/**
 * Abstract base class for agent clients
 * This provides a common interface for all agent implementations
 */
declare abstract class AgentClient {
    type: AgentType;
    modelName: string;
    clientOptions: ClientOptions;
    userProvidedInstructions?: string;
    constructor(type: AgentType, modelName: string, userProvidedInstructions?: string);
    abstract execute(options: AgentExecutionOptions): Promise<AgentResult>;
    abstract captureScreenshot(options?: Record<string, unknown>): Promise<unknown>;
    abstract setViewport(width: number, height: number): void;
    abstract setCurrentUrl(url: string): void;
    abstract setScreenshotProvider(provider: () => Promise<string>): void;
    abstract setActionHandler(handler: (action: AgentAction) => Promise<void>): void;
}

declare const modelToAgentProviderMap: Record<string, AgentProviderType>;
/**
 * Provider for agent clients
 * This class is responsible for creating the appropriate agent client
 * based on the provider type
 */
declare class AgentProvider {
    private logger;
    /**
     * Create a new agent provider
     */
    constructor(logger: (message: LogLine) => void);
    getClient(modelName: string, clientOptions?: ClientOptions, userProvidedInstructions?: string, tools?: ToolSet$1): AgentClient;
    static getAgentProvider(modelName: string): AgentProviderType;
}

declare const gotoTool: (v3: V3) => ai.Tool<{
    url: string;
}, {
    success: boolean;
    url: string;
    error?: undefined;
} | {
    success: boolean;
    error: any;
    url?: undefined;
}>;

declare const actTool: (v3: V3, executionModel?: string) => ai.Tool<{
    action: string;
}, {
    success: boolean;
    action: string;
    playwrightArguments: Action;
    error?: undefined;
} | {
    success: boolean;
    error: any;
    action?: undefined;
    playwrightArguments?: undefined;
}>;

declare const screenshotTool: (v3: V3) => ai.Tool<Record<string, never>, {
    base64: string;
    timestamp: number;
    pageUrl: string;
}>;

declare const waitTool: (v3: V3) => ai.Tool<{
    timeMs: number;
}, {
    success: boolean;
    waited: number;
}>;

declare const navBackTool: (v3: V3) => ai.Tool<{
    reasoningText: string;
}, {
    success: boolean;
}>;

declare const closeTool: () => ai.Tool<{
    reasoning: string;
    taskComplete: boolean;
}, {
    success: boolean;
    reasoning: string;
    taskComplete: boolean;
}>;

declare const ariaTreeTool: (v3: V3) => ai.Tool<Record<string, never>, {
    content: string;
    pageUrl: string;
}>;

declare const fillFormTool: (v3: V3, executionModel?: string) => ai.Tool<{
    fields: {
        action: string;
        value: string;
    }[];
}, {
    success: boolean;
    actions: unknown[];
    playwrightArguments: Action[];
}>;

/**
 * Simple scroll tool for DOM mode (non-grounding models).
 * No coordinates - scrolls from viewport center.
 */
declare const scrollTool: (v3: V3) => ai.Tool<{
    direction: "up" | "down";
    percentage?: number;
}, {
    success: boolean;
    message: string;
    scrolledPixels: number;
}>;
/**
 * Scroll tool for hybrid mode (grounding models).
 * Supports optional coordinates for scrolling within nested scrollable elements.
 */
declare const scrollVisionTool: (v3: V3, provider?: string) => ai.Tool<{
    direction: "up" | "down";
    coordinates?: number[];
    percentage?: number;
}, {
    success: boolean;
    message: string;
    scrolledPixels: number;
}>;

declare const extractTool: (v3: V3, executionModel?: string, logger?: (message: LogLine) => void) => ai.Tool<{
    instruction: string;
    schema?: string;
}, {
    success: boolean;
    result: any;
    error?: undefined;
} | {
    success: boolean;
    error: any;
    result?: undefined;
}>;

declare const clickTool: (v3: V3, provider?: string) => ai.Tool<{
    describe: string;
    coordinates: number[];
}, {
    success: boolean;
    describe: string;
    coordinates: number[];
    error?: undefined;
} | {
    success: boolean;
    error: string;
    describe?: undefined;
    coordinates?: undefined;
}>;

declare const typeTool: (v3: V3, provider?: string) => ai.Tool<{
    describe: string;
    text: string;
    coordinates: number[];
}, {
    success: boolean;
    describe: string;
    text: string;
    error?: undefined;
} | {
    success: boolean;
    error: string;
    describe?: undefined;
    text?: undefined;
}>;

declare const dragAndDropTool: (v3: V3, provider?: string) => ai.Tool<{
    describe: string;
    startCoordinates: number[];
    endCoordinates: number[];
}, {
    success: boolean;
    describe: string;
    error?: undefined;
} | {
    success: boolean;
    error: string;
    describe?: undefined;
}>;

declare const clickAndHoldTool: (v3: V3, provider?: string) => ai.Tool<{
    describe: string;
    duration: number;
    coordinates: number[];
}, {
    success: boolean;
    describe: string;
    error?: undefined;
} | {
    success: boolean;
    error: string;
    describe?: undefined;
}>;

declare const keysTool: (v3: V3) => ai.Tool<{
    method: "type" | "press";
    value: string;
    repeat?: number;
}, {
    success: boolean;
    method: "type";
    value: string;
    times: number;
    error?: undefined;
} | {
    success: boolean;
    method: "press";
    value: string;
    times: number;
    error?: undefined;
} | {
    success: boolean;
    error: string;
    method?: undefined;
    value?: undefined;
    times?: undefined;
}>;

declare const fillFormVisionTool: (v3: V3, provider?: string) => ai.Tool<{
    fields: {
        action: string;
        value: string;
        coordinates: {
            x: number;
            y: number;
        };
    }[];
}, {
    success: boolean;
    playwrightArguments: {
        coordinates: {
            x: number;
            y: number;
        };
        action: string;
        value: string;
    }[];
    error?: undefined;
} | {
    success: boolean;
    error: string;
    playwrightArguments?: undefined;
}>;

declare const thinkTool: () => ai.Tool<{
    reasoning: string;
}, {
    acknowledged: boolean;
    message: string;
}>;

interface BraveSearchResult {
    title: string;
    url: string;
    description?: string;
}
declare const searchTool: (v3: V3) => ai.Tool<{
    query: string;
}, {
    timestamp: number;
    data?: {
        results: BraveSearchResult[];
    };
    error?: string;
}>;

interface V3AgentToolOptions {
    executionModel?: string;
    logger?: (message: LogLine) => void;
    /**
     * Tool mode determines which set of tools are available.
     * - 'dom' (default): Uses DOM-based tools (act, fillForm) - removes coordinate-based tools
     * - 'hybrid': Uses coordinate-based tools (click, type, dragAndDrop, etc.) - removes fillForm
     */
    mode?: AgentToolMode;
    /**
     * The model provider. Used for model-specific coordinate handling
     */
    provider?: string;
    /**
     * Tools to exclude from the available toolset.
     * These tools will be filtered out after mode-based filtering.
     */
    excludeTools?: string[];
}
declare function createAgentTools(v3: V3, options?: V3AgentToolOptions): ToolSet;
type AgentTools = ReturnType<typeof createAgentTools>;
/**
 * Type map of all agent tools for strong typing of tool calls and results.
 * Note: `search` is optional as it's only available when BRAVE_API_KEY is configured.
 */
type AgentToolTypesMap = {
    act: ReturnType<typeof actTool>;
    ariaTree: ReturnType<typeof ariaTreeTool>;
    click: ReturnType<typeof clickTool>;
    clickAndHold: ReturnType<typeof clickAndHoldTool>;
    close: ReturnType<typeof closeTool>;
    dragAndDrop: ReturnType<typeof dragAndDropTool>;
    extract: ReturnType<typeof extractTool>;
    fillForm: ReturnType<typeof fillFormTool>;
    fillFormVision: ReturnType<typeof fillFormVisionTool>;
    goto: ReturnType<typeof gotoTool>;
    keys: ReturnType<typeof keysTool>;
    navback: ReturnType<typeof navBackTool>;
    screenshot: ReturnType<typeof screenshotTool>;
    scroll: ReturnType<typeof scrollTool> | ReturnType<typeof scrollVisionTool>;
    search?: ReturnType<typeof searchTool>;
    think: ReturnType<typeof thinkTool>;
    type: ReturnType<typeof typeTool>;
    wait: ReturnType<typeof waitTool>;
};
/**
 * Inferred UI tools type for type-safe tool inputs and outputs.
 * Use with UIMessage for full type safety in UI contexts.
 */
type AgentUITools = InferUITools<AgentToolTypesMap>;
/**
 * Union type for all possible agent tool calls.
 * Provides type-safe access to tool call arguments.
 */
type AgentToolCall = {
    [K in keyof AgentToolTypesMap]: {
        toolName: K;
        toolCallId: string;
        args: AgentUITools[K]["input"];
    };
}[keyof AgentToolTypesMap];
/**
 * Union type for all possible agent tool results.
 * Provides type-safe access to tool result values.
 */
type AgentToolResult = {
    [K in keyof AgentToolTypesMap]: {
        toolName: K;
        toolCallId: string;
        result: AgentUITools[K]["output"];
    };
}[keyof AgentToolTypesMap];

declare function validateZodSchema(schema: StagehandZodSchema, data: unknown): boolean;
/**
 * Detects if the code is running in the Bun runtime environment.
 * @returns {boolean} True if running in Bun, false otherwise.
 */
declare function isRunningInBun(): boolean;
declare function toGeminiSchema(zodSchema: StagehandZodSchema): Schema;
declare function getZodType(schema: StagehandZodSchema): string;
/**
 * Recursively traverses a given Zod schema, scanning for any fields of type `z.string().url()`.
 * For each such field, it replaces the `z.string().url()` with `z.number()`.
 *
 * This function is used internally by higher-level utilities (e.g., transforming entire object schemas)
 * and handles nested objects, arrays, unions, intersections, optionals.
 *
 * @param schema - The Zod schema to transform.
 * @param currentPath - An array of string/number keys representing the current schema path (used internally for recursion).
 * @returns A two-element tuple:
 *   1. The updated Zod schema, with any `.url()` fields replaced by `z.number()`.
 *   2. An array of {@link ZodPathSegments} objects representing each replaced field, including the path segments.
 */
declare function transformSchema(schema: StagehandZodSchema, currentPath: Array<string | number>): [StagehandZodSchema, ZodPathSegments[]];
/**
 * Once we get the final extracted object that has numeric IDs in place of URLs,
 * use `injectUrls` to walk the object and replace numeric IDs
 * with the real URL strings from idToUrlMapping. The `path` may include `*`
 * for array indices (indicating "all items in the array").
 */
declare function injectUrls(obj: unknown, path: Array<string | number>, idToUrlMapping: Record<string, string>): void;
/**
 * Mapping from LLM provider names to their corresponding environment variable names for API keys.
 */
declare const providerEnvVarMap: Partial<Record<ModelProvider | string, string | Array<string>>>;
/**
 * Loads an API key for a provider, checking environment variables.
 * @param provider The name of the provider (e.g., 'openai', 'anthropic')
 * @param logger Optional logger for info/error messages
 * @returns The API key if found, undefined otherwise
 */
declare function loadApiKeyFromEnv(provider: string | undefined, logger: (logLine: LogLine) => void): string | undefined;
declare function trimTrailingTextNode(path: string | undefined): string | undefined;
interface JsonSchemaProperty {
    type: string;
    enum?: unknown[];
    items?: JsonSchemaProperty;
    properties?: Record<string, JsonSchemaProperty>;
    required?: string[];
    minimum?: number;
    maximum?: number;
    description?: string;
    format?: string;
}
interface JsonSchema extends JsonSchemaProperty {
    type: string;
}
/**
 * Converts a JSON Schema object to a Zod schema
 * @param schema The JSON Schema object to convert
 * @returns A Zod schema equivalent to the input JSON Schema
 */
declare function jsonSchemaToZod(schema: JsonSchema): ZodTypeAny;

interface ConnectToMCPServerOptions {
    serverUrl: string | URL;
    clientOptions?: ClientOptions$3;
}
interface StdioServerConfig {
    command: string;
    args?: string[];
    env?: Record<string, string>;
}
declare const connectToMCPServer: (serverConfig: string | URL | StdioServerConfig | ConnectToMCPServerOptions) => Promise<Client>;

/**
 * V3Evaluator mirrors Evaluator but operates on a V3 instance instead of Stagehand.
 * It uses the V3 page/screenshot APIs and constructs an LLM client to run
 * structured evaluations (YES/NO with reasoning) on screenshots and/or text.
 */

declare class V3Evaluator {
    private v3;
    private modelName;
    private modelClientOptions;
    private silentLogger;
    constructor(v3: V3, modelName?: AvailableModel, modelClientOptions?: ClientOptions);
    private getClient;
    ask(options: EvaluateOptions): Promise<EvaluationResult>;
    batchAsk(options: BatchAskOptions): Promise<EvaluationResult[]>;
    private _evaluateWithMultipleScreenshots;
}

export { type AISDKCustomProvider, type AISDKProvider, AISdkClient, AVAILABLE_CUA_MODELS, type ActOptions, type ActResult, ActTimeoutError, type Action, type ActionExecutionResult, AgentAbortError, type AgentAction, type AgentCallbacks, type AgentConfig, type AgentContext, type AgentExecuteCallbacks, type AgentExecuteOptions, type AgentExecuteOptionsBase, type AgentExecutionOptions, type AgentHandlerOptions, type AgentInstance, type AgentModelConfig, AgentProvider, type AgentProviderType, type AgentResult, AgentScreenshotProviderError, type AgentState, type AgentStreamCallbacks, type AgentStreamExecuteOptions, type AgentStreamResult, type AgentToolCall, type AgentToolMode, type AgentToolResult, type AgentToolTypesMap, type AgentTools, type AgentType, type AgentUITools, AnnotatedScreenshotText, type AnthropicClientOptions, type AnthropicContentBlock, type AnthropicJsonSchemaObject, type AnthropicMessage, type AnthropicTextBlock, type AnthropicToolResult, type AnyPage, api as Api, type AvailableCuaModel, type AvailableModel, BrowserbaseSessionNotFoundError, CaptchaTimeoutError, type ChatCompletionOptions, type ChatMessage, type ChatMessageContent, type ChatMessageImageContent, type ChatMessageTextContent, type ClientOptions, type ComputerCallItem, ConnectionTimeoutError, type ConsoleListener, ConsoleMessage, ContentFrameNotFoundError, type CreateChatCompletionOptions, CreateChatCompletionResponseError, CuaModelRequiredError, ElementNotVisibleError, ExperimentalApiConflictError, ExperimentalNotConfiguredError, type ExtractOptions, type ExtractResult, ExtractTimeoutError, type FunctionCallItem, type GoogleServiceAccountCredentials, type GoogleVertexProviderSettings, HandlerNotInitializedError, type HistoryEntry, type InferStagehandSchema, InvalidAISDKModelFormatError, type JsonSchema, type JsonSchemaDocument, type JsonSchemaProperty, LLMClient, type LLMParsedResponse, type LLMResponse, LLMResponseError, type LLMTool, type LLMUsage, LOG_LEVEL_NAMES, type LoadState, type LocalBrowserLaunchOptions, type LogLevel, type LogLine, type Logger, MCPConnectionError, MissingEnvironmentVariableError, MissingLLMConfigurationError, type ModelConfiguration, type ModelProvider, type NonStreamingAgentInstance, type ObserveOptions, ObserveTimeoutError, type OpenAIClientOptions, Page, PageNotFoundError, Response$1 as Response, ResponseBodyError, type ResponseInputItem, type ResponseItem, ResponseParseError, type SafetyCheck, type SafetyConfirmationHandler, type SafetyConfirmationResponse, V3 as Stagehand, StagehandAPIError, StagehandAPIUnauthorizedError, StagehandClickError, StagehandClosedError, StagehandDefaultError, StagehandDomProcessError, StagehandElementNotFoundError, StagehandEnvironmentError, StagehandError, StagehandEvalError, StagehandHttpError, StagehandIframeError, StagehandInitError, StagehandInvalidArgumentError, type StagehandMetrics, StagehandMissingArgumentError, StagehandNotInitializedError, StagehandResponseBodyError, StagehandResponseParseError, StagehandServerError, StagehandShadowRootMissingError, StagehandShadowSegmentEmptyError, StagehandShadowSegmentNotFoundError, type StagehandZodObject, type StagehandZodSchema, type StreamingAgentInstance, StreamingCallbacksInNonStreamingModeError, TimeoutError, type ToolUseItem, UnsupportedAISDKModelProviderError, UnsupportedModelError, UnsupportedModelProviderError, V3, type V3Env, V3Evaluator, V3FunctionName, type V3Options, XPathResolutionError, ZodSchemaValidationError, connectToMCPServer, defaultExtractSchema, getZodType, injectUrls, isRunningInBun, isZod3Schema, isZod4Schema, jsonSchemaToZod, loadApiKeyFromEnv, localBrowserLaunchOptionsSchema, modelToAgentProviderMap, pageTextSchema, providerEnvVarMap, toGeminiSchema, toJsonSchema, transformSchema, trimTrailingTextNode, validateZodSchema };
