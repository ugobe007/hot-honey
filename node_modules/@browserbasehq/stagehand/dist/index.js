var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decoratorStart = (base) => {
  var _a4;
  return [, , , __create((_a4 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a4 : null)];
};
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n = fns && fns.length; i2 < n; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x2) {
    return __privateSet(this, extra, x2);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: p ? (x2) => __privateIn(target, x2) : (x2) => name in x2 };
      if (k ^ 3) access.get = p ? (x2) => (k ^ 1 ? __privateGet : __privateMethod)(x2, target, k ^ 4 ? extra : desc.get) : (x2) => x2[name];
      if (k > 2) access.set = p ? (x2, y) => __privateSet(x2, target, y, k ^ 4 ? extra : desc.set) : (x2, y) => x2[name] = y;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve3, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve3(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x2 = generator[k](v), isAwait = (v = x2.value) instanceof __await, done = x2.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e2) => resume("throw", e2, yes, no));
    } catch (e2) {
      no(e2);
    }
  }, method = (k) => it[k] = (x2) => new Promise((yes, no) => resume(k, x2, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x2) => obj[k](x2);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve3) => {
          var x2 = obj[k](v);
          if (!(x2 instanceof Object)) __typeError("Object expected");
          resolve3(x2);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x2) => {
    throw x2;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// lib/version.ts
var STAGEHAND_VERSION;
var init_version = __esm({
  "lib/version.ts"() {
    STAGEHAND_VERSION = "3.0.7";
  }
});

// lib/v3/types/public/sdkErrors.ts
var StagehandError, StagehandDefaultError, StagehandEnvironmentError, MissingEnvironmentVariableError, UnsupportedModelError, UnsupportedModelProviderError, UnsupportedAISDKModelProviderError, InvalidAISDKModelFormatError, StagehandNotInitializedError, BrowserbaseSessionNotFoundError, CaptchaTimeoutError, MissingLLMConfigurationError, HandlerNotInitializedError, StagehandInvalidArgumentError, StagehandElementNotFoundError, AgentScreenshotProviderError, StagehandMissingArgumentError, CreateChatCompletionResponseError, StagehandEvalError, StagehandDomProcessError, StagehandClickError, LLMResponseError, StagehandIframeError, ContentFrameNotFoundError, XPathResolutionError, ExperimentalApiConflictError, ExperimentalNotConfiguredError, CuaModelRequiredError, ZodSchemaValidationError, StagehandInitError, MCPConnectionError, StagehandShadowRootMissingError, StagehandShadowSegmentEmptyError, StagehandShadowSegmentNotFoundError, ElementNotVisibleError, ResponseBodyError, ResponseParseError, TimeoutError, ActTimeoutError, ExtractTimeoutError, ObserveTimeoutError, PageNotFoundError, ConnectionTimeoutError, StreamingCallbacksInNonStreamingModeError, AgentAbortError, StagehandClosedError;
var init_sdkErrors = __esm({
  "lib/v3/types/public/sdkErrors.ts"() {
    init_version();
    StagehandError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
      }
    };
    StagehandDefaultError = class extends StagehandError {
      constructor(error) {
        if (error instanceof Error || error instanceof StagehandError) {
          super(
            `
Hey! We're sorry you ran into an error. 
Stagehand version: ${STAGEHAND_VERSION} 
If you need help, please open a Github issue or reach out to us on Slack: https://stagehand.dev/slack

Full error:
${error.message}`
          );
        }
      }
    };
    StagehandEnvironmentError = class extends StagehandError {
      constructor(currentEnvironment, requiredEnvironment, feature) {
        super(
          `You seem to be setting the current environment to ${currentEnvironment}.Ensure the environment is set to ${requiredEnvironment} if you want to use ${feature}.`
        );
      }
    };
    MissingEnvironmentVariableError = class extends StagehandError {
      constructor(missingEnvironmentVariable, feature) {
        super(
          `${missingEnvironmentVariable} is required to use ${feature}.Please set ${missingEnvironmentVariable} in your environment.`
        );
      }
    };
    UnsupportedModelError = class extends StagehandError {
      constructor(supportedModels, feature) {
        super(
          feature ? `${feature} requires one of the following models: ${supportedModels}` : `please use one of the supported models: ${supportedModels}`
        );
      }
    };
    UnsupportedModelProviderError = class extends StagehandError {
      constructor(supportedProviders, feature) {
        super(
          feature ? `${feature} requires one of the following model providers: ${supportedProviders}` : `please use one of the supported model providers: ${supportedProviders}`
        );
      }
    };
    UnsupportedAISDKModelProviderError = class extends StagehandError {
      constructor(provider, supportedProviders) {
        super(
          `${provider} is not currently supported for aiSDK. please use one of the supported model providers: ${supportedProviders}`
        );
      }
    };
    InvalidAISDKModelFormatError = class extends StagehandError {
      constructor(modelName) {
        super(
          `${modelName} does not follow correct format for specifying aiSDK models. Please define your model as 'provider/model-name'. For example: \`model: 'openai/gpt-4o-mini'\``
        );
      }
    };
    StagehandNotInitializedError = class extends StagehandError {
      constructor(prop) {
        super(
          `You seem to be calling \`${prop}\` on a page in an uninitialized \`Stagehand\` object. Ensure you are running \`await stagehand.init()\` on the Stagehand object before referencing the \`page\` object.`
        );
      }
    };
    BrowserbaseSessionNotFoundError = class extends StagehandError {
      constructor() {
        super("No Browserbase session ID found");
      }
    };
    CaptchaTimeoutError = class extends StagehandError {
      constructor() {
        super("Captcha timeout");
      }
    };
    MissingLLMConfigurationError = class extends StagehandError {
      constructor() {
        super(
          "No LLM API key or LLM Client configured. An LLM API key or a custom LLM Client is required to use act, extract, or observe."
        );
      }
    };
    HandlerNotInitializedError = class extends StagehandError {
      constructor(handlerType) {
        super(`${handlerType} handler not initialized`);
      }
    };
    StagehandInvalidArgumentError = class extends StagehandError {
      constructor(message) {
        super(`InvalidArgumentError: ${message}`);
      }
    };
    StagehandElementNotFoundError = class extends StagehandError {
      constructor(xpaths) {
        super(`Could not find an element for the given xPath(s): ${xpaths}`);
      }
    };
    AgentScreenshotProviderError = class extends StagehandError {
      constructor(message) {
        super(`ScreenshotProviderError: ${message}`);
      }
    };
    StagehandMissingArgumentError = class extends StagehandError {
      constructor(message) {
        super(`MissingArgumentError: ${message}`);
      }
    };
    CreateChatCompletionResponseError = class extends StagehandError {
      constructor(message) {
        super(`CreateChatCompletionResponseError: ${message}`);
      }
    };
    StagehandEvalError = class extends StagehandError {
      constructor(message) {
        super(`StagehandEvalError: ${message}`);
      }
    };
    StagehandDomProcessError = class extends StagehandError {
      constructor(message) {
        super(`Error Processing Dom: ${message}`);
      }
    };
    StagehandClickError = class extends StagehandError {
      constructor(message, selector) {
        super(
          `Error Clicking Element with selector: ${selector} Reason: ${message}`
        );
      }
    };
    LLMResponseError = class extends StagehandError {
      constructor(primitive, message) {
        super(`${primitive} LLM response error: ${message}`);
      }
    };
    StagehandIframeError = class extends StagehandError {
      constructor(frameUrl, message) {
        super(
          `Unable to resolve frameId for iframe with URL: ${frameUrl} Full error: ${message}`
        );
      }
    };
    ContentFrameNotFoundError = class extends StagehandError {
      constructor(selector) {
        super(`Unable to obtain a content frame for selector: ${selector}`);
      }
    };
    XPathResolutionError = class extends StagehandError {
      constructor(xpath) {
        super(`XPath "${xpath}" does not resolve in the current page or frames`);
      }
    };
    ExperimentalApiConflictError = class extends StagehandError {
      constructor() {
        super(
          "`experimental` mode cannot be used together with the Stagehand API. To use experimental features, set experimental: true, and useApi: false in the stagehand constructor. To use the Stagehand API, set experimental: false and useApi: true in the stagehand constructor. "
        );
      }
    };
    ExperimentalNotConfiguredError = class extends StagehandError {
      constructor(featureName) {
        super(`Feature "${featureName}" is an experimental feature, and cannot be configured when useAPI: true. 
    Please set experimental: true and useAPI: false in the stagehand constructor to use this feature. 
    If you wish to use the Stagehand API, please ensure ${featureName} is not defined in your function call, 
    and set experimental: false, useAPI: true in the Stagehand constructor. `);
      }
    };
    CuaModelRequiredError = class extends StagehandError {
      constructor(availableModels) {
        super(
          `To use the computer use agent (CUA), please provide a CUA model in the agent constructor or stagehand config. Try one of our supported CUA models: ${availableModels.join(", ")}`
        );
      }
    };
    ZodSchemaValidationError = class extends Error {
      constructor(received, issues) {
        super(`Zod schema validation failed

\u2014 Received \u2014
${JSON.stringify(received, null, 2)}

\u2014 Issues \u2014
${JSON.stringify(issues, null, 2)}`);
        this.received = received;
        this.issues = issues;
        this.name = "ZodSchemaValidationError";
      }
    };
    StagehandInitError = class extends StagehandError {
      constructor(message) {
        super(message);
      }
    };
    MCPConnectionError = class extends StagehandError {
      constructor(serverUrl, originalError) {
        const errorMessage = originalError instanceof Error ? originalError.message : String(originalError);
        super(
          `Failed to connect to MCP server at "${serverUrl}". ${errorMessage}. Please verify the server URL is correct and the server is running.`
        );
        this.serverUrl = serverUrl;
        this.originalError = originalError;
      }
    };
    StagehandShadowRootMissingError = class extends StagehandError {
      constructor(detail) {
        super(
          `No shadow root present on the resolved host` + (detail ? `: ${detail}` : "")
        );
      }
    };
    StagehandShadowSegmentEmptyError = class extends StagehandError {
      constructor() {
        super(`Empty selector segment after shadow-DOM hop ("//")`);
      }
    };
    StagehandShadowSegmentNotFoundError = class extends StagehandError {
      constructor(segment, hint) {
        super(
          `Shadow segment '${segment}' matched no element inside shadow root` + (hint ? ` ${hint}` : "")
        );
      }
    };
    ElementNotVisibleError = class extends StagehandError {
      constructor(selector) {
        super(`Element not visible (no box model): ${selector}`);
      }
    };
    ResponseBodyError = class extends StagehandError {
      constructor(message) {
        super(`Failed to retrieve response body: ${message}`);
      }
    };
    ResponseParseError = class extends StagehandError {
      constructor(message) {
        super(`Failed to parse response: ${message}`);
      }
    };
    TimeoutError = class extends StagehandError {
      constructor(operation, timeoutMs) {
        super(`${operation} timed out after ${timeoutMs}ms`);
      }
    };
    ActTimeoutError = class extends TimeoutError {
      constructor(timeoutMs) {
        super("act()", timeoutMs);
        this.name = "ActTimeoutError";
      }
    };
    ExtractTimeoutError = class extends TimeoutError {
      constructor(timeoutMs) {
        super("extract()", timeoutMs);
        this.name = "ExtractTimeoutError";
      }
    };
    ObserveTimeoutError = class extends TimeoutError {
      constructor(timeoutMs) {
        super("observe()", timeoutMs);
        this.name = "ObserveTimeoutError";
      }
    };
    PageNotFoundError = class extends StagehandError {
      constructor(identifier) {
        super(`No Page found for ${identifier}`);
      }
    };
    ConnectionTimeoutError = class extends StagehandError {
      constructor(message) {
        super(`Connection timeout: ${message}`);
      }
    };
    StreamingCallbacksInNonStreamingModeError = class extends StagehandError {
      constructor(invalidCallbacks) {
        super(
          `Streaming-only callback(s) "${invalidCallbacks.join('", "')}" cannot be used in non-streaming mode. Set 'stream: true' in AgentConfig to use these callbacks.`
        );
        this.invalidCallbacks = invalidCallbacks;
      }
    };
    AgentAbortError = class extends StagehandError {
      constructor(reason) {
        const message = reason ? `Agent execution was aborted: ${reason}` : "Agent execution was aborted";
        super(message);
        this.reason = reason || "aborted";
      }
    };
    StagehandClosedError = class extends StagehandError {
      constructor() {
        super("Stagehand session was closed");
      }
    };
  }
});

// lib/v3/logger.ts
function bindInstanceLogger(instanceId, logger) {
  instanceLoggers.set(instanceId, logger);
}
function unbindInstanceLogger(instanceId) {
  instanceLoggers.delete(instanceId);
}
function withInstanceLogContext(instanceId, fn) {
  return logContext.run(instanceId, fn);
}
function v3Logger(line) {
  var _a4, _b, _c;
  const id = logContext.getStore();
  if (id) {
    const fn = instanceLoggers.get(id);
    if (fn) {
      const enriched = __spreadProps(__spreadValues({}, line), {
        auxiliary: __spreadValues({}, line.auxiliary || {})
      });
      try {
        fn(enriched);
        return;
      } catch (e2) {
      }
    }
  }
  const ts = (_a4 = line.timestamp) != null ? _a4 : (/* @__PURE__ */ new Date()).toISOString();
  const lvl = (_b = line.level) != null ? _b : 1;
  const levelStr = lvl === 0 ? "ERROR" : lvl === 2 ? "DEBUG" : "INFO";
  let output = `[${ts}] ${levelStr}: ${line.message}`;
  if (line.auxiliary) {
    for (const [key, { value, type }] of Object.entries(line.auxiliary)) {
      let formattedValue = value;
      if (type === "object") {
        try {
          formattedValue = JSON.stringify(JSON.parse(value), null, 2).split("\n").map((line2, i2) => i2 === 0 ? line2 : `    ${line2}`).join("\n");
        } catch (e2) {
          formattedValue = value;
        }
      }
      output += `
    ${key}: ${formattedValue}`;
    }
  }
  if (lvl === 0) {
    console.error(output);
  } else if (lvl === 2) {
    ((_c = console.debug) != null ? _c : console.log)(output);
  } else {
    console.log(output);
  }
}
var import_node_async_hooks, logContext, instanceLoggers;
var init_logger = __esm({
  "lib/v3/logger.ts"() {
    import_node_async_hooks = require("async_hooks");
    logContext = new import_node_async_hooks.AsyncLocalStorage();
    instanceLoggers = /* @__PURE__ */ new Map();
  }
});

// lib/v3/understudy/executionContextRegistry.ts
var ExecutionContextRegistry, executionContexts;
var init_executionContextRegistry = __esm({
  "lib/v3/understudy/executionContextRegistry.ts"() {
    ExecutionContextRegistry = class {
      constructor() {
        this.byFrame = /* @__PURE__ */ new WeakMap();
        this.byExec = /* @__PURE__ */ new WeakMap();
      }
      /** Wire listeners for this session. Call BEFORE Runtime.enable. */
      attachSession(session) {
        const onCreated = (evt) => {
          var _a4;
          const aux = (_a4 = evt.context.auxData) != null ? _a4 : {};
          if (aux.isDefault === true && typeof aux.frameId === "string") {
            this.register(session, aux.frameId, evt.context.id);
          }
        };
        const onDestroyed = (evt) => {
          const rev = this.byExec.get(session);
          const fwd = this.byFrame.get(session);
          if (!rev || !fwd) return;
          const frameId = rev.get(evt.executionContextId);
          if (!frameId) return;
          rev.delete(evt.executionContextId);
          if (fwd.get(frameId) === evt.executionContextId) fwd.delete(frameId);
        };
        const onCleared = () => {
          this.byFrame.delete(session);
          this.byExec.delete(session);
        };
        session.on("Runtime.executionContextCreated", onCreated);
        session.on("Runtime.executionContextDestroyed", onDestroyed);
        session.on("Runtime.executionContextsCleared", onCleared);
      }
      getMainWorld(session, frameId) {
        var _a4, _b;
        return (_b = (_a4 = this.byFrame.get(session)) == null ? void 0 : _a4.get(frameId)) != null ? _b : null;
      }
      waitForMainWorld(session, frameId, timeoutMs = 800) {
        return __async(this, null, function* () {
          const cached = this.getMainWorld(session, frameId);
          if (cached) return cached;
          yield session.send("Runtime.enable").catch(() => {
          });
          const after = this.getMainWorld(session, frameId);
          if (after) return after;
          return yield new Promise((resolve3, reject) => {
            let done = false;
            const onCreated = (evt) => {
              var _a4;
              const aux = (_a4 = evt.context.auxData) != null ? _a4 : {};
              if (aux.isDefault === true && aux.frameId === frameId) {
                this.register(session, frameId, evt.context.id);
                if (!done) {
                  done = true;
                  clearTimeout(timer);
                  session.off("Runtime.executionContextCreated", onCreated);
                  resolve3(evt.context.id);
                }
              }
            };
            const timer = setTimeout(() => {
              if (!done) {
                done = true;
                session.off("Runtime.executionContextCreated", onCreated);
                reject(new Error(`main world not ready for frame ${frameId}`));
              }
            }, timeoutMs);
            session.on("Runtime.executionContextCreated", onCreated);
          });
        });
      }
      register(session, frameId, ctxId) {
        let fwd = this.byFrame.get(session);
        if (!fwd) {
          fwd = /* @__PURE__ */ new Map();
          this.byFrame.set(session, fwd);
        }
        let rev = this.byExec.get(session);
        if (!rev) {
          rev = /* @__PURE__ */ new Map();
          this.byExec.set(session, rev);
        }
        fwd.set(frameId, ctxId);
        rev.set(ctxId, frameId);
      }
    };
    executionContexts = new ExecutionContextRegistry();
  }
});

// lib/v3/dom/build/locatorScripts.generated.ts
var locatorScriptBootstrap, locatorScriptSources, locatorScriptGlobalRefs;
var init_locatorScripts_generated = __esm({
  "lib/v3/dom/build/locatorScripts.generated.ts"() {
    locatorScriptBootstrap = 'if (!globalThis.__stagehandLocatorScripts) { var __stagehandLocatorScriptsFactory=(()=>{var L=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var D=(t,e)=>{for(var c in e)L(t,c,{get:e[c],enumerable:!0})},A=(t,e,c,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of k(e))!H.call(t,o)&&o!==c&&L(t,o,{get:()=>e[o],enumerable:!(n=R(e,o))||n.enumerable});return t};var _=t=>A(L({},"__esModule",{value:!0}),t);var oe={};D(oe,{assignFilePayloadsToInputElement:()=>F,countCssMatchesPierce:()=>ee,countCssMatchesPrimary:()=>Z,countTextMatches:()=>te,countXPathMatchesMainWorld:()=>ne,dispatchDomClick:()=>W,ensureFileInputElement:()=>I,fillElementValue:()=>O,focusElement:()=>V,isElementChecked:()=>B,isElementVisible:()=>Y,prepareElementForTyping:()=>T,readElementInnerHTML:()=>U,readElementInnerText:()=>j,readElementInputValue:()=>$,readElementTextContent:()=>z,resolveCssSelector:()=>K,resolveCssSelectorPierce:()=>G,resolveTextSelector:()=>J,resolveXPathMainWorld:()=>Q,scrollElementToPercent:()=>q,selectElementOptions:()=>X});function I(){try{return(this.tagName?.toLowerCase()??"")!=="input"?!1:String(this.type??"").toLowerCase()==="file"}catch{return!1}}function F(t){try{let e=this;if(!e||e.tagName?.toLowerCase()!=="input"||(e.type??"").toLowerCase()!=="file")return!1;let c=(()=>{try{return new DataTransfer}catch{return null}})();if(!c)return!1;let n=Array.isArray(t)?t:[];for(let o of n){if(!o)continue;let y=o.name||"upload.bin",u=o.mimeType||"application/octet-stream",a=typeof o.lastModified=="number"?o.lastModified:Date.now(),l=window.atob(o.base64??""),i=new Uint8Array(l.length);for(let s=0;s<l.length;s+=1)i[s]=l.charCodeAt(s);let f=new Blob([i],{type:u}),h=new File([f],y,{type:u,lastModified:a});c.items.add(h)}return e.files=c.files,e.dispatchEvent(new Event("input",{bubbles:!0})),e.dispatchEvent(new Event("change",{bubbles:!0})),!0}catch{return!1}}function W(t){let e=t??{};try{let c=new MouseEvent("click",{bubbles:!!e.bubbles,cancelable:!!e.cancelable,composed:!!e.composed,detail:typeof e.detail=="number"?e.detail:1,view:this?.ownerDocument?.defaultView??window});this.dispatchEvent(c)}catch{try{this.click()}catch{}}}function q(t){let e=c=>{if(typeof c=="number"&&Number.isFinite(c))return c;let n=String(c??"").trim();if(!n)return 0;let o=parseFloat(n.replace("%",""));return Number.isNaN(o)||!Number.isFinite(o)?0:o};try{let c=Math.max(0,Math.min(e(t),100)),n=this,o=n.tagName?.toLowerCase()??"";if(o==="html"||o==="body"){let h=(n.ownerDocument?.scrollingElement||n.ownerDocument?.documentElement||n.ownerDocument?.body||document.scrollingElement||document.documentElement||document.body)?.scrollHeight??document.body.scrollHeight??0,s=n.ownerDocument?.defaultView?.innerHeight??window.innerHeight,g=Math.max(0,h-s)*(c/100);return n.ownerDocument?.defaultView?.scrollTo({top:g,left:n.ownerDocument?.defaultView?.scrollX??window.scrollX??0,behavior:"smooth"}),!0}let u=n.scrollHeight??0,a=n.clientHeight??0,i=Math.max(0,u-a)*(c/100);return n.scrollTo({top:i,left:n.scrollLeft??0,behavior:"smooth"}),!0}catch{return!1}}var v=new Set(["color","date","datetime-local","month","range","time","week"]),P=new Set(["","email","number","password","search","tel","text","url"]);function T(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument||document,c=e.defaultView||window;try{typeof t.focus=="function"&&t.focus()}catch{}if(t instanceof c.HTMLInputElement||t instanceof c.HTMLTextAreaElement){try{if(typeof t.select=="function")return t.select(),!0}catch{}try{let n=(t.value??"").length;if(typeof t.setSelectionRange=="function")return t.setSelectionRange(0,n),!0}catch{}return!0}if(t.isContentEditable){let n=e.getSelection?.(),o=e.createRange?.();if(n&&o)try{o.selectNodeContents(t),n.removeAllRanges(),n.addRange(o)}catch{}return!0}return!1}catch{return!1}}function O(t){let e=this;if(!e.isConnected)return{status:"error",reason:"notconnected"};let n=(e.ownerDocument||document).defaultView||window,o=t??"";try{let y=u=>{let a;if(typeof n.InputEvent=="function")try{a=new n.InputEvent("input",{bubbles:!0,composed:!0,data:u,inputType:"insertText"})}catch{a=new n.Event("input",{bubbles:!0,composed:!0})}else a=new n.Event("input",{bubbles:!0,composed:!0});e.dispatchEvent(a);let l=new n.Event("change",{bubbles:!0});e.dispatchEvent(l)};if(e instanceof n.HTMLInputElement){let u=(e.type||"").toLowerCase();if(!P.has(u)&&!v.has(u))return{status:"error",reason:`unsupported-input-type:${u}`};let a=t;if(u==="number"){let l=t.trim();if(l!==""&&Number.isNaN(Number(l)))return{status:"error",reason:"invalid-number-value"};a=l}if(o=a,v.has(u)){let l=t.trim();o=l,T.call(e);let i=n.HTMLInputElement.prototype,h=Object.getOwnPropertyDescriptor(i,"value")?.set;return typeof h=="function"?h.call(e,l):e.value=l,e._valueTracker?.setValue?.(l),e.value!==l?{status:"error",reason:"malformed-value"}:(y(l),{status:"done"})}return T.call(e),{status:"needsinput",value:a}}return e instanceof n.HTMLTextAreaElement?(T.call(e),o=t,{status:"needsinput",value:t}):e instanceof n.HTMLSelectElement?{status:"error",reason:"unsupported-element"}:e.isContentEditable?(T.call(e),o=t,{status:"needsinput",value:t}):{status:"error",reason:"unsupported-element"}}catch(y){let u="exception";if(y&&typeof y=="object"){let a=y.message;typeof a=="string"&&a.trim().length>0&&(u=`exception:${a}`)}return{status:"needsinput",value:o,reason:u}}}function V(){try{typeof this.focus=="function"&&this.focus()}catch{}}function X(t){try{if(!(this instanceof HTMLSelectElement))return[];let e=Array.isArray(t)?t:[t],c=new Set(e.map(u=>String(u??"").trim())),n=u=>{let a=(u.label||u.textContent||"").trim(),l=String(u.value??"").trim();return c.has(a)||c.has(l)};if(this.multiple)for(let u of Array.from(this.options))u.selected=n(u);else{let u=!1;for(let a of Array.from(this.options))!u&&n(a)?(a.selected=!0,this.value=a.value,u=!0):a.selected=!1}let o=new Event("input",{bubbles:!0}),y=new Event("change",{bubbles:!0});return this.dispatchEvent(o),this.dispatchEvent(y),Array.from(this.selectedOptions).map(u=>u.value)}catch{return[]}}function Y(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument?.defaultView?.getComputedStyle(t)??window.getComputedStyle(t);if(!e||e.display==="none"||e.visibility==="hidden")return!1;let c=parseFloat(e.opacity??"1");if(!Number.isFinite(c)||c===0)return!1;let n=t.getBoundingClientRect();return!(!n||Math.max(n.width,n.height)===0||t.getClientRects().length===0)}catch{return!1}}function B(){try{let t=this;if((t.tagName||"").toLowerCase()==="input"){let n=t.type?.toLowerCase()??"";if(n==="checkbox"||n==="radio")return!!t.checked}let c=t.getAttribute?.("aria-checked");return c!=null?c==="true":!1}catch{return!1}}function $(){try{let t=this,e=(t.tagName||"").toLowerCase();return e==="input"||e==="textarea"||e==="select"?String(t.value??""):t.isContentEditable?String(t.textContent??""):""}catch{return""}}function z(){try{return String(this.textContent??"")}catch{return""}}function U(){try{return String(this.innerHTML??"")}catch{return""}}function j(){try{let t=this,e=t.innerText;if(typeof e=="string"&&e.length>0)return e;let c=t.textContent;return typeof c=="string"?c:""}catch{return""}}var N=t=>{let e=Number(t??0);return!Number.isFinite(e)||e<0?0:Math.floor(e)},M=(t,e)=>{if(!t)return[];let c=new WeakSet,n=new Set,o=[],y=[document],u=a=>{if(!(!a||c.has(a)||o.length>=e)){c.add(a);try{let l=a.querySelectorAll(t);for(let i of l)if(!n.has(i)&&(n.add(i),o.push(i),o.length>=e))return}catch{}try{let i=(a instanceof Document?a:a.host?.ownerDocument??document).createTreeWalker(a,NodeFilter.SHOW_ELEMENT),f;for(;f=i.nextNode();){if(!(f instanceof Element))continue;let h=f.shadowRoot;h&&y.push(h)}}catch{}}};for(;y.length&&o.length<e;){let a=y.shift();a&&u(a)}return o};function K(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e);return M(c,n+1)[n]??null}function G(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e),o=window.__stagehandV3__;if(!o||typeof o.getClosedRoot!="function")return M(c,n+1)[n]??null;let y=h=>{try{return o.getClosedRoot(h)??null}catch{return null}},u=new WeakSet,a=new Set,l=[],i=[document],f=h=>{if(!(!h||u.has(h)||l.length>=n+1)){u.add(h);try{let s=h.querySelectorAll(c);for(let d of s)if(!a.has(d)&&(a.add(d),l.push(d),l.length>=n+1))return}catch{}try{let d=(h instanceof Document?h:h.host?.ownerDocument??document).createTreeWalker(h,NodeFilter.SHOW_ELEMENT),g;for(;g=d.nextNode();){if(!(g instanceof Element))continue;let w=g.shadowRoot;w&&i.push(w);let E=y(g);E&&i.push(E)}}catch{}}};for(;i.length&&l.length<n+1;){let h=i.shift();h&&f(h)}return l[n]??null}function J(t,e){let c=String(t??"");if(!c)return null;let n=c.toLowerCase(),o=N(e),y=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),u=r=>{if(!r)return!1;let p=r.tagName?.toUpperCase()??"";return y.has(p)},a=r=>{try{if(u(r))return"";let p=r.innerText;if(typeof p=="string"&&p.trim())return p.trim()}catch{}try{let p=r.textContent;if(typeof p=="string")return p.trim()}catch{}return""},l=r=>{let p=a(r);return!!p&&p.toLowerCase().includes(n)},i=window.__stagehandV3__,f=i&&typeof i.getClosedRoot=="function"?r=>{try{return i.getClosedRoot(r)??null}catch{return null}}:r=>null,h=new WeakSet,s=[],d=[],g=r=>{!r||h.has(r)||(h.add(r),s.push(r))},w=r=>{try{return(r instanceof Document?r:r?.ownerDocument??document).createTreeWalker(r,NodeFilter.SHOW_ELEMENT)}catch{return null}};for(g(document);s.length;){let r=s.shift();if(!r)continue;r instanceof Element&&l(r)&&d.push({element:r,tag:r.tagName??"",id:r.id??"",className:r.className??"",text:a(r)});let p=w(r);if(!p)continue;let x;for(;x=p.nextNode();){if(!(x instanceof Element))continue;l(x)&&d.push({element:x,tag:x.tagName??"",id:x.id??"",className:x.className??"",text:a(x)});let b=x.shadowRoot;b&&g(b);let S=f(x);S&&g(S)}}let E=[];for(let r of d){let p=r.element,x=!1;for(let b of d)if(r!==b)try{if(p.contains(b.element)){x=!0;break}}catch{}x||E.push(r)}return E[o]?.element??null}function Q(t,e){let c=String(t??"").trim();if(!c)return null;let n=N(e),o=window.__stagehandV3__;if(n===0){try{if(o&&typeof o.resolveSimpleXPath=="function"){let s=o.resolveSimpleXPath(c);if(s)return s}}catch{}try{return document.evaluate(c,document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue}catch{}}let u=(s=>{let d=String(s||"").trim();if(!d)return[];let g=d.replace(/^xpath=/i,""),w=[],E=0;for(;E<g.length;){let m="child";g.startsWith("//",E)?(m="desc",E+=2):g[E]==="/"&&(m="child",E+=1);let r=E;for(;E<g.length&&g[E]!=="/";)E+=1;let p=g.slice(r,E).trim();if(!p)continue;let x=p.match(/^(.*?)(\\[(\\d+)\\])?$/u),b=(x?.[1]??p).trim(),S=x?.[3]?Math.max(1,Number(x[3])):null,C=b===""?"*":b.toLowerCase();w.push({axis:m,tag:C,index:S})}return w})(c);if(!u.length)return null;let a=o&&typeof o.getClosedRoot=="function"?s=>{try{return o.getClosedRoot(s)??null}catch{return null}}:s=>null,l=s=>{let d=[];if(!s)return d;if(s instanceof Document)return s.documentElement&&d.push(s.documentElement),d;if(s instanceof ShadowRoot||s instanceof DocumentFragment)return d.push(...Array.from(s.children??[])),d;if(s instanceof Element){d.push(...Array.from(s.children??[]));let g=s.shadowRoot;g&&d.push(...Array.from(g.children??[]));let w=a(s);return w&&d.push(...Array.from(w.children??[])),d}return d},i=s=>{let d=[],g=new Set,w=[...l(s)];for(;w.length;){let E=w.shift();!E||g.has(E)||(g.add(E),d.push(E),w.push(...l(E)))}return d},f=[document];for(let s of u){let d=[],g=new Set;for(let w of f){if(!w)continue;let E=s.axis==="child"?l(w):i(w);if(!E.length)continue;let m=E.filter(r=>r instanceof Element?s.tag==="*"?!0:r.localName===s.tag:!1);if(s.index!=null){let r=s.index-1,p=r>=0&&r<m.length?m[r]:null;p&&!g.has(p)&&(g.add(p),d.push(p))}else for(let r of m)g.has(r)||(g.add(r),d.push(r))}if(!d.length)return null;f=d}return f[n]??null}function Z(t){let e=String(t??"").trim();if(!e)return 0;let c=new WeakSet,n=o=>{if(!o||c.has(o))return 0;c.add(o);let y=0;try{let u=o;typeof u.querySelectorAll=="function"&&(y+=u.querySelectorAll(e).length)}catch{}try{let a=(o instanceof Document?o:o?.ownerDocument??document).createTreeWalker(o,NodeFilter.SHOW_ELEMENT),l;for(;l=a.nextNode();)l instanceof Element&&l.shadowRoot&&(y+=n(l.shadowRoot))}catch{}return y};try{return n(document)}catch{try{return document.querySelectorAll(e).length}catch{return 0}}}function ee(t){let e=String(t??"").trim();if(!e)return 0;let c=window.__stagehandV3__;if(!c||typeof c.getClosedRoot!="function")try{return document.querySelectorAll(e).length}catch{return 0}let n=new WeakSet,o=[],y=l=>{!l||n.has(l)||(n.add(l),o.push(l))};y(document);let u=0,a=l=>{let i=l.shadowRoot;i&&y(i);try{let f=c.getClosedRoot(l);f&&y(f)}catch{}};for(;o.length;){let l=o.shift();if(l){try{let i=l;typeof i.querySelectorAll=="function"&&(u+=i.querySelectorAll(e).length)}catch{}try{let f=(l instanceof Document?l:l instanceof ShadowRoot?l.host?.ownerDocument??document:l.ownerDocument??document).createTreeWalker(l,NodeFilter.SHOW_ELEMENT),h;for(;h=f.nextNode();)h instanceof Element&&a(h)}catch{}}}return u}function te(t){let e=String(t??"");if(!e)return{count:0,sample:[],error:null};let c=e.toLowerCase(),n=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),o=m=>{if(!m)return!1;let r=m.tagName?.toUpperCase()??"";return n.has(r)},y=m=>{try{if(o(m))return"";let r=m.innerText;if(typeof r=="string"&&r.trim())return r.trim()}catch{}try{let r=m.textContent;if(typeof r=="string")return r.trim()}catch{}return""},u=m=>{let r=y(m);return!!r&&r.toLowerCase().includes(c)},a=window.__stagehandV3__,l=a&&typeof a.getClosedRoot=="function"?m=>{try{return a.getClosedRoot(m)??null}catch{return null}}:m=>null,i=new WeakSet,f=[],h=m=>{!m||i.has(m)||(i.add(m),f.push(m))},s=m=>{try{return(m instanceof Document?m:m?.ownerDocument??document).createTreeWalker(m,NodeFilter.SHOW_ELEMENT)}catch{return null}},d=[];for(h(document);f.length;){let m=f.shift();if(!m)continue;m instanceof Element&&u(m)&&d.push({element:m,tag:m.tagName??"",id:m.id??"",className:m.className??"",text:y(m)});let r=s(m);if(!r)continue;let p;for(;p=r.nextNode();){if(!(p instanceof Element))continue;u(p)&&d.push({element:p,tag:p.tagName??"",id:p.id??"",className:p.className??"",text:y(p)});let x=p.shadowRoot;x&&h(x);let b=l(p);b&&h(b)}}let g=[];for(let m of d){let r=m.element,p=!1;for(let x of d)if(m!==x)try{if(r.contains(x.element)){p=!0;break}}catch{}p||g.push(m)}let w=g.length,E=g.slice(0,5).map(m=>({tag:m.tag,id:m.id,class:m.className,text:m.text}));return{count:w,sample:E,error:null}}function ne(t){let e=String(t??"").trim();if(!e)return 0;let n=(i=>{let f=String(i||"").trim().replace(/^xpath=/i,"");if(!f)return[];let h=[],s=0;for(;s<f.length;){let d="child";f.startsWith("//",s)?(d="desc",s+=2):f[s]==="/"&&(d="child",s+=1);let g=s;for(;s<f.length&&f[s]!=="/";)s+=1;let w=f.slice(g,s).trim();if(!w)continue;let E=w.match(/^(.*?)(\\[(\\d+)\\])?$/u),m=(E?.[1]??w).trim(),r=E?.[3]?Math.max(1,Number(E[3])):null,p=m===""?"*":m.toLowerCase();h.push({axis:d,tag:p,index:r})}return h})(e);if(!n.length)return 0;let o=window.__stagehandV3__,y=o&&typeof o.getClosedRoot=="function"?i=>{try{return o.getClosedRoot(i)??null}catch{return null}}:i=>null,u=i=>{let f=[];if(!i)return f;if(i instanceof Document)return i.documentElement&&f.push(i.documentElement),f;if(i instanceof ShadowRoot||i instanceof DocumentFragment)return f.push(...Array.from(i.children??[])),f;if(i instanceof Element){f.push(...Array.from(i.children??[]));let h=i.shadowRoot;h&&f.push(...Array.from(h.children??[]));let s=y(i);return s&&f.push(...Array.from(s.children??[])),f}return f},a=i=>{let f=[],h=new Set,s=[...u(i)];for(;s.length;){let d=s.shift();!d||h.has(d)||(h.add(d),f.push(d),s.push(...u(d)))}return f},l=[document];for(let i of n){let f=[],h=new Set;for(let s of l){if(!s)continue;let d=i.axis==="child"?u(s):a(s);if(!d.length)continue;let g=d.filter(w=>w instanceof Element?i.tag==="*"?!0:w.localName===i.tag:!1);if(i.index!=null){let w=i.index-1,E=w>=0&&w<g.length?g[w]:null;E&&!h.has(E)&&(h.add(E),f.push(E))}else for(let w of g)h.has(w)||(h.add(w),f.push(w))}if(!f.length)return 0;l=f}return l.length}return _(oe);})();\n  globalThis.__stagehandLocatorScripts = __stagehandLocatorScriptsFactory;\n}';
    locatorScriptSources = {
      "assignFilePayloadsToInputElement": 'function k(t){try{let e=this;if(!e||e.tagName?.toLowerCase()!=="input"||(e.type??"").toLowerCase()!=="file")return!1;let i=(()=>{try{return new DataTransfer}catch{return null}})();if(!i)return!1;let n=Array.isArray(t)?t:[];for(let s of n){if(!s)continue;let y=s.name||"upload.bin",u=s.mimeType||"application/octet-stream",a=typeof s.lastModified=="number"?s.lastModified:Date.now(),l=window.atob(s.base64??""),c=new Uint8Array(l.length);for(let r=0;r<l.length;r+=1)c[r]=l.charCodeAt(r);let f=new Blob([c],{type:u}),h=new File([f],y,{type:u,lastModified:a});i.items.add(h)}return e.files=i.files,e.dispatchEvent(new Event("input",{bubbles:!0})),e.dispatchEvent(new Event("change",{bubbles:!0})),!0}catch{return!1}}',
      "countCssMatchesPierce": 'function K(t){let e=String(t??"").trim();if(!e)return 0;let i=window.__stagehandV3__;if(!i||typeof i.getClosedRoot!="function")try{return document.querySelectorAll(e).length}catch{return 0}let n=new WeakSet,s=[],y=l=>{!l||n.has(l)||(n.add(l),s.push(l))};y(document);let u=0,a=l=>{let c=l.shadowRoot;c&&y(c);try{let f=i.getClosedRoot(l);f&&y(f)}catch{}};for(;s.length;){let l=s.shift();if(l){try{let c=l;typeof c.querySelectorAll=="function"&&(u+=c.querySelectorAll(e).length)}catch{}try{let f=(l instanceof Document?l:l instanceof ShadowRoot?l.host?.ownerDocument??document:l.ownerDocument??document).createTreeWalker(l,NodeFilter.SHOW_ELEMENT),h;for(;h=f.nextNode();)h instanceof Element&&a(h)}catch{}}}return u}',
      "countCssMatchesPrimary": 'function j(t){let e=String(t??"").trim();if(!e)return 0;let i=new WeakSet,n=s=>{if(!s||i.has(s))return 0;i.add(s);let y=0;try{let u=s;typeof u.querySelectorAll=="function"&&(y+=u.querySelectorAll(e).length)}catch{}try{let a=(s instanceof Document?s:s?.ownerDocument??document).createTreeWalker(s,NodeFilter.SHOW_ELEMENT),l;for(;l=a.nextNode();)l instanceof Element&&l.shadowRoot&&(y+=n(l.shadowRoot))}catch{}return y};try{return n(document)}catch{try{return document.querySelectorAll(e).length}catch{return 0}}}',
      "countTextMatches": 'function G(t){let e=String(t??"");if(!e)return{count:0,sample:[],error:null};let i=e.toLowerCase(),n=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),s=m=>{if(!m)return!1;let o=m.tagName?.toUpperCase()??"";return n.has(o)},y=m=>{try{if(s(m))return"";let o=m.innerText;if(typeof o=="string"&&o.trim())return o.trim()}catch{}try{let o=m.textContent;if(typeof o=="string")return o.trim()}catch{}return""},u=m=>{let o=y(m);return!!o&&o.toLowerCase().includes(i)},a=window.__stagehandV3__,l=a&&typeof a.getClosedRoot=="function"?m=>{try{return a.getClosedRoot(m)??null}catch{return null}}:m=>null,c=new WeakSet,f=[],h=m=>{!m||c.has(m)||(c.add(m),f.push(m))},r=m=>{try{return(m instanceof Document?m:m?.ownerDocument??document).createTreeWalker(m,NodeFilter.SHOW_ELEMENT)}catch{return null}},d=[];for(h(document);f.length;){let m=f.shift();if(!m)continue;m instanceof Element&&u(m)&&d.push({element:m,tag:m.tagName??"",id:m.id??"",className:m.className??"",text:y(m)});let o=r(m);if(!o)continue;let p;for(;p=o.nextNode();){if(!(p instanceof Element))continue;u(p)&&d.push({element:p,tag:p.tagName??"",id:p.id??"",className:p.className??"",text:y(p)});let x=p.shadowRoot;x&&h(x);let b=l(p);b&&h(b)}}let g=[];for(let m of d){let o=m.element,p=!1;for(let x of d)if(m!==x)try{if(o.contains(x.element)){p=!0;break}}catch{}p||g.push(m)}let w=g.length,E=g.slice(0,5).map(m=>({tag:m.tag,id:m.id,class:m.className,text:m.text}));return{count:w,sample:E,error:null}}',
      "countXPathMatchesMainWorld": 'function J(t){let e=String(t??"").trim();if(!e)return 0;let n=(c=>{let f=String(c||"").trim().replace(/^xpath=/i,"");if(!f)return[];let h=[],r=0;for(;r<f.length;){let d="child";f.startsWith("//",r)?(d="desc",r+=2):f[r]==="/"&&(d="child",r+=1);let g=r;for(;r<f.length&&f[r]!=="/";)r+=1;let w=f.slice(g,r).trim();if(!w)continue;let E=w.match(/^(.*?)(\\[(\\d+)\\])?$/u),m=(E?.[1]??w).trim(),o=E?.[3]?Math.max(1,Number(E[3])):null,p=m===""?"*":m.toLowerCase();h.push({axis:d,tag:p,index:o})}return h})(e);if(!n.length)return 0;let s=window.__stagehandV3__,y=s&&typeof s.getClosedRoot=="function"?c=>{try{return s.getClosedRoot(c)??null}catch{return null}}:c=>null,u=c=>{let f=[];if(!c)return f;if(c instanceof Document)return c.documentElement&&f.push(c.documentElement),f;if(c instanceof ShadowRoot||c instanceof DocumentFragment)return f.push(...Array.from(c.children??[])),f;if(c instanceof Element){f.push(...Array.from(c.children??[]));let h=c.shadowRoot;h&&f.push(...Array.from(h.children??[]));let r=y(c);return r&&f.push(...Array.from(r.children??[])),f}return f},a=c=>{let f=[],h=new Set,r=[...u(c)];for(;r.length;){let d=r.shift();!d||h.has(d)||(h.add(d),f.push(d),r.push(...u(d)))}return f},l=[document];for(let c of n){let f=[],h=new Set;for(let r of l){if(!r)continue;let d=c.axis==="child"?u(r):a(r);if(!d.length)continue;let g=d.filter(w=>w instanceof Element?c.tag==="*"?!0:w.localName===c.tag:!1);if(c.index!=null){let w=c.index-1,E=w>=0&&w<g.length?g[w]:null;E&&!h.has(E)&&(h.add(E),f.push(E))}else for(let w of g)h.has(w)||(h.add(w),f.push(w))}if(!f.length)return 0;l=f}return l.length}',
      "dispatchDomClick": 'function H(t){let e=t??{};try{let i=new MouseEvent("click",{bubbles:!!e.bubbles,cancelable:!!e.cancelable,composed:!!e.composed,detail:typeof e.detail=="number"?e.detail:1,view:this?.ownerDocument?.defaultView??window});this.dispatchEvent(i)}catch{try{this.click()}catch{}}}',
      "ensureFileInputElement": 'function R(){try{return(this.tagName?.toLowerCase()??"")!=="input"?!1:String(this.type??"").toLowerCase()==="file"}catch{return!1}}',
      "fillElementValue": 'function A(t){let e=this;if(!e.isConnected)return{status:"error",reason:"notconnected"};let n=(e.ownerDocument||document).defaultView||window,s=t??"";try{let y=u=>{let a;if(typeof n.InputEvent=="function")try{a=new n.InputEvent("input",{bubbles:!0,composed:!0,data:u,inputType:"insertText"})}catch{a=new n.Event("input",{bubbles:!0,composed:!0})}else a=new n.Event("input",{bubbles:!0,composed:!0});e.dispatchEvent(a);let l=new n.Event("change",{bubbles:!0});e.dispatchEvent(l)};if(e instanceof n.HTMLInputElement){let u=(e.type||"").toLowerCase();if(!C.has(u)&&!L.has(u))return{status:"error",reason:`unsupported-input-type:${u}`};let a=t;if(u==="number"){let l=t.trim();if(l!==""&&Number.isNaN(Number(l)))return{status:"error",reason:"invalid-number-value"};a=l}if(s=a,L.has(u)){let l=t.trim();s=l,S.call(e);let c=n.HTMLInputElement.prototype,h=Object.getOwnPropertyDescriptor(c,"value")?.set;return typeof h=="function"?h.call(e,l):e.value=l,e._valueTracker?.setValue?.(l),e.value!==l?{status:"error",reason:"malformed-value"}:(y(l),{status:"done"})}return S.call(e),{status:"needsinput",value:a}}return e instanceof n.HTMLTextAreaElement?(S.call(e),s=t,{status:"needsinput",value:t}):e instanceof n.HTMLSelectElement?{status:"error",reason:"unsupported-element"}:e.isContentEditable?(S.call(e),s=t,{status:"needsinput",value:t}):{status:"error",reason:"unsupported-element"}}catch(y){let u="exception";if(y&&typeof y=="object"){let a=y.message;typeof a=="string"&&a.trim().length>0&&(u=`exception:${a}`)}return{status:"needsinput",value:s,reason:u}}}',
      "focusElement": 'function _(){try{typeof this.focus=="function"&&this.focus()}catch{}}',
      "isElementChecked": 'function W(){try{let t=this;if((t.tagName||"").toLowerCase()==="input"){let n=t.type?.toLowerCase()??"";if(n==="checkbox"||n==="radio")return!!t.checked}let i=t.getAttribute?.("aria-checked");return i!=null?i==="true":!1}catch{return!1}}',
      "isElementVisible": 'function F(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument?.defaultView?.getComputedStyle(t)??window.getComputedStyle(t);if(!e||e.display==="none"||e.visibility==="hidden")return!1;let i=parseFloat(e.opacity??"1");if(!Number.isFinite(i)||i===0)return!1;let n=t.getBoundingClientRect();return!(!n||Math.max(n.width,n.height)===0||t.getClientRects().length===0)}catch{return!1}}',
      "prepareElementForTyping": 'function S(){try{let t=this;if(!t.isConnected)return!1;let e=t.ownerDocument||document,i=e.defaultView||window;try{typeof t.focus=="function"&&t.focus()}catch{}if(t instanceof i.HTMLInputElement||t instanceof i.HTMLTextAreaElement){try{if(typeof t.select=="function")return t.select(),!0}catch{}try{let n=(t.value??"").length;if(typeof t.setSelectionRange=="function")return t.setSelectionRange(0,n),!0}catch{}return!0}if(t.isContentEditable){let n=e.getSelection?.(),s=e.createRange?.();if(n&&s)try{s.selectNodeContents(t),n.removeAllRanges(),n.addRange(s)}catch{}return!0}return!1}catch{return!1}}',
      "readElementInnerHTML": 'function O(){try{return String(this.innerHTML??"")}catch{return""}}',
      "readElementInnerText": 'function V(){try{let t=this,e=t.innerText;if(typeof e=="string"&&e.length>0)return e;let i=t.textContent;return typeof i=="string"?i:""}catch{return""}}',
      "readElementInputValue": 'function q(){try{let t=this,e=(t.tagName||"").toLowerCase();return e==="input"||e==="textarea"||e==="select"?String(t.value??""):t.isContentEditable?String(t.textContent??""):""}catch{return""}}',
      "readElementTextContent": 'function P(){try{return String(this.textContent??"")}catch{return""}}',
      "resolveCssSelector": 'function Y(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e);return v(i,n+1)[n]??null}',
      "resolveCssSelectorPierce": 'function B(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e),s=window.__stagehandV3__;if(!s||typeof s.getClosedRoot!="function")return v(i,n+1)[n]??null;let y=h=>{try{return s.getClosedRoot(h)??null}catch{return null}},u=new WeakSet,a=new Set,l=[],c=[document],f=h=>{if(!(!h||u.has(h)||l.length>=n+1)){u.add(h);try{let r=h.querySelectorAll(i);for(let d of r)if(!a.has(d)&&(a.add(d),l.push(d),l.length>=n+1))return}catch{}try{let d=(h instanceof Document?h:h.host?.ownerDocument??document).createTreeWalker(h,NodeFilter.SHOW_ELEMENT),g;for(;g=d.nextNode();){if(!(g instanceof Element))continue;let w=g.shadowRoot;w&&c.push(w);let E=y(g);E&&c.push(E)}}catch{}}};for(;c.length&&l.length<n+1;){let h=c.shift();h&&f(h)}return l[n]??null}',
      "resolveTextSelector": 'function $(t,e){let i=String(t??"");if(!i)return null;let n=i.toLowerCase(),s=N(e),y=new Set(["SCRIPT","STYLE","TEMPLATE","NOSCRIPT","HEAD","TITLE","LINK","META","HTML","BODY"]),u=o=>{if(!o)return!1;let p=o.tagName?.toUpperCase()??"";return y.has(p)},a=o=>{try{if(u(o))return"";let p=o.innerText;if(typeof p=="string"&&p.trim())return p.trim()}catch{}try{let p=o.textContent;if(typeof p=="string")return p.trim()}catch{}return""},l=o=>{let p=a(o);return!!p&&p.toLowerCase().includes(n)},c=window.__stagehandV3__,f=c&&typeof c.getClosedRoot=="function"?o=>{try{return c.getClosedRoot(o)??null}catch{return null}}:o=>null,h=new WeakSet,r=[],d=[],g=o=>{!o||h.has(o)||(h.add(o),r.push(o))},w=o=>{try{return(o instanceof Document?o:o?.ownerDocument??document).createTreeWalker(o,NodeFilter.SHOW_ELEMENT)}catch{return null}};for(g(document);r.length;){let o=r.shift();if(!o)continue;o instanceof Element&&l(o)&&d.push({element:o,tag:o.tagName??"",id:o.id??"",className:o.className??"",text:a(o)});let p=w(o);if(!p)continue;let x;for(;x=p.nextNode();){if(!(x instanceof Element))continue;l(x)&&d.push({element:x,tag:x.tagName??"",id:x.id??"",className:x.className??"",text:a(x)});let b=x.shadowRoot;b&&g(b);let T=f(x);T&&g(T)}}let E=[];for(let o of d){let p=o.element,x=!1;for(let b of d)if(o!==b)try{if(p.contains(b.element)){x=!0;break}}catch{}x||E.push(o)}return E[s]?.element??null}',
      "resolveXPathMainWorld": 'function z(t,e){let i=String(t??"").trim();if(!i)return null;let n=N(e),s=window.__stagehandV3__;if(n===0){try{if(s&&typeof s.resolveSimpleXPath=="function"){let r=s.resolveSimpleXPath(i);if(r)return r}}catch{}try{return document.evaluate(i,document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue}catch{}}let u=(r=>{let d=String(r||"").trim();if(!d)return[];let g=d.replace(/^xpath=/i,""),w=[],E=0;for(;E<g.length;){let m="child";g.startsWith("//",E)?(m="desc",E+=2):g[E]==="/"&&(m="child",E+=1);let o=E;for(;E<g.length&&g[E]!=="/";)E+=1;let p=g.slice(o,E).trim();if(!p)continue;let x=p.match(/^(.*?)(\\[(\\d+)\\])?$/u),b=(x?.[1]??p).trim(),T=x?.[3]?Math.max(1,Number(x[3])):null,M=b===""?"*":b.toLowerCase();w.push({axis:m,tag:M,index:T})}return w})(i);if(!u.length)return null;let a=s&&typeof s.getClosedRoot=="function"?r=>{try{return s.getClosedRoot(r)??null}catch{return null}}:r=>null,l=r=>{let d=[];if(!r)return d;if(r instanceof Document)return r.documentElement&&d.push(r.documentElement),d;if(r instanceof ShadowRoot||r instanceof DocumentFragment)return d.push(...Array.from(r.children??[])),d;if(r instanceof Element){d.push(...Array.from(r.children??[]));let g=r.shadowRoot;g&&d.push(...Array.from(g.children??[]));let w=a(r);return w&&d.push(...Array.from(w.children??[])),d}return d},c=r=>{let d=[],g=new Set,w=[...l(r)];for(;w.length;){let E=w.shift();!E||g.has(E)||(g.add(E),d.push(E),w.push(...l(E)))}return d},f=[document];for(let r of u){let d=[],g=new Set;for(let w of f){if(!w)continue;let E=r.axis==="child"?l(w):c(w);if(!E.length)continue;let m=E.filter(o=>o instanceof Element?r.tag==="*"?!0:o.localName===r.tag:!1);if(r.index!=null){let o=r.index-1,p=o>=0&&o<m.length?m[o]:null;p&&!g.has(p)&&(g.add(p),d.push(p))}else for(let o of m)g.has(o)||(g.add(o),d.push(o))}if(!d.length)return null;f=d}return f[n]??null}',
      "scrollElementToPercent": 'function D(t){let e=i=>{if(typeof i=="number"&&Number.isFinite(i))return i;let n=String(i??"").trim();if(!n)return 0;let s=parseFloat(n.replace("%",""));return Number.isNaN(s)||!Number.isFinite(s)?0:s};try{let i=Math.max(0,Math.min(e(t),100)),n=this,s=n.tagName?.toLowerCase()??"";if(s==="html"||s==="body"){let h=(n.ownerDocument?.scrollingElement||n.ownerDocument?.documentElement||n.ownerDocument?.body||document.scrollingElement||document.documentElement||document.body)?.scrollHeight??document.body.scrollHeight??0,r=n.ownerDocument?.defaultView?.innerHeight??window.innerHeight,g=Math.max(0,h-r)*(i/100);return n.ownerDocument?.defaultView?.scrollTo({top:g,left:n.ownerDocument?.defaultView?.scrollX??window.scrollX??0,behavior:"smooth"}),!0}let u=n.scrollHeight??0,a=n.clientHeight??0,c=Math.max(0,u-a)*(i/100);return n.scrollTo({top:c,left:n.scrollLeft??0,behavior:"smooth"}),!0}catch{return!1}}',
      "selectElementOptions": 'function I(t){try{if(!(this instanceof HTMLSelectElement))return[];let e=Array.isArray(t)?t:[t],i=new Set(e.map(u=>String(u??"").trim())),n=u=>{let a=(u.label||u.textContent||"").trim(),l=String(u.value??"").trim();return i.has(a)||i.has(l)};if(this.multiple)for(let u of Array.from(this.options))u.selected=n(u);else{let u=!1;for(let a of Array.from(this.options))!u&&n(a)?(a.selected=!0,this.value=a.value,u=!0):a.selected=!1}let s=new Event("input",{bubbles:!0}),y=new Event("change",{bubbles:!0});return this.dispatchEvent(s),this.dispatchEvent(y),Array.from(this.selectedOptions).map(u=>u.value)}catch{return[]}}'
    };
    locatorScriptGlobalRefs = {
      "assignFilePayloadsToInputElement": "globalThis.__stagehandLocatorScripts.assignFilePayloadsToInputElement",
      "countCssMatchesPierce": "globalThis.__stagehandLocatorScripts.countCssMatchesPierce",
      "countCssMatchesPrimary": "globalThis.__stagehandLocatorScripts.countCssMatchesPrimary",
      "countTextMatches": "globalThis.__stagehandLocatorScripts.countTextMatches",
      "countXPathMatchesMainWorld": "globalThis.__stagehandLocatorScripts.countXPathMatchesMainWorld",
      "dispatchDomClick": "globalThis.__stagehandLocatorScripts.dispatchDomClick",
      "ensureFileInputElement": "globalThis.__stagehandLocatorScripts.ensureFileInputElement",
      "fillElementValue": "globalThis.__stagehandLocatorScripts.fillElementValue",
      "focusElement": "globalThis.__stagehandLocatorScripts.focusElement",
      "isElementChecked": "globalThis.__stagehandLocatorScripts.isElementChecked",
      "isElementVisible": "globalThis.__stagehandLocatorScripts.isElementVisible",
      "prepareElementForTyping": "globalThis.__stagehandLocatorScripts.prepareElementForTyping",
      "readElementInnerHTML": "globalThis.__stagehandLocatorScripts.readElementInnerHTML",
      "readElementInnerText": "globalThis.__stagehandLocatorScripts.readElementInnerText",
      "readElementInputValue": "globalThis.__stagehandLocatorScripts.readElementInputValue",
      "readElementTextContent": "globalThis.__stagehandLocatorScripts.readElementTextContent",
      "resolveCssSelector": "globalThis.__stagehandLocatorScripts.resolveCssSelector",
      "resolveCssSelectorPierce": "globalThis.__stagehandLocatorScripts.resolveCssSelectorPierce",
      "resolveTextSelector": "globalThis.__stagehandLocatorScripts.resolveTextSelector",
      "resolveXPathMainWorld": "globalThis.__stagehandLocatorScripts.resolveXPathMainWorld",
      "scrollElementToPercent": "globalThis.__stagehandLocatorScripts.scrollElementToPercent",
      "selectElementOptions": "globalThis.__stagehandLocatorScripts.selectElementOptions"
    };
  }
});

// lib/v3/understudy/locatorInvocation.ts
function buildLocatorInvocation(name, args) {
  const invocation = `${locatorScriptGlobalRefs[name]}(${args.join(", ")})`;
  return `(() => { ${locatorScriptBootstrap}; return ${invocation}; })()`;
}
var init_locatorInvocation = __esm({
  "lib/v3/understudy/locatorInvocation.ts"() {
    init_locatorScripts_generated();
  }
});

// lib/v3/dom/build/a11yScripts.generated.ts
var a11yScriptBootstrap, a11yScriptSources, a11yScriptGlobalRefs;
var init_a11yScripts_generated = __esm({
  "lib/v3/dom/build/a11yScripts.generated.ts"() {
    a11yScriptBootstrap = 'if (!globalThis.__stagehandA11yScripts) { var __stagehandA11yScriptsFactory=(()=>{var i=Object.defineProperty;var a=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.prototype.hasOwnProperty;var N=(o,t)=>{for(var n in t)i(o,n,{get:t[n],enumerable:!0})},h=(o,t,n,d)=>{if(t&&typeof t=="object"||typeof t=="function")for(let u of f(t))!p.call(o,u)&&u!==n&&i(o,u,{get:()=>t[u],enumerable:!(d=a(t,u))||d.enumerable});return o};var E=o=>h(i({},"__esModule",{value:!0}),o);var b={};N(b,{documentHasFocusStrict:()=>g,getBoundingRectLite:()=>w,getScrollOffsets:()=>y,nodeToAbsoluteXPath:()=>$,resolveDeepActiveElement:()=>T});function y(){try{let o=window.scrollX??window.pageXOffset??document.documentElement?.scrollLeft??0,t=window.scrollY??window.pageYOffset??document.documentElement?.scrollTop??0;return{sx:Number(o)||0,sy:Number(t)||0}}catch{return{sx:0,sy:0}}}function w(){try{let o=this.getBoundingClientRect();return{left:Number(o?.left??0)||0,top:Number(o?.top??0)||0}}catch{return{left:0,top:0}}}function T(){try{return(t=>{let n=t.activeElement??null;for(;n&&n.shadowRoot&&n.shadowRoot.activeElement;)n=n.shadowRoot.activeElement;return n??null})(document)}catch{return null}}function $(){return(t=>{try{let n=e=>{if(!e||!e.parentNode)return 1;let l=1,m=`${e.nodeType}:${(e.nodeName||"").toLowerCase()}`;for(let c=e.previousSibling;c;c=c.previousSibling)`${c.nodeType}:${(c.nodeName||"").toLowerCase()}`===m&&(l+=1);return l},d=e=>{if(!e||e.nodeType===Node.DOCUMENT_NODE)return"";if(e.nodeType===Node.DOCUMENT_FRAGMENT_NODE)return"//";if(e.nodeType===Node.TEXT_NODE)return`text()[${n(e)}]`;if(e.nodeType===Node.COMMENT_NODE)return`comment()[${n(e)}]`;let l=(e.nodeName||"").toLowerCase();return`${l.includes(":")?`*[name()=\'${l}\']`:l}[${n(e)}]`},u=[],s=t;for(;s;){if(s.nodeType===Node.DOCUMENT_FRAGMENT_NODE){u.push("//"),s=s.host??null;continue}let e=d(s);e&&u.push(e),s=s.parentNode}u.reverse();let r="";for(let e of u)e==="//"?r=r?r.endsWith("/")?`${r}/`:`${r}//`:"//":r=r?r.endsWith("/")?`${r}${e}`:`${r}/${e}`:`/${e}`;return r||"/"}catch{return"/"}})(this)}function g(){try{return document.hasFocus()===!0}catch{return!1}}return E(b);})();\n  globalThis.__stagehandA11yScripts = __stagehandA11yScriptsFactory;\n}';
    a11yScriptSources = {
      "documentHasFocusStrict": "function h(){try{return document.hasFocus()===!0}catch{return!1}}",
      "getBoundingRectLite": "function f(){try{let r=this.getBoundingClientRect();return{left:Number(r?.left??0)||0,top:Number(r?.top??0)||0}}catch{return{left:0,top:0}}}",
      "getScrollOffsets": "function a(){try{let r=window.scrollX??window.pageXOffset??document.documentElement?.scrollLeft??0,s=window.scrollY??window.pageYOffset??document.documentElement?.scrollTop??0;return{sx:Number(r)||0,sy:Number(s)||0}}catch{return{sx:0,sy:0}}}",
      "nodeToAbsoluteXPath": 'function N(){return(s=>{try{let n=e=>{if(!e||!e.parentNode)return 1;let u=1,d=`${e.nodeType}:${(e.nodeName||"").toLowerCase()}`;for(let l=e.previousSibling;l;l=l.previousSibling)`${l.nodeType}:${(l.nodeName||"").toLowerCase()}`===d&&(u+=1);return u},i=e=>{if(!e||e.nodeType===Node.DOCUMENT_NODE)return"";if(e.nodeType===Node.DOCUMENT_FRAGMENT_NODE)return"//";if(e.nodeType===Node.TEXT_NODE)return`text()[${n(e)}]`;if(e.nodeType===Node.COMMENT_NODE)return`comment()[${n(e)}]`;let u=(e.nodeName||"").toLowerCase();return`${u.includes(":")?`*[name()=\'${u}\']`:u}[${n(e)}]`},c=[],o=s;for(;o;){if(o.nodeType===Node.DOCUMENT_FRAGMENT_NODE){c.push("//"),o=o.host??null;continue}let e=i(o);e&&c.push(e),o=o.parentNode}c.reverse();let t="";for(let e of c)e==="//"?t=t?t.endsWith("/")?`${t}/`:`${t}//`:"//":t=t?t.endsWith("/")?`${t}${e}`:`${t}/${e}`:`/${e}`;return t||"/"}catch{return"/"}})(this)}',
      "resolveDeepActiveElement": "function p(){try{return(s=>{let n=s.activeElement??null;for(;n&&n.shadowRoot&&n.shadowRoot.activeElement;)n=n.shadowRoot.activeElement;return n??null})(document)}catch{return null}}"
    };
    a11yScriptGlobalRefs = {
      "documentHasFocusStrict": "globalThis.__stagehandA11yScripts.documentHasFocusStrict",
      "getBoundingRectLite": "globalThis.__stagehandA11yScripts.getBoundingRectLite",
      "getScrollOffsets": "globalThis.__stagehandA11yScripts.getScrollOffsets",
      "nodeToAbsoluteXPath": "globalThis.__stagehandA11yScripts.nodeToAbsoluteXPath",
      "resolveDeepActiveElement": "globalThis.__stagehandA11yScripts.resolveDeepActiveElement"
    };
  }
});

// lib/v3/understudy/a11y/snapshot/xpathUtils.ts
function buildAbsoluteXPathFromChain(chain, leafSession, leafBackendNodeId) {
  return __async(this, null, function* () {
    let prefix = "";
    for (const step of chain) {
      const xp = yield absoluteXPathForBackendNode(
        step.parentSession,
        step.iframeBackendNodeId
      );
      if (!xp) continue;
      prefix = prefix ? prefixXPath(prefix, xp) : normalizeXPath(xp);
    }
    const leaf = yield absoluteXPathForBackendNode(
      leafSession,
      leafBackendNodeId
    );
    if (!leaf) return prefix || "/";
    return prefix ? prefixXPath(prefix, leaf) : normalizeXPath(leaf);
  });
}
function absoluteXPathForBackendNode(session, backendNodeId) {
  return __async(this, null, function* () {
    try {
      const { object } = yield session.send(
        "DOM.resolveNode",
        { backendNodeId }
      );
      const objectId = object == null ? void 0 : object.objectId;
      if (!objectId) return null;
      const { result } = yield session.send(
        "Runtime.callFunctionOn",
        {
          objectId,
          functionDeclaration: a11yScriptSources.nodeToAbsoluteXPath,
          returnByValue: true
        }
      );
      yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
      });
      return typeof (result == null ? void 0 : result.value) === "string" && result.value ? result.value : null;
    } catch (e2) {
      return null;
    }
  });
}
function prefixXPath(parentAbs, child) {
  const p = parentAbs === "/" ? "" : parentAbs.replace(/\/$/, "");
  if (!child || child === "/") return p || "/";
  if (child.startsWith("//"))
    return p ? `${p}//${child.slice(2)}` : `//${child.slice(2)}`;
  const c = child.replace(/^\//, "");
  return p ? `${p}/${c}` : `/${c}`;
}
function normalizeXPath(x2) {
  if (!x2) return "";
  let s2 = x2.trim().replace(/^xpath=/i, "");
  if (!s2.startsWith("/")) s2 = "/" + s2;
  if (s2.length > 1 && s2.endsWith("/")) s2 = s2.slice(0, -1);
  return s2;
}
function buildChildXPathSegments(kids) {
  var _a4;
  const segs = [];
  const ctr = {};
  for (const child of kids) {
    const tag = String(child.nodeName).toLowerCase();
    const key = `${child.nodeType}:${tag}`;
    const idx = ctr[key] = ((_a4 = ctr[key]) != null ? _a4 : 0) + 1;
    if (child.nodeType === 3) {
      segs.push(`text()[${idx}]`);
    } else if (child.nodeType === 8) {
      segs.push(`comment()[${idx}]`);
    } else {
      segs.push(
        tag.includes(":") ? `*[name()='${tag}'][${idx}]` : `${tag}[${idx}]`
      );
    }
  }
  return segs;
}
function joinXPath(base, step) {
  if (step === "//") {
    if (!base || base === "/") return "//";
    return base.endsWith("/") ? `${base}/` : `${base}//`;
  }
  if (!base || base === "/") return step ? `/${step}` : "/";
  if (base.endsWith("//")) return `${base}${step}`;
  if (!step) return base;
  return `${base}/${step}`;
}
var init_xpathUtils = __esm({
  "lib/v3/understudy/a11y/snapshot/xpathUtils.ts"() {
    init_a11yScripts_generated();
  }
});

// lib/v3/understudy/a11y/snapshot/focusSelectors.ts
function parseXPathToSteps(path8) {
  const s2 = path8.trim();
  let i2 = 0;
  const steps = [];
  while (i2 < s2.length) {
    let axis = "child";
    if (s2.startsWith("//", i2)) {
      axis = "desc";
      i2 += 2;
    } else if (s2[i2] === "/") {
      axis = "child";
      i2 += 1;
    }
    const start = i2;
    while (i2 < s2.length && s2[i2] !== "/") i2++;
    const raw = s2.slice(start, i2).trim();
    if (!raw) continue;
    const name = raw.replace(/\[\d+\]\s*$/u, "").toLowerCase();
    steps.push({ axis, raw, name });
  }
  return steps;
}
function buildXPathFromSteps(steps) {
  let out = "";
  for (const st of steps) {
    out += st.axis === "desc" ? "//" : "/";
    out += st.raw;
  }
  return out || "/";
}
function resolveFocusFrameAndTail(page, absoluteXPath, parentByFrame, rootId) {
  return __async(this, null, function* () {
    const steps = parseXPathToSteps(absoluteXPath);
    let ctxFrameId = rootId;
    let buf = [];
    let absPrefix = "";
    const flushIntoChild = () => __async(null, null, function* () {
      if (!buf.length) return;
      const selectorForIframe = buildXPathFromSteps(buf);
      const parentSess = page.getSessionForFrame(ctxFrameId);
      const objectId = yield resolveObjectIdForXPath(
        parentSess,
        selectorForIframe,
        ctxFrameId
      );
      if (!objectId)
        throw new StagehandIframeError(
          selectorForIframe,
          "Failed to resolve iframe element by XPath"
        );
      try {
        yield parentSess.send("DOM.enable").catch(() => {
        });
        const desc = yield parentSess.send(
          "DOM.describeNode",
          { objectId }
        );
        const iframeBackendNodeId = desc.node.backendNodeId;
        let childFrameId;
        for (const fid of listChildrenOf(parentByFrame, ctxFrameId)) {
          try {
            const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", { frameId: fid });
            if (backendNodeId === iframeBackendNodeId) {
              childFrameId = fid;
              break;
            }
          } catch (e2) {
            continue;
          }
        }
        if (!childFrameId)
          throw new StagehandIframeError(
            selectorForIframe,
            "Could not map iframe to child frameId"
          );
        absPrefix = prefixXPath(absPrefix || "/", selectorForIframe);
        ctxFrameId = childFrameId;
      } finally {
        yield parentSess.send("Runtime.releaseObject", { objectId }).catch(() => {
        });
      }
      buf = [];
    });
    for (const st of steps) {
      buf.push(st);
      if (IFRAME_STEP_RE.test(st.name)) {
        yield flushIntoChild();
      }
    }
    const tailXPath = buildXPathFromSteps(buf);
    return { targetFrameId: ctxFrameId, tailXPath, absPrefix };
  });
}
function resolveCssFocusFrameAndTail(page, rawSelector, parentByFrame, rootId) {
  return __async(this, null, function* () {
    var _a4;
    const parts = rawSelector.split(">>").map((s2) => s2.trim()).filter(Boolean);
    let ctxFrameId = rootId;
    const absPrefix = "";
    for (let i2 = 0; i2 < Math.max(0, parts.length - 1); i2++) {
      const parentSess = page.getSessionForFrame(ctxFrameId);
      const objectId = yield resolveObjectIdForCss(
        parentSess,
        parts[i2],
        ctxFrameId
      );
      if (!objectId)
        throw new StagehandIframeError(
          parts[i2],
          "Failed to resolve iframe via CSS hop"
        );
      try {
        yield parentSess.send("DOM.enable").catch(() => {
        });
        const desc = yield parentSess.send(
          "DOM.describeNode",
          { objectId }
        );
        const iframeBackendNodeId = desc.node.backendNodeId;
        let childFrameId;
        for (const fid of listChildrenOf(parentByFrame, ctxFrameId)) {
          try {
            const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", { frameId: fid });
            if (backendNodeId === iframeBackendNodeId) {
              childFrameId = fid;
              break;
            }
          } catch (e2) {
            continue;
          }
        }
        if (!childFrameId)
          throw new StagehandIframeError(
            parts[i2],
            "Could not map CSS iframe hop to child frameId"
          );
        ctxFrameId = childFrameId;
      } finally {
        yield parentSess.send("Runtime.releaseObject", { objectId }).catch(() => {
        });
      }
    }
    const tailSelector = (_a4 = parts[parts.length - 1]) != null ? _a4 : "*";
    return { targetFrameId: ctxFrameId, tailSelector, absPrefix };
  });
}
function resolveObjectIdForXPath(session, xpath, frameId) {
  return __async(this, null, function* () {
    var _a4;
    let contextId;
    try {
      if (frameId) {
        contextId = yield executionContexts.waitForMainWorld(session, frameId, 800).catch(
          () => {
            var _a5;
            return (_a5 = executionContexts.getMainWorld(session, frameId)) != null ? _a5 : void 0;
          }
        );
      }
    } catch (e2) {
      contextId = void 0;
    }
    const expr = buildLocatorInvocation("resolveXPathMainWorld", [
      JSON.stringify(xpath),
      "0"
    ]);
    const { result, exceptionDetails } = yield session.send("Runtime.evaluate", {
      expression: expr,
      returnByValue: false,
      contextId,
      awaitPromise: true
    });
    if (exceptionDetails) return null;
    return (_a4 = result == null ? void 0 : result.objectId) != null ? _a4 : null;
  });
}
function resolveObjectIdForCss(session, selector, frameId) {
  return __async(this, null, function* () {
    let contextId;
    try {
      if (frameId) {
        contextId = yield executionContexts.waitForMainWorld(session, frameId, 800).catch(
          () => {
            var _a4;
            return (_a4 = executionContexts.getMainWorld(session, frameId)) != null ? _a4 : void 0;
          }
        );
      }
    } catch (e2) {
      contextId = void 0;
    }
    const primaryExpr = buildLocatorInvocation("resolveCssSelector", [
      JSON.stringify(selector),
      "0"
    ]);
    const fallbackExpr = buildLocatorInvocation("resolveCssSelectorPierce", [
      JSON.stringify(selector),
      "0"
    ]);
    const evaluate = (expression) => __async(null, null, function* () {
      var _a4;
      const { result, exceptionDetails } = yield session.send("Runtime.evaluate", {
        expression,
        returnByValue: false,
        contextId,
        awaitPromise: true
      });
      if (exceptionDetails) return null;
      return (_a4 = result == null ? void 0 : result.objectId) != null ? _a4 : null;
    });
    const primary = yield evaluate(primaryExpr);
    if (primary) return primary;
    return evaluate(fallbackExpr);
  });
}
function listChildrenOf(parentByFrame, parentId) {
  const out = [];
  for (const [fid, p] of parentByFrame.entries()) {
    if (p === parentId) out.push(fid);
  }
  return out;
}
var IFRAME_STEP_RE;
var init_focusSelectors = __esm({
  "lib/v3/understudy/a11y/snapshot/focusSelectors.ts"() {
    init_executionContextRegistry();
    init_locatorInvocation();
    init_sdkErrors();
    init_xpathUtils();
    IFRAME_STEP_RE = /^iframe(?:\[\d+])?$/i;
  }
});

// lib/v3/understudy/a11y/snapshot/treeFormatUtils.ts
function formatTreeLine(node, level = 0) {
  var _a4, _b, _c;
  const indent = "  ".repeat(level);
  const labelId = (_a4 = node.encodedId) != null ? _a4 : node.nodeId;
  const label = `[${labelId}] ${node.role}${node.name ? `: ${cleanText(node.name)}` : ""}`;
  const kids = (_c = (_b = node.children) == null ? void 0 : _b.map((c) => formatTreeLine(c, level + 1)).join("\n")) != null ? _c : "";
  return kids ? `${indent}${label}
${kids}` : `${indent}${label}`;
}
function injectSubtrees(rootOutline, idToTree) {
  var _a4, _b;
  const out = [];
  const visited = /* @__PURE__ */ new Set();
  const stack = [{ lines: rootOutline.split("\n"), i: 0 }];
  while (stack.length) {
    const top = stack[stack.length - 1];
    if (top.i >= top.lines.length) {
      stack.pop();
      continue;
    }
    const raw = top.lines[top.i++];
    out.push(raw);
    const indent = (_b = (_a4 = raw.match(/^(\s*)/)) == null ? void 0 : _a4[1]) != null ? _b : "";
    const content = raw.slice(indent.length);
    const m2 = content.match(/^\[([^\]]+)]/);
    if (!m2) continue;
    const encId = m2[1];
    const childOutline = idToTree.get(encId);
    if (!childOutline || visited.has(encId)) continue;
    visited.add(encId);
    const fullyInjectedChild = injectSubtrees(childOutline, idToTree);
    out.push(indentBlock(fullyInjectedChild.trimEnd(), indent + "  "));
  }
  return out.join("\n");
}
function indentBlock(block, indent) {
  if (!block) return "";
  return block.split("\n").map((line) => line.length ? indent + line : indent + line).join("\n");
}
function diffCombinedTrees(prevTree, nextTree) {
  const prevSet = new Set(
    (prevTree || "").split("\n").map((l) => l.trim()).filter((l) => l.length > 0)
  );
  const nextLines = (nextTree || "").split("\n");
  const added = [];
  for (const line of nextLines) {
    const core = line.trim();
    if (!core) continue;
    if (!prevSet.has(core)) added.push(line);
  }
  if (added.length === 0) return "";
  let minIndent = Infinity;
  for (const l of added) {
    if (!l.trim()) continue;
    const m2 = l.match(/^\s*/);
    const indentLen = m2 ? m2[0].length : 0;
    if (indentLen < minIndent) minIndent = indentLen;
  }
  if (!isFinite(minIndent)) minIndent = 0;
  const out = added.map(
    (l) => l.length >= minIndent ? l.slice(minIndent) : l
  );
  return out.join("\n");
}
function cleanText(input) {
  const PUA_START = 57344;
  const PUA_END = 63743;
  const NBSP = /* @__PURE__ */ new Set([160, 8239, 8199, 65279]);
  let out = "";
  let prevSpace = false;
  for (let i2 = 0; i2 < input.length; i2++) {
    const code = input.charCodeAt(i2);
    if (code >= PUA_START && code <= PUA_END) continue;
    if (NBSP.has(code)) {
      if (!prevSpace) {
        out += " ";
        prevSpace = true;
      }
      continue;
    }
    out += input[i2];
    prevSpace = input[i2] === " ";
  }
  return out.trim();
}
function normaliseSpaces(s2) {
  let out = "";
  let inWs = false;
  for (let i2 = 0; i2 < s2.length; i2++) {
    const ch = s2[i2];
    const isWs = /\s/.test(ch);
    if (isWs) {
      if (!inWs) {
        out += " ";
        inWs = true;
      }
    } else {
      out += ch;
      inWs = false;
    }
  }
  return out;
}
var init_treeFormatUtils = __esm({
  "lib/v3/understudy/a11y/snapshot/treeFormatUtils.ts"() {
  }
});

// lib/v3/understudy/a11y/snapshot/a11yTree.ts
function a11yForFrame(session, frameId, opts) {
  return __async(this, null, function* () {
    var _a4, _b;
    yield session.send("Accessibility.enable").catch(() => {
    });
    yield session.send("Runtime.enable").catch(() => {
    });
    yield session.send("DOM.enable").catch(() => {
    });
    let nodes = [];
    try {
      const params = frameId ? { frameId } : {};
      ({ nodes } = yield session.send("Accessibility.getFullAXTree", params));
    } catch (e2) {
      const msg = String((_b = (_a4 = e2 == null ? void 0 : e2.message) != null ? _a4 : e2) != null ? _b : "");
      const isFrameScopeError = msg.includes("Frame with the given") || msg.includes("does not belong to the target") || msg.includes("is not found");
      if (!isFrameScopeError || !frameId) throw e2;
      ({ nodes } = yield session.send("Accessibility.getFullAXTree"));
    }
    const urlMap = {};
    for (const n of nodes) {
      const be = n.backendDOMNodeId;
      if (typeof be !== "number") continue;
      const url = extractUrlFromAXNode(n);
      if (!url) continue;
      const enc = opts.encode(be);
      urlMap[enc] = url;
    }
    let scopeApplied = false;
    const nodesForOutline = yield (() => __async(null, null, function* () {
      var _a5, _b2, _c;
      const sel = (_a5 = opts.focusSelector) == null ? void 0 : _a5.trim();
      if (!sel) return nodes;
      try {
        const looksLikeXPath = /^xpath=/i.test(sel) || sel.startsWith("/");
        const objectId = looksLikeXPath ? yield resolveObjectIdForXPath(session, sel, frameId) : yield resolveObjectIdForCss(session, sel, frameId);
        if (!objectId) return nodes;
        const desc = yield session.send(
          "DOM.describeNode",
          { objectId }
        );
        const be = (_b2 = desc.node) == null ? void 0 : _b2.backendNodeId;
        if (typeof be !== "number") return nodes;
        const target = nodes.find((n) => n.backendDOMNodeId === be);
        if (!target) return nodes;
        scopeApplied = true;
        const keep = /* @__PURE__ */ new Set([target.nodeId]);
        const queue = [target];
        while (queue.length) {
          const cur = queue.shift();
          for (const id of (_c = cur.childIds) != null ? _c : []) {
            if (keep.has(id)) continue;
            keep.add(id);
            const child = nodes.find((n) => n.nodeId === id);
            if (child) queue.push(child);
          }
        }
        return nodes.filter((n) => keep.has(n.nodeId)).map(
          (n) => n.nodeId === target.nodeId ? __spreadProps(__spreadValues({}, n), { parentId: void 0 }) : n
        );
      } catch (e2) {
        return nodes;
      }
    }))();
    const decorated = decorateRoles(nodesForOutline, opts);
    const { tree } = yield buildHierarchicalTree(decorated, opts);
    const simplified = tree.map((n) => formatTreeLine(n)).join("\n");
    return { outline: simplified.trimEnd(), urlMap, scopeApplied };
  });
}
function decorateRoles(nodes, opts) {
  const asRole = (n) => {
    var _a4, _b;
    return String((_b = (_a4 = n.role) == null ? void 0 : _a4.value) != null ? _b : "");
  };
  return nodes.map((n) => {
    var _a4, _b, _c;
    let encodedId;
    if (typeof n.backendDOMNodeId === "number") {
      try {
        encodedId = opts.encode(n.backendDOMNodeId);
      } catch (e2) {
      }
    }
    let role = asRole(n);
    const domIsScrollable = encodedId ? opts.scrollableMap[encodedId] === true : false;
    const tag = encodedId ? opts.tagNameMap[encodedId] : void 0;
    const isHtmlElement = tag === "html";
    if ((domIsScrollable || isHtmlElement) && tag !== "#document") {
      const tagLabel = tag && tag.startsWith("#") ? tag.slice(1) : tag;
      role = tagLabel ? `scrollable, ${tagLabel}` : `scrollable${role ? `, ${role}` : ""}`;
    }
    return {
      role,
      name: (_a4 = n.name) == null ? void 0 : _a4.value,
      description: (_b = n.description) == null ? void 0 : _b.value,
      value: (_c = n.value) == null ? void 0 : _c.value,
      nodeId: n.nodeId,
      backendDOMNodeId: n.backendDOMNodeId,
      parentId: n.parentId,
      childIds: n.childIds,
      encodedId
    };
  });
}
function buildHierarchicalTree(nodes, opts) {
  return __async(this, null, function* () {
    var _a4;
    const nodeMap = /* @__PURE__ */ new Map();
    for (const n of nodes) {
      const keep = !!(n.name && n.name.trim()) || !!(n.childIds && n.childIds.length) || !isStructural(n.role);
      if (!keep) continue;
      nodeMap.set(n.nodeId, __spreadValues({}, n));
    }
    for (const n of nodes) {
      if (!n.parentId) continue;
      const parent = nodeMap.get(n.parentId);
      const cur = nodeMap.get(n.nodeId);
      if (parent && cur) ((_a4 = parent.children) != null ? _a4 : parent.children = []).push(cur);
    }
    const roots = nodes.filter((n) => !n.parentId && nodeMap.has(n.nodeId)).map((n) => nodeMap.get(n.nodeId));
    const cleaned = (yield Promise.all(roots.map(pruneStructuralSafe))).filter(
      Boolean
    );
    return { tree: cleaned };
    function pruneStructuralSafe(node) {
      return __async(this, null, function* () {
        var _a5;
        if (+node.nodeId < 0) return null;
        const children = (_a5 = node.children) != null ? _a5 : [];
        if (!children.length) {
          return isStructural(node.role) ? null : node;
        }
        const cleanedKids = (yield Promise.all(children.map(pruneStructuralSafe))).filter(Boolean);
        const prunedStatic = removeRedundantStaticTextChildren(node, cleanedKids);
        if (isStructural(node.role)) {
          if (prunedStatic.length === 1) return prunedStatic[0];
          if (prunedStatic.length === 0) return null;
        }
        let newRole = node.role;
        if ((newRole === "generic" || newRole === "none") && node.encodedId) {
          const tagName = opts.tagNameMap[node.encodedId];
          if (tagName) newRole = tagName;
        }
        if (newRole === "combobox" && node.encodedId) {
          const tagName = opts.tagNameMap[node.encodedId];
          if (tagName === "select") newRole = "select";
        }
        return __spreadProps(__spreadValues({}, node), { role: newRole, children: prunedStatic });
      });
    }
  });
}
function isStructural(role) {
  const r2 = role == null ? void 0 : role.toLowerCase();
  return r2 === "generic" || r2 === "none" || r2 === "inlinetextbox";
}
function extractUrlFromAXNode(ax) {
  var _a4, _b;
  const props = (_a4 = ax.properties) != null ? _a4 : [];
  const urlProp = props.find((p) => p.name === "url");
  const value = (_b = urlProp == null ? void 0 : urlProp.value) == null ? void 0 : _b.value;
  return typeof value === "string" && value.trim() ? value.trim() : void 0;
}
function removeRedundantStaticTextChildren(parent, children) {
  if (!parent.name) return children;
  const parentNorm = normaliseSpaces(parent.name).trim();
  let combined = "";
  for (const c of children) {
    if (c.role === "StaticText" && c.name) {
      combined += normaliseSpaces(c.name).trim();
    }
  }
  if (combined === parentNorm) {
    return children.filter((c) => c.role !== "StaticText");
  }
  return children;
}
var init_a11yTree = __esm({
  "lib/v3/understudy/a11y/snapshot/a11yTree.ts"() {
    init_focusSelectors();
    init_treeFormatUtils();
  }
});

// lib/v3/understudy/a11y/snapshot/domTree.ts
function isCborStackError(message) {
  return message.includes("CBOR: stack limit exceeded");
}
function shouldExpandNode(node) {
  var _a4, _b, _c;
  const declaredChildren = (_a4 = node.childNodeCount) != null ? _a4 : 0;
  const realizedChildren = (_c = (_b = node.children) == null ? void 0 : _b.length) != null ? _c : 0;
  return declaredChildren > realizedChildren;
}
function mergeDomNodes(target, source) {
  var _a4, _b, _c, _d2;
  target.childNodeCount = (_a4 = source.childNodeCount) != null ? _a4 : target.childNodeCount;
  target.children = (_b = source.children) != null ? _b : target.children;
  target.shadowRoots = (_c = source.shadowRoots) != null ? _c : target.shadowRoots;
  target.contentDocument = (_d2 = source.contentDocument) != null ? _d2 : target.contentDocument;
}
function collectDomTraversalTargets(node) {
  const targets = [];
  if (node.children) targets.push(...node.children);
  if (node.shadowRoots) targets.push(...node.shadowRoots);
  if (node.contentDocument) targets.push(node.contentDocument);
  return targets;
}
function hydrateDomTree(session, root, pierce) {
  return __async(this, null, function* () {
    var _a4, _b;
    const stack = [root];
    const expandedNodeIds = /* @__PURE__ */ new Set();
    const expandedBackendIds = /* @__PURE__ */ new Set();
    while (stack.length) {
      const node = stack.pop();
      const nodeId = typeof node.nodeId === "number" && node.nodeId > 0 ? node.nodeId : void 0;
      const backendId = typeof node.backendNodeId === "number" && node.backendNodeId > 0 ? node.backendNodeId : void 0;
      const seenByNode = nodeId ? expandedNodeIds.has(nodeId) : false;
      const seenByBackend = !nodeId && backendId ? expandedBackendIds.has(backendId) : false;
      if (seenByNode || seenByBackend) continue;
      if (nodeId) expandedNodeIds.add(nodeId);
      else if (backendId) expandedBackendIds.add(backendId);
      const needsExpansion = shouldExpandNode(node);
      if (needsExpansion && (nodeId || backendId)) {
        const describeParamsBase = nodeId ? { nodeId } : { backendNodeId: backendId };
        let expanded = false;
        for (const depth of DESCRIBE_DEPTH_ATTEMPTS) {
          try {
            const described = yield session.send(
              "DOM.describeNode",
              __spreadProps(__spreadValues({}, describeParamsBase), {
                depth,
                pierce
              })
            );
            mergeDomNodes(node, described.node);
            if (!nodeId && described.node.nodeId && described.node.nodeId > 0) {
              node.nodeId = described.node.nodeId;
              expandedNodeIds.add(described.node.nodeId);
            }
            expanded = true;
            break;
          } catch (err) {
            const message = err instanceof Error ? err.message : String(err);
            if (isCborStackError(message)) {
              continue;
            }
            const identifier = (_a4 = nodeId != null ? nodeId : backendId) != null ? _a4 : "unknown";
            throw new StagehandDomProcessError(
              `Failed to expand DOM node ${identifier}: ${String(err)}`
            );
          }
        }
        if (!expanded) {
          const identifier = (_b = nodeId != null ? nodeId : backendId) != null ? _b : "unknown";
          throw new StagehandDomProcessError(
            `Unable to expand DOM node ${identifier} after describeNode depth retries`
          );
        }
      }
      for (const child of collectDomTraversalTargets(node)) {
        stack.push(child);
      }
    }
  });
}
function getDomTreeWithFallback(session, pierce) {
  return __async(this, null, function* () {
    let lastCborMessage = "";
    for (const depth of DOM_DEPTH_ATTEMPTS) {
      try {
        const { root } = yield session.send(
          "DOM.getDocument",
          { depth, pierce }
        );
        if (depth !== -1) {
          yield hydrateDomTree(session, root, pierce);
        }
        return root;
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        if (isCborStackError(message)) {
          lastCborMessage = message;
          continue;
        }
        throw err;
      }
    }
    throw new StagehandDomProcessError(
      lastCborMessage ? `CDP DOM.getDocument failed after adaptive depth retries: ${lastCborMessage}` : "CDP DOM.getDocument failed after adaptive depth retries."
    );
  });
}
function domMapsForSession(session, frameId, pierce, encode, attemptOwnerLookup = true) {
  return __async(this, null, function* () {
    var _a4, _b;
    yield session.send("DOM.enable").catch(() => {
    });
    const root = yield getDomTreeWithFallback(session, pierce);
    let startNode = root;
    if (attemptOwnerLookup) {
      try {
        const owner = yield session.send(
          "DOM.getFrameOwner",
          { frameId }
        );
        const ownerBackendId = owner.backendNodeId;
        if (typeof ownerBackendId === "number") {
          const ownerEl = findNodeByBackendId(root, ownerBackendId);
          if (ownerEl == null ? void 0 : ownerEl.contentDocument) {
            startNode = ownerEl.contentDocument;
          }
        }
      } catch (e2) {
      }
    }
    const tagNameMap = {};
    const xpathMap = {};
    const scrollableMap = {};
    const stack = [{ node: startNode, xpath: "" }];
    while (stack.length) {
      const { node, xpath } = stack.pop();
      if (node.backendNodeId) {
        const encId = encode(frameId, node.backendNodeId);
        tagNameMap[encId] = String(node.nodeName).toLowerCase();
        xpathMap[encId] = xpath || "/";
        const isScrollable = (node == null ? void 0 : node.isScrollable) === true;
        if (isScrollable) scrollableMap[encId] = true;
      }
      const kids = (_a4 = node.children) != null ? _a4 : [];
      if (kids.length) {
        const segs = buildChildXPathSegments(kids);
        for (let i2 = kids.length - 1; i2 >= 0; i2--) {
          const child = kids[i2];
          const step = segs[i2];
          stack.push({
            node: child,
            xpath: joinXPath(xpath, step)
          });
        }
      }
      for (const sr of (_b = node.shadowRoots) != null ? _b : []) {
        stack.push({
          node: sr,
          xpath: joinXPath(xpath, "//")
        });
      }
    }
    return { tagNameMap, xpathMap, scrollableMap };
  });
}
function buildSessionDomIndex(session, pierce) {
  return __async(this, null, function* () {
    var _a4, _b;
    yield session.send("DOM.enable").catch(() => {
    });
    const root = yield getDomTreeWithFallback(session, pierce);
    const absByBe = /* @__PURE__ */ new Map();
    const tagByBe = /* @__PURE__ */ new Map();
    const scrollByBe = /* @__PURE__ */ new Map();
    const docRootOf = /* @__PURE__ */ new Map();
    const contentDocRootByIframe = /* @__PURE__ */ new Map();
    const rootBe = root.backendNodeId;
    const stack = [{ node: root, xp: "/", docRootBe: rootBe }];
    while (stack.length) {
      const { node, xp, docRootBe } = stack.pop();
      if (node.backendNodeId) {
        absByBe.set(node.backendNodeId, xp || "/");
        tagByBe.set(node.backendNodeId, String(node.nodeName).toLowerCase());
        if ((node == null ? void 0 : node.isScrollable) === true) scrollByBe.set(node.backendNodeId, true);
        docRootOf.set(node.backendNodeId, docRootBe);
      }
      const kids = (_a4 = node.children) != null ? _a4 : [];
      if (kids.length) {
        const segs = buildChildXPathSegments(kids);
        for (let i2 = kids.length - 1; i2 >= 0; i2--) {
          const child = kids[i2];
          const step = segs[i2];
          stack.push({ node: child, xp: joinXPath(xp, step), docRootBe });
        }
      }
      for (const sr of (_b = node.shadowRoots) != null ? _b : []) {
        stack.push({ node: sr, xp: joinXPath(xp, "//"), docRootBe });
      }
      const cd = node.contentDocument;
      if (cd && typeof cd.backendNodeId === "number") {
        contentDocRootByIframe.set(node.backendNodeId, cd.backendNodeId);
        stack.push({ node: cd, xp, docRootBe: cd.backendNodeId });
      }
    }
    return {
      rootBackend: rootBe,
      absByBe,
      tagByBe,
      scrollByBe,
      docRootOf,
      contentDocRootByIframe
    };
  });
}
function relativizeXPath(baseAbs, nodeAbs) {
  const base = normalizeXPath(baseAbs);
  const abs = normalizeXPath(nodeAbs);
  if (abs === base) return "/";
  if (abs.startsWith(base)) {
    const tail = abs.slice(base.length);
    if (!tail) return "/";
    return tail.startsWith("/") || tail.startsWith("//") ? tail : `/${tail}`;
  }
  if (base === "/") return abs;
  return abs;
}
function findNodeByBackendId(root, backendNodeId) {
  const stack = [root];
  while (stack.length) {
    const n = stack.pop();
    if (n.backendNodeId === backendNodeId) return n;
    if (n.children) for (const c of n.children) stack.push(c);
    if (n.shadowRoots) for (const s2 of n.shadowRoots) stack.push(s2);
  }
  return void 0;
}
var DOM_DEPTH_ATTEMPTS, DESCRIBE_DEPTH_ATTEMPTS;
var init_domTree = __esm({
  "lib/v3/understudy/a11y/snapshot/domTree.ts"() {
    init_sdkErrors();
    init_xpathUtils();
    DOM_DEPTH_ATTEMPTS = [-1, 256, 128, 64, 32, 16, 8, 4, 2, 1];
    DESCRIBE_DEPTH_ATTEMPTS = [-1, 64, 32, 16, 8, 4, 2, 1];
  }
});

// lib/v3/understudy/a11y/snapshot/sessions.ts
function ownerSession(page, frameId) {
  return page.getSessionForFrame(frameId);
}
function parentSession(page, parentByFrame, frameId) {
  var _a4;
  const parentId = (_a4 = parentByFrame.get(frameId)) != null ? _a4 : null;
  if (!parentId) {
    return page.getSessionForFrame(frameId);
  }
  return page.getSessionForFrame(parentId);
}
var init_sessions = __esm({
  "lib/v3/understudy/a11y/snapshot/sessions.ts"() {
  }
});

// lib/v3/understudy/a11y/snapshot/capture.ts
function captureHybridSnapshot(page, options) {
  return __async(this, null, function* () {
    var _a4;
    const pierce = (_a4 = options == null ? void 0 : options.pierceShadow) != null ? _a4 : true;
    const context = buildFrameContext(page);
    const scopedSnapshot = yield tryScopedSnapshot(
      page,
      options,
      context,
      pierce
    );
    if (scopedSnapshot) return scopedSnapshot;
    const sessionToIndex = yield buildSessionIndexes(
      page,
      context.frames,
      pierce
    );
    const { perFrameMaps, perFrameOutlines } = yield collectPerFrameMaps(
      page,
      context,
      sessionToIndex,
      options,
      pierce
    );
    const { absPrefix, iframeHostEncByChild } = yield computeFramePrefixes(
      page,
      context,
      perFrameMaps
    );
    return mergeFramesIntoSnapshot(
      context,
      perFrameMaps,
      perFrameOutlines,
      absPrefix,
      iframeHostEncByChild
    );
  });
}
function buildFrameContext(page) {
  const rootId = page.mainFrameId();
  const frameTree = page.asProtocolFrameTree(rootId);
  const parentByFrame = /* @__PURE__ */ new Map();
  (function index(n, parent) {
    var _a4;
    parentByFrame.set(n.frame.id, parent);
    for (const c of (_a4 = n.childFrames) != null ? _a4 : []) index(c, n.frame.id);
  })(frameTree, null);
  const frames = page.listAllFrameIds();
  return { rootId, parentByFrame, frames };
}
function tryScopedSnapshot(page, options, context, pierce) {
  return __async(this, null, function* () {
    var _a4, _b;
    const requestedFocus = (_a4 = options == null ? void 0 : options.focusSelector) == null ? void 0 : _a4.trim();
    if (!requestedFocus) return null;
    const logScopeFallback = () => {
      var _a5;
      v3Logger({
        message: `Unable to narrow scope with selector. Falling back to using full DOM`,
        level: 1,
        auxiliary: {
          arguments: {
            value: `selector: ${(_a5 = options == null ? void 0 : options.focusSelector) == null ? void 0 : _a5.trim()}`,
            type: "string"
          }
        }
      });
    };
    try {
      let targetFrameId;
      let tailSelector;
      let absPrefix;
      const looksLikeXPath = /^xpath=/i.test(requestedFocus) || requestedFocus.startsWith("/");
      if (looksLikeXPath) {
        const focus = normalizeXPath(requestedFocus);
        const hit = yield resolveFocusFrameAndTail(
          page,
          focus,
          context.parentByFrame,
          context.rootId
        );
        targetFrameId = hit.targetFrameId;
        tailSelector = hit.tailXPath || void 0;
        absPrefix = hit.absPrefix;
      } else {
        const cssHit = yield resolveCssFocusFrameAndTail(
          page,
          requestedFocus,
          context.parentByFrame,
          context.rootId
        );
        targetFrameId = cssHit.targetFrameId;
        tailSelector = cssHit.tailSelector || void 0;
        absPrefix = cssHit.absPrefix;
      }
      const owningSess = ownerSession(page, targetFrameId);
      const parentId = context.parentByFrame.get(targetFrameId);
      const sameSessionAsParent = !!parentId && ownerSession(page, parentId) === ownerSession(page, targetFrameId);
      const { tagNameMap, xpathMap, scrollableMap } = yield domMapsForSession(
        owningSess,
        targetFrameId,
        pierce,
        (fid, be) => `${page.getOrdinal(fid)}-${be}`,
        sameSessionAsParent
      );
      const { outline, urlMap, scopeApplied } = yield a11yForFrame(
        owningSess,
        targetFrameId,
        {
          focusSelector: tailSelector || void 0,
          tagNameMap,
          experimental: (_b = options == null ? void 0 : options.experimental) != null ? _b : false,
          scrollableMap,
          encode: (backendNodeId) => `${page.getOrdinal(targetFrameId)}-${backendNodeId}`
        }
      );
      const scopedXpathMap = {};
      const abs = absPrefix != null ? absPrefix : "";
      const isRoot = !abs || abs === "/";
      if (isRoot) {
        Object.assign(scopedXpathMap, xpathMap);
      } else {
        for (const [encId, xp] of Object.entries(xpathMap)) {
          scopedXpathMap[encId] = prefixXPath(abs, xp);
        }
      }
      const scopedUrlMap = __spreadValues({}, urlMap);
      const snapshot = {
        combinedTree: outline,
        combinedXpathMap: scopedXpathMap,
        combinedUrlMap: scopedUrlMap,
        perFrame: [
          {
            frameId: targetFrameId,
            outline,
            xpathMap,
            urlMap
          }
        ]
      };
      if (scopeApplied) {
        return snapshot;
      }
      logScopeFallback();
    } catch (e2) {
      logScopeFallback();
    }
    return null;
  });
}
function buildSessionIndexes(page, frames, pierce) {
  return __async(this, null, function* () {
    var _a4;
    const sessionToIndex = /* @__PURE__ */ new Map();
    const sessionById = /* @__PURE__ */ new Map();
    for (const frameId of frames) {
      const sess = ownerSession(page, frameId);
      const sid = (_a4 = sess.id) != null ? _a4 : "root";
      if (!sessionById.has(sid)) sessionById.set(sid, sess);
    }
    for (const [sid, sess] of sessionById.entries()) {
      const idx = yield buildSessionDomIndex(sess, pierce);
      sessionToIndex.set(sid, idx);
    }
    return sessionToIndex;
  });
}
function collectPerFrameMaps(page, context, sessionToIndex, options, pierce) {
  return __async(this, null, function* () {
    var _a4, _b, _c;
    const perFrameMaps = /* @__PURE__ */ new Map();
    const perFrameOutlines = [];
    for (const frameId of context.frames) {
      const sess = ownerSession(page, frameId);
      const sid = (_a4 = sess.id) != null ? _a4 : "root";
      let idx = sessionToIndex.get(sid);
      if (!idx) {
        idx = yield buildSessionDomIndex(sess, pierce);
        sessionToIndex.set(sid, idx);
      }
      const parentId = context.parentByFrame.get(frameId);
      const sameSessionAsParent = !!parentId && ownerSession(page, parentId) === sess;
      let docRootBe = idx.rootBackend;
      if (sameSessionAsParent) {
        try {
          const { backendNodeId } = yield sess.send(
            "DOM.getFrameOwner",
            { frameId }
          );
          if (typeof backendNodeId === "number") {
            const cdBe = idx.contentDocRootByIframe.get(backendNodeId);
            if (typeof cdBe === "number") docRootBe = cdBe;
          }
        } catch (e2) {
        }
      }
      const tagNameMap = {};
      const xpathMap = {};
      const scrollableMap = {};
      const enc = (be) => `${page.getOrdinal(frameId)}-${be}`;
      const baseAbs = (_b = idx.absByBe.get(docRootBe)) != null ? _b : "/";
      for (const [be, nodeAbs] of idx.absByBe.entries()) {
        const nodeDocRoot = idx.docRootOf.get(be);
        if (nodeDocRoot !== docRootBe) continue;
        const rel = relativizeXPath(baseAbs, nodeAbs);
        const key = enc(be);
        xpathMap[key] = rel;
        const tag = idx.tagByBe.get(be);
        if (tag) tagNameMap[key] = tag;
        if (idx.scrollByBe.get(be)) scrollableMap[key] = true;
      }
      const { outline, urlMap } = yield a11yForFrame(sess, frameId, {
        experimental: (_c = options == null ? void 0 : options.experimental) != null ? _c : false,
        tagNameMap,
        scrollableMap,
        encode: (backendNodeId) => `${page.getOrdinal(frameId)}-${backendNodeId}`
      });
      perFrameOutlines.push({ frameId, outline });
      perFrameMaps.set(frameId, { tagNameMap, xpathMap, scrollableMap, urlMap });
    }
    return { perFrameMaps, perFrameOutlines };
  });
}
function computeFramePrefixes(page, context, perFrameMaps) {
  return __async(this, null, function* () {
    const absPrefix = /* @__PURE__ */ new Map();
    const iframeHostEncByChild = /* @__PURE__ */ new Map();
    absPrefix.set(context.rootId, "");
    const queue = [context.rootId];
    while (queue.length) {
      const parent = queue.shift();
      const parentAbs = absPrefix.get(parent);
      for (const child of context.frames) {
        if (context.parentByFrame.get(child) !== parent) continue;
        queue.push(child);
        const parentSess = parentSession(page, context.parentByFrame, child);
        const ownerBackendNodeId = yield (() => __async(null, null, function* () {
          try {
            const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", { frameId: child });
            return backendNodeId;
          } catch (e2) {
            return void 0;
          }
        }))();
        if (!ownerBackendNodeId) {
          absPrefix.set(child, parentAbs);
          continue;
        }
        const parentDom = perFrameMaps.get(parent);
        const iframeEnc = `${page.getOrdinal(parent)}-${ownerBackendNodeId}`;
        const iframeXPath = parentDom == null ? void 0 : parentDom.xpathMap[iframeEnc];
        const childAbs = iframeXPath ? prefixXPath(parentAbs || "/", iframeXPath) : parentAbs;
        absPrefix.set(child, childAbs);
        iframeHostEncByChild.set(child, iframeEnc);
      }
    }
    return { absPrefix, iframeHostEncByChild };
  });
}
function mergeFramesIntoSnapshot(context, perFrameMaps, perFrameOutlines, absPrefix, iframeHostEncByChild) {
  var _a4, _b, _c, _d2, _e;
  const combinedXpathMap = {};
  const combinedUrlMap = {};
  for (const frameId of context.frames) {
    const maps = perFrameMaps.get(frameId);
    if (!maps) continue;
    const abs = (_a4 = absPrefix.get(frameId)) != null ? _a4 : "";
    const isRoot = abs === "" || abs === "/";
    if (isRoot) {
      Object.assign(combinedXpathMap, maps.xpathMap);
      Object.assign(combinedUrlMap, maps.urlMap);
      continue;
    }
    for (const [encId, xp] of Object.entries(maps.xpathMap)) {
      combinedXpathMap[encId] = prefixXPath(abs, xp);
    }
    Object.assign(combinedUrlMap, maps.urlMap);
  }
  const idToTree = /* @__PURE__ */ new Map();
  for (const { frameId, outline } of perFrameOutlines) {
    const parentEnc = iframeHostEncByChild.get(frameId);
    if (parentEnc) idToTree.set(parentEnc, outline);
  }
  const rootOutline = (_e = (_d2 = (_b = perFrameOutlines.find((o) => o.frameId === context.rootId)) == null ? void 0 : _b.outline) != null ? _d2 : (_c = perFrameOutlines[0]) == null ? void 0 : _c.outline) != null ? _e : "";
  const combinedTree = injectSubtrees(rootOutline, idToTree);
  return {
    combinedTree,
    combinedXpathMap,
    combinedUrlMap,
    perFrame: perFrameOutlines.map(({ frameId, outline }) => {
      var _a5, _b2;
      const maps = perFrameMaps.get(frameId);
      return {
        frameId,
        outline,
        xpathMap: (_a5 = maps == null ? void 0 : maps.xpathMap) != null ? _a5 : {},
        urlMap: (_b2 = maps == null ? void 0 : maps.urlMap) != null ? _b2 : {}
      };
    })
  };
}
var init_capture = __esm({
  "lib/v3/understudy/a11y/snapshot/capture.ts"() {
    init_logger();
    init_a11yTree();
    init_focusSelectors();
    init_domTree();
    init_treeFormatUtils();
    init_sessions();
    init_xpathUtils();
  }
});

// lib/v3/understudy/a11yInvocation.ts
function buildA11yInvocation(name, args) {
  const invocation = `${a11yScriptGlobalRefs[name]}(${args.join(", ")})`;
  return `(() => { ${a11yScriptBootstrap}; return ${invocation}; })()`;
}
var init_a11yInvocation = __esm({
  "lib/v3/understudy/a11yInvocation.ts"() {
    init_a11yScripts_generated();
  }
});

// lib/v3/understudy/a11y/snapshot/activeElement.ts
function computeActiveElementXpath(page) {
  return __async(this, null, function* () {
    var _a4;
    const tree = page.getFullFrameTree();
    const parentByFrame = /* @__PURE__ */ new Map();
    (function index(n, parent) {
      var _a5;
      parentByFrame.set(n.frame.id, parent);
      for (const c of (_a5 = n.childFrames) != null ? _a5 : []) index(c, n.frame.id);
    })(tree, null);
    const frames = page.listAllFrameIds();
    let focusedFrameId = null;
    for (const fid of frames) {
      const sess = page.getSessionForFrame(fid);
      try {
        yield sess.send("Runtime.enable").catch(() => {
        });
        const ctxId = yield executionContexts.waitForMainWorld(sess, fid, 1e3).catch(() => {
        });
        const hasFocusExpr = buildA11yInvocation("documentHasFocusStrict", []);
        const evalParams = ctxId ? {
          contextId: ctxId,
          expression: hasFocusExpr,
          returnByValue: true
        } : { expression: hasFocusExpr, returnByValue: true };
        const { result } = yield sess.send(
          "Runtime.evaluate",
          evalParams
        );
        if ((result == null ? void 0 : result.value) === true) {
          focusedFrameId = fid;
          break;
        }
      } catch (e2) {
      }
    }
    if (!focusedFrameId) focusedFrameId = page.mainFrameId();
    const focusedSession = page.getSessionForFrame(focusedFrameId);
    let objectId;
    try {
      yield focusedSession.send("Runtime.enable").catch(() => {
      });
      const ctxId = yield executionContexts.waitForMainWorld(focusedSession, focusedFrameId, 1e3).catch(() => {
      });
      const activeExpr = buildA11yInvocation("resolveDeepActiveElement", []);
      const evalParams = ctxId ? {
        contextId: ctxId,
        expression: activeExpr,
        returnByValue: false
      } : { expression: activeExpr, returnByValue: false };
      const { result } = yield focusedSession.send(
        "Runtime.evaluate",
        evalParams
      );
      objectId = result == null ? void 0 : result.objectId;
    } catch (e2) {
      objectId = void 0;
    }
    if (!objectId) return null;
    const leafXPath = yield (() => __async(null, null, function* () {
      try {
        const { result } = yield focusedSession.send("Runtime.callFunctionOn", {
          objectId,
          functionDeclaration: a11yScriptSources.nodeToAbsoluteXPath,
          returnByValue: true
        });
        try {
          yield focusedSession.send("Runtime.releaseObject", { objectId });
        } catch (e2) {
        }
        const xp = (result == null ? void 0 : result.value) || "";
        return typeof xp === "string" && xp ? xp : null;
      } catch (e2) {
        try {
          yield focusedSession.send("Runtime.releaseObject", { objectId });
        } catch (e3) {
        }
        return null;
      }
    }))();
    if (!leafXPath) return null;
    let prefix = "";
    let cur = focusedFrameId;
    while (cur) {
      const parent = (_a4 = parentByFrame.get(cur)) != null ? _a4 : null;
      if (!parent) break;
      const parentSess = page.getSessionForFrame(parent);
      try {
        const { backendNodeId } = yield parentSess.send("DOM.getFrameOwner", { frameId: cur });
        if (typeof backendNodeId === "number") {
          const xp = yield absoluteXPathForBackendNode(parentSess, backendNodeId);
          if (xp) prefix = prefix ? prefixXPath(prefix, xp) : normalizeXPath(xp);
        }
      } catch (e2) {
      }
      cur = parent;
    }
    return prefix ? prefixXPath(prefix, leafXPath) : normalizeXPath(leafXPath);
  });
}
var init_activeElement = __esm({
  "lib/v3/understudy/a11y/snapshot/activeElement.ts"() {
    init_executionContextRegistry();
    init_a11yInvocation();
    init_a11yScripts_generated();
    init_xpathUtils();
  }
});

// lib/v3/understudy/a11y/snapshot/coordinateResolver.ts
function resolveXpathForLocation(page, x2, y) {
  return __async(this, null, function* () {
    var _a4, _b, _c, _d2, _e, _f, _g, _h;
    const tree = page.getFullFrameTree();
    const parentByFrame = /* @__PURE__ */ new Map();
    (function index(n, parent) {
      var _a5;
      parentByFrame.set(n.frame.id, parent);
      for (const c of (_a5 = n.childFrames) != null ? _a5 : []) index(c, n.frame.id);
    })(tree, null);
    const iframeChain = [];
    let curFrameId = page.mainFrameId();
    let curSession = page.getSessionForFrame(curFrameId);
    let curX = x2;
    let curY = y;
    for (let depth = 0; depth < 8; depth++) {
      try {
        yield curSession.send("DOM.enable").catch(() => {
        });
        let sx = 0;
        let sy = 0;
        try {
          yield curSession.send("Runtime.enable").catch(() => {
          });
          const ctxId = yield executionContexts.waitForMainWorld(curSession, curFrameId).catch(() => {
          });
          const scrollExpr = buildA11yInvocation("getScrollOffsets", []);
          const evalParams = ctxId ? {
            contextId: ctxId,
            expression: scrollExpr,
            returnByValue: true
          } : { expression: scrollExpr, returnByValue: true };
          const { result } = yield curSession.send("Runtime.evaluate", evalParams);
          sx = Number((_b = (_a4 = result == null ? void 0 : result.value) == null ? void 0 : _a4.sx) != null ? _b : 0);
          sy = Number((_d2 = (_c = result == null ? void 0 : result.value) == null ? void 0 : _c.sy) != null ? _d2 : 0);
        } catch (e2) {
        }
        const xi = Math.max(0, Math.floor(curX + sx));
        const yi = Math.max(0, Math.floor(curY + sy));
        let res;
        try {
          res = yield curSession.send("DOM.getNodeForLocation", {
            x: xi,
            y: yi,
            includeUserAgentShadowDOM: false,
            ignorePointerEventsNone: false
          });
        } catch (e2) {
          return null;
        }
        const be = res == null ? void 0 : res.backendNodeId;
        const reportedFrameId = res == null ? void 0 : res.frameId;
        if (typeof be === "number" && reportedFrameId && reportedFrameId !== curFrameId) {
          const abs = yield buildAbsoluteXPathFromChain(
            iframeChain,
            curSession,
            be
          );
          return abs ? { frameId: reportedFrameId, backendNodeId: be, absoluteXPath: abs } : null;
        }
        if (typeof be !== "number") return null;
        let matchedChild;
        for (const fid of listChildrenOf(parentByFrame, curFrameId)) {
          try {
            const { backendNodeId } = yield curSession.send("DOM.getFrameOwner", { frameId: fid });
            if (backendNodeId === be) {
              matchedChild = fid;
              break;
            }
          } catch (e2) {
            continue;
          }
        }
        if (!matchedChild) {
          const abs = yield buildAbsoluteXPathFromChain(
            iframeChain,
            curSession,
            be
          );
          return abs ? { frameId: curFrameId, backendNodeId: be, absoluteXPath: abs } : null;
        }
        iframeChain.push({
          parentSession: curSession,
          iframeBackendNodeId: be
        });
        let left = 0;
        let top = 0;
        try {
          const { object } = yield curSession.send("DOM.resolveNode", { backendNodeId: be });
          const objectId = object == null ? void 0 : object.objectId;
          if (objectId) {
            const { result } = yield curSession.send("Runtime.callFunctionOn", {
              objectId,
              functionDeclaration: a11yScriptSources.getBoundingRectLite,
              returnByValue: true
            });
            left = Number((_f = (_e = result == null ? void 0 : result.value) == null ? void 0 : _e.left) != null ? _f : 0);
            top = Number((_h = (_g = result == null ? void 0 : result.value) == null ? void 0 : _g.top) != null ? _h : 0);
            yield curSession.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        } catch (e2) {
        }
        curX = Math.max(0, curX - left);
        curY = Math.max(0, curY - top);
        curFrameId = matchedChild;
        curSession = page.getSessionForFrame(curFrameId);
      } catch (e2) {
        return null;
      }
    }
    return null;
  });
}
var init_coordinateResolver = __esm({
  "lib/v3/understudy/a11y/snapshot/coordinateResolver.ts"() {
    init_executionContextRegistry();
    init_a11yScripts_generated();
    init_a11yInvocation();
    init_focusSelectors();
    init_xpathUtils();
  }
});

// lib/v3/understudy/a11y/snapshot/index.ts
var init_snapshot = __esm({
  "lib/v3/understudy/a11y/snapshot/index.ts"() {
    init_capture();
    init_activeElement();
    init_treeFormatUtils();
    init_coordinateResolver();
  }
});

// lib/v3/understudy/selectorResolver.ts
var FrameSelectorResolver;
var init_selectorResolver = __esm({
  "lib/v3/understudy/selectorResolver.ts"() {
    init_locatorScripts_generated();
    init_logger();
    init_executionContextRegistry();
    FrameSelectorResolver = class {
      constructor(frame) {
        this.frame = frame;
      }
      static parseSelector(raw) {
        const trimmed = raw.trim();
        const isText = /^text=/i.test(trimmed);
        const looksLikeXPath = /^xpath=/i.test(trimmed) || trimmed.startsWith("/") || trimmed.startsWith("(");
        const isCssPrefixed = /^css=/i.test(trimmed);
        if (isText) {
          let value = trimmed.replace(/^text=/i, "").trim();
          if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
            value = value.slice(1, -1);
          }
          return { kind: "text", value };
        }
        if (looksLikeXPath) {
          const value = trimmed.replace(/^xpath=/i, "");
          return { kind: "xpath", value };
        }
        let selector = isCssPrefixed ? trimmed.replace(/^css=/i, "") : trimmed;
        if (selector.includes(">>")) {
          selector = selector.split(">>").map((piece) => piece.trim()).filter(Boolean).join(" ");
        }
        return { kind: "css", value: selector };
      }
      resolveFirst(query) {
        return __async(this, null, function* () {
          return this.resolveAtIndex(query, 0);
        });
      }
      resolveAll(_0) {
        return __async(this, arguments, function* (query, { limit = Infinity } = {}) {
          if (limit <= 0) return [];
          switch (query.kind) {
            case "css":
              return this.resolveCss(query.value, limit);
            case "text":
              return this.resolveText(query.value, limit);
            case "xpath":
              return this.resolveXPath(query.value, limit);
            default:
              return [];
          }
        });
      }
      count(query) {
        return __async(this, null, function* () {
          switch (query.kind) {
            case "css":
              return this.countCss(query.value);
            case "text":
              return this.countText(query.value);
            case "xpath":
              return this.countXPath(query.value);
            default:
              return 0;
          }
        });
      }
      resolveAtIndex(query, index) {
        return __async(this, null, function* () {
          var _a4;
          if (index < 0 || !Number.isFinite(index)) return null;
          const results = yield this.resolveAll(query, { limit: index + 1 });
          return (_a4 = results[index]) != null ? _a4 : null;
        });
      }
      buildLocatorInvocation(name, args) {
        const call = `${locatorScriptGlobalRefs[name]}(${args.join(", ")})`;
        return `(() => { ${locatorScriptBootstrap}; return ${call}; })()`;
      }
      resolveCss(selector, limit) {
        return __async(this, null, function* () {
          if (limit <= 0) return [];
          const session = this.frame.session;
          const { executionContextId } = yield session.send("Page.createIsolatedWorld", {
            frameId: this.frame.frameId,
            worldName: "v3-world"
          });
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          const results = [];
          let loggedFallback = false;
          for (let index = 0; index < limit; index += 1) {
            const primaryExpr = this.buildLocatorInvocation("resolveCssSelector", [
              JSON.stringify(selector),
              String(index)
            ]);
            const primary = yield this.evaluateElement(
              primaryExpr,
              executionContextId
            );
            if (primary) {
              results.push(primary);
              continue;
            }
            if (!loggedFallback) {
              v3Logger({
                category: "locator",
                message: "css pierce-fallback",
                level: 2,
                auxiliary: {
                  frameId: { value: String(this.frame.frameId), type: "string" },
                  selector: { value: selector, type: "string" }
                }
              });
              loggedFallback = true;
            }
            const fallbackExpr = this.buildLocatorInvocation(
              "resolveCssSelectorPierce",
              [JSON.stringify(selector), String(index)]
            );
            const fallback = yield this.evaluateElement(fallbackExpr, ctxId);
            if (fallback) {
              results.push(fallback);
              continue;
            }
            break;
          }
          return results;
        });
      }
      resolveText(value, limit) {
        return __async(this, null, function* () {
          if (limit <= 0) return [];
          const session = this.frame.session;
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          const results = [];
          for (let index = 0; index < limit; index += 1) {
            const expr = this.buildLocatorInvocation("resolveTextSelector", [
              JSON.stringify(value),
              String(index)
            ]);
            const resolved = yield this.evaluateElement(expr, ctxId);
            if (!resolved) break;
            results.push(resolved);
          }
          return results;
        });
      }
      resolveXPath(value, limit) {
        return __async(this, null, function* () {
          if (limit <= 0) return [];
          const session = this.frame.session;
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          v3Logger({
            category: "locator",
            message: "xpath main-world",
            level: 2,
            auxiliary: {
              frameId: { value: String(this.frame.frameId), type: "string" },
              xp: { value, type: "string" },
              ctxId: { value: String(ctxId), type: "string" }
            }
          });
          const results = [];
          for (let index = 0; index < limit; index += 1) {
            const expr = this.buildLocatorInvocation("resolveXPathMainWorld", [
              JSON.stringify(value),
              String(index)
            ]);
            const resolved = yield this.evaluateElement(expr, ctxId);
            if (!resolved) break;
            results.push(resolved);
          }
          return results;
        });
      }
      countCss(selector) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { executionContextId } = yield session.send("Page.createIsolatedWorld", {
            frameId: this.frame.frameId,
            worldName: "v3-world"
          });
          const primaryExpr = this.buildLocatorInvocation("countCssMatchesPrimary", [
            JSON.stringify(selector)
          ]);
          const primary = yield this.evaluateCount(primaryExpr, executionContextId);
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          const fallbackExpr = this.buildLocatorInvocation("countCssMatchesPierce", [
            JSON.stringify(selector)
          ]);
          const fallback = yield this.evaluateCount(fallbackExpr, ctxId);
          return Math.max(primary, fallback);
        });
      }
      countText(value) {
        return __async(this, null, function* () {
          var _a4, _b, _c, _d2, _e, _f;
          const session = this.frame.session;
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          const expr = this.buildLocatorInvocation("countTextMatches", [
            JSON.stringify(value)
          ]);
          try {
            const evalRes = yield session.send(
              "Runtime.evaluate",
              {
                expression: expr,
                contextId: ctxId,
                returnByValue: true,
                awaitPromise: true
              }
            );
            if (evalRes.exceptionDetails) {
              const details = evalRes.exceptionDetails;
              v3Logger({
                category: "locator",
                message: "count text evaluate exception",
                level: 0,
                auxiliary: {
                  frameId: { value: String(this.frame.frameId), type: "string" },
                  selector: { value, type: "string" },
                  exception: {
                    value: (_e = details.text) != null ? _e : String(
                      (_d2 = (_c = (_a4 = details.exception) == null ? void 0 : _a4.description) != null ? _c : (_b = details.exception) == null ? void 0 : _b.value) != null ? _d2 : ""
                    ),
                    type: "string"
                  }
                }
              });
              return 0;
            }
            const data = (_f = evalRes.result.value) != null ? _f : {};
            const num = typeof data.count === "number" ? data.count : Number(data.count);
            if (!Number.isFinite(num)) return 0;
            return Math.max(0, Math.floor(num));
          } catch (e2) {
            return 0;
          }
        });
      }
      countXPath(value) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const ctxId = yield executionContexts.waitForMainWorld(
            session,
            this.frame.frameId,
            1e3
          );
          const expr = this.buildLocatorInvocation("countXPathMatchesMainWorld", [
            JSON.stringify(value)
          ]);
          try {
            const evalRes = yield session.send(
              "Runtime.evaluate",
              {
                expression: expr,
                contextId: ctxId,
                returnByValue: true,
                awaitPromise: true
              }
            );
            if (evalRes.exceptionDetails) {
              return 0;
            }
            const num = typeof evalRes.result.value === "number" ? evalRes.result.value : Number(evalRes.result.value);
            if (!Number.isFinite(num)) return 0;
            return Math.max(0, Math.floor(num));
          } catch (e2) {
            return 0;
          }
        });
      }
      resolveFromObjectId(objectId) {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          let nodeId = null;
          try {
            const rn = yield session.send(
              "DOM.requestNode",
              { objectId }
            );
            nodeId = (_a4 = rn.nodeId) != null ? _a4 : null;
          } catch (e2) {
            nodeId = null;
          }
          return { objectId, nodeId };
        });
      }
      evaluateCount(expression, contextId) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          try {
            const evalRes = yield session.send(
              "Runtime.evaluate",
              {
                expression,
                contextId,
                returnByValue: true,
                awaitPromise: true
              }
            );
            if (evalRes.exceptionDetails) {
              return 0;
            }
            const value = evalRes.result.value;
            const num = typeof value === "number" ? value : Number(value);
            if (!Number.isFinite(num)) return 0;
            return Math.max(0, Math.floor(num));
          } catch (e2) {
            return 0;
          }
        });
      }
      evaluateElement(expression, contextId) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          try {
            const evalRes = yield session.send(
              "Runtime.evaluate",
              {
                expression,
                contextId,
                returnByValue: false,
                awaitPromise: true
              }
            );
            if (evalRes.exceptionDetails || !evalRes.result.objectId) {
              return null;
            }
            return this.resolveFromObjectId(evalRes.result.objectId);
          } catch (e2) {
            return null;
          }
        });
      }
    };
  }
});

// lib/v3/understudy/fileUploadUtils.ts
function normalizeInputFiles(_0) {
  return __async(this, arguments, function* (files, opts = {}) {
    var _a4;
    if (files === null || files === void 0) return [];
    const flattened = Array.isArray(files) ? files : [files];
    if (!flattened.length) return [];
    const baseDir = (_a4 = opts.baseDir) != null ? _a4 : process.cwd();
    const normalized = [];
    for (const entry of flattened) {
      if (typeof entry === "string") {
        const absolutePath = import_path3.default.isAbsolute(entry) ? entry : import_path3.default.resolve(baseDir, entry);
        const stat2 = yield statFile(absolutePath);
        if (!stat2.isFile()) {
          throw new StagehandInvalidArgumentError(
            `setInputFiles(): expected a file but received directory or special entry at ${absolutePath}`
          );
        }
        const buffer = yield import_fs3.promises.readFile(absolutePath);
        normalized.push({
          name: import_path3.default.basename(absolutePath) || "upload.bin",
          mimeType: DEFAULT_MIME_TYPE,
          buffer,
          lastModified: stat2.mtimeMs || Date.now(),
          absolutePath
        });
        continue;
      }
      if (entry && typeof entry === "object" && "buffer" in entry) {
        const payload = entry;
        const buffer = toBuffer(payload.buffer);
        normalized.push({
          name: payload.name || "upload.bin",
          mimeType: payload.mimeType || DEFAULT_MIME_TYPE,
          buffer,
          lastModified: typeof payload.lastModified === "number" ? payload.lastModified : Date.now()
        });
        continue;
      }
      throw new StagehandInvalidArgumentError(
        "setInputFiles(): expected file path(s) or payload object(s)"
      );
    }
    return normalized;
  });
}
function statFile(absolutePath) {
  return __async(this, null, function* () {
    try {
      return yield import_fs3.promises.stat(absolutePath);
    } catch (error) {
      const code = error == null ? void 0 : error.code;
      if (code === "ENOENT") {
        throw new StagehandInvalidArgumentError(
          `setInputFiles(): file not found at ${absolutePath}`
        );
      }
      throw error;
    }
  });
}
function toBuffer(data) {
  if (import_buffer.Buffer.isBuffer(data)) return data;
  if (data instanceof Uint8Array) return import_buffer.Buffer.from(data);
  if (typeof data === "string") return import_buffer.Buffer.from(data);
  if (data instanceof ArrayBuffer) return import_buffer.Buffer.from(new Uint8Array(data));
  throw new StagehandInvalidArgumentError(
    "Unsupported file payload buffer type"
  );
}
var import_fs3, import_path3, import_buffer, DEFAULT_MIME_TYPE;
var init_fileUploadUtils = __esm({
  "lib/v3/understudy/fileUploadUtils.ts"() {
    import_fs3 = require("fs");
    import_path3 = __toESM(require("path"));
    import_buffer = require("buffer");
    init_sdkErrors();
    DEFAULT_MIME_TYPE = "application/octet-stream";
  }
});

// lib/v3/understudy/locator.ts
var fs4, os, path4, MAX_REMOTE_UPLOAD_BYTES, Locator;
var init_locator = __esm({
  "lib/v3/understudy/locator.ts"() {
    fs4 = __toESM(require("fs"));
    os = __toESM(require("os"));
    path4 = __toESM(require("path"));
    init_locatorScripts_generated();
    init_selectorResolver();
    init_sdkErrors();
    init_fileUploadUtils();
    MAX_REMOTE_UPLOAD_BYTES = 50 * 1024 * 1024;
    Locator = class _Locator {
      constructor(frame, selector, options, nthIndex = 0) {
        this.frame = frame;
        this.selector = selector;
        this.options = options;
        this.selectorResolver = new FrameSelectorResolver(this.frame);
        this.selectorQuery = FrameSelectorResolver.parseSelector(selector);
        this.nthIndex = Math.max(
          0,
          Math.floor(Number.isFinite(nthIndex) ? nthIndex : 0)
        );
      }
      /** Return the owning Frame for this locator (typed accessor, no private access). */
      getFrame() {
        return this.frame;
      }
      /**
       * Set files on an <input type="file"> element.
       *
       * Mirrors Playwright's Locator.setInputFiles basics:
       * - Accepts file path(s) or payload object(s) { name, mimeType, buffer }.
       * - Uses CDP DOM.setFileInputFiles under the hood.
       * - Besteffort dispatches change/input via CDP (Chrome does by default).
       * - Passing an empty array clears the selection.
       */
      setInputFiles(files) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          const tempFiles = [];
          try {
            try {
              const res = yield session.send(
                "Runtime.callFunctionOn",
                {
                  objectId,
                  functionDeclaration: locatorScriptSources.ensureFileInputElement,
                  returnByValue: true
                }
              );
              const ok = Boolean(res.result.value);
              if (!ok)
                throw new StagehandInvalidArgumentError(
                  'Target is not an <input type="file"> element'
                );
            } catch (e2) {
              throw new StagehandInvalidArgumentError(
                e2 instanceof Error ? e2.message : "Unable to verify file input element"
              );
            }
            const normalized = yield normalizeInputFiles(files);
            if (!normalized.length) {
              yield session.send("DOM.setFileInputFiles", {
                objectId,
                files: []
              });
              return;
            }
            if (this.frame.isBrowserRemote()) {
              yield this.assignFilesViaPayloadInjection(objectId, normalized);
              return;
            }
            const filePaths = [];
            for (const payload of normalized) {
              if (payload.absolutePath) {
                filePaths.push(payload.absolutePath);
                continue;
              }
              const ext = path4.extname(payload.name);
              const tmp = path4.join(
                os.tmpdir(),
                `stagehand-upload-${Date.now()}-${Math.random().toString(36).slice(2)}${ext}`
              );
              yield fs4.promises.writeFile(tmp, payload.buffer);
              tempFiles.push(tmp);
              filePaths.push(tmp);
            }
            yield session.send("DOM.setFileInputFiles", {
              objectId,
              files: filePaths
            });
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
            for (const p of tempFiles) {
              try {
                yield fs4.promises.unlink(p);
              } catch (e2) {
              }
            }
          }
        });
      }
      /**
       * Remote browser fallback: build File objects inside the page and attach them via JS.
       *
       * When Stagehand is driving a browser that cannot see the local filesystem (Browserbase,
       * remote CDP, etc.), CDP's DOM.setFileInputFiles would fail because Chrome can't reach
       * our temp files. Instead we base64-encode the payloads, send them into the page, and
       * let a DOM helper create File objects + dispatch change/input events.
       */
      assignFilesViaPayloadInjection(objectId, files) {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          for (const payload of files) {
            if (payload.buffer.length > MAX_REMOTE_UPLOAD_BYTES) {
              throw new StagehandInvalidArgumentError(
                `setInputFiles(): file "${payload.name}" is larger than the 50MB limit for remote uploads`
              );
            }
          }
          const serialized = files.map((payload) => ({
            name: payload.name,
            mimeType: payload.mimeType,
            lastModified: payload.lastModified,
            base64: payload.buffer.toString("base64")
          }));
          const res = yield session.send(
            "Runtime.callFunctionOn",
            {
              objectId,
              functionDeclaration: locatorScriptSources.assignFilePayloadsToInputElement,
              arguments: [
                {
                  value: serialized
                }
              ],
              returnByValue: true
            }
          );
          const ok = Boolean((_a4 = res.result) == null ? void 0 : _a4.value);
          if (!ok) {
            throw new StagehandInvalidArgumentError(
              "Unable to assign file payloads to remote input element"
            );
          }
        });
      }
      /**
       * Return the DOM backendNodeId for this locator's target element.
       * Useful for identity comparisons without needing element handles.
       */
      backendNodeId() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            yield session.send("DOM.enable").catch(() => {
            });
            const { node } = yield session.send(
              "DOM.describeNode",
              { objectId }
            );
            return node.backendNodeId;
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /** Return how many nodes the current selector resolves to. */
      count() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          yield session.send("Runtime.enable");
          yield session.send("DOM.enable");
          return this.selectorResolver.count(this.selectorQuery);
        });
      }
      /**
       * Return the center of the element's bounding box in the owning frame's viewport
       * (CSS pixels), rounded to integers. Scrolls into view best-effort.
       */
      centroid() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            yield session.send("DOM.scrollIntoViewIfNeeded", { objectId }).catch(() => {
            });
            const box = yield session.send(
              "DOM.getBoxModel",
              { objectId }
            );
            if (!box.model) throw new ElementNotVisibleError(this.selector);
            const { cx, cy } = this.centerFromBoxContent(box.model.content);
            return { x: Math.round(cx), y: Math.round(cy) };
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /**
       * Highlight the element's bounding box using the CDP Overlay domain.
       * - Scrolls element into view best-effort.
       * - Shows a semi-transparent overlay briefly, then hides it.
       */
      highlight(options) {
        return __async(this, null, function* () {
          var _a4, _b, _c;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          const duration = Math.max(0, (_a4 = options == null ? void 0 : options.durationMs) != null ? _a4 : 800);
          const borderColor = (_b = options == null ? void 0 : options.borderColor) != null ? _b : { r: 255, g: 0, b: 0, a: 0.9 };
          const contentColor = (_c = options == null ? void 0 : options.contentColor) != null ? _c : { r: 255, g: 200, b: 0, a: 0.2 };
          try {
            yield session.send("Overlay.enable").catch(() => {
            });
            yield session.send("DOM.scrollIntoViewIfNeeded", { objectId }).catch(() => {
            });
            yield session.send("DOM.enable").catch(() => {
            });
            let backendNodeId;
            try {
              const { node } = yield session.send(
                "DOM.describeNode",
                { objectId }
              );
              backendNodeId = node.backendNodeId;
            } catch (e2) {
              backendNodeId = void 0;
            }
            const highlightConfig = {
              showInfo: false,
              showStyles: false,
              showRulers: false,
              showExtensionLines: false,
              borderColor,
              contentColor
            };
            const highlightOnce = () => __async(this, null, function* () {
              yield session.send("Overlay.highlightNode", __spreadProps(__spreadValues({}, backendNodeId ? { backendNodeId } : { objectId }), {
                highlightConfig
              }));
            });
            yield highlightOnce();
            if (duration > 0) {
              const start = Date.now();
              const tick = Math.min(300, Math.max(100, Math.floor(duration / 50)));
              while (Date.now() - start < duration) {
                yield new Promise((r2) => setTimeout(r2, tick));
                try {
                  yield highlightOnce();
                } catch (e2) {
                }
              }
              yield session.send("Overlay.hideHighlight").catch(() => {
              });
            }
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /**
       * Move the mouse cursor to the element's visual center without clicking.
       * - Scrolls into view best-effort, resolves geometry, then dispatches a mouse move.
       */
      hover() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            yield session.send("DOM.scrollIntoViewIfNeeded", { objectId }).catch(() => {
            });
            const box = yield session.send(
              "DOM.getBoxModel",
              { objectId }
            );
            if (!box.model) throw new ElementNotVisibleError(this.selector);
            const { cx, cy } = this.centerFromBoxContent(box.model.content);
            yield session.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              x: cx,
              y: cy,
              button: "none"
            });
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /**
       * Click the element at its visual center.
       * Steps:
       *  1) Resolve selector to { objectId } in the frame world.
       *  2) Scroll into view via `DOM.scrollIntoViewIfNeeded({ objectId })`.
       *  3) Read geometry via `DOM.getBoxModel({ objectId })`  compute a center point.
       *  4) Synthesize mouse press + release via `Input.dispatchMouseEvent`.
       */
      click(options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          const button = (_a4 = options == null ? void 0 : options.button) != null ? _a4 : "left";
          const clickCount = (_b = options == null ? void 0 : options.clickCount) != null ? _b : 1;
          try {
            yield session.send("DOM.scrollIntoViewIfNeeded", { objectId });
            const box = yield session.send(
              "DOM.getBoxModel",
              { objectId }
            );
            if (!box.model) throw new ElementNotVisibleError(this.selector);
            const { cx, cy } = this.centerFromBoxContent(box.model.content);
            yield session.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              x: cx,
              y: cy,
              button: "none"
            });
            for (let i2 = 1; i2 <= clickCount; i2++) {
              yield session.send("Input.dispatchMouseEvent", {
                type: "mousePressed",
                x: cx,
                y: cy,
                button,
                clickCount: i2
              });
              yield session.send("Input.dispatchMouseEvent", {
                type: "mouseReleased",
                x: cx,
                y: cy,
                button,
                clickCount: i2
              });
            }
          } finally {
            try {
              yield session.send("Runtime.releaseObject", { objectId });
            } catch (e2) {
            }
          }
        });
      }
      /**
       * Dispatch a DOM 'click' MouseEvent on the element itself.
       * - Does not synthesize real pointer input; directly dispatches an event.
       * - Useful for elements that rely on click handlers without needing hit-testing.
       */
      sendClickEvent(options) {
        return __async(this, null, function* () {
          var _a4, _b, _c, _d2;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          const bubbles = (_a4 = options == null ? void 0 : options.bubbles) != null ? _a4 : true;
          const cancelable = (_b = options == null ? void 0 : options.cancelable) != null ? _b : true;
          const composed = (_c = options == null ? void 0 : options.composed) != null ? _c : true;
          const detail = (_d2 = options == null ? void 0 : options.detail) != null ? _d2 : 1;
          try {
            yield session.send("DOM.scrollIntoViewIfNeeded", { objectId }).catch(() => {
            });
            yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.dispatchDomClick,
                arguments: [
                  {
                    value: { bubbles, cancelable, composed, detail }
                  }
                ],
                returnByValue: true
              }
            );
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /**
       * Scroll the element vertically to a given percentage (0100).
       * - If the element is <html> or <body>, scrolls the window/document.
       * - Otherwise, scrolls the element itself via element.scrollTo.
       */
      scrollTo(percent) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.scrollElementToPercent,
                arguments: [{ value: percent }],
                returnByValue: true
              }
            );
          } finally {
            yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /**
       * Fill an input/textarea/contenteditable element.
       * Mirrors Playwright semantics: the DOM helper either applies the native
       * value setter (for special input types) or asks us to type text via the CDP
       * Input domain after focusing/selecting.
       */
      fill(value) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          let releaseNeeded = true;
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.fillElementValue,
                arguments: [{ value }],
                returnByValue: true
              }
            );
            const result = res.result.value;
            const status = typeof result === "object" && result ? result.status : void 0;
            if (status === "done") {
              return;
            }
            if (status === "needsinput") {
              yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
              });
              releaseNeeded = false;
              const valueToType = typeof (result == null ? void 0 : result.value) === "string" ? result.value : value;
              let prepared = false;
              try {
                const { objectId: prepObjectId } = yield this.resolveNode();
                try {
                  const prepRes = yield session.send(
                    "Runtime.callFunctionOn",
                    {
                      objectId: prepObjectId,
                      functionDeclaration: locatorScriptSources.prepareElementForTyping,
                      returnByValue: true
                    }
                  );
                  prepared = Boolean(prepRes.result.value);
                } finally {
                  yield session.send("Runtime.releaseObject", { objectId: prepObjectId }).catch(() => {
                  });
                }
              } catch (e2) {
              }
              if (!prepared && valueToType.length > 0) {
                yield this.type(valueToType);
                return;
              }
              if (valueToType.length === 0) {
                yield session.send("Input.dispatchKeyEvent", {
                  type: "keyDown",
                  key: "Backspace",
                  code: "Backspace",
                  windowsVirtualKeyCode: 8,
                  nativeVirtualKeyCode: 8
                });
                yield session.send("Input.dispatchKeyEvent", {
                  type: "keyUp",
                  key: "Backspace",
                  code: "Backspace",
                  windowsVirtualKeyCode: 8,
                  nativeVirtualKeyCode: 8
                });
              } else {
                yield session.send("Input.insertText", { text: valueToType });
              }
              return;
            }
            if (status === "error") {
              const reason = typeof (result == null ? void 0 : result.reason) === "string" && result.reason.length > 0 ? result.reason : "Failed to fill element";
              throw new StagehandInvalidArgumentError(
                `Failed to fill element (${reason})`
              );
            }
            if (!status) {
              yield this.type(value);
            }
          } finally {
            if (releaseNeeded) {
              yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
              });
            }
          }
        });
      }
      /**
       * Type text into the element (focuses first).
       * - Focus via element.focus() in page JS (no DOM.focus(nodeId)).
       * - If no delay, uses `Input.insertText` for efficiency.
       * - With delay, synthesizes `keyDown`/`keyUp` per character.
       */
      type(text, options) {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.focusElement,
                returnByValue: true
              }
            );
            if (!(options == null ? void 0 : options.delay)) {
              yield session.send("Input.insertText", { text });
              return;
            }
            for (const ch of text) {
              yield session.send("Input.dispatchKeyEvent", {
                type: "keyDown",
                text: ch,
                key: ch
              });
              yield session.send("Input.dispatchKeyEvent", {
                type: "keyUp",
                text: ch,
                key: ch
              });
              yield new Promise((r2) => setTimeout(r2, options.delay));
            }
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Select one or more options on a `<select>` element.
       * Returns the values actually selected after the operation.
       */
      selectOption(values) {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          const desired = Array.isArray(values) ? values : [values];
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.selectElementOptions,
                arguments: [{ value: desired }],
                returnByValue: true
              }
            );
            return (_a4 = res.result.value) != null ? _a4 : [];
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return true if the element is attached and visible (rough heuristic).
       */
      isVisible() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.isElementVisible,
                returnByValue: true
              }
            );
            return Boolean(res.result.value);
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return true if the element is an input[type=checkbox|radio] and is checked.
       * Also considers aria-checked for ARIA widgets.
       */
      isChecked() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.isElementChecked,
                returnByValue: true
              }
            );
            return Boolean(res.result.value);
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return the element's input value (for input/textarea/select/contenteditable).
       */
      inputValue() {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.readElementInputValue,
                returnByValue: true
              }
            );
            return String((_a4 = res.result.value) != null ? _a4 : "");
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return the element's textContent (raw, not innerText).
       */
      textContent() {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.readElementTextContent,
                returnByValue: true
              }
            );
            return String((_a4 = res.result.value) != null ? _a4 : "");
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return the element's innerHTML string.
       */
      innerHtml() {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.readElementInnerHTML,
                returnByValue: true
              }
            );
            return String((_a4 = res.result.value) != null ? _a4 : "");
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * Return the element's innerText (layout-aware, visible text).
       */
      innerText() {
        return __async(this, null, function* () {
          var _a4;
          const session = this.frame.session;
          const { objectId } = yield this.resolveNode();
          try {
            const res = yield session.send(
              "Runtime.callFunctionOn",
              {
                objectId,
                functionDeclaration: locatorScriptSources.readElementInnerText,
                returnByValue: true
              }
            );
            return String((_a4 = res.result.value) != null ? _a4 : "");
          } finally {
            yield session.send("Runtime.releaseObject", { objectId });
          }
        });
      }
      /**
       * For API parity, returns the same locator (querySelector already returns the first match).
       */
      first() {
        return this;
      }
      /** Return a locator narrowed to the element at the given zero-based index. */
      nth(index) {
        const value = Number(index);
        if (!Number.isFinite(value) || value < 0) {
          throw new StagehandInvalidArgumentError(
            "locator().nth() expects a non-negative index"
          );
        }
        const nextIndex = Math.floor(value);
        if (nextIndex === this.nthIndex) {
          return this;
        }
        return new _Locator(this.frame, this.selector, this.options, nextIndex);
      }
      // ---------- helpers ----------
      /**
       * Resolve `this.selector` within the frame to `{ objectId, nodeId? }`:
       * Delegates to a shared selector resolver so all selector logic stays in sync.
       */
      resolveNode() {
        return __async(this, null, function* () {
          const session = this.frame.session;
          yield session.send("Runtime.enable");
          yield session.send("DOM.enable");
          const resolved = yield this.selectorResolver.resolveAtIndex(
            this.selectorQuery,
            this.nthIndex
          );
          if (!resolved) {
            throw new StagehandElementNotFoundError([this.selector]);
          }
          return resolved;
        });
      }
      /** Compute a center point from a BoxModel content quad */
      centerFromBoxContent(content) {
        if (!content || content.length < 8) {
          throw new StagehandInvalidArgumentError("Invalid box model content quad");
        }
        const xs = [content[0], content[2], content[4], content[6]];
        const ys = [content[1], content[3], content[5], content[7]];
        const cx = (xs[0] + xs[1] + xs[2] + xs[3]) / 4;
        const cy = (ys[0] + ys[1] + ys[2] + ys[3]) / 4;
        return { cx, cy };
      }
    };
  }
});

// lib/v3/understudy/frameLocator.ts
function frameLocatorFromFrame(page, root, selector) {
  return new FrameLocator(page, selector, void 0, root);
}
function listDirectChildFrameIdsFromRegistry(page, parentFrameId, timeoutMs) {
  return __async(this, null, function* () {
    var _a4, _b;
    const deadline = Date.now() + timeoutMs;
    while (true) {
      try {
        const tree = page.getFullFrameTree();
        const node = findFrameNode(tree, parentFrameId);
        const ids = (_b = (_a4 = node == null ? void 0 : node.childFrames) == null ? void 0 : _a4.map((c) => c.frame.id)) != null ? _b : [];
        if (ids.length > 0 || Date.now() >= deadline) return ids;
      } catch (e2) {
      }
      yield new Promise((r2) => setTimeout(r2, 50));
    }
  });
}
function findFrameNode(tree, targetId) {
  var _a4;
  if (tree.frame.id === targetId) return tree;
  for (const c of (_a4 = tree.childFrames) != null ? _a4 : []) {
    const hit = findFrameNode(c, targetId);
    if (hit) return hit;
  }
  return void 0;
}
function ensureChildFrameReady(page, parentFrame, childFrameId, budgetMs) {
  return __async(this, null, function* () {
    const parentSession2 = parentFrame.session;
    const deadline = Date.now() + Math.max(0, budgetMs);
    const owner = page.getSessionForFrame(childFrameId);
    if (owner && owner !== parentSession2) {
      try {
        yield executionContexts.waitForMainWorld(owner, childFrameId, 600);
      } catch (e2) {
      }
      return;
    }
    const hasMainWorldOnParent = () => {
      try {
        return executionContexts.getMainWorld(parentSession2, childFrameId) !== null;
      } catch (e2) {
        return false;
      }
    };
    if (hasMainWorldOnParent()) return;
    yield parentSession2.send("Page.setLifecycleEventsEnabled", { enabled: true }).catch(() => {
    });
    yield parentSession2.send("Runtime.enable").catch(() => {
    });
    yield new Promise((resolve3) => {
      let done = false;
      const finish = () => {
        if (done) return;
        done = true;
        parentSession2.off("Page.lifecycleEvent", onLifecycle);
        resolve3();
      };
      const onLifecycle = (evt) => {
        if (evt.frameId !== childFrameId || evt.name !== "DOMContentLoaded" && evt.name !== "load" && evt.name !== "networkIdle" && evt.name !== "networkidle") {
          return;
        }
        if (hasMainWorldOnParent()) return finish();
        try {
          const nowOwner = page.getSessionForFrame(childFrameId);
          if (nowOwner && nowOwner !== parentSession2) {
            const left = Math.max(150, deadline - Date.now());
            executionContexts.waitForMainWorld(nowOwner, childFrameId, left).finally(finish);
          }
        } catch (e2) {
        }
      };
      parentSession2.on("Page.lifecycleEvent", onLifecycle);
      const tick = () => {
        if (done) return;
        if (hasMainWorldOnParent()) return finish();
        try {
          const nowOwner = page.getSessionForFrame(childFrameId);
          if (nowOwner && nowOwner !== parentSession2) {
            const left = Math.max(150, deadline - Date.now());
            executionContexts.waitForMainWorld(nowOwner, childFrameId, left).finally(finish);
            return;
          }
        } catch (e2) {
        }
        if (Date.now() >= deadline) return finish();
        setTimeout(tick, 50);
      };
      tick();
    });
  });
}
var FrameLocator, LocatorDelegate;
var init_frameLocator = __esm({
  "lib/v3/understudy/frameLocator.ts"() {
    init_executionContextRegistry();
    init_sdkErrors();
    FrameLocator = class _FrameLocator {
      constructor(page, selector, parent, root) {
        this.page = page;
        this.selector = selector;
        this.parent = parent;
        this.root = root;
      }
      /** Create a nested FrameLocator under this one. */
      frameLocator(selector) {
        return new _FrameLocator(this.page, selector, this);
      }
      /** Resolve to the concrete Frame for this FrameLocator chain. */
      resolveFrame() {
        return __async(this, null, function* () {
          var _a4;
          const parentFrame = this.parent ? yield this.parent.resolveFrame() : (_a4 = this.root) != null ? _a4 : this.page.mainFrame();
          const tmp = parentFrame.locator(this.selector);
          const parentSession2 = parentFrame.session;
          const { objectId } = yield tmp.resolveNode();
          try {
            yield parentSession2.send("DOM.enable").catch(() => {
            });
            const desc = yield parentSession2.send(
              "DOM.describeNode",
              { objectId }
            );
            const iframeBackendNodeId = desc.node.backendNodeId;
            const childIds = yield listDirectChildFrameIdsFromRegistry(
              this.page,
              parentFrame.frameId,
              1e3
            );
            for (const fid of childIds) {
              try {
                const owner = yield parentSession2.send("DOM.getFrameOwner", { frameId: fid });
                if (owner.backendNodeId === iframeBackendNodeId) {
                  yield ensureChildFrameReady(this.page, parentFrame, fid, 1200);
                  return this.page.frameForId(fid);
                }
              } catch (e2) {
              }
            }
            throw new ContentFrameNotFoundError(this.selector);
          } finally {
            yield parentSession2.send("Runtime.releaseObject", { objectId }).catch(() => {
            });
          }
        });
      }
      /** Return a Locator scoped to this frame. Methods delegate to the frame lazily. */
      locator(selector) {
        return new LocatorDelegate(this, selector);
      }
    };
    LocatorDelegate = class {
      constructor(fl, sel) {
        this.fl = fl;
        this.sel = sel;
      }
      real() {
        return __async(this, null, function* () {
          const frame = yield this.fl.resolveFrame();
          return frame.locator(this.sel);
        });
      }
      // Locator API delegates
      click(options) {
        return __async(this, null, function* () {
          return (yield this.real()).click(options);
        });
      }
      hover() {
        return __async(this, null, function* () {
          return (yield this.real()).hover();
        });
      }
      fill(value) {
        return __async(this, null, function* () {
          return (yield this.real()).fill(value);
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          return (yield this.real()).type(text, options);
        });
      }
      selectOption(values) {
        return __async(this, null, function* () {
          return (yield this.real()).selectOption(values);
        });
      }
      scrollTo(percent) {
        return __async(this, null, function* () {
          return (yield this.real()).scrollTo(percent);
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          return (yield this.real()).isVisible();
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          return (yield this.real()).isChecked();
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return (yield this.real()).inputValue();
        });
      }
      textContent() {
        return __async(this, null, function* () {
          return (yield this.real()).textContent();
        });
      }
      innerHtml() {
        return __async(this, null, function* () {
          return (yield this.real()).innerHtml();
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return (yield this.real()).innerText();
        });
      }
      count() {
        return __async(this, null, function* () {
          return (yield this.real()).count();
        });
      }
      first() {
        return this;
      }
    };
  }
});

// lib/v3/understudy/deepLocator.ts
function parseXPath(path8) {
  const s2 = path8.trim();
  let i2 = 0;
  const steps = [];
  while (i2 < s2.length) {
    let axis = "child";
    if (s2.startsWith("//", i2)) {
      axis = "desc";
      i2 += 2;
    } else if (s2[i2] === "/") {
      axis = "child";
      i2 += 1;
    }
    const start = i2;
    while (i2 < s2.length && s2[i2] !== "/") i2++;
    const raw = s2.slice(start, i2).trim();
    if (!raw) continue;
    const name = raw.replace(/\[\d+\]\s*$/u, "").toLowerCase();
    steps.push({ axis, raw, name });
  }
  return steps;
}
function buildXPathFromSteps2(steps) {
  let out = "";
  for (const st of steps) {
    out += st.axis === "desc" ? "//" : "/";
    out += st.raw;
  }
  return out || "/";
}
function deepLocatorThroughIframes(page, root, xpathOrSelector) {
  return __async(this, null, function* () {
    let path8 = xpathOrSelector.trim();
    if (path8.startsWith("xpath=")) path8 = path8.slice("xpath=".length).trim();
    if (!path8.startsWith("/")) path8 = "/" + path8;
    const steps = parseXPath(path8);
    let fl;
    let buf = [];
    const flushIntoFrameLocator = () => {
      if (!buf.length) return;
      const selectorForIframe = "xpath=" + buildXPathFromSteps2(buf);
      v3Logger({
        category: "deep-hop",
        message: "resolving iframe via FrameLocator",
        level: 2,
        auxiliary: {
          selectorForIframe: { value: selectorForIframe, type: "string" },
          rootFrameId: { value: String(root.frameId), type: "string" }
        }
      });
      fl = fl ? fl.frameLocator(selectorForIframe) : frameLocatorFromFrame(page, root, selectorForIframe);
      buf = [];
    };
    for (const st of steps) {
      buf.push(st);
      if (IFRAME_STEP_RE2.test(st.name)) flushIntoFrameLocator();
    }
    const finalSelector = "xpath=" + buildXPathFromSteps2(buf);
    const targetFrame = fl ? yield fl.resolveFrame() : root;
    v3Logger({
      category: "deep-hop",
      message: "final tail",
      level: 2,
      auxiliary: {
        frameId: { value: String(targetFrame.frameId), type: "string" },
        finalSelector: { value: finalSelector, type: "string" }
      }
    });
    return new Locator(targetFrame, finalSelector);
  });
}
function resolveLocatorWithHops(page, root, selectorRaw) {
  return __async(this, null, function* () {
    const sel = selectorRaw.trim();
    const parts = sel.split(">>").map((s2) => s2.trim()).filter(Boolean);
    if (parts.length > 1) {
      let fl = frameLocatorFromFrame(page, root, parts[0]);
      for (let i2 = 1; i2 < parts.length - 1; i2++) {
        fl = fl.frameLocator(parts[i2]);
      }
      const targetFrame = yield fl.resolveFrame();
      return new Locator(targetFrame, parts[parts.length - 1]);
    }
    const isXPath = sel.startsWith("xpath=") || sel.startsWith("/");
    if (isXPath) return deepLocatorThroughIframes(page, root, sel);
    return new Locator(root, sel);
  });
}
function deepLocatorFromPage(page, root, selector) {
  return new DeepLocatorDelegate(page, root, selector);
}
var IFRAME_STEP_RE2, DeepLocatorDelegate;
var init_deepLocator = __esm({
  "lib/v3/understudy/deepLocator.ts"() {
    init_locator();
    init_logger();
    init_frameLocator();
    init_sdkErrors();
    IFRAME_STEP_RE2 = /^iframe(?:\[\d+])?$/i;
    DeepLocatorDelegate = class _DeepLocatorDelegate {
      constructor(page, root, selector, nthIndex = 0) {
        this.page = page;
        this.root = root;
        this.selector = selector;
        this.nthIndex = nthIndex;
      }
      real() {
        return __async(this, null, function* () {
          const base = yield resolveLocatorWithHops(
            this.page,
            this.root,
            this.selector
          );
          return base.nth(this.nthIndex);
        });
      }
      // Locator API delegates
      click(options) {
        return __async(this, null, function* () {
          return (yield this.real()).click(options);
        });
      }
      count() {
        return __async(this, null, function* () {
          return (yield this.real()).count();
        });
      }
      hover() {
        return __async(this, null, function* () {
          return (yield this.real()).hover();
        });
      }
      fill(value) {
        return __async(this, null, function* () {
          return (yield this.real()).fill(value);
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          return (yield this.real()).type(text, options);
        });
      }
      selectOption(values) {
        return __async(this, null, function* () {
          return (yield this.real()).selectOption(values);
        });
      }
      scrollTo(percent) {
        return __async(this, null, function* () {
          return (yield this.real()).scrollTo(percent);
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          return (yield this.real()).isVisible();
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          return (yield this.real()).isChecked();
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return (yield this.real()).inputValue();
        });
      }
      textContent() {
        return __async(this, null, function* () {
          return (yield this.real()).textContent();
        });
      }
      innerHtml() {
        return __async(this, null, function* () {
          return (yield this.real()).innerHtml();
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return (yield this.real()).innerText();
        });
      }
      centroid() {
        return __async(this, null, function* () {
          return (yield this.real()).centroid();
        });
      }
      backendNodeId() {
        return __async(this, null, function* () {
          return (yield this.real()).backendNodeId();
        });
      }
      highlight(options) {
        return __async(this, null, function* () {
          return (yield this.real()).highlight(options);
        });
      }
      sendClickEvent(options) {
        return __async(this, null, function* () {
          return (yield this.real()).sendClickEvent(options);
        });
      }
      setInputFiles(files) {
        return __async(this, null, function* () {
          return (yield this.real()).setInputFiles(files);
        });
      }
      first() {
        return this.nth(0);
      }
      nth(index) {
        const value = Number(index);
        if (!Number.isFinite(value) || value < 0) {
          throw new StagehandInvalidArgumentError(
            "deepLocator().nth() expects a non-negative index"
          );
        }
        const nextIndex = Math.floor(value);
        if (nextIndex === this.nthIndex) return this;
        return new _DeepLocatorDelegate(
          this.page,
          this.root,
          this.selector,
          nextIndex
        );
      }
    };
  }
});

// lib/v3/flowLogger.ts
function truncateCdpIds(value) {
  return value.replace(
    /([iI]d:?"?)([0-9A-F]{32})(?="?[,})\s]|$)/g,
    (_, pre, id) => `${pre}${id.slice(0, 4)}\u2026${id.slice(-4)}`
  );
}
function truncateLine(value, maxLen) {
  const collapsed = value.replace(/\s+/g, " ");
  if (collapsed.length <= maxLen) return collapsed;
  const endLen = Math.floor(maxLen * 0.3);
  const startLen = maxLen - endLen - 1;
  return `${collapsed.slice(0, startLen)}\u2026${collapsed.slice(-endLen)}`;
}
function formatValue(value) {
  if (typeof value === "string") return `'${value}'`;
  if (value == null || typeof value !== "object") return String(value);
  try {
    return JSON.stringify(value);
  } catch (e2) {
    return "[unserializable]";
  }
}
function formatArgs(args) {
  if (args === void 0) return "";
  return (Array.isArray(args) ? args : [args]).filter((e2) => e2 !== void 0).map(formatValue).filter((e2) => e2.length > 0).join(", ");
}
function formatTag(label, id, icon) {
  return id ? `[${icon} #${shortId(id)}${label ? " " + label : ""}]` : "\u2911";
}
function formatTimestamp() {
  const d = /* @__PURE__ */ new Date();
  const pad = (n, w = 2) => String(n).padStart(w, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${pad(d.getMilliseconds(), 3)}${pad(nonce++ % 100)}`;
}
function sanitizeOptions(options) {
  const sanitize = (obj) => {
    if (typeof obj !== "object" || obj === null) return obj;
    if (Array.isArray(obj)) return obj.map(sanitize);
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = SENSITIVE_KEYS.test(key) ? "******" : sanitize(value);
    }
    return result;
  };
  return sanitize(__spreadValues({}, options));
}
function removeQuotes(str) {
  return str.replace(/([^\\])["']/g, "$1").replace(/^["']|["']$/g, "").trim();
}
function prettifyEvent(event) {
  var _a4, _b, _c, _d2, _e, _f, _g, _h;
  const parts = [];
  if (event.category === "AgentTask") {
    parts.push(formatTag("", event.taskId, "\u{1F170}"));
  } else if (event.category === "StagehandStep") {
    parts.push(formatTag("", event.taskId, "\u{1F170}"));
    parts.push(formatTag(event.stepLabel, event.stepId, "\u{1F182}"));
  } else if (event.category === "UnderstudyAction") {
    parts.push(formatTag("", event.taskId, "\u{1F170}"));
    parts.push(formatTag(event.stepLabel, event.stepId, "\u{1F182}"));
    parts.push(formatTag(event.actionLabel, event.actionId, "\u{1F184}"));
  } else if (event.category === "CDP") {
    parts.push(formatTag("", event.taskId, "\u{1F170}"));
    parts.push(formatTag(event.stepLabel, event.stepId, "\u{1F182}"));
    parts.push(formatTag(event.actionLabel, event.actionId, "\u{1F184}"));
    parts.push(formatTag("CDP", event.targetId, "\u{1F172}"));
  } else if (event.category === "LLM") {
    parts.push(formatTag("", event.taskId, "\u{1F170}"));
    parts.push(formatTag(event.stepLabel, event.stepId, "\u{1F182}"));
    parts.push(formatTag("LLM", event.requestId, "\u{1F9E0}"));
  }
  let details = "";
  const argsStr = event.params ? formatArgs(event.params) : "";
  if (event.category === "AgentTask") {
    if (event.event === "started") {
      details = `\u25B7 ${event.method}(${argsStr})`;
    } else if (event.event === "completed") {
      const m2 = event.metrics;
      const durationSec = (m2 == null ? void 0 : m2.durationMs) ? (m2.durationMs / 1e3).toFixed(1) : "?";
      const llmStats = `${(_a4 = m2 == null ? void 0 : m2.llmRequests) != null ? _a4 : 0} LLM calls \uA71B${(_b = m2 == null ? void 0 : m2.inputTokens) != null ? _b : 0} \uA71C${(_c = m2 == null ? void 0 : m2.outputTokens) != null ? _c : 0} tokens`;
      const cdpStats = `${(_d2 = m2 == null ? void 0 : m2.cdpEvents) != null ? _d2 : 0} CDP msgs`;
      details = `\u2713 Agent.execute() DONE in ${durationSec}s | ${llmStats} | ${cdpStats}`;
    }
  } else if (event.category === "StagehandStep") {
    if (event.event === "started") {
      details = `\u25B7 ${event.method}(${argsStr})`;
    } else if (event.event === "completed") {
      const durationSec = ((_e = event.metrics) == null ? void 0 : _e.durationMs) ? (event.metrics.durationMs / 1e3).toFixed(2) : "?";
      details = `\u2713 ${event.stepLabel || "STEP"} completed in ${durationSec}s`;
    }
  } else if (event.category === "UnderstudyAction") {
    if (event.event === "started") {
      details = `\u25B7 ${event.method}(${argsStr})`;
    } else if (event.event === "completed") {
      const durationSec = ((_f = event.metrics) == null ? void 0 : _f.durationMs) ? (event.metrics.durationMs / 1e3).toFixed(2) : "?";
      details = `\u2713 ${event.actionLabel || "ACTION"} completed in ${durationSec}s`;
    }
  } else if (event.category === "CDP") {
    const icon = event.event === "call" ? "\u23F5" : "\u23F4";
    details = `${icon} ${event.method}(${argsStr})`;
  } else if (event.category === "LLM") {
    if (event.event === "request") {
      const promptStr = event.prompt ? " " + String(event.prompt) : "";
      details = `${event.model} \u23F4${promptStr}`;
    } else if (event.event === "response") {
      const hasTokens = event.inputTokens !== void 0 || event.outputTokens !== void 0;
      const tokenStr = hasTokens ? ` \uA71B${(_g = event.inputTokens) != null ? _g : 0} \uA71C${(_h = event.outputTokens) != null ? _h : 0} |` : "";
      const outputStr = event.output ? " " + String(event.output) : "";
      details = `${event.model} \u21B3${tokenStr}${outputStr}`;
    }
  }
  if (!details) return null;
  const fullLine = `${formatTimestamp()} ${parts.join(" ")} ${details}`;
  const cleaned = removeQuotes(fullLine);
  const processed = event.category === "CDP" ? truncateCdpIds(cleaned) : cleaned;
  return truncateLine(processed, MAX_LINE_LENGTH);
}
function shouldFilterCdpEvent(event) {
  var _a4;
  if (event.category !== "CDP") return false;
  if (((_a4 = event.method) == null ? void 0 : _a4.endsWith(".enable")) || event.method === "enable")
    return true;
  return event.event === "message" && NOISY_CDP_EVENTS.has(event.method);
}
function createJsonlStream(ctx) {
  return new import_node_stream.Writable({
    objectMode: true,
    write(chunk, _, cb) {
      if (ctx.initialized && isWritable(ctx.fileStreams.jsonl)) {
        ctx.fileStreams.jsonl.write(chunk, cb);
      } else cb();
    }
  });
}
function createPrettyStream(ctx, category, streamKey) {
  return new import_node_stream.Writable({
    objectMode: true,
    write(chunk, _, cb) {
      const stream = ctx.fileStreams[streamKey];
      if (!ctx.initialized || !isWritable(stream)) return cb();
      try {
        const event = JSON.parse(chunk);
        if (event.category !== category || shouldFilterCdpEvent(event))
          return cb();
        const line = prettifyEvent(event);
        if (line) stream.write(line + "\n", cb);
        else cb();
      } catch (e2) {
        cb();
      }
    }
  });
}
function getConfigDir() {
  return CONFIG_DIR ? import_node_path.default.resolve(CONFIG_DIR) : "";
}
function extractFromContent(content, result) {
  var _a4, _b, _c, _d2;
  for (const part of content) {
    const p = part;
    if (!result.text && p.text) {
      result.text = p.type === "text" || !p.type ? p.text : void 0;
    }
    if (p.type === "image" || p.type === "image_url") {
      const url = (_a4 = p.image_url) == null ? void 0 : _a4.url;
      if (url == null ? void 0 : url.startsWith("data:"))
        result.extras.push(`${dataToKb(url)}kb image`);
      else if ((_b = p.source) == null ? void 0 : _b.data)
        result.extras.push(`${dataToKb(p.source.data)}kb image`);
      else result.extras.push("image");
    } else if ((_c = p.source) == null ? void 0 : _c.data) {
      result.extras.push(`${dataToKb(p.source.data)}kb image`);
    } else if ((_d2 = p.inlineData) == null ? void 0 : _d2.data) {
      result.extras.push(`${dataToKb(p.inlineData.data)}kb image`);
    }
    if (p.type === "tool_result" && Array.isArray(p.content)) {
      extractFromContent(p.content, result);
    }
  }
}
function buildPreview(text, extras, maxLen) {
  if (!text && extras.length === 0) return void 0;
  let result = text || "";
  if (maxLen && result.length > maxLen)
    result = result.slice(0, maxLen) + "...";
  if (extras.length > 0) {
    const extrasStr = extras.map((e2) => `+{${e2}}`).join(" ");
    result = result ? `${result} ${extrasStr}` : extrasStr;
  }
  return result || void 0;
}
function formatLlmPromptPreview(messages, options) {
  try {
    const lastUserMsg = messages.filter((m2) => m2.role === "user").pop();
    if (!lastUserMsg) return void 0;
    const result = {
      text: void 0,
      extras: []
    };
    if (typeof lastUserMsg.content === "string") {
      result.text = lastUserMsg.content;
    } else if (Array.isArray(lastUserMsg.content)) {
      extractFromContent(lastUserMsg.content, result);
    } else {
      return void 0;
    }
    if (result.text) {
      result.text = result.text.replace(/^[Ii]nstruction: /, "");
    }
    if (options == null ? void 0 : options.hasSchema) result.extras.push("schema");
    if (options == null ? void 0 : options.toolCount) result.extras.push(`${options.toolCount} tools`);
    return buildPreview(result.text, result.extras);
  } catch (e2) {
    return void 0;
  }
}
function formatCuaPromptPreview(messages, maxLen = 100) {
  try {
    const lastMsg = messages.filter((m2) => {
      const msg = m2;
      return msg.role === "user" || msg.type === "tool_result";
    }).pop();
    if (!lastMsg) return void 0;
    const result = {
      text: void 0,
      extras: []
    };
    if (typeof lastMsg.content === "string") {
      result.text = lastMsg.content;
    } else if (typeof lastMsg.text === "string") {
      result.text = lastMsg.text;
    } else if (Array.isArray(lastMsg.parts)) {
      extractFromContent(lastMsg.parts, result);
    } else if (Array.isArray(lastMsg.content)) {
      extractFromContent(lastMsg.content, result);
    }
    return buildPreview(result.text, result.extras, maxLen);
  } catch (e2) {
    return void 0;
  }
}
function formatCuaResponsePreview(output, maxLen = 100) {
  var _a4, _b, _c, _d2;
  try {
    const items = (_d2 = (_c = (_b = (_a4 = output == null ? void 0 : output.candidates) == null ? void 0 : _a4[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) != null ? _d2 : Array.isArray(output) ? output : [];
    const preview = items.map((item) => {
      var _a5;
      const i2 = item;
      if (i2.text) return i2.text.slice(0, 50);
      if ((_a5 = i2.functionCall) == null ? void 0 : _a5.name) return `fn:${i2.functionCall.name}`;
      if (i2.type === "tool_use" && i2.name) return `tool_use:${i2.name}`;
      return i2.type ? `[${i2.type}]` : "[item]";
    }).join(" ");
    return preview.slice(0, maxLen);
  } catch (e2) {
    return "[error]";
  }
}
function logAction(actionType) {
  return function(originalMethod) {
    if (!CONFIG_DIR) {
      return originalMethod;
    }
    return function(...args) {
      return __async(this, null, function* () {
        SessionFileLogger.logUnderstudyActionEvent({
          actionType,
          args: args.length > 0 ? args : void 0
        });
        try {
          return yield originalMethod.apply(this, args);
        } finally {
          SessionFileLogger.logUnderstudyActionCompleted();
        }
      });
    };
  };
}
function logStagehandStep(invocation, label) {
  return function(originalMethod) {
    if (!CONFIG_DIR) {
      return originalMethod;
    }
    return function(...args) {
      return __async(this, null, function* () {
        SessionFileLogger.logStagehandStepEvent({
          invocation,
          args: args.length > 0 ? args : void 0,
          label
        });
        try {
          return yield originalMethod.apply(this, args);
        } finally {
          SessionFileLogger.logStagehandStepCompleted();
        }
      });
    };
  };
}
var import_node_async_hooks2, import_node_fs, import_node_stream, import_uuid, import_node_path, import_pino2, MAX_LINE_LENGTH, CONFIG_DIR, NOISY_CDP_EVENTS, loggerContext, dataToKb, shortId, nonce, SENSITIVE_KEYS, isWritable, SessionFileLogger;
var init_flowLogger = __esm({
  "lib/v3/flowLogger.ts"() {
    import_node_async_hooks2 = require("async_hooks");
    import_node_fs = __toESM(require("fs"));
    import_node_stream = require("stream");
    import_uuid = require("uuid");
    import_node_path = __toESM(require("path"));
    import_pino2 = __toESM(require("pino"));
    MAX_LINE_LENGTH = 160;
    CONFIG_DIR = process.env.BROWSERBASE_CONFIG_DIR || "";
    NOISY_CDP_EVENTS = /* @__PURE__ */ new Set([
      "Target.targetInfoChanged",
      "Runtime.executionContextCreated",
      "Runtime.executionContextDestroyed",
      "Runtime.executionContextsCleared",
      "Page.lifecycleEvent",
      "Network.dataReceived",
      "Network.loadingFinished",
      "Network.requestWillBeSentExtraInfo",
      "Network.responseReceivedExtraInfo",
      "Network.requestWillBeSent",
      "Network.responseReceived"
    ]);
    loggerContext = new import_node_async_hooks2.AsyncLocalStorage();
    dataToKb = (data) => (data.length * 0.75 / 1024).toFixed(1);
    shortId = (id) => id ? id.slice(-4) : "-";
    nonce = 0;
    SENSITIVE_KEYS = /apikey|api_key|key|secret|token|password|passwd|pwd|credential|auth/i;
    isWritable = (s2) => !!(s2 && !s2.destroyed && s2.writable);
    SessionFileLogger = class _SessionFileLogger {
      /**
       * Initialize a new logging context. Call this at the start of a session.
       * If BROWSERBASE_CONFIG_DIR is not set, logging is disabled.
       */
      static init(sessionId, v3Options) {
        const configDir = getConfigDir();
        if (!configDir) return;
        const sessionDir = import_node_path.default.join(configDir, "sessions", sessionId);
        const ctx = {
          logger: (0, import_pino2.default)({ level: "silent" }),
          // Placeholder, replaced below
          metrics: {
            llmRequests: 0,
            llmInputTokens: 0,
            llmOutputTokens: 0,
            cdpEvents: 0
          },
          sessionId,
          sessionDir,
          configDir,
          initPromise: Promise.resolve(),
          initialized: false,
          // Span context - mutable, injected into every log via mixin
          taskId: null,
          stepId: null,
          stepLabel: null,
          actionId: null,
          actionLabel: null,
          fileStreams: {
            agent: null,
            stagehand: null,
            understudy: null,
            cdp: null,
            llm: null,
            jsonl: null
          }
        };
        ctx.initPromise = _SessionFileLogger.initAsync(ctx, v3Options);
        loggerContext.enterWith(ctx);
      }
      static initAsync(ctx, v3Options) {
        return __async(this, null, function* () {
          try {
            yield import_node_fs.default.promises.mkdir(ctx.sessionDir, { recursive: true });
            if (v3Options) {
              const sanitizedOptions = sanitizeOptions(v3Options);
              const sessionJsonPath = import_node_path.default.join(ctx.sessionDir, "session.json");
              yield import_node_fs.default.promises.writeFile(
                sessionJsonPath,
                JSON.stringify(sanitizedOptions, null, 2),
                "utf-8"
              );
            }
            const latestLink = import_node_path.default.join(ctx.configDir, "sessions", "latest");
            try {
              try {
                yield import_node_fs.default.promises.unlink(latestLink);
              } catch (e2) {
              }
              yield import_node_fs.default.promises.symlink(ctx.sessionId, latestLink, "dir");
            } catch (e2) {
            }
            const dir = ctx.sessionDir;
            ctx.fileStreams.agent = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "agent_events.log"),
              { flags: "a" }
            );
            ctx.fileStreams.stagehand = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "stagehand_events.log"),
              { flags: "a" }
            );
            ctx.fileStreams.understudy = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "understudy_events.log"),
              { flags: "a" }
            );
            ctx.fileStreams.cdp = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "cdp_events.log"),
              { flags: "a" }
            );
            ctx.fileStreams.llm = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "llm_events.log"),
              { flags: "a" }
            );
            ctx.fileStreams.jsonl = import_node_fs.default.createWriteStream(
              import_node_path.default.join(dir, "session_events.jsonl"),
              { flags: "a" }
            );
            ctx.initialized = true;
            const streams = [
              { stream: createJsonlStream(ctx) },
              { stream: createPrettyStream(ctx, "AgentTask", "agent") },
              { stream: createPrettyStream(ctx, "StagehandStep", "stagehand") },
              { stream: createPrettyStream(ctx, "UnderstudyAction", "understudy") },
              { stream: createPrettyStream(ctx, "CDP", "cdp") },
              { stream: createPrettyStream(ctx, "LLM", "llm") }
            ];
            ctx.logger = (0, import_pino2.default)(
              {
                level: "info",
                // Mixin adds eventId and current span context to every log
                mixin() {
                  const store = loggerContext.getStore();
                  return {
                    eventId: (0, import_uuid.v7)(),
                    sessionId: store == null ? void 0 : store.sessionId,
                    taskId: store == null ? void 0 : store.taskId,
                    stepId: store == null ? void 0 : store.stepId,
                    stepLabel: store == null ? void 0 : store.stepLabel,
                    actionId: store == null ? void 0 : store.actionId,
                    actionLabel: store == null ? void 0 : store.actionLabel
                  };
                }
              },
              import_pino2.default.multistream(streams)
            );
          } catch (e2) {
          }
        });
      }
      static close() {
        return __async(this, null, function* () {
          const ctx = loggerContext.getStore();
          if (!ctx) return;
          yield ctx.initPromise;
          _SessionFileLogger.logAgentTaskCompleted();
          yield Promise.all(
            Object.values(ctx.fileStreams).filter(Boolean).map((s2) => new Promise((r2) => s2.end(r2)))
          ).catch(() => {
          });
        });
      }
      static get sessionId() {
        var _a4, _b;
        return (_b = (_a4 = loggerContext.getStore()) == null ? void 0 : _a4.sessionId) != null ? _b : null;
      }
      static get sessionDir() {
        var _a4, _b;
        return (_b = (_a4 = loggerContext.getStore()) == null ? void 0 : _a4.sessionDir) != null ? _b : null;
      }
      /**
       * Get the current logger context object.
       */
      static getContext() {
        var _a4;
        return (_a4 = loggerContext.getStore()) != null ? _a4 : null;
      }
      // ===========================================================================
      // Agent Task Events
      // ===========================================================================
      /**
       * Start a new task and log it.
       */
      static logAgentTaskStarted({
        invocation,
        args
      }) {
        const ctx = loggerContext.getStore();
        if (!ctx) return;
        ctx.taskId = (0, import_uuid.v7)();
        ctx.stepId = null;
        ctx.stepLabel = null;
        ctx.actionId = null;
        ctx.actionLabel = null;
        ctx.metrics = {
          taskStartTime: Date.now(),
          llmRequests: 0,
          llmInputTokens: 0,
          llmOutputTokens: 0,
          cdpEvents: 0
        };
        ctx.logger.info({
          category: "AgentTask",
          event: "started",
          method: invocation,
          params: args
        });
      }
      /**
       * Log task completion with metrics summary.
       */
      static logAgentTaskCompleted(options) {
        const ctx = loggerContext.getStore();
        if (!ctx || !ctx.metrics.taskStartTime) return;
        const durationMs = Date.now() - ctx.metrics.taskStartTime;
        const event = {
          category: "AgentTask",
          event: "completed",
          method: "Agent.execute",
          metrics: {
            durationMs,
            llmRequests: ctx.metrics.llmRequests,
            inputTokens: ctx.metrics.llmInputTokens,
            outputTokens: ctx.metrics.llmOutputTokens,
            cdpEvents: ctx.metrics.cdpEvents
          }
        };
        if (options == null ? void 0 : options.cacheHit) {
          event.msg = "CACHE HIT, NO LLM NEEDED";
        }
        ctx.logger.info(event);
        ctx.taskId = null;
        ctx.stepId = null;
        ctx.stepLabel = null;
        ctx.actionId = null;
        ctx.actionLabel = null;
        ctx.metrics.taskStartTime = void 0;
      }
      // ===========================================================================
      // Stagehand Step Events
      // ===========================================================================
      static logStagehandStepEvent({
        invocation,
        args,
        label
      }) {
        const ctx = loggerContext.getStore();
        if (!ctx) return (0, import_uuid.v7)();
        ctx.stepId = (0, import_uuid.v7)();
        ctx.stepLabel = label.toUpperCase();
        ctx.actionId = null;
        ctx.actionLabel = null;
        ctx.metrics.stepStartTime = Date.now();
        ctx.logger.info({
          category: "StagehandStep",
          event: "started",
          method: invocation,
          params: args
        });
        return ctx.stepId;
      }
      static logStagehandStepCompleted() {
        const ctx = loggerContext.getStore();
        if (!ctx || !ctx.stepId) return;
        const durationMs = ctx.metrics.stepStartTime ? Date.now() - ctx.metrics.stepStartTime : 0;
        ctx.logger.info({
          category: "StagehandStep",
          event: "completed",
          metrics: { durationMs }
        });
        ctx.stepId = null;
        ctx.stepLabel = null;
        ctx.actionId = null;
        ctx.actionLabel = null;
        ctx.metrics.stepStartTime = void 0;
      }
      // ===========================================================================
      // Understudy Action Events
      // ===========================================================================
      static logUnderstudyActionEvent({
        actionType,
        target,
        args
      }) {
        const ctx = loggerContext.getStore();
        if (!ctx) return (0, import_uuid.v7)();
        ctx.actionId = (0, import_uuid.v7)();
        ctx.actionLabel = actionType.toUpperCase().replace("UNDERSTUDY.", "").replace("PAGE.", "");
        ctx.metrics.actionStartTime = Date.now();
        const params = {};
        if (target) params.target = target;
        if (args) params.args = args;
        ctx.logger.info({
          category: "UnderstudyAction",
          event: "started",
          method: actionType,
          params: Object.keys(params).length > 0 ? params : void 0
        });
        return ctx.actionId;
      }
      static logUnderstudyActionCompleted() {
        const ctx = loggerContext.getStore();
        if (!ctx || !ctx.actionId) return;
        const durationMs = ctx.metrics.actionStartTime ? Date.now() - ctx.metrics.actionStartTime : 0;
        ctx.logger.info({
          category: "UnderstudyAction",
          event: "completed",
          metrics: { durationMs }
        });
        ctx.actionId = null;
        ctx.actionLabel = null;
        ctx.metrics.actionStartTime = void 0;
      }
      // ===========================================================================
      // CDP Events
      // ===========================================================================
      static logCdpEvent(eventType, {
        method,
        params,
        targetId
      }, explicitCtx) {
        const ctx = explicitCtx != null ? explicitCtx : loggerContext.getStore();
        if (!ctx) return;
        if (eventType === "call") ctx.metrics.cdpEvents++;
        ctx.logger.info({
          category: "CDP",
          event: eventType,
          method,
          params,
          targetId
        });
      }
      static logCdpCallEvent(data, ctx) {
        _SessionFileLogger.logCdpEvent("call", data, ctx);
      }
      static logCdpMessageEvent(data, ctx) {
        _SessionFileLogger.logCdpEvent("message", data, ctx);
      }
      // ===========================================================================
      // LLM Events
      // ===========================================================================
      static logLlmRequest({
        requestId,
        model,
        prompt
      }, explicitCtx) {
        const ctx = explicitCtx != null ? explicitCtx : loggerContext.getStore();
        if (!ctx) return;
        ctx.metrics.llmRequests++;
        ctx.logger.info({
          category: "LLM",
          event: "request",
          requestId,
          method: "LLM.request",
          model,
          prompt
        });
      }
      static logLlmResponse({
        requestId,
        model,
        output,
        inputTokens,
        outputTokens
      }, explicitCtx) {
        const ctx = explicitCtx != null ? explicitCtx : loggerContext.getStore();
        if (!ctx) return;
        ctx.metrics.llmInputTokens += inputTokens != null ? inputTokens : 0;
        ctx.metrics.llmOutputTokens += outputTokens != null ? outputTokens : 0;
        ctx.logger.info({
          category: "LLM",
          event: "response",
          requestId,
          method: "LLM.response",
          model,
          output,
          inputTokens,
          outputTokens
        });
      }
      // ===========================================================================
      // LLM Logging Middleware
      // ===========================================================================
      /**
       * Create middleware for wrapping language models with LLM call logging.
       * Returns a no-op middleware when logging is disabled.
       */
      static createLlmLoggingMiddleware(modelId) {
        if (!CONFIG_DIR) {
          return {
            wrapGenerate: (_0) => __async(null, [_0], function* ({ doGenerate }) {
              return doGenerate();
            })
          };
        }
        return {
          wrapGenerate: (_0) => __async(null, [_0], function* ({ doGenerate, params }) {
            var _a4, _b, _c, _d2, _e;
            const ctx = _SessionFileLogger.getContext();
            if (!ctx) {
              return doGenerate();
            }
            const llmRequestId = (0, import_uuid.v7)();
            const toolCount = Array.isArray(params.tools) ? params.tools.length : 0;
            const messages = (_a4 = params.prompt) != null ? _a4 : [];
            const lastMsg = messages.filter((m2) => m2.role !== "system").pop();
            const extracted = {
              text: void 0,
              extras: []
            };
            let rolePrefix = (_b = lastMsg == null ? void 0 : lastMsg.role) != null ? _b : "?";
            if (lastMsg) {
              if (typeof lastMsg.content === "string") {
                extracted.text = lastMsg.content;
              } else if (Array.isArray(lastMsg.content)) {
                const toolResult = lastMsg.content.find((p) => p.type === "tool-result");
                if (toolResult) {
                  rolePrefix = `tool result: ${toolResult.toolName}()`;
                  const out = toolResult.output;
                  if ((out == null ? void 0 : out.type) === "json" && out.value) {
                    extracted.text = JSON.stringify(out.value).slice(0, 150);
                  } else if (Array.isArray(out == null ? void 0 : out.value)) {
                    extractFromContent(out.value, extracted);
                  }
                } else {
                  extractFromContent(lastMsg.content, extracted);
                }
              }
            }
            const promptText = extracted.text || "(no text)";
            const promptPreview = `${rolePrefix}: ${promptText} +{${toolCount} tools}`;
            _SessionFileLogger.logLlmRequest(
              {
                requestId: llmRequestId,
                model: modelId,
                operation: "generateText",
                prompt: promptPreview
              },
              ctx
            );
            const result = yield doGenerate();
            const res = result;
            let outputPreview = res.text || "";
            if (!outputPreview && res.content) {
              if (typeof res.content === "string") {
                outputPreview = res.content;
              } else if (Array.isArray(res.content)) {
                outputPreview = res.content.map(
                  (c) => c.text || (c.type === "tool-call" ? `tool call: ${c.toolName}()` : `[${c.type}]`)
                ).join(" ");
              }
            }
            if (!outputPreview && ((_c = res.toolCalls) == null ? void 0 : _c.length)) {
              outputPreview = `[${res.toolCalls.length} tool calls]`;
            }
            _SessionFileLogger.logLlmResponse(
              {
                requestId: llmRequestId,
                model: modelId,
                operation: "generateText",
                output: outputPreview || "[empty]",
                inputTokens: (_d2 = result.usage) == null ? void 0 : _d2.inputTokens,
                outputTokens: (_e = result.usage) == null ? void 0 : _e.outputTokens
              },
              ctx
            );
            return result;
          })
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs2;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs2(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os3 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os3.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs2;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs2(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "../../node_modules/.pnpm/is-docker@2.2.1/node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs12 = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs12.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs12.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// ../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "../../node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os3 = require("os");
    var fs12 = require("fs");
    var isDocker = require_is_docker();
    var isWsl3 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os3.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs12.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl3;
    } else {
      module2.exports = isWsl3();
    }
  }
});

// ../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
var require_extend = __commonJS({
  "../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i2 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/package.json"(exports2, module2) {
    module2.exports = {
      name: "gaxios",
      version: "7.1.3",
      description: "A simple common HTTP client specifically for Google APIs and services.",
      main: "build/cjs/src/index.js",
      types: "build/cjs/src/index.d.ts",
      files: [
        "build/"
      ],
      exports: {
        ".": {
          import: {
            types: "./build/esm/src/index.d.ts",
            default: "./build/esm/src/index.js"
          },
          require: {
            types: "./build/cjs/src/index.d.ts",
            default: "./build/cjs/src/index.js"
          }
        }
      },
      scripts: {
        lint: "gts check --no-inline-config",
        test: "c8 mocha build/esm/test",
        "presystem-test": "npm run compile",
        "system-test": "mocha build/esm/system-test --timeout 80000",
        compile: "tsc -b ./tsconfig.json ./tsconfig.cjs.json && node utils/enable-esm.mjs",
        fix: "gts fix",
        prepare: "npm run compile",
        pretest: "npm run compile",
        webpack: "webpack",
        "prebrowser-test": "npm run compile",
        "browser-test": "node build/browser-test/browser-test-runner.js",
        docs: "jsdoc -c .jsdoc.js",
        "docs-test": "linkinator docs",
        "predocs-test": "npm run docs",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        prelint: "cd samples; npm link ../; npm install",
        clean: "gts clean"
      },
      repository: {
        type: "git",
        directory: "packages/gaxios",
        url: "https://github.com/googleapis/google-cloud-node-core.git"
      },
      keywords: [
        "google"
      ],
      engines: {
        node: ">=18"
      },
      author: "Google, LLC",
      license: "Apache-2.0",
      devDependencies: {
        "@babel/plugin-proposal-private-methods": "^7.18.6",
        "@types/cors": "^2.8.6",
        "@types/express": "^5.0.0",
        "@types/extend": "^3.0.1",
        "@types/mocha": "^10.0.10",
        "@types/multiparty": "4.2.1",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^22.0.0",
        "@types/sinon": "^17.0.0",
        "@types/tmp": "0.2.6",
        assert: "^2.0.0",
        browserify: "^17.0.0",
        c8: "^10.0.0",
        cors: "^2.8.5",
        express: "^5.0.0",
        gts: "^6.0.0",
        "is-docker": "^3.0.0",
        jsdoc: "^4.0.0",
        "jsdoc-fresh": "^5.0.0",
        "jsdoc-region-tag": "^4.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-remap-coverage": "^0.1.5",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "^5.0.1",
        linkinator: "^6.1.2",
        mocha: "^11.1.0",
        multiparty: "^4.2.1",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^14.0.0-beta.13",
        "null-loader": "^4.0.0",
        "pack-n-play": "^4.0.0",
        puppeteer: "^24.0.0",
        sinon: "^21.0.0",
        "stream-browserify": "^3.0.0",
        tmp: "0.2.5",
        "ts-loader": "^9.5.2",
        typescript: "^5.8.3",
        webpack: "^5.35.0",
        "webpack-cli": "^6.0.1"
      },
      dependencies: {
        extend: "^3.0.2",
        "https-proxy-agent": "^7.0.1",
        "node-fetch": "^3.3.2",
        rimraf: "^5.0.1"
      },
      homepage: "https://github.com/googleapis/google-cloud-node-core/tree/main/packages/gaxios"
    };
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/util.cjs
var require_util = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/util.cjs"(exports2, module2) {
    "use strict";
    var pkg = require_package();
    module2.exports = { pkg };
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/common.js
var require_common2 = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/common.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GaxiosError = exports2.GAXIOS_ERROR_SYMBOL = void 0;
    exports2.defaultErrorRedactor = defaultErrorRedactor;
    var extend_1 = __importDefault(require_extend());
    var util_cjs_1 = __importDefault(require_util());
    var pkg = util_cjs_1.default.pkg;
    exports2.GAXIOS_ERROR_SYMBOL = Symbol.for(`${pkg.name}-gaxios-error`);
    var _a4;
    var GaxiosError = class _GaxiosError extends Error {
      constructor(message, config, response, cause) {
        var _a5, _b;
        super(message, { cause });
        __publicField(this, "config");
        __publicField(this, "response");
        /**
         * An error code.
         * Can be a system error code, DOMException error name, or any error's 'code' property where it is a `string`.
         *
         * It is only a `number` when the cause is sourced from an API-level error (AIP-193).
         *
         * @see {@link https://nodejs.org/api/errors.html#errorcode error.code}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMException#error_names DOMException#error_names}
         * @see {@link https://google.aip.dev/193#http11json-representation AIP-193}
         *
         * @example
         * 'ECONNRESET'
         *
         * @example
         * 'TimeoutError'
         *
         * @example
         * 500
         */
        __publicField(this, "code");
        /**
         * An HTTP Status code.
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Response/status Response#status}
         *
         * @example
         * 500
         */
        __publicField(this, "status");
        /**
         * @deprecated use {@link GaxiosError.cause} instead.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause Error#cause}
         *
         * @privateRemarks
         *
         * We will want to remove this property later as the modern `cause` property is better suited
         * for displaying and relaying nested errors. Keeping this here makes the resulting
         * error log larger than it needs to be.
         *
         */
        __publicField(this, "error");
        /**
         * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
         *
         * @see {@link GAXIOS_ERROR_SYMBOL}
         * @see {@link GaxiosError[Symbol.hasInstance]}
         * @see {@link https://github.com/microsoft/TypeScript/issues/13965#issuecomment-278570200}
         * @see {@link https://stackoverflow.com/questions/46618852/require-and-instanceof}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/@@hasInstance#reverting_to_default_instanceof_behavior}
         */
        __publicField(this, _a4, pkg.version);
        this.config = config;
        this.response = response;
        this.error = cause instanceof Error ? cause : void 0;
        this.config = (0, extend_1.default)(true, {}, config);
        if (this.response) {
          this.response.config = (0, extend_1.default)(true, {}, this.response.config);
        }
        if (this.response) {
          try {
            this.response.data = translateData(
              this.config.responseType,
              // workaround for `node-fetch`'s `.data` deprecation...
              ((_a5 = this.response) == null ? void 0 : _a5.bodyUsed) ? (_b = this.response) == null ? void 0 : _b.data : void 0
            );
          } catch (e2) {
          }
          this.status = this.response.status;
        }
        if (cause instanceof DOMException) {
          this.code = cause.name;
        } else if (cause && typeof cause === "object" && "code" in cause && (typeof cause.code === "string" || typeof cause.code === "number")) {
          this.code = cause.code;
        }
      }
      /**
       * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
       *
       * @see {@link GAXIOS_ERROR_SYMBOL}
       * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
       */
      static [(_a4 = exports2.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](instance) {
        if (instance && typeof instance === "object" && exports2.GAXIOS_ERROR_SYMBOL in instance && instance[exports2.GAXIOS_ERROR_SYMBOL] === pkg.version) {
          return true;
        }
        return Function.prototype[Symbol.hasInstance].call(_GaxiosError, instance);
      }
      /**
       * An AIP-193 conforming error extractor.
       *
       * @see {@link https://google.aip.dev/193#http11json-representation AIP-193}
       *
       * @internal
       * @expiremental
       *
       * @param res the response object
       * @returns the extracted error information
       */
      static extractAPIErrorFromResponse(res, defaultErrorMessage = "The request failed") {
        let message = defaultErrorMessage;
        if (typeof res.data === "string") {
          message = res.data;
        }
        if (res.data && typeof res.data === "object" && "error" in res.data && res.data.error && !res.ok) {
          if (typeof res.data.error === "string") {
            return {
              message: res.data.error,
              code: res.status,
              status: res.statusText
            };
          }
          if (typeof res.data.error === "object") {
            message = "message" in res.data.error && typeof res.data.error.message === "string" ? res.data.error.message : message;
            const status = "status" in res.data.error && typeof res.data.error.status === "string" ? res.data.error.status : res.statusText;
            const code = "code" in res.data.error && typeof res.data.error.code === "number" ? res.data.error.code : res.status;
            if ("errors" in res.data.error && Array.isArray(res.data.error.errors)) {
              const errorMessages = [];
              for (const e2 of res.data.error.errors) {
                if (typeof e2 === "object" && "message" in e2 && typeof e2.message === "string") {
                  errorMessages.push(e2.message);
                }
              }
              return Object.assign({
                message: errorMessages.join("\n") || message,
                code,
                status
              }, res.data.error);
            }
            return Object.assign({
              message,
              code,
              status
            }, res.data.error);
          }
        }
        return {
          message,
          code: res.status,
          status: res.statusText
        };
      }
    };
    exports2.GaxiosError = GaxiosError;
    function translateData(responseType, data) {
      switch (responseType) {
        case "stream":
          return data;
        case "json":
          return JSON.parse(JSON.stringify(data));
        case "arraybuffer":
          return JSON.parse(Buffer.from(data).toString("utf8"));
        case "blob":
          return JSON.parse(data.text());
        default:
          return data;
      }
    }
    function defaultErrorRedactor(data) {
      const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
      function redactHeaders(headers) {
        if (!headers)
          return;
        headers.forEach((_, key) => {
          if (/^authentication$/i.test(key) || /^authorization$/i.test(key) || /secret/i.test(key))
            headers.set(key, REDACT);
        });
      }
      function redactString(obj, key) {
        if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
          const text = obj[key];
          if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) {
            obj[key] = REDACT;
          }
        }
      }
      function redactObject(obj) {
        if (!obj || typeof obj !== "object") {
          return;
        } else if (obj instanceof FormData || obj instanceof URLSearchParams || // support `node-fetch` FormData/URLSearchParams
        "forEach" in obj && "set" in obj) {
          obj.forEach((_, key) => {
            if (["grant_type", "assertion"].includes(key) || /secret/.test(key)) {
              obj.set(key, REDACT);
            }
          });
        } else {
          if ("grant_type" in obj) {
            obj["grant_type"] = REDACT;
          }
          if ("assertion" in obj) {
            obj["assertion"] = REDACT;
          }
          if ("client_secret" in obj) {
            obj["client_secret"] = REDACT;
          }
        }
      }
      if (data.config) {
        redactHeaders(data.config.headers);
        redactString(data.config, "data");
        redactObject(data.config.data);
        redactString(data.config, "body");
        redactObject(data.config.body);
        if (data.config.url.searchParams.has("token")) {
          data.config.url.searchParams.set("token", REDACT);
        }
        if (data.config.url.searchParams.has("client_secret")) {
          data.config.url.searchParams.set("client_secret", REDACT);
        }
      }
      if (data.response) {
        defaultErrorRedactor({ config: data.response.config });
        redactHeaders(data.response.headers);
        if (data.response.bodyUsed) {
          redactString(data.response, "data");
          redactObject(data.response.data);
        }
      }
      return data;
    }
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/retry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRetryConfig = getRetryConfig;
    function getRetryConfig(err) {
      return __async(this, null, function* () {
        let config = getConfig(err);
        if (!err || !err.config || !config && !err.config.retry) {
          return { shouldRetry: false };
        }
        config = config || {};
        config.currentRetryAttempt = config.currentRetryAttempt || 0;
        config.retry = config.retry === void 0 || config.retry === null ? 3 : config.retry;
        config.httpMethodsToRetry = config.httpMethodsToRetry || [
          "GET",
          "HEAD",
          "PUT",
          "OPTIONS",
          "DELETE"
        ];
        config.noResponseRetries = config.noResponseRetries === void 0 || config.noResponseRetries === null ? 2 : config.noResponseRetries;
        config.retryDelayMultiplier = config.retryDelayMultiplier ? config.retryDelayMultiplier : 2;
        config.timeOfFirstRequest = config.timeOfFirstRequest ? config.timeOfFirstRequest : Date.now();
        config.totalTimeout = config.totalTimeout ? config.totalTimeout : Number.MAX_SAFE_INTEGER;
        config.maxRetryDelay = config.maxRetryDelay ? config.maxRetryDelay : Number.MAX_SAFE_INTEGER;
        const retryRanges = [
          // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
          // 1xx - Retry (Informational, request still processing)
          // 2xx - Do not retry (Success)
          // 3xx - Do not retry (Redirect)
          // 4xx - Do not retry (Client errors)
          // 408 - Retry ("Request Timeout")
          // 429 - Retry ("Too Many Requests")
          // 5xx - Retry (Server errors)
          [100, 199],
          [408, 408],
          [429, 429],
          [500, 599]
        ];
        config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;
        err.config.retryConfig = config;
        const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
        if (!(yield shouldRetryFn(err))) {
          return { shouldRetry: false, config: err.config };
        }
        const delay2 = getNextRetryDelay(config);
        err.config.retryConfig.currentRetryAttempt += 1;
        const backoff = config.retryBackoff ? config.retryBackoff(err, delay2) : new Promise((resolve3) => {
          setTimeout(resolve3, delay2);
        });
        if (config.onRetryAttempt) {
          yield config.onRetryAttempt(err);
        }
        yield backoff;
        return { shouldRetry: true, config: err.config };
      });
    }
    function shouldRetryRequest(err) {
      var _a4, _b;
      const config = getConfig(err);
      if (((_a4 = err.config.signal) == null ? void 0 : _a4.aborted) && err.code !== "TimeoutError" || err.code === "AbortError") {
        return false;
      }
      if (!config || config.retry === 0) {
        return false;
      }
      if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
        return false;
      }
      if (!config.httpMethodsToRetry || !config.httpMethodsToRetry.includes(((_b = err.config.method) == null ? void 0 : _b.toUpperCase()) || "GET")) {
        return false;
      }
      if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config.statusCodesToRetry) {
          const status = err.response.status;
          if (status >= min && status <= max) {
            isInRange = true;
            break;
          }
        }
        if (!isInRange) {
          return false;
        }
      }
      config.currentRetryAttempt = config.currentRetryAttempt || 0;
      if (config.currentRetryAttempt >= config.retry) {
        return false;
      }
      return true;
    }
    function getConfig(err) {
      if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
      }
      return;
    }
    function getNextRetryDelay(config) {
      var _a4;
      const retryDelay = config.currentRetryAttempt ? 0 : (_a4 = config.retryDelay) != null ? _a4 : 100;
      const calculatedDelay = retryDelay + (Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) / 2 * 1e3;
      const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
      return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
    }
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/interceptor.js
var require_interceptor = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/interceptor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GaxiosInterceptorManager = void 0;
    var GaxiosInterceptorManager = class extends Set {
    };
    exports2.GaxiosInterceptorManager = GaxiosInterceptorManager;
  }
});

// ../../node_modules/.pnpm/agent-base@7.1.3/node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/agent-base@7.1.3/node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http3 = __importStar(require("http"));
    var https2 = __importStar(require("https"));
    function toBuffer2(stream) {
      return __async(this, null, function* () {
        let length = 0;
        const chunks = [];
        try {
          for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const chunk = temp.value;
            length += chunk.length;
            chunks.push(chunk);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return Buffer.concat(chunks, length);
      });
    }
    exports2.toBuffer = toBuffer2;
    function json(stream) {
      return __async(this, null, function* () {
        const buf = yield toBuffer2(stream);
        const str = buf.toString("utf8");
        try {
          return JSON.parse(str);
        } catch (_err) {
          const err = _err;
          err.message += ` (input: ${str})`;
          throw err;
        }
      });
    }
    exports2.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https2 : http3).request(url, opts);
      const promise = new Promise((resolve3, reject) => {
        req2.once("response", resolve3).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// ../../node_modules/.pnpm/agent-base@7.1.3/node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/agent-base@7.1.3/node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net2 = __importStar(require("net"));
    var http3 = __importStar(require("http"));
    var https_1 = require("https");
    __exportStar(require_helpers(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http3.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net2.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = __spreadProps(__spreadValues({}, options), {
          secureEndpoint: this.isSecureEndpoint(options)
        });
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http3.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        var _a4;
        return (_a4 = this[INTERNAL].defaultPort) != null ? _a4 : this.protocol === "https:" ? 443 : 80;
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        var _a4;
        return (_a4 = this[INTERNAL].protocol) != null ? _a4 : this.isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent;
  }
});

// ../../node_modules/.pnpm/https-proxy-agent@7.0.6/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "../../node_modules/.pnpm/https-proxy-agent@7.0.6/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_src());
    var debug2 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve3, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug2("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug2("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug2("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug2("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve3({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// ../../node_modules/.pnpm/https-proxy-agent@7.0.6/node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/https-proxy-agent@7.0.6/node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net2 = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug2 = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net2.isIP(options.host)) {
        return __spreadProps(__spreadValues({}, options), {
          servername: options.host
        });
      }
      return options;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        var _a4;
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = (_a4 = opts == null ? void 0 : opts.headers) != null ? _a4 : {};
        debug2("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = __spreadProps(__spreadValues({
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"]
        }, opts ? omit(opts, "headers") : null), {
          host,
          port
        });
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      connect(req, opts) {
        return __async(this, null, function* () {
          const { proxy } = this;
          if (!opts.host) {
            throw new TypeError('No "host" provided');
          }
          let socket;
          if (proxy.protocol === "https:") {
            debug2("Creating `tls.Socket`: %o", this.connectOpts);
            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
          } else {
            debug2("Creating `net.Socket`: %o", this.connectOpts);
            socket = net2.connect(this.connectOpts);
          }
          const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : __spreadValues({}, this.proxyHeaders);
          const host = net2.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
          let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
          if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
          }
          headers.Host = `${host}:${opts.port}`;
          if (!headers["Proxy-Connection"]) {
            headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
          }
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
          socket.write(`${payload}\r
`);
          const { connect, buffered } = yield proxyResponsePromise;
          req.emit("proxyConnect", connect);
          this.emit("proxyConnect", connect, req);
          if (connect.statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug2("Upgrading socket connection to TLS");
              return tls.connect(__spreadProps(__spreadValues({}, omit(setServernameFromNonIpHost(opts), "host", "path", "port")), {
                socket
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net2.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s2) => {
            debug2("Replaying proxy buffer for failed request");
            (0, assert_1.default)(s2.listenerCount("data") > 0);
            s2.push(buffered);
            s2.push(null);
          });
          return fakeSocket;
        });
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/data-uri-to-buffer@4.0.1/node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base64 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default;
var init_dist = __esm({
  "../../node_modules/.pnpm/data-uri-to-buffer@4.0.1/node_modules/data-uri-to-buffer/dist/index.js"() {
    dist_default = dataUriToBuffer;
  }
});

// ../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS({
  "../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"(exports2, module2) {
    (function(global2, factory6) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory6(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory6) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory6(global2.WebStreamsPolyfill = {}));
    })(exports2, (function(exports3) {
      "use strict";
      function noop3() {
        return void 0;
      }
      function typeIsObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      const rethrowAssertionErrorRejection = noop3;
      function setFunctionName(fn, name) {
        try {
          Object.defineProperty(fn, "name", {
            value: name,
            configurable: true
          });
        } catch (_a5) {
        }
      }
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise((resolve3) => resolve3(value));
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      let _queueMicrotask = (callback) => {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          const resolvedPromise = promiseResolvedWith(void 0);
          _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F2, V, args) {
        if (typeof F2 !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F2, V, args);
      }
      function promiseCall(F2, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F2, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
          let i2 = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i2 !== elements.length || node._next !== void 0) {
            if (i2 === elements.length) {
              node = node._next;
              elements = node._elements;
              i2 = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i2]);
            ++i2;
          }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      const AbortSteps = Symbol("[[AbortSteps]]");
      const ErrorSteps = Symbol("[[ErrorSteps]]");
      const CancelSteps = Symbol("[[CancelSteps]]");
      const PullSteps = Symbol("[[PullSteps]]");
      const ReleaseSteps = Symbol("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve3, reject) => {
          reader._closedPromise_resolve = resolve3;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const NumberIsFinite = Number.isFinite || function(x2) {
        return typeof x2 === "number" && isFinite(x2);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x2) {
        return typeof x2 === "object" || typeof x2 === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x2, context) {
        if (typeof x2 !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
      }
      function assertObject(x2, context) {
        if (!isObject(x2)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x2, position, context) {
        if (x2 === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x2, field, context) {
        if (x2 === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function integerPart(x2) {
        return censorNegativeZero(MathTrunc(x2));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x2 = Number(value);
        x2 = censorNegativeZero(x2);
        if (!NumberIsFinite(x2)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x2 = integerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x2) || x2 === 0) {
          return 0;
        }
        return x2;
      }
      function assertReadableStream(x2, context) {
        if (!IsReadableStream(x2)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve3, reject) => {
            resolvePromise = resolve3;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamDefaultReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e2) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach((readRequest) => {
          readRequest._errorSteps(e2);
        });
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
      }
      const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(function() {
        return __asyncGenerator(this, null, function* () {
        });
      }).prototype);
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve3, reject) => {
            resolvePromise = resolve3;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a5) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x2) {
        return x2 !== x2;
      };
      var _a4, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = (buffer) => buffer.transfer();
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
        } else {
          TransferArrayBuffer = (buffer) => buffer;
        }
        return TransferArrayBuffer(O);
      };
      let IsDetachedBuffer = (O) => {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = (buffer) => buffer.detached;
        } else {
          IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        const syncIterable = {
          [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        const asyncIterator = (function() {
          return __asyncGenerator(this, null, function* () {
            return yield* __yieldStar(syncIterable);
          });
        })();
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
      }
      const SymbolAsyncIterator = (_c = (_a4 = Symbol.asyncIterator) !== null && _a4 !== void 0 ? _a4 : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint = "sync", method) {
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              const syncMethod = GetMethod(obj, Symbol.iterator);
              const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, Symbol.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view) {
        return isDataViewConstructor(view.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer)) {
            throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
          }
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer)) {
            throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              minimumFill: 1,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
          if (this._pendingPullIntos.length > 0) {
            const firstPullInto = this._pendingPullIntos.peek();
            firstPullInto.readerType = "none";
            this._pendingPullIntos = new SimpleQueue();
            this._pendingPullIntos.push(firstPullInto);
          }
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController.prototype.close, "close");
      setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
          return false;
        }
        return x2 instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableByteStreamControllerError(controller, e2);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
          buffer = TransferArrayBuffer(view.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        const pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableByteStreamControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertByobReadOptions(options, context) {
        var _a5;
        assertDictionary(options, context);
        const min = (_a5 = options === null || options === void 0 ? void 0 : options.min) !== null && _a5 !== void 0 ? _a5 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer)) {
            return promiseRejectedWith(new TypeError("view's buffer has been detached"));
          }
          let options;
          try {
            options = convertByobReadOptions(rawOptions, "options");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const min = options.min;
          if (min === 0) {
            return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
          }
          if (!isDataView(view)) {
            if (min > view.length) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
            }
          } else if (min > view.byteLength) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve3, reject) => {
            resolvePromise = resolve3;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e2) => rejectPromise(e2)
          };
          ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
          return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          ReadableStreamBYOBReaderRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
          return false;
        }
        return x2 instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e2 = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._errorSteps(e2);
        });
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x2, context) {
        if (!IsWritableStream(x2)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal2(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a5) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream.prototype.abort, "abort");
      setFunctionName(WritableStream.prototype.close, "close");
      setFunctionName(WritableStream.prototype.getWriter, "getWriter");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
          return false;
        }
        return x2 instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a5;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a5 = stream._writableStreamController._abortController) === null || _a5 === void 0 ? void 0 : _a5.abort(reason);
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve3, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve3,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve3, reject) => {
          const closeRequest = {
            _resolve: resolve3,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve3, reject) => {
          const writeRequest = {
            _resolve: resolve3,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writers lock is released before the stream finishes closing.
         */
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writers lock is released.
         */
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e2 = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
          return false;
        }
        return x2 instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (r2) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r2);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        } else {
          writeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        } else {
          closeAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        } else {
          abortAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
          return null;
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve3, reject) => {
          writer._closedPromise_resolve = resolve3;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve3, reject) => {
          writer._readyPromise_resolve = resolve3;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a5) {
          return false;
        }
      }
      function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        const ctor = function DOMException4(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException3 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve3, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = signal.reason !== void 0 ? signal.reason : new DOMException3("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              return null;
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve3(void 0);
            }
            return null;
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e2 = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        }
        /** @internal */
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
        /** @internal */
        [ReleaseSteps]() {
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
          return false;
        }
        return x2 instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, (e2) => {
          ReadableStreamDefaultControllerError(controller, e2);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(controller, r2);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        } else {
          startAlgorithm = () => void 0;
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        } else {
          pullAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve3) => {
          resolveCancelPromise = resolve3;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r2) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve3) => {
          resolveCancelPromise = resolve3;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r2) => {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r2);
            ReadableByteStreamControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              _queueMicrotask(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, "async");
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            const done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          const iterator = iteratorRecord.iterator;
          let returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          let returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          const returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, (iterResult) => {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop3;
        function pullAlgorithm() {
          let readPromise;
          try {
            readPromise = reader.read();
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          return transformPromiseWith(readPromise, (readResult) => {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream._readableStreamController);
            } else {
              const value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal2(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream2 {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
          return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
          return ReadableStreamFrom(asyncIterable);
        }
      }
      Object.defineProperties(ReadableStream2, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream2.from, "from");
      setFunctionName(ReadableStream2.prototype.cancel, "cancel");
      setFunctionName(ReadableStream2.prototype.getReader, "getReader");
      setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream2.prototype.tee, "tee");
      setFunctionName(ReadableStream2.prototype.values, "values");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
          return false;
        }
        return x2 instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          const readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop3);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          const readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e2);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e2);
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x2 instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      class TransformStream2 {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve3) => {
            startPromise_resolve = resolve3;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream2.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStream2.prototype, Symbol.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
          return false;
        }
        return x2 instanceof TransformStream2;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        TransformStreamUnblockWrite(stream);
      }
      function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve3) => {
          stream._backpressureChangePromise_resolve = resolve3;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        /**
         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
      if (typeof Symbol.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x2) {
        if (!typeIsObject(x2)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
          return false;
        }
        return x2 instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        } else {
          transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        } else {
          flushAlgorithm = () => promiseResolvedWith(void 0);
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = (reason) => transformer.cancel(reason);
        } else {
          cancelAlgorithm = () => promiseResolvedWith(void 0);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r2) => {
          TransformStreamError(controller._controlledTransformStream, r2);
          throw r2;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve3, reject) => {
          controller._finishPromise_resolve = resolve3;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const readable = stream._readable;
        controller._finishPromise = newPromise((resolve3, reject) => {
          controller._finishPromise_resolve = resolve3;
          controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r2);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        const writable = stream._writable;
        controller._finishPromise = newPromise((resolve3, reject) => {
          controller._finishPromise_resolve = resolve3;
          controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, (r2) => {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r2);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseReject(controller, r2);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream2;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    }));
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs"() {
    var POOL_SIZE2 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process4 = require("process");
        const { emitWarning } = process4;
        try {
          process4.emitWarning = () => {
          };
          Object.assign(globalThis, require("stream/web"));
          process4.emitWarning = emitWarning;
        } catch (error) {
          process4.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, require_ponyfill_es2018());
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            pull(ctrl) {
              return __async(this, null, function* () {
                const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE2));
                const buffer = yield chunk.arrayBuffer();
                position += buffer.byteLength;
                ctrl.enqueue(new Uint8Array(buffer));
                if (position === blob.size) {
                  ctrl.close();
                }
              });
            }
          });
        };
      }
    } catch (error) {
    }
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js
function toIterator(parts, clone2 = true) {
  return __asyncGenerator(this, null, function* () {
    for (const part of parts) {
      if ("stream" in part) {
        yield* __yieldStar(
          /** @type {AsyncIterableIterator<Uint8Array>} */
          part.stream()
        );
      } else if (ArrayBuffer.isView(part)) {
        if (clone2) {
          let position = part.byteOffset;
          const end = part.byteOffset + part.byteLength;
          while (position !== end) {
            const size = Math.min(end - position, POOL_SIZE);
            const chunk = part.buffer.slice(position, position + size);
            position += chunk.byteLength;
            yield new Uint8Array(chunk);
          }
        } else {
          yield part;
        }
      } else {
        let position = 0, b = (
          /** @type {Blob} */
          part
        );
        while (position !== b.size) {
          const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
          const buffer = yield new __await(chunk.arrayBuffer());
          position += buffer.byteLength;
          yield new Uint8Array(buffer);
        }
      }
    }
  });
}
var import_streams, POOL_SIZE, _parts, _type, _size, _endings, _a, _Blob, Blob2, fetch_blob_default;
var init_fetch_blob = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js"() {
    import_streams = __toESM(require_streams(), 1);
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        /** @type {Array.<(Blob|Uint8Array)>} */
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        __privateAdd(this, _endings, "transparent");
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null) options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder.encode(`${element}`);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        __privateSet(this, _endings, `${options.endings === void 0 ? "transparent" : options.endings}`);
        const type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return __privateGet(this, _type);
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      text() {
        return __async(this, null, function* () {
          const decoder = new TextDecoder();
          let str = "";
          try {
            for (var iter = __forAwait(toIterator(__privateGet(this, _parts), false)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const part = temp.value;
              str += decoder.decode(part, { stream: true });
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          str += decoder.decode();
          return str;
        });
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      arrayBuffer() {
        return __async(this, null, function* () {
          const data = new Uint8Array(this.size);
          let offset = 0;
          try {
            for (var iter = __forAwait(toIterator(__privateGet(this, _parts), false)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const chunk = temp.value;
              data.set(chunk, offset);
              offset += chunk.length;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          return data.buffer;
        });
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          pull(ctrl) {
            return __async(this, null, function* () {
              const chunk = yield it.next();
              chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
            });
          },
          cancel() {
            return __async(this, null, function* () {
              yield it.return();
            });
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _endings = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    fetch_blob_default = Blob2;
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js
var _lastModified, _name, _a2, _File, File2, file_default;
var init_file = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js"() {
    init_fetch_blob();
    _File = (_a2 = class extends fetch_blob_default {
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        if (options === null) options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __privateSet(this, _lastModified, lastModified);
        }
        __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof fetch_blob_default && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2);
    File2 = _File;
    file_default = File2;
  }
});

// ../../node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F2, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(new RegExp("\\r(?!\\n)|(?<!\\r)\\n", "g"), "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t, i, h, r, m, f, e, x, _d, _a3, FormData2;
var init_esm_min = __esm({
  "../../node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js"() {
    init_fetch_blob();
    init_file();
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData2 = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        __privateGet(this, _d).push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this) a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        __privateSet(this, _d, b);
      }
      *entries() {
        yield* __yieldStar(__privateGet(this, _d));
      }
      *keys() {
        for (var [a] of this) yield a;
      }
      *values() {
        for (var [, a] of this) yield a;
      }
    }, _d = new WeakMap(), _a3);
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/base.js
var FetchBaseError;
var init_base = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/base.js"() {
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/fetch-error.js
var FetchError;
var init_fetch_error = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/fetch-error.js"() {
    init_base();
    FetchError = class extends FetchBaseError {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} [type] -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is.js
var NAME, isURLSearchParameters, isBlob, isAbortSignal, isDomainOrSubdomain, isSameProtocol;
var init_is = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is.js"() {
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    isDomainOrSubdomain = (destination, original) => {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    };
    isSameProtocol = (destination, original) => {
      const orig = new URL(original).protocol;
      const dest = new URL(destination).protocol;
      return orig === dest;
    };
  }
});

// ../../node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js
var require_node_domexception = __commonJS({
  "../../node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js"(exports2, module2) {
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    module2.exports = globalThis.DOMException;
  }
});

// ../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js
var import_node_fs2, import_node_path2, import_node_domexception, stat, blobFromSync, blobFrom, fileFrom, fileFromSync, fromBlob, fromFile, _path, _start, _BlobDataItem, BlobDataItem;
var init_from = __esm({
  "../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js"() {
    import_node_fs2 = require("fs");
    import_node_path2 = require("path");
    import_node_domexception = __toESM(require_node_domexception(), 1);
    init_file();
    init_fetch_blob();
    ({ stat } = import_node_fs2.promises);
    blobFromSync = (path8, type) => fromBlob((0, import_node_fs2.statSync)(path8), path8, type);
    blobFrom = (path8, type) => stat(path8).then((stat2) => fromBlob(stat2, path8, type));
    fileFrom = (path8, type) => stat(path8).then((stat2) => fromFile(stat2, path8, type));
    fileFromSync = (path8, type) => fromFile((0, import_node_fs2.statSync)(path8), path8, type);
    fromBlob = (stat2, path8, type = "") => new fetch_blob_default([new BlobDataItem({
      path: path8,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], { type });
    fromFile = (stat2, path8, type = "") => new file_default([new BlobDataItem({
      path: path8,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], (0, import_node_path2.basename)(path8), { type, lastModified: stat2.mtimeMs });
    _BlobDataItem = class _BlobDataItem {
      constructor(options) {
        __privateAdd(this, _path);
        __privateAdd(this, _start);
        __privateSet(this, _path, options.path);
        __privateSet(this, _start, options.start);
        this.size = options.size;
        this.lastModified = options.lastModified;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new _BlobDataItem({
          path: __privateGet(this, _path),
          lastModified: this.lastModified,
          size: end - start,
          start: __privateGet(this, _start) + start
        });
      }
      stream() {
        return __asyncGenerator(this, null, function* () {
          const { mtimeMs } = yield new __await(stat(__privateGet(this, _path)));
          if (mtimeMs > this.lastModified) {
            throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
          }
          yield* __yieldStar((0, import_node_fs2.createReadStream)(__privateGet(this, _path), {
            start: __privateGet(this, _start),
            end: __privateGet(this, _start) + this.size - 1
          }));
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    _path = new WeakMap();
    _start = new WeakMap();
    BlobDataItem = _BlobDataItem;
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
function toFormData(Body2, ct) {
  return __async(this, null, function* () {
    if (!/multipart/i.test(ct)) {
      throw new TypeError("Failed to fetch");
    }
    const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
    if (!m2) {
      throw new TypeError("no or bad content-type header, no multipart boundary");
    }
    const parser = new MultipartParser(m2[1] || m2[2]);
    let headerField;
    let headerValue;
    let entryValue;
    let entryName;
    let contentType;
    let filename;
    const entryChunks = [];
    const formData = new FormData2();
    const onPartData = (ui8a) => {
      entryValue += decoder.decode(ui8a, { stream: true });
    };
    const appendToFile = (ui8a) => {
      entryChunks.push(ui8a);
    };
    const appendFileToFormData = () => {
      const file = new file_default(entryChunks, filename, { type: contentType });
      formData.append(entryName, file);
    };
    const appendEntryToFormData = () => {
      formData.append(entryName, entryValue);
    };
    const decoder = new TextDecoder("utf-8");
    decoder.decode();
    parser.onPartBegin = function() {
      parser.onPartData = onPartData;
      parser.onPartEnd = appendEntryToFormData;
      headerField = "";
      headerValue = "";
      entryValue = "";
      entryName = "";
      contentType = "";
      filename = null;
      entryChunks.length = 0;
    };
    parser.onHeaderField = function(ui8a) {
      headerField += decoder.decode(ui8a, { stream: true });
    };
    parser.onHeaderValue = function(ui8a) {
      headerValue += decoder.decode(ui8a, { stream: true });
    };
    parser.onHeaderEnd = function() {
      headerValue += decoder.decode();
      headerField = headerField.toLowerCase();
      if (headerField === "content-disposition") {
        const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
        if (m3) {
          entryName = m3[2] || m3[3] || "";
        }
        filename = _fileName(headerValue);
        if (filename) {
          parser.onPartData = appendToFile;
          parser.onPartEnd = appendFileToFormData;
        }
      } else if (headerField === "content-type") {
        contentType = headerValue;
      }
      headerValue = "";
      headerField = "";
    };
    try {
      for (var iter = __forAwait(Body2), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const chunk = temp.value;
        parser.write(chunk);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    parser.end();
    return formData;
  });
}
var s, S, f2, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop2, MultipartParser;
var init_multipart_parser = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/multipart-parser.js"() {
    init_from();
    init_esm_min();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f2 = 1;
    F = {
      PART_BOUNDARY: f2,
      LAST_BOUNDARY: f2 *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop2 = () => {
    };
    MultipartParser = class {
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop2;
        this.onHeaderField = noop2;
        this.onHeadersEnd = noop2;
        this.onHeaderValue = noop2;
        this.onPartBegin = noop2;
        this.onPartData = noop2;
        this.onPartEnd = noop2;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark2 = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear2 = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear3) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear3) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark2("onHeaderField");
              index = 0;
            // falls through
            case S.HEADER_FIELD:
              if (c === CR) {
                clear2("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark2("onHeaderValue");
              state = S.HEADER_VALUE;
            // falls through
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark2("onPartData");
            // falls through
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark2("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/body.js
function consumeBody(data) {
  return __async(this, null, function* () {
    if (data[INTERNALS].disturbed) {
      throw new TypeError(`body used already for: ${data.url}`);
    }
    data[INTERNALS].disturbed = true;
    if (data[INTERNALS].error) {
      throw data[INTERNALS].error;
    }
    const { body } = data;
    if (body === null) {
      return import_node_buffer.Buffer.alloc(0);
    }
    if (!(body instanceof import_node_stream2.default)) {
      return import_node_buffer.Buffer.alloc(0);
    }
    const accum = [];
    let accumBytes = 0;
    try {
      try {
        for (var iter = __forAwait(body), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const chunk = temp.value;
          if (data.size > 0 && accumBytes + chunk.length > data.size) {
            const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
            body.destroy(error2);
            throw error2;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    } catch (error2) {
      const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
      throw error_;
    }
    if (body.readableEnded === true || body._readableState.ended === true) {
      try {
        if (accum.every((c) => typeof c === "string")) {
          return import_node_buffer.Buffer.from(accum.join(""));
        }
        return import_node_buffer.Buffer.concat(accum, accumBytes);
      } catch (error2) {
        throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
      }
    } else {
      throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
    }
  });
}
var import_node_stream2, import_node_util, import_node_buffer, pipeline, INTERNALS, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream;
var init_body = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/body.js"() {
    import_node_stream2 = __toESM(require("stream"), 1);
    import_node_util = require("util");
    import_node_buffer = require("buffer");
    init_fetch_blob();
    init_esm_min();
    init_fetch_error();
    init_base();
    init_is();
    pipeline = (0, import_node_util.promisify)(import_node_stream2.default.pipeline);
    INTERNALS = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = import_node_buffer.Buffer.from(body.toString());
        } else if (isBlob(body)) {
        } else if (import_node_buffer.Buffer.isBuffer(body)) {
        } else if (import_node_util.types.isAnyArrayBuffer(body)) {
          body = import_node_buffer.Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = import_node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream2.default) {
        } else if (body instanceof FormData2) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = import_node_buffer.Buffer.from(String(body));
        }
        let stream = body;
        if (import_node_buffer.Buffer.isBuffer(body)) {
          stream = import_node_stream2.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream2.default.Readable.from(body.stream());
        }
        this[INTERNALS] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream2.default) {
          body.on("error", (error_) => {
            const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS].error = error;
          });
        }
      }
      get body() {
        return this[INTERNALS].stream;
      }
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return __async(this, null, function* () {
          const { buffer, byteOffset, byteLength } = yield consumeBody(this);
          return buffer.slice(byteOffset, byteOffset + byteLength);
        });
      }
      formData() {
        return __async(this, null, function* () {
          const ct = this.headers.get("content-type");
          if (ct.startsWith("application/x-www-form-urlencoded")) {
            const formData = new FormData2();
            const parameters = new URLSearchParams(yield this.text());
            for (const [name, value] of parameters) {
              formData.append(name, value);
            }
            return formData;
          }
          const { toFormData: toFormData2 } = yield Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
          return toFormData2(this.body, ct);
        });
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        return __async(this, null, function* () {
          const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
          const buf = yield this.arrayBuffer();
          return new fetch_blob_default([buf], {
            type: ct
          });
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        return __async(this, null, function* () {
          const text = yield this.text();
          return JSON.parse(text);
        });
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return __async(this, null, function* () {
          const buffer = yield consumeBody(this);
          return new TextDecoder().decode(buffer);
        });
      }
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
      data: { get: (0, import_node_util.deprecate)(
        () => {
        },
        "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
        "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
      ) }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream2.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream2.PassThrough({ highWaterMark });
        p2 = new import_node_stream2.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
      (body) => body.getBoundary(),
      "form-data doesn't follow the spec and requires special treatment. Use alternative package",
      "https://github.com/node-fetch/node-fetch/issues/1167"
    );
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (import_node_buffer.Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData2) {
        return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream2.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (import_node_buffer.Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (_0, _1) => __async(null, [_0, _1], function* (dest, { body }) {
      if (body === null) {
        dest.end();
      } else {
        yield pipeline(body, dest);
      }
    });
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/headers.js
function fromRawHeaders(headers = []) {
  return new Headers2(
    headers.reduce((result, value, index, array) => {
      if (index % 2 === 0) {
        result.push(array.slice(index, index + 2));
      }
      return result;
    }, []).filter(([name, value]) => {
      try {
        validateHeaderName(name);
        validateHeaderValue(name, String(value));
        return true;
      } catch (e2) {
        return false;
      }
    })
  );
}
var import_node_util2, import_node_http, validateHeaderName, validateHeaderValue, Headers2;
var init_headers = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/headers.js"() {
    import_node_util2 = require("util");
    import_node_http = __toESM(require("http"), 1);
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
        throw error;
      }
    };
    Headers2 = class _Headers extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init) {
        let result = [];
        if (init instanceof _Headers) {
          const raw = init.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init == null) {
        } else if (typeof init === "object" && !import_node_util2.types.isBoxedPrimitive(init)) {
          const method = init[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init].map((pair) => {
              if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(
                    target,
                    String(name).toLowerCase(),
                    String(value)
                  );
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(
                    target,
                    String(name).toLowerCase()
                  );
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      /**
       * @type {() => IterableIterator<[string, string]>}
       */
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(
      Headers2.prototype,
      ["get", "entries", "forEach", "values"].reduce((result, property) => {
        result[property] = { enumerable: true };
        return result;
      }, {})
    );
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus, isRedirect;
var init_is_redirect = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/is-redirect.js"() {
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/response.js
var INTERNALS2, Response;
var init_response = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/response.js"() {
    init_headers();
    init_body();
    init_is_redirect();
    INTERNALS2 = Symbol("Response internals");
    Response = class _Response extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS2] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS2].type;
      }
      get url() {
        return this[INTERNALS2].url || "";
      }
      get status() {
        return this[INTERNALS2].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
      }
      get redirected() {
        return this[INTERNALS2].counter > 0;
      }
      get statusText() {
        return this[INTERNALS2].statusText;
      }
      get headers() {
        return this[INTERNALS2].headers;
      }
      get highWaterMark() {
        return this[INTERNALS2].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new _Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new _Response(null, { status: 0, statusText: "" });
        response[INTERNALS2].type = "error";
        return response;
      }
      static json(data = void 0, init = {}) {
        const body = JSON.stringify(data);
        if (body === void 0) {
          throw new TypeError("data is not JSON serializable");
        }
        const headers = new Headers2(init && init.headers);
        if (!headers.has("content-type")) {
          headers.set("content-type", "application/json");
        }
        return new _Response(body, __spreadProps(__spreadValues({}, init), {
          headers
        }));
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/get-search.js
var getSearch;
var init_get_search = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/get-search.js"() {
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/referrer.js
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_node_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
var import_node_net, ReferrerPolicy, DEFAULT_REFERRER_POLICY;
var init_referrer = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/utils/referrer.js"() {
    import_node_net = require("net");
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/request.js
var import_node_url, import_node_util3, INTERNALS3, isRequest, doBadDataWarn, Request, getNodeRequestOptions;
var init_request = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/request.js"() {
    import_node_url = require("url");
    import_node_util3 = require("util");
    init_headers();
    init_body();
    init_is();
    init_get_search();
    init_referrer();
    INTERNALS3 = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS3] === "object";
    };
    doBadDataWarn = (0, import_node_util3.deprecate)(
      () => {
      },
      ".data is not a valid RequestInit property, use .body instead",
      "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
    );
    Request = class _Request extends Body {
      constructor(input, init = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
        }
        let method = init.method || input.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(method)) {
          method = method.toUpperCase();
        }
        if (!isRequest(init) && "data" in init) {
          doBadDataWarn();
        }
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init.size || input.size || 0
        });
        const headers = new Headers2(init.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) {
          signal = init.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init.referrer == null ? input.referrer : init.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS3] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
        this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
      }
      /** @returns {string} */
      get method() {
        return this[INTERNALS3].method;
      }
      /** @returns {string} */
      get url() {
        return (0, import_node_url.format)(this[INTERNALS3].parsedURL);
      }
      /** @returns {Headers} */
      get headers() {
        return this[INTERNALS3].headers;
      }
      get redirect() {
        return this[INTERNALS3].redirect;
      }
      /** @returns {AbortSignal} */
      get signal() {
        return this[INTERNALS3].signal;
      }
      // https://fetch.spec.whatwg.org/#dom-request-referrer
      get referrer() {
        if (this[INTERNALS3].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS3].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS3].referrer) {
          return this[INTERNALS3].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS3].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS3];
      const headers = new Headers2(request[INTERNALS3].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS3].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS3].referrer = "no-referrer";
      }
      if (request[INTERNALS3].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip, deflate, br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      const search = getSearch(parsedURL);
      const options = {
        // Overwrite search to retain trailing ? (issue #776)
        path: parsedURL.pathname + search,
        // The following options are not expressed in the URL
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        /** @type {URL} */
        parsedURL,
        options
      };
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/abort-error.js
var AbortError;
var init_abort_error = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/errors/abort-error.js"() {
    init_base();
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
  }
});

// ../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/index.js
var src_exports = {};
__export(src_exports, {
  AbortError: () => AbortError,
  Blob: () => fetch_blob_default,
  FetchError: () => FetchError,
  File: () => file_default,
  FormData: () => FormData2,
  Headers: () => Headers2,
  Request: () => Request,
  Response: () => Response,
  blobFrom: () => blobFrom,
  blobFromSync: () => blobFromSync,
  default: () => fetch2,
  fileFrom: () => fileFrom,
  fileFromSync: () => fileFromSync,
  isRedirect: () => isRedirect
});
function fetch2(url, options_) {
  return __async(this, null, function* () {
    return new Promise((resolve3, reject) => {
      const request = new Request(url, options_);
      const { parsedURL, options } = getNodeRequestOptions(request);
      if (!supportedSchemas.has(parsedURL.protocol)) {
        throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
      }
      if (parsedURL.protocol === "data:") {
        const data = dist_default(request.url);
        const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
        resolve3(response2);
        return;
      }
      const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http2.default).request;
      const { signal } = request;
      let response = null;
      const abort = () => {
        const error = new AbortError("The operation was aborted.");
        reject(error);
        if (request.body && request.body instanceof import_node_stream3.default.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body) {
          return;
        }
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = () => {
        abort();
        finalize();
      };
      const request_ = send(parsedURL.toString(), options);
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      const finalize = () => {
        request_.abort();
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      };
      request_.on("error", (error) => {
        reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
        finalize();
      });
      fixResponseChunkedTransferBadEnding(request_, (error) => {
        if (response && response.body) {
          response.body.destroy(error);
        }
      });
      if (process.version < "v14") {
        request_.on("socket", (s2) => {
          let endedWithEventsCount;
          s2.prependListener("end", () => {
            endedWithEventsCount = s2._eventsCount;
          });
          s2.prependListener("close", (hadError) => {
            if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
              const error = new Error("Premature close");
              error.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", error);
            }
          });
        });
      }
      request_.on("response", (response_) => {
        request_.setTimeout(0);
        const headers = fromRawHeaders(response_.rawHeaders);
        if (isRedirect(response_.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL(location, request.url);
          } catch (e2) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              break;
            case "follow": {
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOptions = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: clone(request),
                signal: request.signal,
                size: request.size,
                referrer: request.referrer,
                referrerPolicy: request.referrerPolicy
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOptions.headers.delete(name);
                }
              }
              if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream3.default.Readable) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
                requestOptions.method = "GET";
                requestOptions.body = void 0;
                requestOptions.headers.delete("content-length");
              }
              const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
              if (responseReferrerPolicy) {
                requestOptions.referrerPolicy = responseReferrerPolicy;
              }
              resolve3(fetch2(new Request(locationURL, requestOptions)));
              finalize();
              return;
            }
            default:
              return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
          }
        }
        if (signal) {
          response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
        }
        let body = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
          if (error) {
            reject(error);
          }
        });
        if (process.version < "v12.10") {
          response_.on("aborted", abortAndFinalize);
        }
        const responseOptions = {
          url: request.url,
          status: response_.statusCode,
          statusText: response_.statusMessage,
          headers,
          size: request.size,
          counter: request.counter,
          highWaterMark: request.highWaterMark
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
          response = new Response(body, responseOptions);
          resolve3(response);
          return;
        }
        const zlibOptions = {
          flush: import_node_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
        };
        if (codings === "gzip" || codings === "x-gzip") {
          body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), (error) => {
            if (error) {
              reject(error);
            }
          });
          response = new Response(body, responseOptions);
          resolve3(response);
          return;
        }
        if (codings === "deflate" || codings === "x-deflate") {
          const raw = (0, import_node_stream3.pipeline)(response_, new import_node_stream3.PassThrough(), (error) => {
            if (error) {
              reject(error);
            }
          });
          raw.once("data", (chunk) => {
            if ((chunk[0] & 15) === 8) {
              body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflate(), (error) => {
                if (error) {
                  reject(error);
                }
              });
            } else {
              body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createInflateRaw(), (error) => {
                if (error) {
                  reject(error);
                }
              });
            }
            response = new Response(body, responseOptions);
            resolve3(response);
          });
          raw.once("end", () => {
            if (!response) {
              response = new Response(body, responseOptions);
              resolve3(response);
            }
          });
          return;
        }
        if (codings === "br") {
          body = (0, import_node_stream3.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), (error) => {
            if (error) {
              reject(error);
            }
          });
          response = new Response(body, responseOptions);
          resolve3(response);
          return;
        }
        response = new Response(body, responseOptions);
        resolve3(response);
      });
      writeToStream(request_, request).catch(reject);
    });
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_node_buffer2.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = import_node_buffer2.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_node_buffer2.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}
var import_node_http2, import_node_https, import_node_zlib, import_node_stream3, import_node_buffer2, supportedSchemas;
var init_src = __esm({
  "../../node_modules/.pnpm/node-fetch@3.3.2/node_modules/node-fetch/src/index.js"() {
    import_node_http2 = __toESM(require("http"), 1);
    import_node_https = __toESM(require("https"), 1);
    import_node_zlib = __toESM(require("zlib"), 1);
    import_node_stream3 = __toESM(require("stream"), 1);
    import_node_buffer2 = require("buffer");
    init_dist();
    init_body();
    init_response();
    init_headers();
    init_request();
    init_fetch_error();
    init_abort_error();
    init_is_redirect();
    init_esm_min();
    init_is();
    init_referrer();
    init_from();
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/gaxios.js
var require_gaxios = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/gaxios.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a4;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Gaxios = void 0;
    var extend_1 = __importDefault(require_extend());
    var https_1 = require("https");
    var common_js_1 = require_common2();
    var retry_js_1 = require_retry();
    var stream_1 = require("stream");
    var interceptor_js_1 = require_interceptor();
    var randomUUID = () => __async(exports2, null, function* () {
      var _a5;
      return ((_a5 = globalThis.crypto) == null ? void 0 : _a5.randomUUID()) || (yield import("crypto")).randomUUID();
    });
    var HTTP_STATUS_NO_CONTENT = 204;
    var _Gaxios_instances, urlMayUseProxy_fn, applyRequestInterceptors_fn, applyResponseInterceptors_fn, prepareRequest_fn, appendTimeoutToSignal_fn, _proxyAgent, _fetch, _Gaxios_static, getProxyAgent_fn, getFetch_fn;
    var Gaxios = class {
      /**
       * The Gaxios class is responsible for making HTTP requests.
       * @param defaults The default set of options to be used for this instance.
       */
      constructor(defaults2) {
        __privateAdd(this, _Gaxios_instances);
        __publicField(this, "agentCache", /* @__PURE__ */ new Map());
        /**
         * Default HTTP options that will be used for every HTTP request.
         */
        __publicField(this, "defaults");
        /**
         * Interceptors
         */
        __publicField(this, "interceptors");
        this.defaults = defaults2 || {};
        this.interceptors = {
          request: new interceptor_js_1.GaxiosInterceptorManager(),
          response: new interceptor_js_1.GaxiosInterceptorManager()
        };
      }
      /**
       * A {@link fetch `fetch`} compliant API for {@link Gaxios}.
       *
       * @remarks
       *
       * This is useful as a drop-in replacement for `fetch` API usage.
       *
       * @example
       *
       * ```ts
       * const gaxios = new Gaxios();
       * const myFetch: typeof fetch = (...args) => gaxios.fetch(...args);
       * await myFetch('https://example.com');
       * ```
       *
       * @param args `fetch` API or `Gaxios#request` parameters
       * @returns the {@link Response} with Gaxios-added properties
       */
      fetch(...args) {
        const input = args[0];
        const init = args[1];
        let url = void 0;
        const headers = new Headers();
        if (typeof input === "string") {
          url = new URL(input);
        } else if (input instanceof URL) {
          url = input;
        } else if (input && input.url) {
          url = new URL(input.url);
        }
        if (input && typeof input === "object" && "headers" in input) {
          _a4.mergeHeaders(headers, input.headers);
        }
        if (init) {
          _a4.mergeHeaders(headers, new Headers(init.headers));
        }
        if (typeof input === "object" && !(input instanceof URL)) {
          return this.request(__spreadProps(__spreadValues(__spreadValues({}, init), input), { headers, url }));
        } else {
          return this.request(__spreadProps(__spreadValues({}, init), { headers, url }));
        }
      }
      /**
       * Perform an HTTP request with the given options.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      request() {
        return __async(this, arguments, function* (opts = {}) {
          let prepared = yield __privateMethod(this, _Gaxios_instances, prepareRequest_fn).call(this, opts);
          prepared = yield __privateMethod(this, _Gaxios_instances, applyRequestInterceptors_fn).call(this, prepared);
          return __privateMethod(this, _Gaxios_instances, applyResponseInterceptors_fn).call(this, this._request(prepared));
        });
      }
      _defaultAdapter(config) {
        return __async(this, null, function* () {
          var _a5, _b;
          const fetchImpl = config.fetchImplementation || this.defaults.fetchImplementation || (yield __privateMethod(_a5 = _a4, _Gaxios_static, getFetch_fn).call(_a5));
          const preparedOpts = __spreadValues({}, config);
          delete preparedOpts.data;
          const res = yield fetchImpl(config.url, preparedOpts);
          const data = yield this.getResponseData(config, res);
          if (!((_b = Object.getOwnPropertyDescriptor(res, "data")) == null ? void 0 : _b.configurable)) {
            Object.defineProperties(res, {
              data: {
                configurable: true,
                writable: true,
                enumerable: true,
                value: data
              }
            });
          }
          return Object.assign(res, { config, data });
        });
      }
      /**
       * Internal, retryable version of the `request` method.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      _request(opts) {
        return __async(this, null, function* () {
          var _a5;
          try {
            let translatedResponse;
            if (opts.adapter) {
              translatedResponse = yield opts.adapter(opts, this._defaultAdapter.bind(this));
            } else {
              translatedResponse = yield this._defaultAdapter(opts);
            }
            if (!opts.validateStatus(translatedResponse.status)) {
              if (opts.responseType === "stream") {
                const response = [];
                try {
                  for (var iter = __forAwait(translatedResponse.data), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
                    const chunk = temp.value;
                    response.push(chunk);
                  }
                } catch (temp) {
                  error = [temp];
                } finally {
                  try {
                    more && (temp = iter.return) && (yield temp.call(iter));
                  } finally {
                    if (error)
                      throw error[0];
                  }
                }
                translatedResponse.data = response.toString();
              }
              const errorInfo = common_js_1.GaxiosError.extractAPIErrorFromResponse(translatedResponse, `Request failed with status code ${translatedResponse.status}`);
              throw new common_js_1.GaxiosError(errorInfo == null ? void 0 : errorInfo.message, opts, translatedResponse, errorInfo);
            }
            return translatedResponse;
          } catch (e2) {
            let err;
            if (e2 instanceof common_js_1.GaxiosError) {
              err = e2;
            } else if (e2 instanceof Error) {
              err = new common_js_1.GaxiosError(e2.message, opts, void 0, e2);
            } else {
              err = new common_js_1.GaxiosError("Unexpected Gaxios Error", opts, void 0, e2);
            }
            const { shouldRetry, config } = yield (0, retry_js_1.getRetryConfig)(err);
            if (shouldRetry && config) {
              err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;
              opts.retryConfig = (_a5 = err.config) == null ? void 0 : _a5.retryConfig;
              __privateMethod(this, _Gaxios_instances, appendTimeoutToSignal_fn).call(this, opts);
              return this._request(opts);
            }
            if (opts.errorRedactor) {
              opts.errorRedactor(err);
            }
            throw err;
          }
        });
      }
      getResponseData(opts, res) {
        return __async(this, null, function* () {
          var _a5;
          if (res.status === HTTP_STATUS_NO_CONTENT) {
            return "";
          }
          if (opts.maxContentLength && res.headers.has("content-length") && opts.maxContentLength < Number.parseInt(((_a5 = res.headers) == null ? void 0 : _a5.get("content-length")) || "")) {
            throw new common_js_1.GaxiosError("Response's `Content-Length` is over the limit.", opts, Object.assign(res, { config: opts }));
          }
          switch (opts.responseType) {
            case "stream":
              return res.body;
            case "json": {
              const data = yield res.text();
              try {
                return JSON.parse(data);
              } catch (e2) {
                return data;
              }
            }
            case "arraybuffer":
              return res.arrayBuffer();
            case "blob":
              return res.blob();
            case "text":
              return res.text();
            default:
              return this.getResponseDataFromContentType(res);
          }
        });
      }
      /**
       * By default, throw for any non-2xx status code
       * @param status status code from the HTTP response
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
      /**
       * Attempts to parse a response by looking at the Content-Type header.
       * @param {Response} response the HTTP response.
       * @returns a promise that resolves to the response data.
       */
      getResponseDataFromContentType(response) {
        return __async(this, null, function* () {
          let contentType = response.headers.get("Content-Type");
          if (contentType === null) {
            return response.text();
          }
          contentType = contentType.toLowerCase();
          if (contentType.includes("application/json")) {
            let data = yield response.text();
            try {
              data = JSON.parse(data);
            } catch (e2) {
            }
            return data;
          } else if (contentType.match(/^text\//)) {
            return response.text();
          } else {
            return response.blob();
          }
        });
      }
      /**
       * Creates an async generator that yields the pieces of a multipart/related request body.
       * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
       * multipart/related requests are not currently supported.
       *
       * @param {GaxiosMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
       * @param {string} boundary the boundary string to be placed between each part.
       */
      getMultipartRequest(multipartOptions, boundary) {
        return __asyncGenerator(this, null, function* () {
          const finale = `--${boundary}--`;
          for (const currentPart of multipartOptions) {
            const partContentType = currentPart.headers.get("Content-Type") || "application/octet-stream";
            const preamble = `--${boundary}\r
Content-Type: ${partContentType}\r
\r
`;
            yield preamble;
            if (typeof currentPart.content === "string") {
              yield currentPart.content;
            } else {
              yield* __yieldStar(currentPart.content);
            }
            yield "\r\n";
          }
          yield finale;
        });
      }
      /**
       * Merges headers.
       * If the base headers do not exist a new `Headers` object will be returned.
       *
       * @remarks
       *
       * Using this utility can be helpful when the headers are not known to exist:
       * - if they exist as `Headers`, that instance will be used
       *   - it improves performance and allows users to use their existing references to their `Headers`
       * - if they exist in another form (`HeadersInit`), they will be used to create a new `Headers` object
       * - if the base headers do not exist a new `Headers` object will be created
       *
       * @param base headers to append/overwrite to
       * @param append headers to append/overwrite with
       * @returns the base headers instance with merged `Headers`
       */
      static mergeHeaders(base, ...append) {
        base = base instanceof Headers ? base : new Headers(base);
        for (const headers of append) {
          const add = headers instanceof Headers ? headers : new Headers(headers);
          add.forEach((value, key) => {
            key === "set-cookie" ? base.append(key, value) : base.set(key, value);
          });
        }
        return base;
      }
    };
    _Gaxios_instances = new WeakSet();
    urlMayUseProxy_fn = function(url, noProxy = []) {
      var _a5, _b;
      const candidate = new URL(url);
      const noProxyList = [...noProxy];
      const noProxyEnvList = ((_b = (_a5 = process.env.NO_PROXY) != null ? _a5 : process.env.no_proxy) == null ? void 0 : _b.split(",")) || [];
      for (const rule of noProxyEnvList) {
        noProxyList.push(rule.trim());
      }
      for (const rule of noProxyList) {
        if (rule instanceof RegExp) {
          if (rule.test(candidate.toString())) {
            return false;
          }
        } else if (rule instanceof URL) {
          if (rule.origin === candidate.origin) {
            return false;
          }
        } else if (rule.startsWith("*.") || rule.startsWith(".")) {
          const cleanedRule = rule.replace(/^\*\./, ".");
          if (candidate.hostname.endsWith(cleanedRule)) {
            return false;
          }
        } else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) {
          return false;
        }
      }
      return true;
    };
    applyRequestInterceptors_fn = function(options) {
      return __async(this, null, function* () {
        let promiseChain = Promise.resolve(options);
        for (const interceptor of this.interceptors.request.values()) {
          if (interceptor) {
            promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
          }
        }
        return promiseChain;
      });
    };
    applyResponseInterceptors_fn = function(response) {
      return __async(this, null, function* () {
        let promiseChain = Promise.resolve(response);
        for (const interceptor of this.interceptors.response.values()) {
          if (interceptor) {
            promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
          }
        }
        return promiseChain;
      });
    };
    prepareRequest_fn = function(options) {
      return __async(this, null, function* () {
        var _a5, _b, _c, _d2, _e, _f, _g, _h;
        const preparedHeaders = new Headers(this.defaults.headers);
        _a4.mergeHeaders(preparedHeaders, options.headers);
        const opts = (0, extend_1.default)(true, {}, this.defaults, options);
        if (!opts.url) {
          throw new Error("URL is required.");
        }
        if (opts.baseURL) {
          opts.url = new URL(opts.url, opts.baseURL);
        }
        opts.url = new URL(opts.url);
        if (opts.params) {
          if (opts.paramsSerializer) {
            let additionalQueryParams = opts.paramsSerializer(opts.params);
            if (additionalQueryParams.startsWith("?")) {
              additionalQueryParams = additionalQueryParams.slice(1);
            }
            const prefix = opts.url.toString().includes("?") ? "&" : "?";
            opts.url = opts.url + prefix + additionalQueryParams;
          } else {
            const url = opts.url instanceof URL ? opts.url : new URL(opts.url);
            for (const [key, value] of new URLSearchParams(opts.params)) {
              url.searchParams.append(key, value);
            }
            opts.url = url;
          }
        }
        if (typeof options.maxContentLength === "number") {
          opts.size = options.maxContentLength;
        }
        if (typeof options.maxRedirects === "number") {
          opts.follow = options.maxRedirects;
        }
        const shouldDirectlyPassData = typeof opts.data === "string" || opts.data instanceof ArrayBuffer || opts.data instanceof Blob || // Node 18 does not have a global `File` object
        globalThis.File && opts.data instanceof File || opts.data instanceof FormData || opts.data instanceof stream_1.Readable || opts.data instanceof ReadableStream || opts.data instanceof String || opts.data instanceof URLSearchParams || ArrayBuffer.isView(opts.data) || // `Buffer` (Node.js), `DataView`, `TypedArray`
        /**
         * @deprecated `node-fetch` or another third-party's request types
         */
        ["Blob", "File", "FormData"].includes(((_b = (_a5 = opts.data) == null ? void 0 : _a5.constructor) == null ? void 0 : _b.name) || "");
        if ((_c = opts.multipart) == null ? void 0 : _c.length) {
          const boundary = yield randomUUID();
          preparedHeaders.set("content-type", `multipart/related; boundary=${boundary}`);
          opts.body = stream_1.Readable.from(this.getMultipartRequest(opts.multipart, boundary));
        } else if (shouldDirectlyPassData) {
          opts.body = opts.data;
        } else if (typeof opts.data === "object") {
          if (preparedHeaders.get("Content-Type") === "application/x-www-form-urlencoded") {
            opts.body = opts.paramsSerializer ? opts.paramsSerializer(opts.data) : new URLSearchParams(opts.data);
          } else {
            if (!preparedHeaders.has("content-type")) {
              preparedHeaders.set("content-type", "application/json");
            }
            opts.body = JSON.stringify(opts.data);
          }
        } else if (opts.data) {
          opts.body = opts.data;
        }
        opts.validateStatus = opts.validateStatus || this.validateStatus;
        opts.responseType = opts.responseType || "unknown";
        if (!preparedHeaders.has("accept") && opts.responseType === "json") {
          preparedHeaders.set("accept", "application/json");
        }
        const proxy = opts.proxy || ((_d2 = process == null ? void 0 : process.env) == null ? void 0 : _d2.HTTPS_PROXY) || ((_e = process == null ? void 0 : process.env) == null ? void 0 : _e.https_proxy) || ((_f = process == null ? void 0 : process.env) == null ? void 0 : _f.HTTP_PROXY) || ((_g = process == null ? void 0 : process.env) == null ? void 0 : _g.http_proxy);
        if (opts.agent) {
        } else if (proxy && __privateMethod(this, _Gaxios_instances, urlMayUseProxy_fn).call(this, opts.url, opts.noProxy)) {
          const HttpsProxyAgent = yield __privateMethod(_h = _a4, _Gaxios_static, getProxyAgent_fn).call(_h);
          if (this.agentCache.has(proxy)) {
            opts.agent = this.agentCache.get(proxy);
          } else {
            opts.agent = new HttpsProxyAgent(proxy, {
              cert: opts.cert,
              key: opts.key
            });
            this.agentCache.set(proxy, opts.agent);
          }
        } else if (opts.cert && opts.key) {
          if (this.agentCache.has(opts.key)) {
            opts.agent = this.agentCache.get(opts.key);
          } else {
            opts.agent = new https_1.Agent({
              cert: opts.cert,
              key: opts.key
            });
            this.agentCache.set(opts.key, opts.agent);
          }
        }
        if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) {
          opts.errorRedactor = common_js_1.defaultErrorRedactor;
        }
        if (opts.body && !("duplex" in opts)) {
          opts.duplex = "half";
        }
        __privateMethod(this, _Gaxios_instances, appendTimeoutToSignal_fn).call(this, opts);
        return Object.assign(opts, {
          headers: preparedHeaders,
          url: opts.url instanceof URL ? opts.url : new URL(opts.url)
        });
      });
    };
    appendTimeoutToSignal_fn = function(opts) {
      if (opts.timeout) {
        const timeoutSignal = AbortSignal.timeout(opts.timeout);
        if (opts.signal && !opts.signal.aborted) {
          opts.signal = AbortSignal.any([opts.signal, timeoutSignal]);
        } else {
          opts.signal = timeoutSignal;
        }
      }
    };
    _proxyAgent = new WeakMap();
    _fetch = new WeakMap();
    _Gaxios_static = new WeakSet();
    getProxyAgent_fn = function() {
      return __async(this, null, function* () {
        __privateGet(this, _proxyAgent) || __privateSet(this, _proxyAgent, (yield Promise.resolve().then(() => __toESM(require_dist2()))).HttpsProxyAgent);
        return __privateGet(this, _proxyAgent);
      });
    };
    getFetch_fn = function() {
      return __async(this, null, function* () {
        const hasWindow = typeof window !== "undefined" && !!window;
        __privateGet(this, _fetch) || __privateSet(this, _fetch, hasWindow ? window.fetch : (yield Promise.resolve().then(() => (init_src(), src_exports))).default);
        return __privateGet(this, _fetch);
      });
    };
    __privateAdd(Gaxios, _Gaxios_static);
    /**
     * A cache for the lazily-loaded proxy agent.
     *
     * Should use {@link Gaxios[#getProxyAgent]} to retrieve.
     */
    // using `import` to dynamically import the types here
    __privateAdd(Gaxios, _proxyAgent);
    /**
     * A cache for the lazily-loaded fetch library.
     *
     * Should use {@link Gaxios[#getFetch]} to retrieve.
     */
    //
    __privateAdd(Gaxios, _fetch);
    exports2.Gaxios = Gaxios;
    _a4 = Gaxios;
  }
});

// ../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/gaxios@7.1.3/node_modules/gaxios/build/cjs/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.Gaxios = exports2.GaxiosError = void 0;
    exports2.request = request;
    var gaxios_js_1 = require_gaxios();
    Object.defineProperty(exports2, "Gaxios", { enumerable: true, get: function() {
      return gaxios_js_1.Gaxios;
    } });
    var common_js_1 = require_common2();
    Object.defineProperty(exports2, "GaxiosError", { enumerable: true, get: function() {
      return common_js_1.GaxiosError;
    } });
    __exportStar(require_interceptor(), exports2);
    exports2.instance = new gaxios_js_1.Gaxios();
    function request(opts) {
      return __async(this, null, function* () {
        return exports2.instance.request(opts);
      });
    }
  }
});

// ../../node_modules/.pnpm/bignumber.js@9.3.0/node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "../../node_modules/.pnpm/bignumber.js@9.3.0/node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e2, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x2.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v.e;
                x2.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x2.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e2;
                  x2.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v);
              return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x2, str, isNum, b);
              x2.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet.indexOf(c = str.charAt(i2)) < 0) {
                if (c == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x2.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x2.s * v);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e2 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e2;
              x2.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n, c = v.c, e2 = v.e, s2 = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c[0] === 0) {
                if (e2 === 0 && c.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c[0]).length == i2) {
                for (i2 = 0; i2 < c.length; i2++) {
                  n = c[i2];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = (function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e2, k, v, i2 = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i2 < k; ) {
                  v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i2] = b[0];
                    a[i2 + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i2 < k; ) {
                  v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i2);
                  } else {
                    c.push(v % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i2++] = v % 1e14;
              }
            }
            k = c[--i2];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i2] = mathfloor(k / v) * v;
            }
            for (; c[i2] === 0; c.pop(), i2--) ;
            if (i2 < 0) {
              c = [e2 = 0];
            } else {
              for (e2 = -1; c[0] === 0; c.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c;
            return rand;
          };
        })();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ (function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i2++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e2, k, r2, x2, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x2 = y.pow(str.length - i2);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e2 = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x2.c = xc;
              x2.e = e2;
              x2.s = sign;
              x2 = div(x2, y, dp, rm, baseOut);
              xc = x2.c;
              r2 = x2.r;
              e2 = x2.e;
            }
            d = e2 + dp + 1;
            i2 = xc[d];
            k = baseOut / 2;
            r2 = r2 || d < 0 || xc[d + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r2) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i2 = 0, str = ""; i2 <= k; str += alphabet.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet.charAt(0));
            }
            return str;
          };
        })();
        div = /* @__PURE__ */ (function() {
          function multiply(x2, k, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare2(a, b, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a[i2] != b[i2]) {
                  cmp = a[i2] > b[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a[aL] -= i2;
              i2 = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i2 * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x2, y, dp, rm, base) {
            var cmp, e2, i2, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y.s ? 1 : -1, xc = x2.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q = new BigNumber2(s2);
            qc = q.c = [];
            e2 = x2.e - y.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i2++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q, dp + (q.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e2;
              q.r = +more;
            }
            return q;
          };
        })();
        function format(n, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i2 == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i2, rm);
            e2 = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y = new BigNumber2(args[i2]);
            if (!y.s || (k = compare(x2, y)) === n || k === 0 && x2.s === n) {
              x2 = y;
            }
          }
          return x2;
        }
        function normalise(n, c, e2) {
          var i2 = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e2 < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e2;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ (function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m2;
                });
                if (b) {
                  base = b;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        })();
        function round(x2, sd, rm, r2) {
          var d, i2, j, k, n, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i2 = sd - d;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i2 %= LOG_BASE;
                    j = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i2];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i2 != k) {
                      x2.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n) {
          var str, e2 = n.e;
          if (e2 === null) return n.toString();
          str = coeffToString(n.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c = x2.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m2) {
          var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x2 = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m2 ? y.mod(m2) : y;
          }
          nIsNeg = n.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k = x2.s < 0 && isOdd(n) ? -0 : 0;
            if (x2.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i2 = Math.abs(+valueOf(n));
            nIsOdd = i2 % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x2);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i2 = +valueOf(n);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k) {
              if (x2.c && x2.c.length > k) x2.c.length = k;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m2 ? y.mod(m2) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i2, j, t2, xLTy, x2 = this, a = x2.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x2.plus(y);
          }
          var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t2 = xc;
            } else {
              ye = xe;
              t2 = yc;
            }
            t2.reverse();
            for (b = a; b--; t2.push(0)) ;
            t2.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc;
            xc = yc;
            yc = t2;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i2 = xc.length);
          if (b > 0) for (; b--; xc[i2++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i2 = j; i2 && !xc[--i2]; xc[i2] = b) ;
              --xc[i2];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s2, x2 = this;
          y = new BigNumber2(y, b);
          if (!x2.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y.s;
            y.s = 1;
            q = div(x2, y, 0, 3);
            y.s = s2;
            q.s *= s2;
          } else {
            q = div(x2, y, 0, MODULO_MODE);
          }
          y = x2.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x2.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e2, i2, j, k, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x2.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k = xcL, j = i2 + k; j > i2; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e2);
        };
        P.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P.plus = function(y, b) {
          var t2, x2 = this, a = x2.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x2.minus(y);
          }
          var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x2 : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t2 = yc;
            } else {
              a = -a;
              t2 = xc;
            }
            t2.reverse();
            for (; a--; t2.push(0)) ;
            t2.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t2 = yc;
            yc = xc;
            xc = t2;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), sd, rm);
          }
          if (!(c = x2.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x2.e + 1 > n) n = x2.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m2, n, r2, rep, t2, x2 = this, c = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c || !c[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e2) % 2 == 0) n += "0";
            s2 = Math.sqrt(+n);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n = "5e" + e2;
            } else {
              n = s2.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber2(n);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n = n.slice(s2 - 3, s2 + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x2)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x2 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e2, exp, n, n0, n1, q, r2, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s2 = coeffToString(xc);
          e2 = d.e = s2.length - x2.e - 1;
          d.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e2 > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x2.s;
          e2 = e2 * 2;
          r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r2;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s2 = n.s, e2 = n.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e2) : toFixedPoint(coeffToString(n.c), e2, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e2, "0"), 10, b, s2, true);
            }
            if (s2 < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i2 = n | 0;
        return n > 0 || n === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a) {
        var s2, z78, i2 = 1, j = a.length, r2 = a[0] + "";
        for (; i2 < j; ) {
          s2 = a[i2++] + "";
          z78 = LOG_BASE - s2.length;
          for (; z78--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j = r2.length; r2.charCodeAt(--j) === 48; ) ;
        return r2.slice(0, j + 1 || 1);
      }
      function compare(x2, y) {
        var a, b, xc = x2.c, yc = y.c, i2 = x2.s, j = y.s, k = x2.e, l = y.e;
        if (!i2 || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i2;
        if (i2 != j) return i2;
        a = i2 < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i2 = 0; i2 < j; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z78) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z78 + "."; ++e2; zs += z78) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z78, e2 -= len; --e2; zs += z78) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f3(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i2, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k = rep[i2];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// ../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx3 = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx3 = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i2, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx3.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx3.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? (function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        })({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// ../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "../../node_modules/.pnpm/json-bigint@1.0.0/node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// ../../node_modules/.pnpm/gcp-metadata@8.1.2/node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS({
  "../../node_modules/.pnpm/gcp-metadata@8.1.2/node_modules/gcp-metadata/build/src/gcp-residency.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GCE_LINUX_BIOS_PATHS = void 0;
    exports2.isGoogleCloudServerless = isGoogleCloudServerless;
    exports2.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
    exports2.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
    exports2.isGoogleComputeEngine = isGoogleComputeEngine;
    exports2.detectGCPResidency = detectGCPResidency;
    var fs_1 = require("fs");
    var os_1 = require("os");
    exports2.GCE_LINUX_BIOS_PATHS = {
      BIOS_DATE: "/sys/class/dmi/id/bios_date",
      BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
    };
    var GCE_MAC_ADDRESS_REGEX = /^42:01/;
    function isGoogleCloudServerless() {
      const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
      return !!isGFEnvironment;
    }
    function isGoogleComputeEngineLinux() {
      if ((0, os_1.platform)() !== "linux")
        return false;
      try {
        (0, fs_1.statSync)(exports2.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
        const biosVendor = (0, fs_1.readFileSync)(exports2.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
        return /Google/.test(biosVendor);
      } catch (e2) {
        return false;
      }
    }
    function isGoogleComputeEngineMACAddress() {
      const interfaces = (0, os_1.networkInterfaces)();
      for (const item of Object.values(interfaces)) {
        if (!item)
          continue;
        for (const { mac } of item) {
          if (GCE_MAC_ADDRESS_REGEX.test(mac)) {
            return true;
          }
        }
      }
      return false;
    }
    function isGoogleComputeEngine() {
      return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
    }
    function detectGCPResidency() {
      return isGoogleCloudServerless() || isGoogleComputeEngine();
    }
  }
});

// ../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/colours.js
var require_colours = __commonJS({
  "../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/colours.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Colours = void 0;
    var Colours = class _Colours {
      /**
       * @param stream The stream (e.g. process.stderr)
       * @returns true if the stream should have colourization enabled
       */
      static isEnabled(stream) {
        return stream && // May happen in browsers.
        stream.isTTY && (typeof stream.getColorDepth === "function" ? stream.getColorDepth() > 2 : true);
      }
      static refresh() {
        _Colours.enabled = _Colours.isEnabled(process === null || process === void 0 ? void 0 : process.stderr);
        if (!this.enabled) {
          _Colours.reset = "";
          _Colours.bright = "";
          _Colours.dim = "";
          _Colours.red = "";
          _Colours.green = "";
          _Colours.yellow = "";
          _Colours.blue = "";
          _Colours.magenta = "";
          _Colours.cyan = "";
          _Colours.white = "";
          _Colours.grey = "";
        } else {
          _Colours.reset = "\x1B[0m";
          _Colours.bright = "\x1B[1m";
          _Colours.dim = "\x1B[2m";
          _Colours.red = "\x1B[31m";
          _Colours.green = "\x1B[32m";
          _Colours.yellow = "\x1B[33m";
          _Colours.blue = "\x1B[34m";
          _Colours.magenta = "\x1B[35m";
          _Colours.cyan = "\x1B[36m";
          _Colours.white = "\x1B[37m";
          _Colours.grey = "\x1B[90m";
        }
      }
    };
    exports2.Colours = Colours;
    Colours.enabled = false;
    Colours.reset = "";
    Colours.bright = "";
    Colours.dim = "";
    Colours.red = "";
    Colours.green = "";
    Colours.yellow = "";
    Colours.blue = "";
    Colours.magenta = "";
    Colours.cyan = "";
    Colours.white = "";
    Colours.grey = "";
    Colours.refresh();
  }
});

// ../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/logging-utils.js
var require_logging_utils = __commonJS({
  "../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/logging-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.env = exports2.DebugLogBackendBase = exports2.placeholder = exports2.AdhocDebugLogger = exports2.LogSeverity = void 0;
    exports2.getNodeBackend = getNodeBackend;
    exports2.getDebugBackend = getDebugBackend;
    exports2.getStructuredBackend = getStructuredBackend;
    exports2.setBackend = setBackend;
    exports2.log = log;
    var events_1 = require("events");
    var process4 = __importStar(require("process"));
    var util = __importStar(require("util"));
    var colours_1 = require_colours();
    var LogSeverity;
    (function(LogSeverity2) {
      LogSeverity2["DEFAULT"] = "DEFAULT";
      LogSeverity2["DEBUG"] = "DEBUG";
      LogSeverity2["INFO"] = "INFO";
      LogSeverity2["WARNING"] = "WARNING";
      LogSeverity2["ERROR"] = "ERROR";
    })(LogSeverity || (exports2.LogSeverity = LogSeverity = {}));
    var AdhocDebugLogger = class extends events_1.EventEmitter {
      /**
       * @param upstream The backend will pass a function that will be
       *   called whenever our logger function is invoked.
       */
      constructor(namespace, upstream) {
        super();
        this.namespace = namespace;
        this.upstream = upstream;
        this.func = Object.assign(this.invoke.bind(this), {
          // Also add an instance pointer back to us.
          instance: this,
          // And pull over the EventEmitter functionality.
          on: (event, listener) => this.on(event, listener)
        });
        this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);
        this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);
        this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);
        this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);
        this.func.sublog = (namespace2) => log(namespace2, this.func);
      }
      invoke(fields, ...args) {
        if (this.upstream) {
          try {
            this.upstream(fields, ...args);
          } catch (e2) {
          }
        }
        try {
          this.emit("log", fields, args);
        } catch (e2) {
        }
      }
      invokeSeverity(severity, ...args) {
        this.invoke({ severity }, ...args);
      }
    };
    exports2.AdhocDebugLogger = AdhocDebugLogger;
    exports2.placeholder = new AdhocDebugLogger("", () => {
    }).func;
    var DebugLogBackendBase = class {
      constructor() {
        var _a4;
        this.cached = /* @__PURE__ */ new Map();
        this.filters = [];
        this.filtersSet = false;
        let nodeFlag = (_a4 = process4.env[exports2.env.nodeEnables]) !== null && _a4 !== void 0 ? _a4 : "*";
        if (nodeFlag === "all") {
          nodeFlag = "*";
        }
        this.filters = nodeFlag.split(",");
      }
      log(namespace, fields, ...args) {
        try {
          if (!this.filtersSet) {
            this.setFilters();
            this.filtersSet = true;
          }
          let logger = this.cached.get(namespace);
          if (!logger) {
            logger = this.makeLogger(namespace);
            this.cached.set(namespace, logger);
          }
          logger(fields, ...args);
        } catch (e2) {
          console.error(e2);
        }
      }
    };
    exports2.DebugLogBackendBase = DebugLogBackendBase;
    var NodeBackend = class extends DebugLogBackendBase {
      constructor() {
        super(...arguments);
        this.enabledRegexp = /.*/g;
      }
      isEnabled(namespace) {
        return this.enabledRegexp.test(namespace);
      }
      makeLogger(namespace) {
        if (!this.enabledRegexp.test(namespace)) {
          return () => {
          };
        }
        return (fields, ...args) => {
          var _a4;
          const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;
          const pid = `${colours_1.Colours.yellow}${process4.pid}${colours_1.Colours.reset}`;
          let level;
          switch (fields.severity) {
            case LogSeverity.ERROR:
              level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;
              break;
            case LogSeverity.INFO:
              level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;
              break;
            case LogSeverity.WARNING:
              level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;
              break;
            default:
              level = (_a4 = fields.severity) !== null && _a4 !== void 0 ? _a4 : LogSeverity.DEFAULT;
              break;
          }
          const msg = util.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);
          const filteredFields = Object.assign({}, fields);
          delete filteredFields.severity;
          const fieldsJson = Object.getOwnPropertyNames(filteredFields).length ? JSON.stringify(filteredFields) : "";
          const fieldsColour = fieldsJson ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}` : "";
          console.error("%s [%s|%s] %s%s", pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : "");
        };
      }
      // Regexp patterns below are from here:
      // https://github.com/nodejs/node/blob/c0aebed4b3395bd65d54b18d1fd00f071002ac20/lib/internal/util/debuglog.js#L36
      setFilters() {
        const totalFilters = this.filters.join(",");
        const regexp = totalFilters.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
        this.enabledRegexp = new RegExp(`^${regexp}$`, "i");
      }
    };
    function getNodeBackend() {
      return new NodeBackend();
    }
    var DebugBackend = class extends DebugLogBackendBase {
      constructor(pkg) {
        super();
        this.debugPkg = pkg;
      }
      makeLogger(namespace) {
        const debugLogger = this.debugPkg(namespace);
        return (fields, ...args) => {
          debugLogger(args[0], ...args.slice(1));
        };
      }
      setFilters() {
        var _a4;
        const existingFilters = (_a4 = process4.env["NODE_DEBUG"]) !== null && _a4 !== void 0 ? _a4 : "";
        process4.env["NODE_DEBUG"] = `${existingFilters}${existingFilters ? "," : ""}${this.filters.join(",")}`;
      }
    };
    function getDebugBackend(debugPkg) {
      return new DebugBackend(debugPkg);
    }
    var StructuredBackend = class extends DebugLogBackendBase {
      constructor(upstream) {
        var _a4;
        super();
        this.upstream = (_a4 = upstream) !== null && _a4 !== void 0 ? _a4 : void 0;
      }
      makeLogger(namespace) {
        var _a4;
        const debugLogger = (_a4 = this.upstream) === null || _a4 === void 0 ? void 0 : _a4.makeLogger(namespace);
        return (fields, ...args) => {
          var _a5;
          const severity = (_a5 = fields.severity) !== null && _a5 !== void 0 ? _a5 : LogSeverity.INFO;
          const json = Object.assign({
            severity,
            message: util.format(...args)
          }, fields);
          const jsonString = JSON.stringify(json);
          if (debugLogger) {
            debugLogger(fields, jsonString);
          } else {
            console.log("%s", jsonString);
          }
        };
      }
      setFilters() {
        var _a4;
        (_a4 = this.upstream) === null || _a4 === void 0 ? void 0 : _a4.setFilters();
      }
    };
    function getStructuredBackend(upstream) {
      return new StructuredBackend(upstream);
    }
    exports2.env = {
      /**
       * Filter wildcards specific to the Node syntax, and similar to the built-in
       * utils.debuglog() environment variable. If missing, disables logging.
       */
      nodeEnables: "GOOGLE_SDK_NODE_LOGGING"
    };
    var loggerCache = /* @__PURE__ */ new Map();
    var cachedBackend = void 0;
    function setBackend(backend) {
      cachedBackend = backend;
      loggerCache.clear();
    }
    function log(namespace, parent) {
      if (!cachedBackend) {
        const enablesFlag = process4.env[exports2.env.nodeEnables];
        if (!enablesFlag) {
          return exports2.placeholder;
        }
      }
      if (!namespace) {
        return exports2.placeholder;
      }
      if (parent) {
        namespace = `${parent.instance.namespace}:${namespace}`;
      }
      const existing = loggerCache.get(namespace);
      if (existing) {
        return existing.func;
      }
      if (cachedBackend === null) {
        return exports2.placeholder;
      } else if (cachedBackend === void 0) {
        cachedBackend = getNodeBackend();
      }
      const logger = (() => {
        let previousBackend = void 0;
        const newLogger = new AdhocDebugLogger(namespace, (fields, ...args) => {
          if (previousBackend !== cachedBackend) {
            if (cachedBackend === null) {
              return;
            } else if (cachedBackend === void 0) {
              cachedBackend = getNodeBackend();
            }
            previousBackend = cachedBackend;
          }
          cachedBackend === null || cachedBackend === void 0 ? void 0 : cachedBackend.log(namespace, fields, ...args);
        });
        return newLogger;
      })();
      loggerCache.set(namespace, logger);
      return logger.func;
    }
  }
});

// ../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/google-logging-utils@1.1.3/node_modules/google-logging-utils/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_logging_utils(), exports2);
  }
});

// ../../node_modules/.pnpm/gcp-metadata@8.1.2/node_modules/gcp-metadata/build/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/gcp-metadata@8.1.2/node_modules/gcp-metadata/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gcpResidencyCache = exports2.METADATA_SERVER_DETECTION = exports2.HEADERS = exports2.HEADER_VALUE = exports2.HEADER_NAME = exports2.SECONDARY_HOST_ADDRESS = exports2.HOST_ADDRESS = exports2.BASE_PATH = void 0;
    exports2.instance = instance;
    exports2.project = project;
    exports2.universe = universe;
    exports2.bulk = bulk;
    exports2.isAvailable = isAvailable;
    exports2.resetIsAvailableCache = resetIsAvailableCache;
    exports2.getGCPResidency = getGCPResidency;
    exports2.setGCPResidency = setGCPResidency;
    exports2.requestTimeout = requestTimeout;
    var gaxios_1 = require_src2();
    var jsonBigint = require_json_bigint();
    var gcp_residency_1 = require_gcp_residency();
    var logger = __importStar(require_src3());
    exports2.BASE_PATH = "/computeMetadata/v1";
    exports2.HOST_ADDRESS = "http://169.254.169.254";
    exports2.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
    exports2.HEADER_NAME = "Metadata-Flavor";
    exports2.HEADER_VALUE = "Google";
    exports2.HEADERS = Object.freeze({ [exports2.HEADER_NAME]: exports2.HEADER_VALUE });
    var log = logger.log("gcp-metadata");
    exports2.METADATA_SERVER_DETECTION = Object.freeze({
      "assume-present": "don't try to ping the metadata server, but assume it's present",
      none: "don't try to ping the metadata server, but don't try to use it either",
      "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
      "ping-only": "skip the BIOS probe, and go straight to pinging"
    });
    function getBaseUrl(baseUrl) {
      if (!baseUrl) {
        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports2.HOST_ADDRESS;
      }
      if (!/^https?:\/\//.test(baseUrl)) {
        baseUrl = `http://${baseUrl}`;
      }
      return new URL(exports2.BASE_PATH, baseUrl).href;
    }
    function validate(options) {
      Object.keys(options).forEach((key) => {
        switch (key) {
          case "params":
          case "property":
          case "headers":
            break;
          case "qs":
            throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
          default:
            throw new Error(`'${key}' is not a valid configuration option.`);
        }
      });
    }
    function metadataAccessor(_0) {
      return __async(this, arguments, function* (type, options = {}, noResponseRetries = 3, fastFail = false) {
        const headers = new Headers(exports2.HEADERS);
        let metadataKey = "";
        let params = {};
        if (typeof type === "object") {
          const metadataAccessor2 = type;
          new Headers(metadataAccessor2.headers).forEach((value, key) => headers.set(key, value));
          metadataKey = metadataAccessor2.metadataKey;
          params = metadataAccessor2.params || params;
          noResponseRetries = metadataAccessor2.noResponseRetries || noResponseRetries;
          fastFail = metadataAccessor2.fastFail || fastFail;
        } else {
          metadataKey = type;
        }
        if (typeof options === "string") {
          metadataKey += `/${options}`;
        } else {
          validate(options);
          if (options.property) {
            metadataKey += `/${options.property}`;
          }
          new Headers(options.headers).forEach((value, key) => headers.set(key, value));
          params = options.params || params;
        }
        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
        const req = {
          url: `${getBaseUrl()}/${metadataKey}`,
          headers,
          retryConfig: { noResponseRetries },
          params,
          responseType: "text",
          timeout: requestTimeout()
        };
        log.info("instance request %j", req);
        const res = yield requestMethod(req);
        log.info("instance metadata is %s", res.data);
        const metadataFlavor = res.headers.get(exports2.HEADER_NAME);
        if (metadataFlavor !== exports2.HEADER_VALUE) {
          throw new RangeError(`Invalid response from metadata service: incorrect ${exports2.HEADER_NAME} header. Expected '${exports2.HEADER_VALUE}', got ${metadataFlavor ? `'${metadataFlavor}'` : "no header"}`);
        }
        if (typeof res.data === "string") {
          try {
            return jsonBigint.parse(res.data);
          } catch (e2) {
          }
        }
        return res.data;
      });
    }
    function fastFailMetadataRequest(options) {
      return __async(this, null, function* () {
        var _a4;
        const secondaryOptions = __spreadProps(__spreadValues({}, options), {
          url: (_a4 = options.url) == null ? void 0 : _a4.toString().replace(getBaseUrl(), getBaseUrl(exports2.SECONDARY_HOST_ADDRESS))
        });
        const r1 = (0, gaxios_1.request)(options);
        const r2 = (0, gaxios_1.request)(secondaryOptions);
        return Promise.any([r1, r2]);
      });
    }
    function instance(options) {
      return metadataAccessor("instance", options);
    }
    function project(options) {
      return metadataAccessor("project", options);
    }
    function universe(options) {
      return metadataAccessor("universe", options);
    }
    function bulk(properties) {
      return __async(this, null, function* () {
        const r2 = {};
        yield Promise.all(properties.map((item) => {
          return (() => __async(null, null, function* () {
            const res = yield metadataAccessor(item);
            const key = item.metadataKey;
            r2[key] = res;
          }))();
        }));
        return r2;
      });
    }
    function detectGCPAvailableRetries() {
      return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
    }
    var cachedIsAvailableResponse;
    function isAvailable() {
      return __async(this, null, function* () {
        if (process.env.METADATA_SERVER_DETECTION) {
          const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
          if (!(value in exports2.METADATA_SERVER_DETECTION)) {
            throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports2.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
          }
          switch (value) {
            case "assume-present":
              return true;
            case "none":
              return false;
            case "bios-only":
              return getGCPResidency();
            case "ping-only":
          }
        }
        try {
          if (cachedIsAvailableResponse === void 0) {
            cachedIsAvailableResponse = metadataAccessor(
              "instance",
              void 0,
              detectGCPAvailableRetries(),
              // If the default HOST_ADDRESS has been overridden, we should not
              // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
              // a non-GCP environment):
              !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
            );
          }
          yield cachedIsAvailableResponse;
          return true;
        } catch (e2) {
          const err = e2;
          if (process.env.DEBUG_AUTH) {
            console.info(err);
          }
          if (err.type === "request-timeout") {
            return false;
          }
          if (err.response && err.response.status === 404) {
            return false;
          } else {
            if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code
            // is not populated:
            (!err.code || ![
              "EHOSTDOWN",
              "EHOSTUNREACH",
              "ENETUNREACH",
              "ENOENT",
              "ENOTFOUND",
              "ECONNREFUSED"
            ].includes(err.code.toString()))) {
              let code = "UNKNOWN";
              if (err.code)
                code = err.code.toString();
              process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
            }
            return false;
          }
        }
      });
    }
    function resetIsAvailableCache() {
      cachedIsAvailableResponse = void 0;
    }
    exports2.gcpResidencyCache = null;
    function getGCPResidency() {
      if (exports2.gcpResidencyCache === null) {
        setGCPResidency();
      }
      return exports2.gcpResidencyCache;
    }
    function setGCPResidency(value = null) {
      exports2.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
    }
    function requestTimeout() {
      return getGCPResidency() ? 0 : 3e3;
    }
    __exportStar(require_gcp_residency(), exports2);
  }
});

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/shared.js
var require_shared = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromArrayBufferToHex = fromArrayBufferToHex;
    function fromArrayBufferToHex(arrayBuffer) {
      const byteArray = Array.from(new Uint8Array(arrayBuffer));
      return byteArray.map((byte) => {
        return byte.toString(16).padStart(2, "0");
      }).join("");
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/browser/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserCrypto = void 0;
    var base64js = require_base64_js();
    var shared_1 = require_shared();
    var BrowserCrypto = class _BrowserCrypto {
      constructor() {
        if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) {
          throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
        }
      }
      sha256DigestBase64(str) {
        return __async(this, null, function* () {
          const inputBuffer = new TextEncoder().encode(str);
          const outputBuffer = yield window.crypto.subtle.digest("SHA-256", inputBuffer);
          return base64js.fromByteArray(new Uint8Array(outputBuffer));
        });
      }
      randomBytesBase64(count) {
        const array = new Uint8Array(count);
        window.crypto.getRandomValues(array);
        return base64js.fromByteArray(array);
      }
      static padBase64(base64) {
        while (base64.length % 4 !== 0) {
          base64 += "=";
        }
        return base64;
      }
      verify(pubkey, data, signature) {
        return __async(this, null, function* () {
          const algo = {
            name: "RSASSA-PKCS1-v1_5",
            hash: { name: "SHA-256" }
          };
          const dataArray = new TextEncoder().encode(data);
          const signatureArray = base64js.toByteArray(_BrowserCrypto.padBase64(signature));
          const cryptoKey = yield window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
          const result = yield window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
          return result;
        });
      }
      sign(privateKey, data) {
        return __async(this, null, function* () {
          const algo = {
            name: "RSASSA-PKCS1-v1_5",
            hash: { name: "SHA-256" }
          };
          const dataArray = new TextEncoder().encode(data);
          const cryptoKey = yield window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
          const result = yield window.crypto.subtle.sign(algo, cryptoKey, dataArray);
          return base64js.fromByteArray(new Uint8Array(result));
        });
      }
      decodeBase64StringUtf8(base64) {
        const uint8array = base64js.toByteArray(_BrowserCrypto.padBase64(base64));
        const result = new TextDecoder().decode(uint8array);
        return result;
      }
      encodeBase64StringUtf8(text) {
        const uint8array = new TextEncoder().encode(text);
        const result = base64js.fromByteArray(uint8array);
        return result;
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      sha256DigestHex(str) {
        return __async(this, null, function* () {
          const inputBuffer = new TextEncoder().encode(str);
          const outputBuffer = yield window.crypto.subtle.digest("SHA-256", inputBuffer);
          return (0, shared_1.fromArrayBufferToHex)(outputBuffer);
        });
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      signWithHmacSha256(key, msg) {
        return __async(this, null, function* () {
          const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
          const enc = new TextEncoder();
          const cryptoKey = yield window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
            name: "HMAC",
            hash: {
              name: "SHA-256"
            }
          }, false, ["sign"]);
          return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
        });
      }
    };
    exports2.BrowserCrypto = BrowserCrypto;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto2 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/node/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeCrypto = void 0;
    var crypto2 = require("crypto");
    var NodeCrypto = class {
      sha256DigestBase64(str) {
        return __async(this, null, function* () {
          return crypto2.createHash("sha256").update(str).digest("base64");
        });
      }
      randomBytesBase64(count) {
        return crypto2.randomBytes(count).toString("base64");
      }
      verify(pubkey, data, signature) {
        return __async(this, null, function* () {
          const verifier = crypto2.createVerify("RSA-SHA256");
          verifier.update(data);
          verifier.end();
          return verifier.verify(pubkey, signature, "base64");
        });
      }
      sign(privateKey, data) {
        return __async(this, null, function* () {
          const signer = crypto2.createSign("RSA-SHA256");
          signer.update(data);
          signer.end();
          return signer.sign(privateKey, "base64");
        });
      }
      decodeBase64StringUtf8(base64) {
        return Buffer.from(base64, "base64").toString("utf-8");
      }
      encodeBase64StringUtf8(text) {
        return Buffer.from(text, "utf-8").toString("base64");
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      sha256DigestHex(str) {
        return __async(this, null, function* () {
          return crypto2.createHash("sha256").update(str).digest("hex");
        });
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      signWithHmacSha256(key, msg) {
        return __async(this, null, function* () {
          const cryptoKey = typeof key === "string" ? key : toBuffer2(key);
          return toArrayBuffer(crypto2.createHmac("sha256", cryptoKey).update(msg).digest());
        });
      }
    };
    exports2.NodeCrypto = NodeCrypto;
    function toArrayBuffer(buffer) {
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    }
    function toBuffer2(arrayBuffer) {
      return Buffer.from(arrayBuffer);
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto3 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/crypto/crypto.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCrypto = createCrypto;
    exports2.hasBrowserCrypto = hasBrowserCrypto;
    var crypto_1 = require_crypto();
    var crypto_2 = require_crypto2();
    __exportStar(require_shared(), exports2);
    function createCrypto() {
      if (hasBrowserCrypto()) {
        return new crypto_1.BrowserCrypto();
      }
      return new crypto_2.NodeCrypto();
    }
    function hasBrowserCrypto() {
      return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
    }
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer5 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer5(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer5.prototype);
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer5(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// ../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "../../node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer5 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer5.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer5.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer5.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop2) {
      var padding = 0;
      while (start + padding < stop2 && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer5.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    exports2.snakeToCamel = snakeToCamel;
    exports2.originalOrCamelOptions = originalOrCamelOptions;
    exports2.removeUndefinedValuesInObject = removeUndefinedValuesInObject;
    exports2.isValidFile = isValidFile;
    exports2.getWellKnownCertificateConfigFileLocation = getWellKnownCertificateConfigFileLocation;
    var fs12 = require("fs");
    var os3 = require("os");
    var path8 = require("path");
    var WELL_KNOWN_CERTIFICATE_CONFIG_FILE = "certificate_config.json";
    var CLOUDSDK_CONFIG_DIRECTORY = "gcloud";
    function snakeToCamel(str) {
      return str.replace(/([_][^_])/g, (match) => match.slice(1).toUpperCase());
    }
    function originalOrCamelOptions(obj) {
      function get(key) {
        var _a4;
        const o = obj || {};
        return (_a4 = o[key]) != null ? _a4 : o[snakeToCamel(key)];
      }
      return { get };
    }
    var _cache, _LRUCache_instances, moveToEnd_fn, evict_fn;
    var LRUCache = class {
      constructor(options) {
        __privateAdd(this, _LRUCache_instances);
        __publicField(this, "capacity");
        /**
         * Maps are in order. Thus, the older item is the first item.
         *
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}
         */
        __privateAdd(this, _cache, /* @__PURE__ */ new Map());
        __publicField(this, "maxAge");
        this.capacity = options.capacity;
        this.maxAge = options.maxAge;
      }
      /**
       * Add an item to the cache.
       *
       * @param key the key to upsert
       * @param value the value of the key
       */
      set(key, value) {
        __privateMethod(this, _LRUCache_instances, moveToEnd_fn).call(this, key, value);
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this);
      }
      /**
       * Get an item from the cache.
       *
       * @param key the key to retrieve
       */
      get(key) {
        const item = __privateGet(this, _cache).get(key);
        if (!item)
          return;
        __privateMethod(this, _LRUCache_instances, moveToEnd_fn).call(this, key, item.value);
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this);
        return item.value;
      }
    };
    _cache = new WeakMap();
    _LRUCache_instances = new WeakSet();
    /**
     * Moves the key to the end of the cache.
     *
     * @param key the key to move
     * @param value the value of the key
     */
    moveToEnd_fn = function(key, value) {
      __privateGet(this, _cache).delete(key);
      __privateGet(this, _cache).set(key, {
        value,
        lastAccessed: Date.now()
      });
    };
    /**
     * Maintain the cache based on capacity and TTL.
     */
    evict_fn = function() {
      const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
      let oldestItem = __privateGet(this, _cache).entries().next();
      while (!oldestItem.done && (__privateGet(this, _cache).size > this.capacity || // too many
      oldestItem.value[1].lastAccessed < cutoffDate)) {
        __privateGet(this, _cache).delete(oldestItem.value[0]);
        oldestItem = __privateGet(this, _cache).entries().next();
      }
    };
    exports2.LRUCache = LRUCache;
    function removeUndefinedValuesInObject(object) {
      Object.entries(object).forEach(([key, value]) => {
        if (value === void 0 || value === "undefined") {
          delete object[key];
        }
      });
      return object;
    }
    function isValidFile(filePath) {
      return __async(this, null, function* () {
        try {
          const stats = yield fs12.promises.lstat(filePath);
          return stats.isFile();
        } catch (e2) {
          return false;
        }
      });
    }
    function getWellKnownCertificateConfigFileLocation() {
      const configDir = process.env.CLOUDSDK_CONFIG || (_isWindows() ? path8.join(process.env.APPDATA || "", CLOUDSDK_CONFIG_DIRECTORY) : path8.join(process.env.HOME || "", ".config", CLOUDSDK_CONFIG_DIRECTORY));
      return path8.join(configDir, WELL_KNOWN_CERTIFICATE_CONFIG_FILE);
    }
    function _isWindows() {
      return os3.platform().startsWith("win");
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/package.json
var require_package2 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/package.json"(exports2, module2) {
    module2.exports = {
      name: "google-auth-library",
      version: "10.5.0",
      author: "Google Inc.",
      description: "Google APIs Authentication Client Library for Node.js",
      engines: {
        node: ">=18"
      },
      main: "./build/src/index.js",
      types: "./build/src/index.d.ts",
      repository: "googleapis/google-auth-library-nodejs.git",
      keywords: [
        "google",
        "api",
        "google apis",
        "client",
        "client library"
      ],
      dependencies: {
        "base64-js": "^1.3.0",
        "ecdsa-sig-formatter": "^1.0.11",
        gaxios: "^7.0.0",
        "gcp-metadata": "^8.0.0",
        "google-logging-utils": "^1.0.0",
        gtoken: "^8.0.0",
        jws: "^4.0.0"
      },
      devDependencies: {
        "@types/base64-js": "^1.2.5",
        "@types/jws": "^3.1.0",
        "@types/mocha": "^10.0.10",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^22.0.0",
        "@types/sinon": "^17.0.0",
        "assert-rejects": "^1.0.0",
        c8: "^10.0.0",
        codecov: "^3.0.2",
        gts: "^6.0.0",
        "is-docker": "^3.0.0",
        jsdoc: "^4.0.0",
        "jsdoc-fresh": "^5.0.0",
        "jsdoc-region-tag": "^4.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "^5.0.1",
        keypair: "^1.0.4",
        mocha: "^11.1.0",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^14.0.5",
        "null-loader": "^4.0.0",
        puppeteer: "^24.0.0",
        sinon: "^21.0.0",
        "ts-loader": "^8.0.0",
        typescript: "5.8.2",
        webpack: "^5.21.2",
        "webpack-cli": "^4.0.0"
      },
      files: [
        "build/src",
        "!build/src/**/*.map"
      ],
      scripts: {
        test: "c8 mocha build/test",
        clean: "gts clean",
        prepare: "npm run compile",
        lint: "gts check --no-inline-config",
        compile: "tsc -p .",
        fix: "gts fix",
        pretest: "npm run compile -- --sourceMap",
        docs: "jsdoc -c .jsdoc.js",
        "samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        "system-test": "mocha build/system-test --timeout 60000",
        "presystem-test": "npm run compile -- --sourceMap",
        webpack: "webpack",
        "browser-test": "karma start",
        "docs-test": "echo 'disabled until linkinator is fixed'",
        "predocs-test": "npm run docs",
        prelint: "cd samples; npm link ../; npm install"
      },
      license: "Apache-2.0"
    };
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/shared.cjs
var require_shared2 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/shared.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.USER_AGENT = exports2.PRODUCT_NAME = exports2.pkg = void 0;
    var pkg = require_package2();
    exports2.pkg = pkg;
    var PRODUCT_NAME = "google-api-nodejs-client";
    exports2.PRODUCT_NAME = PRODUCT_NAME;
    var USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
    exports2.USER_AGENT = USER_AGENT;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/authclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthClient = exports2.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports2.DEFAULT_UNIVERSE = void 0;
    var events_1 = require("events");
    var gaxios_1 = require_src2();
    var util_1 = require_util2();
    var google_logging_utils_1 = require_src3();
    var shared_cjs_1 = require_shared2();
    exports2.DEFAULT_UNIVERSE = "googleapis.com";
    exports2.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var _AuthClient = class _AuthClient extends events_1.EventEmitter {
      constructor(opts = {}) {
        var _a4, _b, _c, _d2, _e;
        super();
        __publicField(this, "apiKey");
        __publicField(this, "projectId");
        /**
         * The quota project ID. The quota project can be used by client libraries for the billing purpose.
         * See {@link https://cloud.google.com/docs/quota Working with quotas}
         */
        __publicField(this, "quotaProjectId");
        /**
         * The {@link Gaxios `Gaxios`} instance used for making requests.
         */
        __publicField(this, "transporter");
        __publicField(this, "credentials", {});
        __publicField(this, "eagerRefreshThresholdMillis", exports2.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS);
        __publicField(this, "forceRefreshOnFailure", false);
        __publicField(this, "universeDomain", exports2.DEFAULT_UNIVERSE);
        const options = (0, util_1.originalOrCamelOptions)(opts);
        this.apiKey = opts.apiKey;
        this.projectId = (_a4 = options.get("project_id")) != null ? _a4 : null;
        this.quotaProjectId = options.get("quota_project_id");
        this.credentials = (_b = options.get("credentials")) != null ? _b : {};
        this.universeDomain = (_c = options.get("universe_domain")) != null ? _c : exports2.DEFAULT_UNIVERSE;
        this.transporter = (_d2 = opts.transporter) != null ? _d2 : new gaxios_1.Gaxios(opts.transporterOptions);
        if (options.get("useAuthRequestParameters") !== false) {
          this.transporter.interceptors.request.add(_AuthClient.DEFAULT_REQUEST_INTERCEPTOR);
          this.transporter.interceptors.response.add(_AuthClient.DEFAULT_RESPONSE_INTERCEPTOR);
        }
        if (opts.eagerRefreshThresholdMillis) {
          this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) != null ? _e : false;
      }
      /**
       * A {@link fetch `fetch`} compliant API for {@link AuthClient}.
       *
       * @see {@link AuthClient.request} for the classic method.
       *
       * @remarks
       *
       * This is useful as a drop-in replacement for `fetch` API usage.
       *
       * @example
       *
       * ```ts
       * const authClient = new AuthClient();
       * const fetchWithAuthClient: typeof fetch = (...args) => authClient.fetch(...args);
       * await fetchWithAuthClient('https://example.com');
       * ```
       *
       * @param args `fetch` API or {@link Gaxios.fetch `Gaxios#fetch`} parameters
       * @returns the {@link GaxiosResponse} with Gaxios-added properties
       */
      fetch(...args) {
        const input = args[0];
        const init = args[1];
        let url = void 0;
        const headers = new Headers();
        if (typeof input === "string") {
          url = new URL(input);
        } else if (input instanceof URL) {
          url = input;
        } else if (input && input.url) {
          url = new URL(input.url);
        }
        if (input && typeof input === "object" && "headers" in input) {
          gaxios_1.Gaxios.mergeHeaders(headers, input.headers);
        }
        if (init) {
          gaxios_1.Gaxios.mergeHeaders(headers, new Headers(init.headers));
        }
        if (typeof input === "object" && !(input instanceof URL)) {
          return this.request(__spreadProps(__spreadValues(__spreadValues({}, init), input), { headers, url }));
        } else {
          return this.request(__spreadProps(__spreadValues({}, init), { headers, url }));
        }
      }
      /**
       * Sets the auth credentials.
       */
      setCredentials(credentials) {
        this.credentials = credentials;
      }
      /**
       * Append additional headers, e.g., x-goog-user-project, shared across the
       * classes inheriting AuthClient. This method should be used by any method
       * that overrides getRequestMetadataAsync(), which is a shared helper for
       * setting request information in both gRPC and HTTP API calls.
       *
       * @param headers object to append additional headers to.
       */
      addSharedMetadataHeaders(headers) {
        if (!headers.has("x-goog-user-project") && // don't override a value the user sets.
        this.quotaProjectId) {
          headers.set("x-goog-user-project", this.quotaProjectId);
        }
        return headers;
      }
      /**
       * Adds the `x-goog-user-project` and `authorization` headers to the target Headers
       * object, if they exist on the source.
       *
       * @param target the headers to target
       * @param source the headers to source from
       * @returns the target headers
       */
      addUserProjectAndAuthHeaders(target, source) {
        const xGoogUserProject = source.get("x-goog-user-project");
        const authorizationHeader = source.get("authorization");
        if (xGoogUserProject) {
          target.set("x-goog-user-project", xGoogUserProject);
        }
        if (authorizationHeader) {
          target.set("authorization", authorizationHeader);
        }
        return target;
      }
      /**
       * Sets the method name that is making a Gaxios request, so that logging may tag
       * log lines with the operation.
       * @param config A Gaxios request config
       * @param methodName The method name making the call
       */
      static setMethodName(config, methodName) {
        try {
          const symbols = config;
          symbols[_AuthClient.RequestMethodNameSymbol] = methodName;
        } catch (e2) {
        }
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    /**
     * Symbols that can be added to GaxiosOptions to specify the method name that is
     * making an RPC call, for logging purposes, as well as a string ID that can be
     * used to correlate calls and responses.
     */
    __publicField(_AuthClient, "RequestMethodNameSymbol", Symbol("request method name"));
    __publicField(_AuthClient, "RequestLogIdSymbol", Symbol("request log id"));
    __publicField(_AuthClient, "log", (0, google_logging_utils_1.log)("auth"));
    __publicField(_AuthClient, "DEFAULT_REQUEST_INTERCEPTOR", {
      resolved: (config) => __async(null, null, function* () {
        if (!config.headers.has("x-goog-api-client")) {
          const nodeVersion = process.version.replace(/^v/, "");
          config.headers.set("x-goog-api-client", `gl-node/${nodeVersion}`);
        }
        const userAgent = config.headers.get("User-Agent");
        if (!userAgent) {
          config.headers.set("User-Agent", shared_cjs_1.USER_AGENT);
        } else if (!userAgent.includes(`${shared_cjs_1.PRODUCT_NAME}/`)) {
          config.headers.set("User-Agent", `${userAgent} ${shared_cjs_1.USER_AGENT}`);
        }
        try {
          const symbols = config;
          const methodName = symbols[_AuthClient.RequestMethodNameSymbol];
          const logId = `${Math.floor(Math.random() * 1e3)}`;
          symbols[_AuthClient.RequestLogIdSymbol] = logId;
          const logObject = {
            url: config.url,
            headers: config.headers
          };
          if (methodName) {
            _AuthClient.log.info("%s [%s] request %j", methodName, logId, logObject);
          } else {
            _AuthClient.log.info("[%s] request %j", logId, logObject);
          }
        } catch (e2) {
        }
        return config;
      })
    });
    __publicField(_AuthClient, "DEFAULT_RESPONSE_INTERCEPTOR", {
      resolved: (response) => __async(null, null, function* () {
        try {
          const symbols = response.config;
          const methodName = symbols[_AuthClient.RequestMethodNameSymbol];
          const logId = symbols[_AuthClient.RequestLogIdSymbol];
          if (methodName) {
            _AuthClient.log.info("%s [%s] response %j", methodName, logId, response.data);
          } else {
            _AuthClient.log.info("[%s] response %j", logId, response.data);
          }
        } catch (e2) {
        }
        return response;
      }),
      rejected: (error) => __async(null, null, function* () {
        var _a4, _b;
        try {
          const symbols = error.config;
          const methodName = symbols[_AuthClient.RequestMethodNameSymbol];
          const logId = symbols[_AuthClient.RequestLogIdSymbol];
          if (methodName) {
            _AuthClient.log.info("%s [%s] error %j", methodName, logId, (_a4 = error.response) == null ? void 0 : _a4.data);
          } else {
            _AuthClient.log.error("[%s] error %j", logId, (_b = error.response) == null ? void 0 : _b.data);
          }
        } catch (e2) {
        }
        throw error;
      })
    });
    var AuthClient = _AuthClient;
    exports2.AuthClient = AuthClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/loginticket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoginTicket = void 0;
    var LoginTicket = class {
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @param {string} env Envelope of the jwt
       * @param {TokenPayload} pay Payload of the jwt
       * @constructor
       */
      constructor(env, pay) {
        __publicField(this, "envelope");
        __publicField(this, "payload");
        this.envelope = env;
        this.payload = pay;
      }
      getEnvelope() {
        return this.envelope;
      }
      getPayload() {
        return this.payload;
      }
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @return The user ID
       */
      getUserId() {
        const payload = this.getPayload();
        if (payload && payload.sub) {
          return payload.sub;
        }
        return null;
      }
      /**
       * Returns attributes from the login ticket.  This can contain
       * various information about the user session.
       *
       * @return The envelope and payload
       */
      getAttributes() {
        return { envelope: this.getEnvelope(), payload: this.getPayload() };
      }
    };
    exports2.LoginTicket = LoginTicket;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/oauth2client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Client = exports2.ClientAuthentication = exports2.CertificateFormat = exports2.CodeChallengeMethod = void 0;
    var gaxios_1 = require_src2();
    var querystring = require("querystring");
    var stream = require("stream");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util_1 = require_util2();
    var crypto_1 = require_crypto3();
    var authclient_1 = require_authclient();
    var loginticket_1 = require_loginticket();
    var CodeChallengeMethod;
    (function(CodeChallengeMethod2) {
      CodeChallengeMethod2["Plain"] = "plain";
      CodeChallengeMethod2["S256"] = "S256";
    })(CodeChallengeMethod || (exports2.CodeChallengeMethod = CodeChallengeMethod = {}));
    var CertificateFormat;
    (function(CertificateFormat2) {
      CertificateFormat2["PEM"] = "PEM";
      CertificateFormat2["JWK"] = "JWK";
    })(CertificateFormat || (exports2.CertificateFormat = CertificateFormat = {}));
    var ClientAuthentication;
    (function(ClientAuthentication2) {
      ClientAuthentication2["ClientSecretPost"] = "ClientSecretPost";
      ClientAuthentication2["ClientSecretBasic"] = "ClientSecretBasic";
      ClientAuthentication2["None"] = "None";
    })(ClientAuthentication || (exports2.ClientAuthentication = ClientAuthentication = {}));
    var _OAuth2Client = class _OAuth2Client extends authclient_1.AuthClient {
      /**
       * An OAuth2 Client for Google APIs.
       *
       * @param options The OAuth2 Client Options. Passing an `clientId` directly is **@DEPRECATED**.
       * @param clientSecret **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.
       * @param redirectUri **@DEPRECATED**. Provide a {@link OAuth2ClientOptions `OAuth2ClientOptions`} object in the first parameter instead.
       */
      constructor(options = {}, clientSecret, redirectUri) {
        var _a4;
        super(typeof options === "object" ? options : {});
        __publicField(this, "redirectUri");
        __publicField(this, "certificateCache", {});
        __publicField(this, "certificateExpiry", null);
        __publicField(this, "certificateCacheFormat", CertificateFormat.PEM);
        __publicField(this, "refreshTokenPromises", /* @__PURE__ */ new Map());
        __publicField(this, "endpoints");
        __publicField(this, "issuers");
        __publicField(this, "clientAuthentication");
        // TODO: refactor tests to make this private
        __publicField(this, "_clientId");
        // TODO: refactor tests to make this private
        __publicField(this, "_clientSecret");
        __publicField(this, "refreshHandler");
        if (typeof options !== "object") {
          options = {
            clientId: options,
            clientSecret,
            redirectUri
          };
        }
        this._clientId = options.clientId || options.client_id;
        this._clientSecret = options.clientSecret || options.client_secret;
        this.redirectUri = options.redirectUri || ((_a4 = options.redirect_uris) == null ? void 0 : _a4[0]);
        this.endpoints = __spreadValues({
          tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
          oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
          oauth2TokenUrl: "https://oauth2.googleapis.com/token",
          oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
          oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
          oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
          oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key"
        }, options.endpoints);
        this.clientAuthentication = options.clientAuthentication || ClientAuthentication.ClientSecretPost;
        this.issuers = options.issuers || [
          "accounts.google.com",
          "https://accounts.google.com",
          this.universeDomain
        ];
      }
      /**
       * Generates URL for consent page landing.
       * @param opts Options.
       * @return URL to consent page.
       */
      generateAuthUrl(opts = {}) {
        if (opts.code_challenge_method && !opts.code_challenge) {
          throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
        }
        opts.response_type = opts.response_type || "code";
        opts.client_id = opts.client_id || this._clientId;
        opts.redirect_uri = opts.redirect_uri || this.redirectUri;
        if (Array.isArray(opts.scope)) {
          opts.scope = opts.scope.join(" ");
        }
        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();
        return rootUrl + "?" + querystring.stringify(opts);
      }
      generateCodeVerifier() {
        throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
      }
      /**
       * Convenience method to automatically generate a code_verifier, and its
       * resulting SHA256. If used, this must be paired with a S256
       * code_challenge_method.
       *
       * For a full example see:
       * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
       */
      generateCodeVerifierAsync() {
        return __async(this, null, function* () {
          const crypto2 = (0, crypto_1.createCrypto)();
          const randomString = crypto2.randomBytesBase64(96);
          const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
          const unencodedCodeChallenge = yield crypto2.sha256DigestBase64(codeVerifier);
          const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
          return { codeVerifier, codeChallenge };
        });
      }
      getToken(codeOrOptions, callback) {
        const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
        if (callback) {
          this.getTokenAsync(options).then((r2) => callback(null, r2.tokens, r2.res), (e2) => callback(e2, null, e2.response));
        } else {
          return this.getTokenAsync(options);
        }
      }
      getTokenAsync(options) {
        return __async(this, null, function* () {
          const url = this.endpoints.oauth2TokenUrl.toString();
          const headers = new Headers();
          const values = {
            client_id: options.client_id || this._clientId,
            code_verifier: options.codeVerifier,
            code: options.code,
            grant_type: "authorization_code",
            redirect_uri: options.redirect_uri || this.redirectUri
          };
          if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
            const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
            headers.set("authorization", `Basic ${basic.toString("base64")}`);
          }
          if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {
            values.client_secret = this._clientSecret;
          }
          const opts = __spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
            method: "POST",
            url,
            data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(values)),
            headers
          });
          authclient_1.AuthClient.setMethodName(opts, "getTokenAsync");
          const res = yield this.transporter.request(opts);
          const tokens = res.data;
          if (res.data && res.data.expires_in) {
            tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
            delete tokens.expires_in;
          }
          this.emit("tokens", tokens);
          return { tokens, res };
        });
      }
      /**
       * Refreshes the access token.
       * @param refresh_token Existing refresh token.
       * @private
       */
      refreshToken(refreshToken) {
        return __async(this, null, function* () {
          if (!refreshToken) {
            return this.refreshTokenNoCache(refreshToken);
          }
          if (this.refreshTokenPromises.has(refreshToken)) {
            return this.refreshTokenPromises.get(refreshToken);
          }
          const p = this.refreshTokenNoCache(refreshToken).then((r2) => {
            this.refreshTokenPromises.delete(refreshToken);
            return r2;
          }, (e2) => {
            this.refreshTokenPromises.delete(refreshToken);
            throw e2;
          });
          this.refreshTokenPromises.set(refreshToken, p);
          return p;
        });
      }
      refreshTokenNoCache(refreshToken) {
        return __async(this, null, function* () {
          var _a4;
          if (!refreshToken) {
            throw new Error("No refresh token is set.");
          }
          const url = this.endpoints.oauth2TokenUrl.toString();
          const data = {
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
            grant_type: "refresh_token"
          };
          let res;
          try {
            const opts = __spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
              method: "POST",
              url,
              data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(data))
            });
            authclient_1.AuthClient.setMethodName(opts, "refreshTokenNoCache");
            res = yield this.transporter.request(opts);
          } catch (e2) {
            if (e2 instanceof gaxios_1.GaxiosError && e2.message === "invalid_grant" && ((_a4 = e2.response) == null ? void 0 : _a4.data) && /ReAuth/i.test(e2.response.data.error_description)) {
              e2.message = JSON.stringify(e2.response.data);
            }
            throw e2;
          }
          const tokens = res.data;
          if (res.data && res.data.expires_in) {
            tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
            delete tokens.expires_in;
          }
          this.emit("tokens", tokens);
          return { tokens, res };
        });
      }
      refreshAccessToken(callback) {
        if (callback) {
          this.refreshAccessTokenAsync().then((r2) => callback(null, r2.credentials, r2.res), callback);
        } else {
          return this.refreshAccessTokenAsync();
        }
      }
      refreshAccessTokenAsync() {
        return __async(this, null, function* () {
          const r2 = yield this.refreshToken(this.credentials.refresh_token);
          const tokens = r2.tokens;
          tokens.refresh_token = this.credentials.refresh_token;
          this.credentials = tokens;
          return { credentials: this.credentials, res: r2.res };
        });
      }
      getAccessToken(callback) {
        if (callback) {
          this.getAccessTokenAsync().then((r2) => callback(null, r2.token, r2.res), callback);
        } else {
          return this.getAccessTokenAsync();
        }
      }
      getAccessTokenAsync() {
        return __async(this, null, function* () {
          const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
          if (shouldRefresh) {
            if (!this.credentials.refresh_token) {
              if (this.refreshHandler) {
                const refreshedAccessToken = yield this.processAndValidateRefreshHandler();
                if (refreshedAccessToken == null ? void 0 : refreshedAccessToken.access_token) {
                  this.setCredentials(refreshedAccessToken);
                  return { token: this.credentials.access_token };
                }
              } else {
                throw new Error("No refresh token or refresh handler callback is set.");
              }
            }
            const r2 = yield this.refreshAccessTokenAsync();
            if (!r2.credentials || r2.credentials && !r2.credentials.access_token) {
              throw new Error("Could not refresh access token.");
            }
            return { token: r2.credentials.access_token, res: r2.res };
          } else {
            return { token: this.credentials.access_token };
          }
        });
      }
      /**
       * The main authentication interface.  It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * In OAuth2Client, the result has the form:
       * { authorization: 'Bearer <access_token_value>' }
       */
      getRequestHeaders(url) {
        return __async(this, null, function* () {
          const headers = (yield this.getRequestMetadataAsync(url)).headers;
          return headers;
        });
      }
      getRequestMetadataAsync(url) {
        return __async(this, null, function* () {
          url;
          const thisCreds = this.credentials;
          if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {
            throw new Error("No access, refresh token, API key or refresh handler callback is set.");
          }
          if (thisCreds.access_token && !this.isTokenExpiring()) {
            thisCreds.token_type = thisCreds.token_type || "Bearer";
            const headers2 = new Headers({
              authorization: thisCreds.token_type + " " + thisCreds.access_token
            });
            return { headers: this.addSharedMetadataHeaders(headers2) };
          }
          if (this.refreshHandler) {
            const refreshedAccessToken = yield this.processAndValidateRefreshHandler();
            if (refreshedAccessToken == null ? void 0 : refreshedAccessToken.access_token) {
              this.setCredentials(refreshedAccessToken);
              const headers2 = new Headers({
                authorization: "Bearer " + this.credentials.access_token
              });
              return { headers: this.addSharedMetadataHeaders(headers2) };
            }
          }
          if (this.apiKey) {
            return { headers: new Headers({ "X-Goog-Api-Key": this.apiKey }) };
          }
          let r2 = null;
          let tokens = null;
          try {
            r2 = yield this.refreshToken(thisCreds.refresh_token);
            tokens = r2.tokens;
          } catch (err) {
            const e2 = err;
            if (e2.response && (e2.response.status === 403 || e2.response.status === 404)) {
              e2.message = `Could not refresh access token: ${e2.message}`;
            }
            throw e2;
          }
          const credentials = this.credentials;
          credentials.token_type = credentials.token_type || "Bearer";
          tokens.refresh_token = credentials.refresh_token;
          this.credentials = tokens;
          const headers = new Headers({
            authorization: credentials.token_type + " " + tokens.access_token
          });
          return { headers: this.addSharedMetadataHeaders(headers), res: r2.res };
        });
      }
      /**
       * Generates an URL to revoke the given token.
       * @param token The existing token to be revoked.
       *
       * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
       */
      static getRevokeTokenUrl(token) {
        return new _OAuth2Client().getRevokeTokenURL(token).toString();
      }
      /**
       * Generates a URL to revoke the given token.
       *
       * @param token The existing token to be revoked.
       */
      getRevokeTokenURL(token) {
        const url = new URL(this.endpoints.oauth2RevokeUrl);
        url.searchParams.append("token", token);
        return url;
      }
      revokeToken(token, callback) {
        const opts = __spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
          url: this.getRevokeTokenURL(token).toString(),
          method: "POST"
        });
        authclient_1.AuthClient.setMethodName(opts, "revokeToken");
        if (callback) {
          this.transporter.request(opts).then((r2) => callback(null, r2), callback);
        } else {
          return this.transporter.request(opts);
        }
      }
      revokeCredentials(callback) {
        if (callback) {
          this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
        } else {
          return this.revokeCredentialsAsync();
        }
      }
      revokeCredentialsAsync() {
        return __async(this, null, function* () {
          const token = this.credentials.access_token;
          this.credentials = {};
          if (token) {
            return this.revokeToken(token);
          } else {
            throw new Error("No access token to revoke.");
          }
        });
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      requestAsync(opts, reAuthRetried = false) {
        return __async(this, null, function* () {
          try {
            const r2 = yield this.getRequestMetadataAsync();
            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
            this.addUserProjectAndAuthHeaders(opts.headers, r2.headers);
            if (this.apiKey) {
              opts.headers.set("X-Goog-Api-Key", this.apiKey);
            }
            return yield this.transporter.request(opts);
          } catch (e2) {
            const res = e2.response;
            if (res) {
              const statusCode = res.status;
              const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
              const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
              const isReadableStream = res.config.data instanceof stream.Readable;
              const isAuthErr = statusCode === 401 || statusCode === 403;
              if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
                yield this.refreshAccessTokenAsync();
                return this.requestAsync(opts, true);
              } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
                const refreshedAccessToken = yield this.processAndValidateRefreshHandler();
                if (refreshedAccessToken == null ? void 0 : refreshedAccessToken.access_token) {
                  this.setCredentials(refreshedAccessToken);
                }
                return this.requestAsync(opts, true);
              }
            }
            throw e2;
          }
        });
      }
      verifyIdToken(options, callback) {
        if (callback && typeof callback !== "function") {
          throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
        }
        if (callback) {
          this.verifyIdTokenAsync(options).then((r2) => callback(null, r2), callback);
        } else {
          return this.verifyIdTokenAsync(options);
        }
      }
      verifyIdTokenAsync(options) {
        return __async(this, null, function* () {
          if (!options.idToken) {
            throw new Error("The verifyIdToken method requires an ID Token");
          }
          const response = yield this.getFederatedSignonCertsAsync();
          const login = yield this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
          return login;
        });
      }
      /**
       * Obtains information about the provisioned access token.  Especially useful
       * if you want to check the scopes that were provisioned to a given token.
       *
       * @param accessToken Required.  The Access Token for which you want to get
       * user info.
       */
      getTokenInfo(accessToken) {
        return __async(this, null, function* () {
          const { data } = yield this.transporter.request(__spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
            method: "POST",
            headers: {
              "content-type": "application/x-www-form-urlencoded;charset=UTF-8",
              authorization: `Bearer ${accessToken}`
            },
            url: this.endpoints.tokenInfoUrl.toString()
          }));
          const info = Object.assign({
            expiry_date: (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3,
            scopes: data.scope.split(" ")
          }, data);
          delete info.expires_in;
          delete info.scope;
          return info;
        });
      }
      getFederatedSignonCerts(callback) {
        if (callback) {
          this.getFederatedSignonCertsAsync().then((r2) => callback(null, r2.certs, r2.res), callback);
        } else {
          return this.getFederatedSignonCertsAsync();
        }
      }
      getFederatedSignonCertsAsync() {
        return __async(this, null, function* () {
          var _a4, _b;
          const nowTime = (/* @__PURE__ */ new Date()).getTime();
          const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
          if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {
            return { certs: this.certificateCache, format };
          }
          let res;
          let url;
          switch (format) {
            case CertificateFormat.PEM:
              url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
              break;
            case CertificateFormat.JWK:
              url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
              break;
            default:
              throw new Error(`Unsupported certificate format ${format}`);
          }
          try {
            const opts = __spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
              url
            });
            authclient_1.AuthClient.setMethodName(opts, "getFederatedSignonCertsAsync");
            res = yield this.transporter.request(opts);
          } catch (e2) {
            if (e2 instanceof Error) {
              e2.message = `Failed to retrieve verification certificates: ${e2.message}`;
            }
            throw e2;
          }
          const cacheControl = res == null ? void 0 : res.headers.get("cache-control");
          let cacheAge = -1;
          if (cacheControl) {
            const maxAge = (_b = (_a4 = new RegExp("max-age=(?<maxAge>[0-9]+)").exec(cacheControl)) == null ? void 0 : _a4.groups) == null ? void 0 : _b.maxAge;
            if (maxAge) {
              cacheAge = Number(maxAge) * 1e3;
            }
          }
          let certificates = {};
          switch (format) {
            case CertificateFormat.PEM:
              certificates = res.data;
              break;
            case CertificateFormat.JWK:
              for (const key of res.data.keys) {
                certificates[key.kid] = key;
              }
              break;
            default:
              throw new Error(`Unsupported certificate format ${format}`);
          }
          const now2 = /* @__PURE__ */ new Date();
          this.certificateExpiry = cacheAge === -1 ? null : new Date(now2.getTime() + cacheAge);
          this.certificateCache = certificates;
          this.certificateCacheFormat = format;
          return { certs: certificates, format, res };
        });
      }
      getIapPublicKeys(callback) {
        if (callback) {
          this.getIapPublicKeysAsync().then((r2) => callback(null, r2.pubkeys, r2.res), callback);
        } else {
          return this.getIapPublicKeysAsync();
        }
      }
      getIapPublicKeysAsync() {
        return __async(this, null, function* () {
          let res;
          const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
          try {
            const opts = __spreadProps(__spreadValues({}, _OAuth2Client.RETRY_CONFIG), {
              url
            });
            authclient_1.AuthClient.setMethodName(opts, "getIapPublicKeysAsync");
            res = yield this.transporter.request(opts);
          } catch (e2) {
            if (e2 instanceof Error) {
              e2.message = `Failed to retrieve verification certificates: ${e2.message}`;
            }
            throw e2;
          }
          return { pubkeys: res.data, res };
        });
      }
      verifySignedJwtWithCerts() {
        throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
      }
      /**
       * Verify the id token is signed with the correct certificate
       * and is from the correct audience.
       * @param jwt The jwt to verify (The ID Token in this case).
       * @param certs The array of certs to test the jwt against.
       * @param requiredAudience The audience to test the jwt against.
       * @param issuers The allowed issuers of the jwt (Optional).
       * @param maxExpiry The max expiry the certificate can be (Optional).
       * @return Returns a promise resolving to LoginTicket on verification.
       */
      verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
        return __async(this, null, function* () {
          const crypto2 = (0, crypto_1.createCrypto)();
          if (!maxExpiry) {
            maxExpiry = _OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
          }
          const segments = jwt.split(".");
          if (segments.length !== 3) {
            throw new Error("Wrong number of segments in token: " + jwt);
          }
          const signed = segments[0] + "." + segments[1];
          let signature = segments[2];
          let envelope;
          let payload;
          try {
            envelope = JSON.parse(crypto2.decodeBase64StringUtf8(segments[0]));
          } catch (err) {
            if (err instanceof Error) {
              err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
            }
            throw err;
          }
          if (!envelope) {
            throw new Error("Can't parse token envelope: " + segments[0]);
          }
          try {
            payload = JSON.parse(crypto2.decodeBase64StringUtf8(segments[1]));
          } catch (err) {
            if (err instanceof Error) {
              err.message = `Can't parse token payload '${segments[0]}`;
            }
            throw err;
          }
          if (!payload) {
            throw new Error("Can't parse token payload: " + segments[1]);
          }
          if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
            throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
          }
          const cert = certs[envelope.kid];
          if (envelope.alg === "ES256") {
            signature = formatEcdsa.joseToDer(signature, "ES256").toString("base64");
          }
          const verified = yield crypto2.verify(cert, signed, signature);
          if (!verified) {
            throw new Error("Invalid token signature: " + jwt);
          }
          if (!payload.iat) {
            throw new Error("No issue time in token: " + JSON.stringify(payload));
          }
          if (!payload.exp) {
            throw new Error("No expiration time in token: " + JSON.stringify(payload));
          }
          const iat = Number(payload.iat);
          if (isNaN(iat))
            throw new Error("iat field using invalid format");
          const exp = Number(payload.exp);
          if (isNaN(exp))
            throw new Error("exp field using invalid format");
          const now2 = (/* @__PURE__ */ new Date()).getTime() / 1e3;
          if (exp >= now2 + maxExpiry) {
            throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
          }
          const earliest = iat - _OAuth2Client.CLOCK_SKEW_SECS_;
          const latest = exp + _OAuth2Client.CLOCK_SKEW_SECS_;
          if (now2 < earliest) {
            throw new Error("Token used too early, " + now2 + " < " + earliest + ": " + JSON.stringify(payload));
          }
          if (now2 > latest) {
            throw new Error("Token used too late, " + now2 + " > " + latest + ": " + JSON.stringify(payload));
          }
          if (issuers && issuers.indexOf(payload.iss) < 0) {
            throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
          }
          if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
            const aud = payload.aud;
            let audVerified = false;
            if (requiredAudience.constructor === Array) {
              audVerified = requiredAudience.indexOf(aud) > -1;
            } else {
              audVerified = aud === requiredAudience;
            }
            if (!audVerified) {
              throw new Error("Wrong recipient, payload audience != requiredAudience");
            }
          }
          return new loginticket_1.LoginTicket(envelope, payload);
        });
      }
      /**
       * Returns a promise that resolves with AccessTokenResponse type if
       * refreshHandler is defined.
       * If not, nothing is returned.
       */
      processAndValidateRefreshHandler() {
        return __async(this, null, function* () {
          if (this.refreshHandler) {
            const accessTokenResponse = yield this.refreshHandler();
            if (!accessTokenResponse.access_token) {
              throw new Error("No access token is returned by the refreshHandler callback.");
            }
            return accessTokenResponse;
          }
          return;
        });
      }
      /**
       * Returns true if a token is expired or will expire within
       * eagerRefreshThresholdMillismilliseconds.
       * If there is no expiry time, assumes the token is not expired or expiring.
       */
      isTokenExpiring() {
        const expiryDate = this.credentials.expiry_date;
        return expiryDate ? expiryDate <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : false;
      }
    };
    /**
     * @deprecated use instance's {@link OAuth2Client.endpoints}
     */
    __publicField(_OAuth2Client, "GOOGLE_TOKEN_INFO_URL", "https://oauth2.googleapis.com/tokeninfo");
    /**
     * Clock skew - five minutes in seconds
     */
    __publicField(_OAuth2Client, "CLOCK_SKEW_SECS_", 300);
    /**
     * The default max Token Lifetime is one day in seconds
     */
    __publicField(_OAuth2Client, "DEFAULT_MAX_TOKEN_LIFETIME_SECS_", 86400);
    var OAuth2Client = _OAuth2Client;
    exports2.OAuth2Client = OAuth2Client;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/computeclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Compute = void 0;
    var gaxios_1 = require_src2();
    var gcpMetadata = require_src4();
    var oauth2client_1 = require_oauth2client();
    var Compute = class extends oauth2client_1.OAuth2Client {
      /**
       * Google Compute Engine service account credentials.
       *
       * Retrieve access token from the metadata server.
       * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
       */
      constructor(options = {}) {
        super(options);
        __publicField(this, "serviceAccountEmail");
        __publicField(this, "scopes");
        this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" };
        this.serviceAccountEmail = options.serviceAccountEmail || "default";
        this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
      }
      /**
       * Refreshes the access token.
       * @param refreshToken Unused parameter
       */
      refreshTokenNoCache() {
        return __async(this, null, function* () {
          const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
          let data;
          try {
            const instanceOptions = {
              property: tokenPath
            };
            if (this.scopes.length > 0) {
              instanceOptions.params = {
                scopes: this.scopes.join(",")
              };
            }
            data = yield gcpMetadata.instance(instanceOptions);
          } catch (e2) {
            if (e2 instanceof gaxios_1.GaxiosError) {
              e2.message = `Could not refresh access token: ${e2.message}`;
              this.wrapError(e2);
            }
            throw e2;
          }
          const tokens = data;
          if (data && data.expires_in) {
            tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3;
            delete tokens.expires_in;
          }
          this.emit("tokens", tokens);
          return { tokens, res: null };
        });
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      fetchIdToken(targetAudience) {
        return __async(this, null, function* () {
          const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
          let idToken;
          try {
            const instanceOptions = {
              property: idTokenPath
            };
            idToken = yield gcpMetadata.instance(instanceOptions);
          } catch (e2) {
            if (e2 instanceof Error) {
              e2.message = `Could not fetch ID token: ${e2.message}`;
            }
            throw e2;
          }
          return idToken;
        });
      }
      wrapError(e2) {
        const res = e2.response;
        if (res && res.status) {
          e2.status = res.status;
          if (res.status === 403) {
            e2.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e2.message;
          } else if (res.status === 404) {
            e2.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e2.message;
          }
        }
      }
    };
    exports2.Compute = Compute;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/idtokenclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdTokenClient = void 0;
    var oauth2client_1 = require_oauth2client();
    var IdTokenClient = class extends oauth2client_1.OAuth2Client {
      /**
       * Google ID Token client
       *
       * Retrieve ID token from the metadata server.
       * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
       */
      constructor(options) {
        super(options);
        __publicField(this, "targetAudience");
        __publicField(this, "idTokenProvider");
        this.targetAudience = options.targetAudience;
        this.idTokenProvider = options.idTokenProvider;
      }
      getRequestMetadataAsync() {
        return __async(this, null, function* () {
          if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
            const idToken = yield this.idTokenProvider.fetchIdToken(this.targetAudience);
            this.credentials = {
              id_token: idToken,
              expiry_date: this.getIdTokenExpiryDate(idToken)
            };
          }
          const headers = new Headers({
            authorization: "Bearer " + this.credentials.id_token
          });
          return { headers };
        });
      }
      getIdTokenExpiryDate(idToken) {
        const payloadB64 = idToken.split(".")[1];
        if (payloadB64) {
          const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
          return payload.exp * 1e3;
        }
      }
    };
    exports2.IdTokenClient = IdTokenClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/envDetect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GCPEnv = void 0;
    exports2.clear = clear2;
    exports2.getEnv = getEnv;
    var gcpMetadata = require_src4();
    var GCPEnv;
    (function(GCPEnv2) {
      GCPEnv2["APP_ENGINE"] = "APP_ENGINE";
      GCPEnv2["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
      GCPEnv2["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
      GCPEnv2["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
      GCPEnv2["CLOUD_RUN"] = "CLOUD_RUN";
      GCPEnv2["CLOUD_RUN_JOBS"] = "CLOUD_RUN_JOBS";
      GCPEnv2["NONE"] = "NONE";
    })(GCPEnv || (exports2.GCPEnv = GCPEnv = {}));
    var envPromise;
    function clear2() {
      envPromise = void 0;
    }
    function getEnv() {
      return __async(this, null, function* () {
        if (envPromise) {
          return envPromise;
        }
        envPromise = getEnvMemoized();
        return envPromise;
      });
    }
    function getEnvMemoized() {
      return __async(this, null, function* () {
        let env = GCPEnv.NONE;
        if (isAppEngine()) {
          env = GCPEnv.APP_ENGINE;
        } else if (isCloudFunction()) {
          env = GCPEnv.CLOUD_FUNCTIONS;
        } else if (yield isComputeEngine()) {
          if (yield isKubernetesEngine()) {
            env = GCPEnv.KUBERNETES_ENGINE;
          } else if (isCloudRun()) {
            env = GCPEnv.CLOUD_RUN;
          } else if (isCloudRunJob()) {
            env = GCPEnv.CLOUD_RUN_JOBS;
          } else {
            env = GCPEnv.COMPUTE_ENGINE;
          }
        } else {
          env = GCPEnv.NONE;
        }
        return env;
      });
    }
    function isAppEngine() {
      return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
    }
    function isCloudFunction() {
      return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
    }
    function isCloudRun() {
      return !!process.env.K_CONFIGURATION;
    }
    function isCloudRunJob() {
      return !!process.env.CLOUD_RUN_JOB;
    }
    function isKubernetesEngine() {
      return __async(this, null, function* () {
        try {
          yield gcpMetadata.instance("attributes/cluster-name");
          return true;
        } catch (e2) {
          return false;
        }
      });
    }
    function isComputeEngine() {
      return __async(this, null, function* () {
        return gcpMetadata.isAvailable();
      });
    }
  }
});

// ../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer5 = require_safe_buffer().Buffer;
    var Stream3 = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer5.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer5.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream3);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer5.concat([this.buffer, Buffer5.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// ../../node_modules/.pnpm/buffer-equal-constant-time@1.0.1/node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "../../node_modules/.pnpm/buffer-equal-constant-time@1.0.1/node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer5 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i2 = 0; i2 < a.length; i2++) {
        c |= a[i2] ^ b[i2];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer5.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer5.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer5.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// ../../node_modules/.pnpm/jwa@2.0.0/node_modules/jwa/index.js
var require_jwa = __commonJS({
  "../../node_modules/.pnpm/jwa@2.0.0/node_modules/jwa/index.js"(exports2, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer5 = require_safe_buffer().Buffer;
    var crypto2 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer5.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer5.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer5.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i2 = 0; i2 < padding; ++i2) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer5.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer5.from(signature), Buffer5.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// ../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer5 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer5.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// ../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer5 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream3 = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer5.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream3);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e2) {
        this.readable = false;
        this.emit("error", e2);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// ../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer5 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream3 = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e2) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer5.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer5.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream3);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e2) {
        this.readable = false;
        this.emit("error", e2);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// ../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/index.js
var require_jws = __commonJS({
  "../../node_modules/.pnpm/jws@4.0.0/node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// ../../node_modules/.pnpm/gtoken@8.0.0/node_modules/gtoken/build/cjs/src/index.cjs
var require_src5 = __commonJS({
  "../../node_modules/.pnpm/gtoken@8.0.0/node_modules/gtoken/build/cjs/src/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GoogleToken = void 0;
    var fs12 = _interopRequireWildcard(require("fs"));
    var _gaxios = require_src2();
    var jws = _interopRequireWildcard(require_jws());
    var path8 = _interopRequireWildcard(require("path"));
    var _util = require("util");
    function _interopRequireWildcard(e2, t2) {
      if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
      return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t3) {
        if (!t3 && e3 && e3.__esModule) return e3;
        var o, i2, f3 = { __proto__: null, "default": e3 };
        if (null === e3 || "object" != _typeof(e3) && "function" != typeof e3) return f3;
        if (o = t3 ? n : r2) {
          if (o.has(e3)) return o.get(e3);
          o.set(e3, f3);
        }
        for (var _t3 in e3) "default" !== _t3 && {}.hasOwnProperty.call(e3, _t3) && ((i2 = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t3)) && (i2.get || i2.set) ? o(f3, _t3, i2) : f3[_t3] = e3[_t3]);
        return f3;
      })(e2, t2);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classPrivateMethodInitSpec(e2, a) {
      _checkPrivateRedeclaration(e2, a), a.add(e2);
    }
    function _classPrivateFieldInitSpec(e2, t2, a) {
      _checkPrivateRedeclaration(e2, t2), t2.set(e2, a);
    }
    function _checkPrivateRedeclaration(e2, t2) {
      if (t2.has(e2)) throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
    function _classPrivateFieldSet(s2, a, r2) {
      return s2.set(_assertClassBrand(s2, a), r2), r2;
    }
    function _classPrivateFieldGet(s2, a) {
      return s2.get(_assertClassBrand(s2, a));
    }
    function _assertClassBrand(e2, t2, n) {
      if ("function" == typeof e2 ? e2 === t2 : e2.has(t2)) return arguments.length < 3 ? t2 : n;
      throw new TypeError("Private element is not present on this object");
    }
    function _defineProperties(e2, r2) {
      for (var t2 = 0; t2 < r2.length; t2++) {
        var o = r2[t2];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e2, r2, t2) {
      return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t2, o, e2) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o, e2 || [], _getPrototypeOf(t2).constructor) : o.apply(t2, e2));
    }
    function _possibleConstructorReturn(t2, e2) {
      if (e2 && ("object" == _typeof(e2) || "function" == typeof e2)) return e2;
      if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t2);
    }
    function _assertThisInitialized(e2) {
      if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e2;
    }
    function _inherits(t2, e2) {
      if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
      t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && _setPrototypeOf(t2, e2);
    }
    function _wrapNativeSuper(t2) {
      var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
        if (null === t3 || !_isNativeFunction(t3)) return t3;
        if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r2) {
          if (r2.has(t3)) return r2.get(t3);
          r2.set(t3, Wrapper);
        }
        function Wrapper() {
          return _construct(t3, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t3.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t3);
      }, _wrapNativeSuper(t2);
    }
    function _construct(t2, e2, r2) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e2);
      var p = new (t2.bind.apply(t2, o))();
      return r2 && _setPrototypeOf(p, r2.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t3) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t2;
      })();
    }
    function _isNativeFunction(t2) {
      try {
        return -1 !== Function.toString.call(t2).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t2;
      }
    }
    function _setPrototypeOf(t2, e2) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, _setPrototypeOf(t2, e2);
    }
    function _getPrototypeOf(t2) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, _getPrototypeOf(t2);
    }
    function _defineProperty(e2, r2, t2) {
      return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
    }
    function _toPropertyKey(t2) {
      var i2 = _toPrimitive(t2, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    function _toPrimitive(t2, r2) {
      if ("object" != _typeof(t2) || !t2) return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2 || "default");
        if ("object" != _typeof(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function _regenerator() {
      var e2, t2, r2 = "function" == typeof Symbol ? Symbol : {}, n = r2.iterator || "@@iterator", o = r2.toStringTag || "@@toStringTag";
      function i2(r3, n2, o2, i3) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r4, n3, o3) {
          var i4, c3, u3, f4 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e2, a: d, f: d.bind(e2, 4), d: function d2(t3, r5) {
            return i4 = t3, c3 = 0, u3 = e2, G.n = r5, a;
          } };
          function d(r5, n4) {
            for (c3 = r5, u3 = n4, t2 = 0; !y && f4 && !o4 && t2 < p.length; t2++) {
              var o4, i5 = p[t2], d2 = G.p, l = i5[2];
              r5 > 3 ? (o4 = l === n4) && (u3 = i5[(c3 = i5[4]) ? 5 : (c3 = 3, 3)], i5[4] = i5[5] = e2) : i5[0] <= d2 && ((o4 = r5 < 2 && d2 < i5[1]) ? (c3 = 0, G.v = n4, G.n = i5[1]) : d2 < l && (o4 = r5 < 3 || i5[0] > n4 || n4 > l) && (i5[4] = r5, i5[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r5 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f4 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t2 = c3 < 2 ? e2 : u3) || !y; ) {
              i4 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f4 = 2, i4) {
                  if (c3 || (o4 = "next"), t2 = i4[o4]) {
                    if (!(t2 = t2.call(i4, u3))) throw TypeError("iterator result is not an object");
                    if (!t2.done) return t2;
                    u3 = t2.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t2 = i4["return"]) && t2.call(i4), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i4 = e2;
                } else if ((t2 = (y = G.n < 0) ? u3 : r4.call(n3, G)) !== a) break;
              } catch (t3) {
                i4 = e2, c3 = 1, u3 = t3;
              } finally {
                f4 = 1;
              }
            }
            return { value: t2, done: y };
          };
        })(r3, o2, i3), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t2 = Object.getPrototypeOf;
      var c = [][n] ? t2(t2([][n]())) : (_regeneratorDefine2(t2 = {}, n, function() {
        return this;
      }), t2), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f3(e3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e3, GeneratorFunctionPrototype) : (e3.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e3, o, "GeneratorFunction")), e3.prototype = Object.create(u), e3;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i2, m: f3 };
      })();
    }
    function _regeneratorDefine2(e2, r2, n, t2) {
      var i2 = Object.defineProperty;
      try {
        i2({}, "", {});
      } catch (e3) {
        i2 = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e3, r3, n2, t3) {
        if (r3) i2 ? i2(e3, r3, { value: n2, enumerable: !t3, configurable: !t3, writable: !t3 }) : e3[r3] = n2;
        else {
          var o = function o2(r4, n3) {
            _regeneratorDefine2(e3, r4, function(e4) {
              return this._invoke(r4, n3, e4);
            });
          };
          o("next", 0), o("throw", 1), o("return", 2);
        }
      }, _regeneratorDefine2(e2, r2, n, t2);
    }
    function asyncGeneratorStep(n, t2, e2, r2, o, a, c) {
      try {
        var i2 = n[a](c), u = i2.value;
      } catch (n2) {
        return void e2(n2);
      }
      i2.done ? t2(u) : Promise.resolve(u).then(r2, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t2 = this, e2 = arguments;
        return new Promise(function(r2, o) {
          var a = n.apply(t2, e2);
          function _next(n2) {
            asyncGeneratorStep(a, r2, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r2, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var readFile = fs12.readFile ? (0, _util.promisify)(fs12.readFile) : /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee() {
      return _regenerator().w(function(_context) {
        while (1) switch (_context.n) {
          case 0:
            throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
          case 1:
            return _context.a(2);
        }
      }, _callee);
    }));
    var GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
    var GOOGLE_REVOKE_TOKEN_URL = "https://oauth2.googleapis.com/revoke?token=";
    var ErrorWithCode = /* @__PURE__ */ (function(_Error) {
      function ErrorWithCode2(message, code) {
        var _this;
        _classCallCheck(this, ErrorWithCode2);
        _this = _callSuper(this, ErrorWithCode2, [message]);
        _defineProperty(_this, "code", void 0);
        _this.code = code;
        return _this;
      }
      _inherits(ErrorWithCode2, _Error);
      return _createClass(ErrorWithCode2);
    })(/* @__PURE__ */ _wrapNativeSuper(Error));
    var _inFlightRequest = /* @__PURE__ */ new WeakMap();
    var _GoogleToken_brand = /* @__PURE__ */ new WeakSet();
    var GoogleToken = exports2.GoogleToken = /* @__PURE__ */ (function() {
      function GoogleToken2(_options) {
        _classCallCheck(this, GoogleToken2);
        _classPrivateMethodInitSpec(this, _GoogleToken_brand);
        _defineProperty(this, "expiresAt", void 0);
        _defineProperty(this, "key", void 0);
        _defineProperty(this, "keyFile", void 0);
        _defineProperty(this, "iss", void 0);
        _defineProperty(this, "sub", void 0);
        _defineProperty(this, "scope", void 0);
        _defineProperty(this, "rawToken", void 0);
        _defineProperty(this, "tokenExpires", void 0);
        _defineProperty(this, "email", void 0);
        _defineProperty(this, "additionalClaims", void 0);
        _defineProperty(this, "eagerRefreshThresholdMillis", void 0);
        _defineProperty(this, "transporter", {
          request: function request(opts) {
            return (0, _gaxios.request)(opts);
          }
        });
        _classPrivateFieldInitSpec(this, _inFlightRequest, void 0);
        _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, _options);
      }
      return _createClass(GoogleToken2, [{
        key: "accessToken",
        get: function get() {
          return this.rawToken ? this.rawToken.access_token : void 0;
        }
      }, {
        key: "idToken",
        get: function get() {
          return this.rawToken ? this.rawToken.id_token : void 0;
        }
      }, {
        key: "tokenType",
        get: function get() {
          return this.rawToken ? this.rawToken.token_type : void 0;
        }
      }, {
        key: "refreshToken",
        get: function get() {
          return this.rawToken ? this.rawToken.refresh_token : void 0;
        }
      }, {
        key: "hasExpired",
        value: function hasExpired() {
          var now2 = (/* @__PURE__ */ new Date()).getTime();
          if (this.rawToken && this.expiresAt) {
            return now2 >= this.expiresAt;
          } else {
            return true;
          }
        }
        /**
         * Returns whether the token will expire within eagerRefreshThresholdMillis
         *
         * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
         */
      }, {
        key: "isTokenExpiring",
        value: function isTokenExpiring() {
          var _this$eagerRefreshThr;
          var now2 = (/* @__PURE__ */ new Date()).getTime();
          var eagerRefreshThresholdMillis = (_this$eagerRefreshThr = this.eagerRefreshThresholdMillis) !== null && _this$eagerRefreshThr !== void 0 ? _this$eagerRefreshThr : 0;
          if (this.rawToken && this.expiresAt) {
            return this.expiresAt <= now2 + eagerRefreshThresholdMillis;
          } else {
            return true;
          }
        }
        /**
         * Returns a cached token or retrieves a new one from Google.
         *
         * @param callback The callback function.
         */
      }, {
        key: "getToken",
        value: function getToken(callback) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (_typeof(callback) === "object") {
            opts = callback;
            callback = void 0;
          }
          opts = Object.assign({
            forceRefresh: false
          }, opts);
          if (callback) {
            var cb = callback;
            _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts).then(function(t2) {
              return cb(null, t2);
            }, callback);
            return;
          }
          return _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts);
        }
        /**
         * Given a keyFile, extract the key and client email if available
         * @param keyFile Path to a json, pem, or p12 file that contains the key.
         * @returns an object with privateKey and clientEmail properties
         */
      }, {
        key: "getCredentials",
        value: (function() {
          var _getCredentials = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee2(keyFile) {
            var ext, key, body, privateKey, clientEmail, _privateKey, _t;
            return _regenerator().w(function(_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  ext = path8.extname(keyFile);
                  _t = ext;
                  _context2.n = _t === ".json" ? 1 : _t === ".der" ? 4 : _t === ".crt" ? 4 : _t === ".pem" ? 4 : _t === ".p12" ? 6 : _t === ".pfx" ? 6 : 7;
                  break;
                case 1:
                  _context2.n = 2;
                  return readFile(keyFile, "utf8");
                case 2:
                  key = _context2.v;
                  body = JSON.parse(key);
                  privateKey = body.private_key;
                  clientEmail = body.client_email;
                  if (!(!privateKey || !clientEmail)) {
                    _context2.n = 3;
                    break;
                  }
                  throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
                case 3:
                  return _context2.a(2, {
                    privateKey,
                    clientEmail
                  });
                case 4:
                  _context2.n = 5;
                  return readFile(keyFile, "utf8");
                case 5:
                  _privateKey = _context2.v;
                  return _context2.a(2, {
                    privateKey: _privateKey
                  });
                case 6:
                  throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
                case 7:
                  throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
                case 8:
                  return _context2.a(2);
              }
            }, _callee2);
          }));
          function getCredentials(_x) {
            return _getCredentials.apply(this, arguments);
          }
          return getCredentials;
        })()
      }, {
        key: "revokeToken",
        value: function revokeToken(callback) {
          if (callback) {
            _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this).then(function() {
              return callback();
            }, callback);
            return;
          }
          return _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this);
        }
      }]);
    })();
    function _getTokenAsync(_x2) {
      return _getTokenAsync2.apply(this, arguments);
    }
    function _getTokenAsync2() {
      _getTokenAsync2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee3(opts) {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!(_classPrivateFieldGet(_inFlightRequest, this) && !opts.forceRefresh)) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2, _classPrivateFieldGet(_inFlightRequest, this));
            case 1:
              _context3.p = 1;
              _context3.n = 2;
              return _classPrivateFieldSet(_inFlightRequest, this, _assertClassBrand(_GoogleToken_brand, this, _getTokenAsyncInner).call(this, opts));
            case 2:
              return _context3.a(2, _context3.v);
            case 3:
              _context3.p = 3;
              _classPrivateFieldSet(_inFlightRequest, this, void 0);
              return _context3.f(3);
            case 4:
              return _context3.a(2);
          }
        }, _callee3, this, [[1, , 3, 4]]);
      }));
      return _getTokenAsync2.apply(this, arguments);
    }
    function _getTokenAsyncInner(_x3) {
      return _getTokenAsyncInner2.apply(this, arguments);
    }
    function _getTokenAsyncInner2() {
      _getTokenAsyncInner2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee4(opts) {
        var creds;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (!(this.isTokenExpiring() === false && opts.forceRefresh === false)) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2, Promise.resolve(this.rawToken));
            case 1:
              if (!(!this.key && !this.keyFile)) {
                _context4.n = 2;
                break;
              }
              throw new Error("No key or keyFile set.");
            case 2:
              if (!(!this.key && this.keyFile)) {
                _context4.n = 4;
                break;
              }
              _context4.n = 3;
              return this.getCredentials(this.keyFile);
            case 3:
              creds = _context4.v;
              this.key = creds.privateKey;
              this.iss = creds.clientEmail || this.iss;
              if (!creds.clientEmail) {
                _assertClassBrand(_GoogleToken_brand, this, _ensureEmail).call(this);
              }
            case 4:
              return _context4.a(2, _assertClassBrand(_GoogleToken_brand, this, _requestToken).call(this));
          }
        }, _callee4, this);
      }));
      return _getTokenAsyncInner2.apply(this, arguments);
    }
    function _ensureEmail() {
      if (!this.iss) {
        throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
      }
    }
    function _revokeTokenAsync() {
      return _revokeTokenAsync2.apply(this, arguments);
    }
    function _revokeTokenAsync2() {
      _revokeTokenAsync2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee5() {
        var url;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              if (this.accessToken) {
                _context5.n = 1;
                break;
              }
              throw new Error("No token to revoke.");
            case 1:
              url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
              _context5.n = 2;
              return this.transporter.request({
                url,
                retry: true
              });
            case 2:
              _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, {
                email: this.iss,
                sub: this.sub,
                key: this.key,
                keyFile: this.keyFile,
                scope: this.scope,
                additionalClaims: this.additionalClaims
              });
            case 3:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      return _revokeTokenAsync2.apply(this, arguments);
    }
    function _configure() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.keyFile = options.keyFile;
      this.key = options.key;
      this.rawToken = void 0;
      this.iss = options.email || options.iss;
      this.sub = options.sub;
      this.additionalClaims = options.additionalClaims;
      if (_typeof(options.scope) === "object") {
        this.scope = options.scope.join(" ");
      } else {
        this.scope = options.scope;
      }
      this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
      if (options.transporter) {
        this.transporter = options.transporter;
      }
    }
    function _requestToken() {
      return _requestToken2.apply(this, arguments);
    }
    function _requestToken2() {
      _requestToken2 = _asyncToGenerator(/* @__PURE__ */ _regenerator().m(function _callee6() {
        var iat, additionalClaims, payload, signedJWT, r2, _response, _response2, body, desc, _t2;
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              iat = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
              additionalClaims = this.additionalClaims || {};
              payload = Object.assign({
                iss: this.iss,
                scope: this.scope,
                aud: GOOGLE_TOKEN_URL,
                exp: iat + 3600,
                iat,
                sub: this.sub
              }, additionalClaims);
              signedJWT = jws.sign({
                header: {
                  alg: "RS256"
                },
                payload,
                secret: this.key
              });
              _context6.p = 1;
              _context6.n = 2;
              return this.transporter.request({
                method: "POST",
                url: GOOGLE_TOKEN_URL,
                data: new URLSearchParams({
                  grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                  assertion: signedJWT
                }),
                responseType: "json",
                retryConfig: {
                  httpMethodsToRetry: ["POST"]
                }
              });
            case 2:
              r2 = _context6.v;
              this.rawToken = r2.data;
              this.expiresAt = r2.data.expires_in === null || r2.data.expires_in === void 0 ? void 0 : (iat + r2.data.expires_in) * 1e3;
              return _context6.a(2, this.rawToken);
            case 3:
              _context6.p = 3;
              _t2 = _context6.v;
              this.rawToken = void 0;
              this.tokenExpires = void 0;
              body = _t2.response && (_response = _t2.response) !== null && _response !== void 0 && _response.data ? (_response2 = _t2.response) === null || _response2 === void 0 ? void 0 : _response2.data : {};
              if (body.error) {
                desc = body.error_description ? ": ".concat(body.error_description) : "";
                _t2.message = "".concat(body.error).concat(desc);
              }
              throw _t2;
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 3]]);
      }));
      return _requestToken2.apply(this, arguments);
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/jwtaccess.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JWTAccess = void 0;
    var jws = require_jws();
    var util_1 = require_util2();
    var DEFAULT_HEADER = {
      alg: "RS256",
      typ: "JWT"
    };
    var JWTAccess = class _JWTAccess {
      /**
       * JWTAccess service account credentials.
       *
       * Create a new access token by using the credential to create a new JWT token
       * that's recognized as the access token.
       *
       * @param email the service account email address.
       * @param key the private key that will be used to sign the token.
       * @param keyId the ID of the private key used to sign the token.
       */
      constructor(email, key, keyId, eagerRefreshThresholdMillis) {
        __publicField(this, "email");
        __publicField(this, "key");
        __publicField(this, "keyId");
        __publicField(this, "projectId");
        __publicField(this, "eagerRefreshThresholdMillis");
        __publicField(this, "cache", new util_1.LRUCache({
          capacity: 500,
          maxAge: 60 * 60 * 1e3
        }));
        this.email = email;
        this.key = key;
        this.keyId = keyId;
        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis != null ? eagerRefreshThresholdMillis : 5 * 60 * 1e3;
      }
      /**
       * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
       *
       * @param url The URI being authorized.
       * @param scopes The scope or scopes being authorized
       * @returns A string that returns the cached key.
       */
      getCachedKey(url, scopes) {
        let cacheKey = url;
        if (scopes && Array.isArray(scopes) && scopes.length) {
          cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
        } else if (typeof scopes === "string") {
          cacheKey = url ? `${url}_${scopes}` : scopes;
        }
        if (!cacheKey) {
          throw Error("Scopes or url must be provided");
        }
        return cacheKey;
      }
      /**
       * Get a non-expired access token, after refreshing if necessary.
       *
       * @param url The URI being authorized.
       * @param additionalClaims An object with a set of additional claims to
       * include in the payload.
       * @returns An object that includes the authorization header.
       */
      getRequestHeaders(url, additionalClaims, scopes) {
        const key = this.getCachedKey(url, scopes);
        const cachedToken = this.cache.get(key);
        const now2 = Date.now();
        if (cachedToken && cachedToken.expiration - now2 > this.eagerRefreshThresholdMillis) {
          return new Headers(cachedToken.headers);
        }
        const iat = Math.floor(Date.now() / 1e3);
        const exp = _JWTAccess.getExpirationTime(iat);
        let defaultClaims;
        if (Array.isArray(scopes)) {
          scopes = scopes.join(" ");
        }
        if (scopes) {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            scope: scopes,
            exp,
            iat
          };
        } else {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            aud: url,
            exp,
            iat
          };
        }
        if (additionalClaims) {
          for (const claim in defaultClaims) {
            if (additionalClaims[claim]) {
              throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
            }
          }
        }
        const header = this.keyId ? __spreadProps(__spreadValues({}, DEFAULT_HEADER), { kid: this.keyId }) : DEFAULT_HEADER;
        const payload = Object.assign(defaultClaims, additionalClaims);
        const signedJWT = jws.sign({ header, payload, secret: this.key });
        const headers = new Headers({ authorization: `Bearer ${signedJWT}` });
        this.cache.set(key, {
          expiration: exp * 1e3,
          headers
        });
        return headers;
      }
      /**
       * Returns an expiration time for the JWT token.
       *
       * @param iat The issued at time for the JWT.
       * @returns An expiration time for the JWT.
       */
      static getExpirationTime(iat) {
        const exp = iat + 3600;
        return exp;
      }
      /**
       * Create a JWTAccess credentials instance using the given input options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve3, reject) => {
          if (!inputStream) {
            reject(new Error("Must pass in a stream containing the service account auth settings."));
          }
          let s2 = "";
          inputStream.setEncoding("utf8").on("data", (chunk) => s2 += chunk).on("error", reject).on("end", () => {
            try {
              const data = JSON.parse(s2);
              this.fromJSON(data);
              resolve3();
            } catch (err) {
              reject(err);
            }
          });
        });
      }
    };
    exports2.JWTAccess = JWTAccess;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/jwtclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JWT = void 0;
    var gtoken_1 = require_src5();
    var jwtaccess_1 = require_jwtaccess();
    var oauth2client_1 = require_oauth2client();
    var authclient_1 = require_authclient();
    var JWT = class _JWT extends oauth2client_1.OAuth2Client {
      /**
       * JWT service account credentials.
       *
       * Retrieve access token using gtoken.
       *
       * @param options the
       */
      constructor(options = {}) {
        super(options);
        __publicField(this, "email");
        __publicField(this, "keyFile");
        __publicField(this, "key");
        __publicField(this, "keyId");
        __publicField(this, "defaultScopes");
        __publicField(this, "scopes");
        __publicField(this, "scope");
        __publicField(this, "subject");
        __publicField(this, "gtoken");
        __publicField(this, "additionalClaims");
        __publicField(this, "useJWTAccessWithScope");
        __publicField(this, "defaultServicePath");
        __publicField(this, "access");
        this.email = options.email;
        this.keyFile = options.keyFile;
        this.key = options.key;
        this.keyId = options.keyId;
        this.scopes = options.scopes;
        this.subject = options.subject;
        this.additionalClaims = options.additionalClaims;
        this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
      }
      /**
       * Creates a copy of the credential with the specified scopes.
       * @param scopes List of requested scopes or a single scope.
       * @return The cloned instance.
       */
      createScoped(scopes) {
        const jwt = new _JWT(this);
        jwt.scopes = scopes;
        return jwt;
      }
      /**
       * Obtains the metadata to be sent with the request.
       *
       * @param url the URI being authorized.
       */
      getRequestMetadataAsync(url) {
        return __async(this, null, function* () {
          url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
          const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
          if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {
            throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);
          }
          if (!this.apiKey && useSelfSignedJWT) {
            if (this.additionalClaims && this.additionalClaims.target_audience) {
              const { tokens } = yield this.refreshToken();
              return {
                headers: this.addSharedMetadataHeaders(new Headers({
                  authorization: `Bearer ${tokens.id_token}`
                }))
              };
            } else {
              if (!this.access) {
                this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
              }
              let scopes;
              if (this.hasUserScopes()) {
                scopes = this.scopes;
              } else if (!url) {
                scopes = this.defaultScopes;
              }
              const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
              const headers = yield this.access.getRequestHeaders(
                url != null ? url : void 0,
                this.additionalClaims,
                // Scopes take precedent over audience for signing,
                // so we only provide them if `useJWTAccessWithScope` is on or
                // if we are in a non-default universe
                useScopes ? scopes : void 0
              );
              return { headers: this.addSharedMetadataHeaders(headers) };
            }
          } else if (this.hasAnyScopes() || this.apiKey) {
            return __superGet(_JWT.prototype, this, "getRequestMetadataAsync").call(this, url);
          } else {
            return { headers: new Headers() };
          }
        });
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      fetchIdToken(targetAudience) {
        return __async(this, null, function* () {
          const gtoken = new gtoken_1.GoogleToken({
            iss: this.email,
            sub: this.subject,
            scope: this.scopes || this.defaultScopes,
            keyFile: this.keyFile,
            key: this.key,
            additionalClaims: { target_audience: targetAudience },
            transporter: this.transporter
          });
          yield gtoken.getToken({
            forceRefresh: true
          });
          if (!gtoken.idToken) {
            throw new Error("Unknown error: Failed to fetch ID token");
          }
          return gtoken.idToken;
        });
      }
      /**
       * Determine if there are currently scopes available.
       */
      hasUserScopes() {
        if (!this.scopes) {
          return false;
        }
        return this.scopes.length > 0;
      }
      /**
       * Are there any default or user scopes defined.
       */
      hasAnyScopes() {
        if (this.scopes && this.scopes.length > 0)
          return true;
        if (this.defaultScopes && this.defaultScopes.length > 0)
          return true;
        return false;
      }
      authorize(callback) {
        if (callback) {
          this.authorizeAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.authorizeAsync();
        }
      }
      authorizeAsync() {
        return __async(this, null, function* () {
          const result = yield this.refreshToken();
          if (!result) {
            throw new Error("No result returned");
          }
          this.credentials = result.tokens;
          this.credentials.refresh_token = "jwt-placeholder";
          this.key = this.gtoken.key;
          this.email = this.gtoken.iss;
          return result.tokens;
        });
      }
      /**
       * Refreshes the access token.
       * @param refreshToken ignored
       * @private
       */
      refreshTokenNoCache() {
        return __async(this, null, function* () {
          const gtoken = this.createGToken();
          const token = yield gtoken.getToken({
            forceRefresh: this.isTokenExpiring()
          });
          const tokens = {
            access_token: token.access_token,
            token_type: "Bearer",
            expiry_date: gtoken.expiresAt,
            id_token: gtoken.idToken
          };
          this.emit("tokens", tokens);
          return { res: null, tokens };
        });
      }
      /**
       * Create a gToken if it doesn't already exist.
       */
      createGToken() {
        if (!this.gtoken) {
          this.gtoken = new gtoken_1.GoogleToken({
            iss: this.email,
            sub: this.subject,
            scope: this.scopes || this.defaultScopes,
            keyFile: this.keyFile,
            key: this.key,
            additionalClaims: this.additionalClaims,
            transporter: this.transporter
          });
        }
        return this.gtoken;
      }
      /**
       * Create a JWT credentials instance using the given input options.
       * @param json The input object.
       *
       * @remarks
       *
       * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve3, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the service account auth settings.");
          }
          let s2 = "";
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s2 += chunk).on("end", () => {
            try {
              const data = JSON.parse(s2);
              this.fromJSON(data);
              resolve3();
            } catch (e2) {
              reject(e2);
            }
          });
        });
      }
      /**
       * Creates a JWT credentials instance using an API Key for authentication.
       * @param apiKey The API Key in string form.
       */
      fromAPIKey(apiKey) {
        if (typeof apiKey !== "string") {
          throw new Error("Must provide an API Key string.");
        }
        this.apiKey = apiKey;
      }
      /**
       * Using the key or keyFile on the JWT client, obtain an object that contains
       * the key and the client email.
       */
      getCredentials() {
        return __async(this, null, function* () {
          if (this.key) {
            return { private_key: this.key, client_email: this.email };
          } else if (this.keyFile) {
            const gtoken = this.createGToken();
            const creds = yield gtoken.getCredentials(this.keyFile);
            return { private_key: creds.privateKey, client_email: creds.clientEmail };
          }
          throw new Error("A key or a keyFile must be provided to getCredentials.");
        });
      }
    };
    exports2.JWT = JWT;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/refreshclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserRefreshClient = exports2.USER_REFRESH_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var authclient_1 = require_authclient();
    exports2.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
    var UserRefreshClient = class _UserRefreshClient extends oauth2client_1.OAuth2Client {
      /**
       * The User Refresh Token client.
       *
       * @param optionsOrClientId The User Refresh Token client options. Passing an `clientId` directly is **@DEPRECATED**.
       * @param clientSecret **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
       * @param refreshToken **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
       * @param eagerRefreshThresholdMillis **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
       * @param forceRefreshOnFailure **@DEPRECATED**. Provide a {@link UserRefreshClientOptions `UserRefreshClientOptions`} object in the first parameter instead.
       */
      constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
        const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
          clientId: optionsOrClientId,
          clientSecret,
          refreshToken,
          eagerRefreshThresholdMillis,
          forceRefreshOnFailure
        };
        super(opts);
        // TODO: refactor tests to make this private
        // In a future gts release, the _propertyName rule will be lifted.
        // This is also a hard one because `this.refreshToken` is a function.
        __publicField(this, "_refreshToken");
        this._refreshToken = opts.refreshToken;
        this.credentials.refresh_token = opts.refreshToken;
      }
      /**
       * Refreshes the access token.
       * @param refreshToken An ignored refreshToken..
       * @param callback Optional callback.
       */
      refreshTokenNoCache() {
        return __async(this, null, function* () {
          return __superGet(_UserRefreshClient.prototype, this, "refreshTokenNoCache").call(this, this._refreshToken);
        });
      }
      fetchIdToken(targetAudience) {
        return __async(this, null, function* () {
          const opts = __spreadProps(__spreadValues({}, _UserRefreshClient.RETRY_CONFIG), {
            url: this.endpoints.oauth2TokenUrl,
            method: "POST",
            data: new URLSearchParams({
              client_id: this._clientId,
              client_secret: this._clientSecret,
              grant_type: "refresh_token",
              refresh_token: this._refreshToken,
              target_audience: targetAudience
            })
          });
          authclient_1.AuthClient.setMethodName(opts, "fetchIdToken");
          const res = yield this.transporter.request(opts);
          return res.data.id_token;
        });
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the user refresh token");
        }
        if (json.type !== "authorized_user") {
          throw new Error('The incoming JSON object does not have the "authorized_user" type');
        }
        if (!json.client_id) {
          throw new Error("The incoming JSON object does not contain a client_id field");
        }
        if (!json.client_secret) {
          throw new Error("The incoming JSON object does not contain a client_secret field");
        }
        if (!json.refresh_token) {
          throw new Error("The incoming JSON object does not contain a refresh_token field");
        }
        this._clientId = json.client_id;
        this._clientSecret = json.client_secret;
        this._refreshToken = json.refresh_token;
        this.credentials.refresh_token = json.refresh_token;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return __async(this, null, function* () {
          return new Promise((resolve3, reject) => {
            if (!inputStream) {
              return reject(new Error("Must pass in a stream containing the user refresh token."));
            }
            let s2 = "";
            inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s2 += chunk).on("end", () => {
              try {
                const data = JSON.parse(s2);
                this.fromJSON(data);
                return resolve3();
              } catch (err) {
                return reject(err);
              }
            });
          });
        });
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      static fromJSON(json) {
        const client = new _UserRefreshClient();
        client.fromJSON(json);
        return client;
      }
    };
    exports2.UserRefreshClient = UserRefreshClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/impersonated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Impersonated = exports2.IMPERSONATED_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var gaxios_1 = require_src2();
    var util_1 = require_util2();
    exports2.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
    var Impersonated = class _Impersonated extends oauth2client_1.OAuth2Client {
      /**
       * Impersonated service account credentials.
       *
       * Create a new access token by impersonating another service account.
       *
       * Impersonated Credentials allowing credentials issued to a user or
       * service account to impersonate another. The source project using
       * Impersonated Credentials must enable the "IAMCredentials" API.
       * Also, the target service account must grant the orginating principal
       * the "Service Account Token Creator" IAM role.
       *
       * **IMPORTANT**: This method does not validate the credential configuration.
       * A security risk occurs when a credential configuration configured with
       * malicious URLs is used. When the credential configuration is accepted from
       * an untrusted source, you should validate it before using it with this
       * method. For more details, see
       * https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
       *
       * @param {object} options - The configuration object.
       * @param {object} [options.sourceClient] the source credential used as to
       * acquire the impersonated credentials.
       * @param {string} [options.targetPrincipal] the service account to
       * impersonate.
       * @param {string[]} [options.delegates] the chained list of delegates
       * required to grant the final access_token. If set, the sequence of
       * identities must have "Service Account Token Creator" capability granted to
       * the preceding identity. For example, if set to [serviceAccountB,
       * serviceAccountC], the sourceCredential must have the Token Creator role on
       * serviceAccountB. serviceAccountB must have the Token Creator on
       * serviceAccountC. Finally, C must have Token Creator on target_principal.
       * If left unset, sourceCredential must have that role on targetPrincipal.
       * @param {string[]} [options.targetScopes] scopes to request during the
       * authorization grant.
       * @param {number} [options.lifetime] number of seconds the delegated
       * credential should be valid for up to 3600 seconds by default, or 43,200
       * seconds by extending the token's lifetime, see:
       * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
       * @param {string} [options.endpoint] api endpoint override.
       */
      constructor(options = {}) {
        var _a4, _b, _c, _d2, _e, _f;
        super(options);
        __publicField(this, "sourceClient");
        __publicField(this, "targetPrincipal");
        __publicField(this, "targetScopes");
        __publicField(this, "delegates");
        __publicField(this, "lifetime");
        __publicField(this, "endpoint");
        this.credentials = {
          expiry_date: 1,
          refresh_token: "impersonated-placeholder"
        };
        this.sourceClient = (_a4 = options.sourceClient) != null ? _a4 : new oauth2client_1.OAuth2Client();
        this.targetPrincipal = (_b = options.targetPrincipal) != null ? _b : "";
        this.delegates = (_c = options.delegates) != null ? _c : [];
        this.targetScopes = (_d2 = options.targetScopes) != null ? _d2 : [];
        this.lifetime = (_e = options.lifetime) != null ? _e : 3600;
        const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (!usingExplicitUniverseDomain) {
          this.universeDomain = this.sourceClient.universeDomain;
        } else if (this.sourceClient.universeDomain !== this.universeDomain) {
          throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
        }
        this.endpoint = (_f = options.endpoint) != null ? _f : `https://iamcredentials.${this.universeDomain}`;
      }
      /**
       * Signs some bytes.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
       * @param blobToSign String to sign.
       *
       * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
       */
      sign(blobToSign) {
        return __async(this, null, function* () {
          yield this.sourceClient.getAccessToken();
          const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
          const u = `${this.endpoint}/v1/${name}:signBlob`;
          const body = {
            delegates: this.delegates,
            payload: Buffer.from(blobToSign).toString("base64")
          };
          const res = yield this.sourceClient.request(__spreadProps(__spreadValues({}, _Impersonated.RETRY_CONFIG), {
            url: u,
            data: body,
            method: "POST"
          }));
          return res.data;
        });
      }
      /** The service account email to be impersonated. */
      getTargetPrincipal() {
        return this.targetPrincipal;
      }
      /**
       * Refreshes the access token.
       */
      refreshToken() {
        return __async(this, null, function* () {
          var _a4, _b, _c, _d2, _e, _f;
          try {
            yield this.sourceClient.getAccessToken();
            const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;
            const body = {
              delegates: this.delegates,
              scope: this.targetScopes,
              lifetime: this.lifetime + "s"
            };
            const res = yield this.sourceClient.request(__spreadProps(__spreadValues({}, _Impersonated.RETRY_CONFIG), {
              url: u,
              data: body,
              method: "POST"
            }));
            const tokenResponse = res.data;
            this.credentials.access_token = tokenResponse.accessToken;
            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
            return {
              tokens: this.credentials,
              res
            };
          } catch (error) {
            if (!(error instanceof Error))
              throw error;
            let status = 0;
            let message = "";
            if (error instanceof gaxios_1.GaxiosError) {
              status = (_c = (_b = (_a4 = error == null ? void 0 : error.response) == null ? void 0 : _a4.data) == null ? void 0 : _b.error) == null ? void 0 : _c.status;
              message = (_f = (_e = (_d2 = error == null ? void 0 : error.response) == null ? void 0 : _d2.data) == null ? void 0 : _e.error) == null ? void 0 : _f.message;
            }
            if (status && message) {
              error.message = `${status}: unable to impersonate: ${message}`;
              throw error;
            } else {
              error.message = `unable to impersonate: ${error}`;
              throw error;
            }
          }
        });
      }
      /**
       * Generates an OpenID Connect ID token for a service account.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
       *
       * @param targetAudience the audience for the fetched ID token.
       * @param options the for the request
       * @return an OpenID Connect ID token
       */
      fetchIdToken(targetAudience, options) {
        return __async(this, null, function* () {
          var _a4, _b;
          yield this.sourceClient.getAccessToken();
          const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
          const u = `${this.endpoint}/v1/${name}:generateIdToken`;
          const body = {
            delegates: this.delegates,
            audience: targetAudience,
            includeEmail: (_a4 = options == null ? void 0 : options.includeEmail) != null ? _a4 : true,
            useEmailAzp: (_b = options == null ? void 0 : options.includeEmail) != null ? _b : true
          };
          const res = yield this.sourceClient.request(__spreadProps(__spreadValues({}, _Impersonated.RETRY_CONFIG), {
            url: u,
            data: body,
            method: "POST"
          }));
          return res.data.token;
        });
      }
    };
    exports2.Impersonated = Impersonated;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/oauth2common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuthClientAuthHandler = void 0;
    exports2.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
    var gaxios_1 = require_src2();
    var crypto_1 = require_crypto3();
    var METHODS_SUPPORTING_REQUEST_BODY = ["PUT", "POST", "PATCH"];
    var _crypto, _clientAuthentication;
    var OAuthClientAuthHandler = class {
      /**
       * Instantiates an OAuth client authentication handler.
       * @param options The OAuth Client Auth Handler instance options. Passing an `ClientAuthentication` directly is **@DEPRECATED**.
       */
      constructor(options) {
        __privateAdd(this, _crypto, (0, crypto_1.createCrypto)());
        __privateAdd(this, _clientAuthentication);
        __publicField(this, "transporter");
        if (options && "clientId" in options) {
          __privateSet(this, _clientAuthentication, options);
          this.transporter = new gaxios_1.Gaxios();
        } else {
          __privateSet(this, _clientAuthentication, options == null ? void 0 : options.clientAuthentication);
          this.transporter = (options == null ? void 0 : options.transporter) || new gaxios_1.Gaxios();
        }
      }
      /**
       * Applies client authentication on the OAuth request's headers or POST
       * body but does not process the request.
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      applyClientAuthenticationOptions(opts, bearerToken) {
        opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
        this.injectAuthenticatedHeaders(opts, bearerToken);
        if (!bearerToken) {
          this.injectAuthenticatedRequestBody(opts);
        }
      }
      /**
       * Applies client authentication on the request's header if either
       * basic authentication or bearer token authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      injectAuthenticatedHeaders(opts, bearerToken) {
        var _a4;
        if (bearerToken) {
          opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers, {
            authorization: `Bearer ${bearerToken}`
          });
        } else if (((_a4 = __privateGet(this, _clientAuthentication)) == null ? void 0 : _a4.confidentialClientType) === "basic") {
          opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
          const clientId = __privateGet(this, _clientAuthentication).clientId;
          const clientSecret = __privateGet(this, _clientAuthentication).clientSecret || "";
          const base64EncodedCreds = __privateGet(this, _crypto).encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
          gaxios_1.Gaxios.mergeHeaders(opts.headers, {
            authorization: `Basic ${base64EncodedCreds}`
          });
        }
      }
      /**
       * Applies client authentication on the request's body if request-body
       * client authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       */
      injectAuthenticatedRequestBody(opts) {
        var _a4, _b;
        if (((_a4 = __privateGet(this, _clientAuthentication)) == null ? void 0 : _a4.confidentialClientType) === "request-body") {
          const method = (opts.method || "GET").toUpperCase();
          if (!METHODS_SUPPORTING_REQUEST_BODY.includes(method)) {
            throw new Error(`${method} HTTP method does not support ${__privateGet(this, _clientAuthentication).confidentialClientType} client authentication`);
          }
          const headers = new Headers(opts.headers);
          const contentType = headers.get("content-type");
          if ((contentType == null ? void 0 : contentType.startsWith("application/x-www-form-urlencoded")) || opts.data instanceof URLSearchParams) {
            const data = new URLSearchParams((_b = opts.data) != null ? _b : "");
            data.append("client_id", __privateGet(this, _clientAuthentication).clientId);
            data.append("client_secret", __privateGet(this, _clientAuthentication).clientSecret || "");
            opts.data = data;
          } else if (contentType == null ? void 0 : contentType.startsWith("application/json")) {
            opts.data = opts.data || {};
            Object.assign(opts.data, {
              client_id: __privateGet(this, _clientAuthentication).clientId,
              client_secret: __privateGet(this, _clientAuthentication).clientSecret || ""
            });
          } else {
            throw new Error(`${contentType} content-types are not supported with ${__privateGet(this, _clientAuthentication).confidentialClientType} client authentication`);
          }
        }
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    _crypto = new WeakMap();
    _clientAuthentication = new WeakMap();
    exports2.OAuthClientAuthHandler = OAuthClientAuthHandler;
    function getErrorFromOAuthErrorResponse(resp, err) {
      const errorCode = resp.error;
      const errorDescription = resp.error_description;
      const errorUri = resp.error_uri;
      let message = `Error code ${errorCode}`;
      if (typeof errorDescription !== "undefined") {
        message += `: ${errorDescription}`;
      }
      if (typeof errorUri !== "undefined") {
        message += ` - ${errorUri}`;
      }
      const newError = new Error(message);
      if (err) {
        const keys = Object.keys(err);
        if (err.stack) {
          keys.push("stack");
        }
        keys.forEach((key) => {
          if (key !== "message") {
            Object.defineProperty(newError, key, {
              value: err[key],
              writable: false,
              enumerable: true
            });
          }
        });
      }
      return newError;
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/stscredentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StsCredentials = void 0;
    var gaxios_1 = require_src2();
    var authclient_1 = require_authclient();
    var oauth2common_1 = require_oauth2common();
    var util_1 = require_util2();
    var _tokenExchangeEndpoint;
    var _StsCredentials = class _StsCredentials extends oauth2common_1.OAuthClientAuthHandler {
      /**
       * Initializes an STS credentials instance.
       *
       * @param options The STS credentials instance options. Passing an `tokenExchangeEndpoint` directly is **@DEPRECATED**.
       * @param clientAuthentication **@DEPRECATED**. Provide a {@link StsCredentialsConstructionOptions `StsCredentialsConstructionOptions`} object in the first parameter instead.
       */
      constructor(options = {
        tokenExchangeEndpoint: ""
      }, clientAuthentication) {
        if (typeof options !== "object" || options instanceof URL) {
          options = {
            tokenExchangeEndpoint: options,
            clientAuthentication
          };
        }
        super(options);
        __privateAdd(this, _tokenExchangeEndpoint);
        __privateSet(this, _tokenExchangeEndpoint, options.tokenExchangeEndpoint);
      }
      /**
       * Exchanges the provided token for another type of token based on the
       * rfc8693 spec.
       * @param stsCredentialsOptions The token exchange options used to populate
       *   the token exchange request.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @param options Optional additional GCP-specific non-spec defined options
       *   to send with the request.
       *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
       * @return A promise that resolves with the token exchange response containing
       *   the requested token and its expiration time.
       */
      exchangeToken(stsCredentialsOptions, headers, options) {
        return __async(this, null, function* () {
          var _a4, _b, _c;
          const values = {
            grant_type: stsCredentialsOptions.grantType,
            resource: stsCredentialsOptions.resource,
            audience: stsCredentialsOptions.audience,
            scope: (_a4 = stsCredentialsOptions.scope) == null ? void 0 : _a4.join(" "),
            requested_token_type: stsCredentialsOptions.requestedTokenType,
            subject_token: stsCredentialsOptions.subjectToken,
            subject_token_type: stsCredentialsOptions.subjectTokenType,
            actor_token: (_b = stsCredentialsOptions.actingParty) == null ? void 0 : _b.actorToken,
            actor_token_type: (_c = stsCredentialsOptions.actingParty) == null ? void 0 : _c.actorTokenType,
            // Non-standard GCP-specific options.
            options: options && JSON.stringify(options)
          };
          const opts = __spreadProps(__spreadValues({}, _StsCredentials.RETRY_CONFIG), {
            url: __privateGet(this, _tokenExchangeEndpoint).toString(),
            method: "POST",
            headers,
            data: new URLSearchParams((0, util_1.removeUndefinedValuesInObject)(values))
          });
          authclient_1.AuthClient.setMethodName(opts, "exchangeToken");
          this.applyClientAuthenticationOptions(opts);
          try {
            const response = yield this.transporter.request(opts);
            const stsSuccessfulResponse = response.data;
            stsSuccessfulResponse.res = response;
            return stsSuccessfulResponse;
          } catch (error) {
            if (error instanceof gaxios_1.GaxiosError && error.response) {
              throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
                error.response.data,
                // Preserve other fields from the original error.
                error
              );
            }
            throw error;
          }
        });
      }
    };
    _tokenExchangeEndpoint = new WeakMap();
    var StsCredentials = _StsCredentials;
    exports2.StsCredentials = StsCredentials;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseExternalAccountClient = exports2.CLOUD_RESOURCE_MANAGER = exports2.EXTERNAL_ACCOUNT_TYPE = exports2.EXPIRATION_TIME_OFFSET = void 0;
    var gaxios_1 = require_src2();
    var stream = require("stream");
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var util_1 = require_util2();
    var shared_cjs_1 = require_shared2();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
    var DEFAULT_TOKEN_LIFESPAN = 3600;
    exports2.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    exports2.EXTERNAL_ACCOUNT_TYPE = "external_account";
    exports2.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
    var WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/token";
    var _pendingAccessToken, _BaseExternalAccountClient_instances, internalRefreshAccessTokenAsync_fn;
    var _BaseExternalAccountClient = class _BaseExternalAccountClient extends authclient_1.AuthClient {
      /**
       * Instantiate a BaseExternalAccountClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       */
      constructor(options) {
        var _a4;
        super(options);
        __privateAdd(this, _BaseExternalAccountClient_instances);
        /**
         * OAuth scopes for the GCP access token to use. When not provided,
         * the default https://www.googleapis.com/auth/cloud-platform is
         * used.
         */
        __publicField(this, "scopes");
        __publicField(this, "projectNumber");
        __publicField(this, "audience");
        __publicField(this, "subjectTokenType");
        __publicField(this, "stsCredential");
        __publicField(this, "clientAuth");
        __publicField(this, "credentialSourceType");
        __publicField(this, "cachedAccessToken");
        __publicField(this, "serviceAccountImpersonationUrl");
        __publicField(this, "serviceAccountImpersonationLifetime");
        __publicField(this, "workforcePoolUserProject");
        __publicField(this, "configLifetimeRequested");
        __publicField(this, "tokenUrl");
        /**
         * @example
         * ```ts
         * new URL('https://cloudresourcemanager.googleapis.com/v1/projects/');
         * ```
         */
        __publicField(this, "cloudResourceManagerURL");
        __publicField(this, "supplierContext");
        /**
         * A pending access token request. Used for concurrent calls.
         */
        __privateAdd(this, _pendingAccessToken, null);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const type = opts.get("type");
        if (type && type !== exports2.EXTERNAL_ACCOUNT_TYPE) {
          throw new Error(`Expected "${exports2.EXTERNAL_ACCOUNT_TYPE}" type but received "${options.type}"`);
        }
        const clientId = opts.get("client_id");
        const clientSecret = opts.get("client_secret");
        this.tokenUrl = (_a4 = opts.get("token_url")) != null ? _a4 : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain);
        const subjectTokenType = opts.get("subject_token_type");
        const workforcePoolUserProject = opts.get("workforce_pool_user_project");
        const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
        const serviceAccountImpersonation = opts.get("service_account_impersonation");
        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
        this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
        if (clientId) {
          this.clientAuth = {
            confidentialClientType: "basic",
            clientId,
            clientSecret
          };
        }
        this.stsCredential = new sts.StsCredentials({
          tokenExchangeEndpoint: this.tokenUrl,
          clientAuthentication: this.clientAuth
        });
        this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
        this.cachedAccessToken = null;
        this.audience = opts.get("audience");
        this.subjectTokenType = subjectTokenType;
        this.workforcePoolUserProject = workforcePoolUserProject;
        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {
          throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
        }
        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
        this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
        if (this.serviceAccountImpersonationLifetime) {
          this.configLifetimeRequested = true;
        } else {
          this.configLifetimeRequested = false;
          this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
        }
        this.projectNumber = this.getProjectNumber(this.audience);
        this.supplierContext = {
          audience: this.audience,
          subjectTokenType: this.subjectTokenType,
          transporter: this.transporter
        };
      }
      /** The service account email to be impersonated, if available. */
      getServiceAccountEmail() {
        var _a4;
        if (this.serviceAccountImpersonationUrl) {
          if (this.serviceAccountImpersonationUrl.length > 256) {
            throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
          }
          const re = new RegExp("serviceAccounts\\/(?<email>[^:]+):generateAccessToken$");
          const result = re.exec(this.serviceAccountImpersonationUrl);
          return ((_a4 = result == null ? void 0 : result.groups) == null ? void 0 : _a4.email) || null;
        }
        return null;
      }
      /**
       * Provides a mechanism to inject GCP access tokens directly.
       * When the provided credential expires, a new credential, using the
       * external account options, is retrieved.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        super.setCredentials(credentials);
        this.cachedAccessToken = credentials;
      }
      /**
       * @return A promise that resolves with the current GCP access token
       *   response. If the current credential is expired, a new one is retrieved.
       */
      getAccessToken() {
        return __async(this, null, function* () {
          if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
            yield this.refreshAccessTokenAsync();
          }
          return {
            token: this.cachedAccessToken.access_token,
            res: this.cachedAccessToken.res
          };
        });
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { authorization: 'Bearer <access_token_value>' }
       */
      getRequestHeaders() {
        return __async(this, null, function* () {
          const accessTokenResponse = yield this.getAccessToken();
          const headers = new Headers({
            authorization: `Bearer ${accessTokenResponse.token}`
          });
          return this.addSharedMetadataHeaders(headers);
        });
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * @return A promise that resolves with the project ID corresponding to the
       *   current workload identity pool or current workforce pool if
       *   determinable. For workforce pool credential, it returns the project ID
       *   corresponding to the workforcePoolUserProject.
       *   This is introduced to match the current pattern of using the Auth
       *   library:
       *   const projectId = await auth.getProjectId();
       *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
       *   const res = await client.request({ url });
       *   The resource may not have permission
       *   (resourcemanager.projects.get) to call this API or the required
       *   scopes may not be selected:
       *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
       */
      getProjectId() {
        return __async(this, null, function* () {
          const projectNumber = this.projectNumber || this.workforcePoolUserProject;
          if (this.projectId) {
            return this.projectId;
          } else if (projectNumber) {
            const headers = yield this.getRequestHeaders();
            const opts = __spreadProps(__spreadValues({}, _BaseExternalAccountClient.RETRY_CONFIG), {
              headers,
              url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`
            });
            authclient_1.AuthClient.setMethodName(opts, "getProjectId");
            const response = yield this.transporter.request(opts);
            this.projectId = response.data.projectId;
            return this.projectId;
          }
          return null;
        });
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      requestAsync(opts, reAuthRetried = false) {
        return __async(this, null, function* () {
          let response;
          try {
            const requestHeaders = yield this.getRequestHeaders();
            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
            this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
            response = yield this.transporter.request(opts);
          } catch (e2) {
            const res = e2.response;
            if (res) {
              const statusCode = res.status;
              const isReadableStream = res.config.data instanceof stream.Readable;
              const isAuthErr = statusCode === 401 || statusCode === 403;
              if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
                yield this.refreshAccessTokenAsync();
                return yield this.requestAsync(opts, true);
              }
            }
            throw e2;
          }
          return response;
        });
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * External credentials are exchanged for GCP access tokens via the token
       * exchange endpoint and other settings provided in the client options
       * object.
       * If the service_account_impersonation_url is provided, an additional
       * step to exchange the external account GCP access token for a service
       * account impersonated token is performed.
       * @return A promise that resolves with the fresh GCP access tokens.
       */
      refreshAccessTokenAsync() {
        return __async(this, null, function* () {
          __privateSet(this, _pendingAccessToken, __privateGet(this, _pendingAccessToken) || __privateMethod(this, _BaseExternalAccountClient_instances, internalRefreshAccessTokenAsync_fn).call(this));
          try {
            return yield __privateGet(this, _pendingAccessToken);
          } finally {
            __privateSet(this, _pendingAccessToken, null);
          }
        });
      }
      /**
       * Returns the workload identity pool project number if it is determinable
       * from the audience resource name.
       * @param audience The STS audience used to determine the project number.
       * @return The project number associated with the workload identity pool, if
       *   this can be determined from the STS audience field. Otherwise, null is
       *   returned.
       */
      getProjectNumber(audience) {
        const match = audience.match(/\/projects\/([^/]+)/);
        if (!match) {
          return null;
        }
        return match[1];
      }
      /**
       * Exchanges an external account GCP access token for a service
       * account impersonated access token using iamcredentials
       * GenerateAccessToken API.
       * @param token The access token to exchange for a service account access
       *   token.
       * @return A promise that resolves with the service account impersonated
       *   credentials response.
       */
      getImpersonatedAccessToken(token) {
        return __async(this, null, function* () {
          const opts = __spreadProps(__spreadValues({}, _BaseExternalAccountClient.RETRY_CONFIG), {
            url: this.serviceAccountImpersonationUrl,
            method: "POST",
            headers: {
              "content-type": "application/json",
              authorization: `Bearer ${token}`
            },
            data: {
              scope: this.getScopesArray(),
              lifetime: this.serviceAccountImpersonationLifetime + "s"
            }
          });
          authclient_1.AuthClient.setMethodName(opts, "getImpersonatedAccessToken");
          const response = yield this.transporter.request(opts);
          const successResponse = response.data;
          return {
            access_token: successResponse.accessToken,
            // Convert from ISO format to timestamp.
            expiry_date: new Date(successResponse.expireTime).getTime(),
            res: response
          };
        });
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param accessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(accessToken) {
        const now2 = (/* @__PURE__ */ new Date()).getTime();
        return accessToken.expiry_date ? now2 >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
      /**
       * @return The list of scopes for the requested GCP access token.
       */
      getScopesArray() {
        if (typeof this.scopes === "string") {
          return [this.scopes];
        }
        return this.scopes || [DEFAULT_OAUTH_SCOPE];
      }
      getMetricsHeaderValue() {
        const nodeVersion = process.version.replace(/^v/, "");
        const saImpersonation = this.serviceAccountImpersonationUrl !== void 0;
        const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
        return `gl-node/${nodeVersion} auth/${shared_cjs_1.pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
      }
      getTokenUrl() {
        return this.tokenUrl;
      }
    };
    _pendingAccessToken = new WeakMap();
    _BaseExternalAccountClient_instances = new WeakSet();
    internalRefreshAccessTokenAsync_fn = function() {
      return __async(this, null, function* () {
        const subjectToken = yield this.retrieveSubjectToken();
        const stsCredentialsOptions = {
          grantType: STS_GRANT_TYPE,
          audience: this.audience,
          requestedTokenType: STS_REQUEST_TOKEN_TYPE,
          subjectToken,
          subjectTokenType: this.subjectTokenType,
          // generateAccessToken requires the provided access token to have
          // scopes:
          // https://www.googleapis.com/auth/iam or
          // https://www.googleapis.com/auth/cloud-platform
          // The new service account access token scopes will match the user
          // provided ones.
          scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
        };
        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0;
        const additionalHeaders = new Headers({
          "x-goog-api-client": this.getMetricsHeaderValue()
        });
        const stsResponse = yield this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
        if (this.serviceAccountImpersonationUrl) {
          this.cachedAccessToken = yield this.getImpersonatedAccessToken(stsResponse.access_token);
        } else if (stsResponse.expires_in) {
          this.cachedAccessToken = {
            access_token: stsResponse.access_token,
            expiry_date: (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3,
            res: stsResponse.res
          };
        } else {
          this.cachedAccessToken = {
            access_token: stsResponse.access_token,
            res: stsResponse.res
          };
        }
        this.credentials = {};
        Object.assign(this.credentials, this.cachedAccessToken);
        delete this.credentials.res;
        this.emit("tokens", {
          refresh_token: null,
          expiry_date: this.cachedAccessToken.expiry_date,
          access_token: this.cachedAccessToken.access_token,
          token_type: "Bearer",
          id_token: null
        });
        return this.cachedAccessToken;
      });
    };
    var BaseExternalAccountClient = _BaseExternalAccountClient;
    exports2.BaseExternalAccountClient = BaseExternalAccountClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileSubjectTokenSupplier = void 0;
    var util_1 = require("util");
    var fs12 = require("fs");
    var _a4;
    var readFile = (0, util_1.promisify)((_a4 = fs12.readFile) != null ? _a4 : (() => {
    }));
    var _a5;
    var realpath = (0, util_1.promisify)((_a5 = fs12.realpath) != null ? _a5 : (() => {
    }));
    var _a6;
    var lstat = (0, util_1.promisify)((_a6 = fs12.lstat) != null ? _a6 : (() => {
    }));
    var FileSubjectTokenSupplier = class {
      /**
       * Instantiates a new file based subject token supplier.
       * @param opts The file subject token supplier options to build the supplier
       *   with.
       */
      constructor(opts) {
        __publicField(this, "filePath");
        __publicField(this, "formatType");
        __publicField(this, "subjectTokenFieldName");
        this.filePath = opts.filePath;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
      }
      /**
       * Returns the subject token stored at the file specified in the constructor.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      getSubjectToken() {
        return __async(this, null, function* () {
          let parsedFilePath = this.filePath;
          try {
            parsedFilePath = yield realpath(parsedFilePath);
            if (!(yield lstat(parsedFilePath)).isFile()) {
              throw new Error();
            }
          } catch (err) {
            if (err instanceof Error) {
              err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
            }
            throw err;
          }
          let subjectToken;
          const rawText = yield readFile(parsedFilePath, { encoding: "utf8" });
          if (this.formatType === "text") {
            subjectToken = rawText;
          } else if (this.formatType === "json" && this.subjectTokenFieldName) {
            const json = JSON.parse(rawText);
            subjectToken = json[this.subjectTokenFieldName];
          }
          if (!subjectToken) {
            throw new Error("Unable to parse the subject_token from the credential_source file");
          }
          return subjectToken;
        });
      }
    };
    exports2.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UrlSubjectTokenSupplier = void 0;
    var authclient_1 = require_authclient();
    var UrlSubjectTokenSupplier = class {
      /**
       * Instantiates a URL subject token supplier.
       * @param opts The URL subject token supplier options to build the supplier with.
       */
      constructor(opts) {
        __publicField(this, "url");
        __publicField(this, "headers");
        __publicField(this, "formatType");
        __publicField(this, "subjectTokenFieldName");
        __publicField(this, "additionalGaxiosOptions");
        this.url = opts.url;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
        this.headers = opts.headers;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Sends a GET request to the URL provided in the constructor and resolves
       * with the returned external subject token.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      getSubjectToken(context) {
        return __async(this, null, function* () {
          const opts = __spreadProps(__spreadValues({}, this.additionalGaxiosOptions), {
            url: this.url,
            method: "GET",
            headers: this.headers
          });
          authclient_1.AuthClient.setMethodName(opts, "getSubjectToken");
          let subjectToken;
          if (this.formatType === "text") {
            const response = yield context.transporter.request(opts);
            subjectToken = response.data;
          } else if (this.formatType === "json" && this.subjectTokenFieldName) {
            const response = yield context.transporter.request(opts);
            subjectToken = response.data[this.subjectTokenFieldName];
          }
          if (!subjectToken) {
            throw new Error("Unable to parse the subject_token from the credential_source URL");
          }
          return subjectToken;
        });
      }
    };
    exports2.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/certificatesubjecttokensupplier.js
var require_certificatesubjecttokensupplier = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/certificatesubjecttokensupplier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CertificateSubjectTokenSupplier = exports2.InvalidConfigurationError = exports2.CertificateSourceUnavailableError = exports2.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = void 0;
    var util_1 = require_util2();
    var fs12 = require("fs");
    var crypto_1 = require("crypto");
    var https2 = require("https");
    exports2.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = "GOOGLE_API_CERTIFICATE_CONFIG";
    var CertificateSourceUnavailableError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "CertificateSourceUnavailableError";
      }
    };
    exports2.CertificateSourceUnavailableError = CertificateSourceUnavailableError;
    var InvalidConfigurationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidConfigurationError";
      }
    };
    exports2.InvalidConfigurationError = InvalidConfigurationError;
    var _CertificateSubjectTokenSupplier_instances, resolveCertificateConfigFilePath_fn, getCertAndKeyPaths_fn, getKeyAndCert_fn, processChainFromPaths_fn;
    var CertificateSubjectTokenSupplier = class {
      /**
       * Initializes a new instance of the CertificateSubjectTokenSupplier.
       * @param opts The configuration options for the supplier.
       */
      constructor(opts) {
        __privateAdd(this, _CertificateSubjectTokenSupplier_instances);
        __publicField(this, "certificateConfigPath");
        __publicField(this, "trustChainPath");
        __publicField(this, "cert");
        __publicField(this, "key");
        var _a4;
        if (!opts.useDefaultCertificateConfig && !opts.certificateConfigLocation) {
          throw new InvalidConfigurationError("Either `useDefaultCertificateConfig` must be true or a `certificateConfigLocation` must be provided.");
        }
        if (opts.useDefaultCertificateConfig && opts.certificateConfigLocation) {
          throw new InvalidConfigurationError("Both `useDefaultCertificateConfig` and `certificateConfigLocation` cannot be provided.");
        }
        this.trustChainPath = opts.trustChainPath;
        this.certificateConfigPath = (_a4 = opts.certificateConfigLocation) != null ? _a4 : "";
      }
      /**
       * Creates an HTTPS agent configured with the client certificate and private key for mTLS.
       * @returns An mTLS-configured https.Agent.
       */
      createMtlsHttpsAgent() {
        return __async(this, null, function* () {
          if (!this.key || !this.cert) {
            throw new InvalidConfigurationError("Cannot create mTLS Agent with missing certificate or key");
          }
          return new https2.Agent({ key: this.key, cert: this.cert });
        });
      }
      /**
       * Constructs the subject token, which is the base64-encoded certificate chain.
       * @returns A promise that resolves with the subject token.
       */
      getSubjectToken() {
        return __async(this, null, function* () {
          this.certificateConfigPath = yield __privateMethod(this, _CertificateSubjectTokenSupplier_instances, resolveCertificateConfigFilePath_fn).call(this);
          const { certPath, keyPath } = yield __privateMethod(this, _CertificateSubjectTokenSupplier_instances, getCertAndKeyPaths_fn).call(this);
          ({ cert: this.cert, key: this.key } = yield __privateMethod(this, _CertificateSubjectTokenSupplier_instances, getKeyAndCert_fn).call(this, certPath, keyPath));
          return yield __privateMethod(this, _CertificateSubjectTokenSupplier_instances, processChainFromPaths_fn).call(this, this.cert);
        });
      }
    };
    _CertificateSubjectTokenSupplier_instances = new WeakSet();
    resolveCertificateConfigFilePath_fn = function() {
      return __async(this, null, function* () {
        const overridePath = this.certificateConfigPath;
        if (overridePath) {
          if (yield (0, util_1.isValidFile)(overridePath)) {
            return overridePath;
          }
          throw new CertificateSourceUnavailableError(`Provided certificate config path is invalid: ${overridePath}`);
        }
        const envPath = process.env[exports2.CERTIFICATE_CONFIGURATION_ENV_VARIABLE];
        if (envPath) {
          if (yield (0, util_1.isValidFile)(envPath)) {
            return envPath;
          }
          throw new CertificateSourceUnavailableError(`Path from environment variable "${exports2.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" is invalid: ${envPath}`);
        }
        const wellKnownPath = (0, util_1.getWellKnownCertificateConfigFileLocation)();
        if (yield (0, util_1.isValidFile)(wellKnownPath)) {
          return wellKnownPath;
        }
        throw new CertificateSourceUnavailableError(`Could not find certificate configuration file. Searched override path, the "${exports2.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" env var, and the gcloud path (${wellKnownPath}).`);
      });
    };
    getCertAndKeyPaths_fn = function() {
      return __async(this, null, function* () {
        var _a4, _b, _c, _d2;
        const configPath = this.certificateConfigPath;
        let fileContents;
        try {
          fileContents = yield fs12.promises.readFile(configPath, "utf8");
        } catch (err) {
          throw new CertificateSourceUnavailableError(`Failed to read certificate config file at: ${configPath}`);
        }
        try {
          const config = JSON.parse(fileContents);
          const certPath = (_b = (_a4 = config == null ? void 0 : config.cert_configs) == null ? void 0 : _a4.workload) == null ? void 0 : _b.cert_path;
          const keyPath = (_d2 = (_c = config == null ? void 0 : config.cert_configs) == null ? void 0 : _c.workload) == null ? void 0 : _d2.key_path;
          if (!certPath || !keyPath) {
            throw new InvalidConfigurationError(`Certificate config file (${configPath}) is missing required "cert_path" or "key_path" in the workload config.`);
          }
          return { certPath, keyPath };
        } catch (e2) {
          if (e2 instanceof InvalidConfigurationError)
            throw e2;
          throw new InvalidConfigurationError(`Failed to parse certificate config from ${configPath}: ${e2.message}`);
        }
      });
    };
    getKeyAndCert_fn = function(certPath, keyPath) {
      return __async(this, null, function* () {
        let cert, key;
        try {
          cert = yield fs12.promises.readFile(certPath);
          new crypto_1.X509Certificate(cert);
        } catch (err) {
          const message = err instanceof Error ? err.message : String(err);
          throw new CertificateSourceUnavailableError(`Failed to read certificate file at ${certPath}: ${message}`);
        }
        try {
          key = yield fs12.promises.readFile(keyPath);
          (0, crypto_1.createPrivateKey)(key);
        } catch (err) {
          const message = err instanceof Error ? err.message : String(err);
          throw new CertificateSourceUnavailableError(`Failed to read private key file at ${keyPath}: ${message}`);
        }
        return { cert, key };
      });
    };
    processChainFromPaths_fn = function(leafCertBuffer) {
      return __async(this, null, function* () {
        var _a4;
        const leafCert = new crypto_1.X509Certificate(leafCertBuffer);
        if (!this.trustChainPath) {
          return JSON.stringify([leafCert.raw.toString("base64")]);
        }
        try {
          const chainPems = yield fs12.promises.readFile(this.trustChainPath, "utf8");
          const pemBlocks = (_a4 = chainPems.match(/-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/g)) != null ? _a4 : [];
          const chainCerts = pemBlocks.map((pem, index) => {
            try {
              return new crypto_1.X509Certificate(pem);
            } catch (err) {
              const message = err instanceof Error ? err.message : String(err);
              throw new InvalidConfigurationError(`Failed to parse certificate at index ${index} in trust chain file ${this.trustChainPath}: ${message}`);
            }
          });
          const leafIndex = chainCerts.findIndex((chainCert) => leafCert.raw.equals(chainCert.raw));
          let finalChain;
          if (leafIndex === -1) {
            finalChain = [leafCert, ...chainCerts];
          } else if (leafIndex === 0) {
            finalChain = chainCerts;
          } else {
            throw new InvalidConfigurationError(`Leaf certificate exists in the trust chain but is not the first entry (found at index ${leafIndex}).`);
          }
          return JSON.stringify(finalChain.map((cert) => cert.raw.toString("base64")));
        } catch (err) {
          if (err instanceof InvalidConfigurationError)
            throw err;
          const message = err instanceof Error ? err.message : String(err);
          throw new CertificateSourceUnavailableError(`Failed to process certificate chain from ${this.trustChainPath}: ${message}`);
        }
      });
    };
    exports2.CertificateSubjectTokenSupplier = CertificateSubjectTokenSupplier;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/identitypoolclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdentityPoolClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var util_1 = require_util2();
    var filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
    var urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();
    var certificatesubjecttokensupplier_1 = require_certificatesubjecttokensupplier();
    var stscredentials_1 = require_stscredentials();
    var gaxios_1 = require_src2();
    var IdentityPoolClient = class _IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiate an IdentityPoolClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid file-sourced or
       * url-sourced credential or a workforce pool user project is provided
       * with a non workforce audience.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       */
      constructor(options) {
        super(options);
        __publicField(this, "subjectTokenSupplier");
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const subjectTokenSupplier = opts.get("subject_token_supplier");
        if (!credentialSource && !subjectTokenSupplier) {
          throw new Error("A credential source or subject token supplier must be specified.");
        }
        if (credentialSource && subjectTokenSupplier) {
          throw new Error("Only one of credential source or subject token supplier can be specified.");
        }
        if (subjectTokenSupplier) {
          this.subjectTokenSupplier = subjectTokenSupplier;
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          const formatOpts = (0, util_1.originalOrCamelOptions)(credentialSourceOpts.get("format"));
          const formatType = formatOpts.get("type") || "text";
          const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
          if (formatType !== "json" && formatType !== "text") {
            throw new Error(`Invalid credential_source format "${formatType}"`);
          }
          if (formatType === "json" && !formatSubjectTokenFieldName) {
            throw new Error("Missing subject_token_field_name for JSON credential_source format");
          }
          const file = credentialSourceOpts.get("file");
          const url = credentialSourceOpts.get("url");
          const certificate = credentialSourceOpts.get("certificate");
          const headers = credentialSourceOpts.get("headers");
          if (file && url || url && certificate || file && certificate) {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file, url, or certificate.');
          } else if (file) {
            this.credentialSourceType = "file";
            this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
              filePath: file,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName
            });
          } else if (url) {
            this.credentialSourceType = "url";
            this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
              url,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName,
              headers,
              additionalGaxiosOptions: _IdentityPoolClient.RETRY_CONFIG
            });
          } else if (certificate) {
            this.credentialSourceType = "certificate";
            const certificateSubjecttokensupplier = new certificatesubjecttokensupplier_1.CertificateSubjectTokenSupplier({
              useDefaultCertificateConfig: certificate.use_default_certificate_config,
              certificateConfigLocation: certificate.certificate_config_location,
              trustChainPath: certificate.trust_chain_path
            });
            this.subjectTokenSupplier = certificateSubjecttokensupplier;
          } else {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file, url, or certificate.');
          }
        }
      }
      /**
       * Triggered when a external subject token is needed to be exchanged for a GCP
       * access token via GCP STS endpoint. Gets a subject token by calling
       * the configured {@link SubjectTokenSupplier}
       * @return A promise that resolves with the external subject token.
       */
      retrieveSubjectToken() {
        return __async(this, null, function* () {
          const subjectToken = yield this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
          if (this.subjectTokenSupplier instanceof certificatesubjecttokensupplier_1.CertificateSubjectTokenSupplier) {
            const mtlsAgent = yield this.subjectTokenSupplier.createMtlsHttpsAgent();
            this.stsCredential = new stscredentials_1.StsCredentials({
              tokenExchangeEndpoint: this.getTokenUrl(),
              clientAuthentication: this.clientAuth,
              transporter: new gaxios_1.Gaxios({ agent: mtlsAgent })
            });
            this.transporter = new gaxios_1.Gaxios(__spreadProps(__spreadValues({}, this.transporter.defaults || {}), {
              agent: mtlsAgent
            }));
          }
          return subjectToken;
        });
      }
    };
    exports2.IdentityPoolClient = IdentityPoolClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/awsrequestsigner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsRequestSigner = void 0;
    var gaxios_1 = require_src2();
    var crypto_1 = require_crypto3();
    var AWS_ALGORITHM = "AWS4-HMAC-SHA256";
    var AWS_REQUEST_TYPE = "aws4_request";
    var AwsRequestSigner = class {
      /**
       * Instantiates an AWS API request signer used to send authenticated signed
       * requests to AWS APIs based on the AWS Signature Version 4 signing process.
       * This also provides a mechanism to generate the signed request without
       * sending it.
       * @param getCredentials A mechanism to retrieve AWS security credentials
       *   when needed.
       * @param region The AWS region to use.
       */
      constructor(getCredentials, region) {
        __publicField(this, "getCredentials");
        __publicField(this, "region");
        __publicField(this, "crypto");
        this.getCredentials = getCredentials;
        this.region = region;
        this.crypto = (0, crypto_1.createCrypto)();
      }
      /**
       * Generates the signed request for the provided HTTP request for calling
       * an AWS API. This follows the steps described at:
       * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
       * @param amzOptions The AWS request options that need to be signed.
       * @return A promise that resolves with the GaxiosOptions containing the
       *   signed HTTP request parameters.
       */
      getRequestOptions(amzOptions) {
        return __async(this, null, function* () {
          if (!amzOptions.url) {
            throw new RangeError('"url" is required in "amzOptions"');
          }
          const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
          const url = amzOptions.url;
          const method = amzOptions.method || "GET";
          const requestPayload = amzOptions.body || requestPayloadData;
          const additionalAmzHeaders = amzOptions.headers;
          const awsSecurityCredentials = yield this.getCredentials();
          const uri = new URL(url);
          if (typeof requestPayload !== "string" && requestPayload !== void 0) {
            throw new TypeError(`'requestPayload' is expected to be a string if provided. Got: ${requestPayload}`);
          }
          const headerMap = yield generateAuthenticationHeaderMap({
            crypto: this.crypto,
            host: uri.host,
            canonicalUri: uri.pathname,
            canonicalQuerystring: uri.search.slice(1),
            method,
            region: this.region,
            securityCredentials: awsSecurityCredentials,
            requestPayload,
            additionalAmzHeaders
          });
          const headers = gaxios_1.Gaxios.mergeHeaders(
            // Add x-amz-date if available.
            headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {},
            {
              authorization: headerMap.authorizationHeader,
              host: uri.host
            },
            additionalAmzHeaders || {}
          );
          if (awsSecurityCredentials.token) {
            gaxios_1.Gaxios.mergeHeaders(headers, {
              "x-amz-security-token": awsSecurityCredentials.token
            });
          }
          const awsSignedReq = {
            url,
            method,
            headers
          };
          if (requestPayload !== void 0) {
            awsSignedReq.body = requestPayload;
          }
          return awsSignedReq;
        });
      }
    };
    exports2.AwsRequestSigner = AwsRequestSigner;
    function sign(crypto2, key, msg) {
      return __async(this, null, function* () {
        return yield crypto2.signWithHmacSha256(key, msg);
      });
    }
    function getSigningKey(crypto2, key, dateStamp, region, serviceName) {
      return __async(this, null, function* () {
        const kDate = yield sign(crypto2, `AWS4${key}`, dateStamp);
        const kRegion = yield sign(crypto2, kDate, region);
        const kService = yield sign(crypto2, kRegion, serviceName);
        const kSigning = yield sign(crypto2, kService, "aws4_request");
        return kSigning;
      });
    }
    function generateAuthenticationHeaderMap(options) {
      return __async(this, null, function* () {
        const additionalAmzHeaders = gaxios_1.Gaxios.mergeHeaders(options.additionalAmzHeaders);
        const requestPayload = options.requestPayload || "";
        const serviceName = options.host.split(".")[0];
        const now2 = /* @__PURE__ */ new Date();
        const amzDate = now2.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
        const dateStamp = now2.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
        if (options.securityCredentials.token) {
          additionalAmzHeaders.set("x-amz-security-token", options.securityCredentials.token);
        }
        const amzHeaders = gaxios_1.Gaxios.mergeHeaders(
          {
            host: options.host
          },
          // Previously the date was not fixed with x-amz- and could be provided manually.
          // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
          additionalAmzHeaders.has("date") ? {} : { "x-amz-date": amzDate },
          additionalAmzHeaders
        );
        let canonicalHeaders = "";
        const signedHeadersList = [
          ...amzHeaders.keys()
        ].sort();
        signedHeadersList.forEach((key) => {
          canonicalHeaders += `${key}:${amzHeaders.get(key)}
`;
        });
        const signedHeaders = signedHeadersList.join(";");
        const payloadHash = yield options.crypto.sha256DigestHex(requestPayload);
        const canonicalRequest = `${options.method.toUpperCase()}
${options.canonicalUri}
${options.canonicalQuerystring}
${canonicalHeaders}
${signedHeaders}
${payloadHash}`;
        const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
        const stringToSign = `${AWS_ALGORITHM}
${amzDate}
${credentialScope}
` + (yield options.crypto.sha256DigestHex(canonicalRequest));
        const signingKey = yield getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
        const signature = yield sign(options.crypto, signingKey, stringToSign);
        const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;
        return {
          // Do not return x-amz-date if date is available.
          amzDate: additionalAmzHeaders.has("date") ? void 0 : amzDate,
          authorizationHeader,
          canonicalQuerystring: options.canonicalQuerystring
        };
      });
    }
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultAwsSecurityCredentialsSupplier = void 0;
    var authclient_1 = require_authclient();
    var _DefaultAwsSecurityCredentialsSupplier_instances, getImdsV2SessionToken_fn, getAwsRoleName_fn, retrieveAwsSecurityCredentials_fn, regionFromEnv_get, securityCredentialsFromEnv_get;
    var DefaultAwsSecurityCredentialsSupplier = class {
      /**
       * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
       * from the credential_source stored in the ADC file.
       * @param opts The default aws security credentials supplier options object to
       *   build the supplier with.
       */
      constructor(opts) {
        __privateAdd(this, _DefaultAwsSecurityCredentialsSupplier_instances);
        __publicField(this, "regionUrl");
        __publicField(this, "securityCredentialsUrl");
        __publicField(this, "imdsV2SessionTokenUrl");
        __publicField(this, "additionalGaxiosOptions");
        this.regionUrl = opts.regionUrl;
        this.securityCredentialsUrl = opts.securityCredentialsUrl;
        this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Returns the active AWS region. This first checks to see if the region
       * is available as an environment variable. If it is not, then the supplier
       * will call the region URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS region string.
       */
      getAwsRegion(context) {
        return __async(this, null, function* () {
          if (__privateGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, regionFromEnv_get)) {
            return __privateGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, regionFromEnv_get);
          }
          const metadataHeaders = new Headers();
          if (!__privateGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, regionFromEnv_get) && this.imdsV2SessionTokenUrl) {
            metadataHeaders.set("x-aws-ec2-metadata-token", yield __privateMethod(this, _DefaultAwsSecurityCredentialsSupplier_instances, getImdsV2SessionToken_fn).call(this, context.transporter));
          }
          if (!this.regionUrl) {
            throw new RangeError('Unable to determine AWS region due to missing "options.credential_source.region_url"');
          }
          const opts = __spreadProps(__spreadValues({}, this.additionalGaxiosOptions), {
            url: this.regionUrl,
            method: "GET",
            headers: metadataHeaders
          });
          authclient_1.AuthClient.setMethodName(opts, "getAwsRegion");
          const response = yield context.transporter.request(opts);
          return response.data.substr(0, response.data.length - 1);
        });
      }
      /**
       * Returns AWS security credentials. This first checks to see if the credentials
       * is available as environment variables. If it is not, then the supplier
       * will call the security credentials URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS security credentials.
       */
      getAwsSecurityCredentials(context) {
        return __async(this, null, function* () {
          if (__privateGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, securityCredentialsFromEnv_get)) {
            return __privateGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, securityCredentialsFromEnv_get);
          }
          const metadataHeaders = new Headers();
          if (this.imdsV2SessionTokenUrl) {
            metadataHeaders.set("x-aws-ec2-metadata-token", yield __privateMethod(this, _DefaultAwsSecurityCredentialsSupplier_instances, getImdsV2SessionToken_fn).call(this, context.transporter));
          }
          const roleName = yield __privateMethod(this, _DefaultAwsSecurityCredentialsSupplier_instances, getAwsRoleName_fn).call(this, metadataHeaders, context.transporter);
          const awsCreds = yield __privateMethod(this, _DefaultAwsSecurityCredentialsSupplier_instances, retrieveAwsSecurityCredentials_fn).call(this, roleName, metadataHeaders, context.transporter);
          return {
            accessKeyId: awsCreds.AccessKeyId,
            secretAccessKey: awsCreds.SecretAccessKey,
            token: awsCreds.Token
          };
        });
      }
    };
    _DefaultAwsSecurityCredentialsSupplier_instances = new WeakSet();
    getImdsV2SessionToken_fn = function(transporter) {
      return __async(this, null, function* () {
        const opts = __spreadProps(__spreadValues({}, this.additionalGaxiosOptions), {
          url: this.imdsV2SessionTokenUrl,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
        });
        authclient_1.AuthClient.setMethodName(opts, "#getImdsV2SessionToken");
        const response = yield transporter.request(opts);
        return response.data;
      });
    };
    getAwsRoleName_fn = function(headers, transporter) {
      return __async(this, null, function* () {
        if (!this.securityCredentialsUrl) {
          throw new Error('Unable to determine AWS role name due to missing "options.credential_source.url"');
        }
        const opts = __spreadProps(__spreadValues({}, this.additionalGaxiosOptions), {
          url: this.securityCredentialsUrl,
          method: "GET",
          headers
        });
        authclient_1.AuthClient.setMethodName(opts, "#getAwsRoleName");
        const response = yield transporter.request(opts);
        return response.data;
      });
    };
    retrieveAwsSecurityCredentials_fn = function(roleName, headers, transporter) {
      return __async(this, null, function* () {
        const opts = __spreadProps(__spreadValues({}, this.additionalGaxiosOptions), {
          url: `${this.securityCredentialsUrl}/${roleName}`,
          headers
        });
        authclient_1.AuthClient.setMethodName(opts, "#retrieveAwsSecurityCredentials");
        const response = yield transporter.request(opts);
        return response.data;
      });
    };
    regionFromEnv_get = function() {
      return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
    };
    securityCredentialsFromEnv_get = function() {
      if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) {
        return {
          accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
          secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
          token: process.env["AWS_SESSION_TOKEN"]
        };
      }
      return null;
    };
    exports2.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/awsclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsClient = void 0;
    var awsrequestsigner_1 = require_awsrequestsigner();
    var baseexternalclient_1 = require_baseexternalclient();
    var defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
    var util_1 = require_util2();
    var gaxios_1 = require_src2();
    var _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
    var _AwsClient = class _AwsClient extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiates an AwsClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid AWS credential.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       */
      constructor(options) {
        super(options);
        __publicField(this, "environmentId");
        __publicField(this, "awsSecurityCredentialsSupplier");
        __publicField(this, "regionalCredVerificationUrl");
        __publicField(this, "awsRequestSigner");
        __publicField(this, "region");
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
        if (!credentialSource && !awsSecurityCredentialsSupplier) {
          throw new Error("A credential source or AWS security credentials supplier must be specified.");
        }
        if (credentialSource && awsSecurityCredentialsSupplier) {
          throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
        }
        if (awsSecurityCredentialsSupplier) {
          this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
          this.regionalCredVerificationUrl = __privateGet(_AwsClient, _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          this.environmentId = credentialSourceOpts.get("environment_id");
          const regionUrl = credentialSourceOpts.get("region_url");
          const securityCredentialsUrl = credentialSourceOpts.get("url");
          const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
          this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
            regionUrl,
            securityCredentialsUrl,
            imdsV2SessionTokenUrl
          });
          this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
          this.credentialSourceType = "aws";
          this.validateEnvironmentId();
        }
        this.awsRequestSigner = null;
        this.region = "";
      }
      validateEnvironmentId() {
        var _a4;
        const match = (_a4 = this.environmentId) == null ? void 0 : _a4.match(/^(aws)(\d+)$/);
        if (!match || !this.regionalCredVerificationUrl) {
          throw new Error('No valid AWS "credential_source" provided');
        } else if (parseInt(match[2], 10) !== 1) {
          throw new Error(`aws version "${match[2]}" is not supported in the current build.`);
        }
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint. This will call the
       * {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
       * Security Credentials, then use them to create a signed AWS STS request that
       * can be exchanged for a GCP access token.
       * @return A promise that resolves with the external subject token.
       */
      retrieveSubjectToken() {
        return __async(this, null, function* () {
          if (!this.awsRequestSigner) {
            this.region = yield this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(() => __async(this, null, function* () {
              return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
            }), this.region);
          }
          const options = yield this.awsRequestSigner.getRequestOptions(__spreadProps(__spreadValues({}, _AwsClient.RETRY_CONFIG), {
            url: this.regionalCredVerificationUrl.replace("{region}", this.region),
            method: "POST"
          }));
          const reformattedHeader = [];
          const extendedHeaders = gaxios_1.Gaxios.mergeHeaders({
            // The full, canonical resource name of the workload identity pool
            // provider, with or without the HTTPS prefix.
            // Including this header as part of the signature is recommended to
            // ensure data integrity.
            "x-goog-cloud-target-resource": this.audience
          }, options.headers);
          extendedHeaders.forEach((value, key) => reformattedHeader.push({ key, value }));
          return encodeURIComponent(JSON.stringify({
            url: options.url,
            method: options.method,
            headers: reformattedHeader
          }));
        });
      }
    };
    _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = new WeakMap();
    __privateAdd(_AwsClient, _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL, "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15");
    /**
     * @deprecated AWS client no validates the EC2 metadata address.
     **/
    __publicField(_AwsClient, "AWS_EC2_METADATA_IPV4_ADDRESS", "169.254.169.254");
    /**
     * @deprecated AWS client no validates the EC2 metadata address.
     **/
    __publicField(_AwsClient, "AWS_EC2_METADATA_IPV6_ADDRESS", "fd00:ec2::254");
    var AwsClient = _AwsClient;
    exports2.AwsClient = AwsClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/executable-response.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidSubjectTokenError = exports2.InvalidMessageFieldError = exports2.InvalidCodeFieldError = exports2.InvalidTokenTypeFieldError = exports2.InvalidExpirationTimeFieldError = exports2.InvalidSuccessFieldError = exports2.InvalidVersionFieldError = exports2.ExecutableResponseError = exports2.ExecutableResponse = void 0;
    var SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
    var OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
    var OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";
    var ExecutableResponse = class {
      /**
       * Instantiates an ExecutableResponse instance using the provided JSON object
       * from the output of the executable.
       * @param responseJson Response from a 3rd party executable, loaded from a
       * run of the executable or a cached output file.
       */
      constructor(responseJson) {
        /**
         * The version of the Executable response. Only version 1 is currently supported.
         */
        __publicField(this, "version");
        /**
         * Whether the executable ran successfully.
         */
        __publicField(this, "success");
        /**
         * The epoch time for expiration of the token in seconds.
         */
        __publicField(this, "expirationTime");
        /**
         * The type of subject token in the response, currently supported values are:
         * urn:ietf:params:oauth:token-type:saml2
         * urn:ietf:params:oauth:token-type:id_token
         * urn:ietf:params:oauth:token-type:jwt
         */
        __publicField(this, "tokenType");
        /**
         * The error code from the executable.
         */
        __publicField(this, "errorCode");
        /**
         * The error message from the executable.
         */
        __publicField(this, "errorMessage");
        /**
         * The subject token from the executable, format depends on tokenType.
         */
        __publicField(this, "subjectToken");
        if (!responseJson.version) {
          throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
        }
        if (responseJson.success === void 0) {
          throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
        }
        this.version = responseJson.version;
        this.success = responseJson.success;
        if (this.success) {
          this.expirationTime = responseJson.expiration_time;
          this.tokenType = responseJson.token_type;
          if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {
            throw new InvalidTokenTypeFieldError(`Executable response must contain a 'token_type' field when successful and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
          }
          if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
            if (!responseJson.saml_response) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
            }
            this.subjectToken = responseJson.saml_response;
          } else {
            if (!responseJson.id_token) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'id_token' field when token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
            }
            this.subjectToken = responseJson.id_token;
          }
        } else {
          if (!responseJson.code) {
            throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
          }
          if (!responseJson.message) {
            throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
          }
          this.errorCode = responseJson.code;
          this.errorMessage = responseJson.message;
        }
      }
      /**
       * @return A boolean representing if the response has a valid token. Returns
       * true when the response was successful and the token is not expired.
       */
      isValid() {
        return !this.isExpired() && this.success;
      }
      /**
       * @return A boolean representing if the response is expired. Returns true if the
       * provided timeout has passed.
       */
      isExpired() {
        return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
      }
    };
    exports2.ExecutableResponse = ExecutableResponse;
    var ExecutableResponseError = class extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports2.ExecutableResponseError = ExecutableResponseError;
    var InvalidVersionFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidVersionFieldError = InvalidVersionFieldError;
    var InvalidSuccessFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidSuccessFieldError = InvalidSuccessFieldError;
    var InvalidExpirationTimeFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;
    var InvalidTokenTypeFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;
    var InvalidCodeFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidCodeFieldError = InvalidCodeFieldError;
    var InvalidMessageFieldError = class extends ExecutableResponseError {
    };
    exports2.InvalidMessageFieldError = InvalidMessageFieldError;
    var InvalidSubjectTokenError = class extends ExecutableResponseError {
    };
    exports2.InvalidSubjectTokenError = InvalidSubjectTokenError;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PluggableAuthHandler = exports2.ExecutableError = void 0;
    var executable_response_1 = require_executable_response();
    var childProcess2 = require("child_process");
    var fs12 = require("fs");
    var ExecutableError = class extends Error {
      constructor(message, code) {
        super(`The executable failed with exit code: ${code} and error message: ${message}.`);
        /**
         * The exit code returned by the executable.
         */
        __publicField(this, "code");
        this.code = code;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports2.ExecutableError = ExecutableError;
    var PluggableAuthHandler = class _PluggableAuthHandler {
      /**
       * Instantiates a PluggableAuthHandler instance using the provided
       * PluggableAuthHandlerOptions object.
       */
      constructor(options) {
        __publicField(this, "commandComponents");
        __publicField(this, "timeoutMillis");
        __publicField(this, "outputFile");
        if (!options.command) {
          throw new Error("No command provided.");
        }
        this.commandComponents = _PluggableAuthHandler.parseCommand(options.command);
        this.timeoutMillis = options.timeoutMillis;
        if (!this.timeoutMillis) {
          throw new Error("No timeoutMillis provided.");
        }
        this.outputFile = options.outputFile;
      }
      /**
       * Calls user provided executable to get a 3rd party subject token and
       * returns the response.
       * @param envMap a Map of additional Environment Variables required for
       *   the executable.
       * @return A promise that resolves with the executable response.
       */
      retrieveResponseFromExecutable(envMap) {
        return new Promise((resolve3, reject) => {
          const child = childProcess2.spawn(this.commandComponents[0], this.commandComponents.slice(1), {
            env: __spreadValues(__spreadValues({}, process.env), Object.fromEntries(envMap))
          });
          let output = "";
          child.stdout.on("data", (data) => {
            output += data;
          });
          child.stderr.on("data", (err) => {
            output += err;
          });
          const timeout = setTimeout(() => {
            child.removeAllListeners();
            child.kill();
            return reject(new Error("The executable failed to finish within the timeout specified."));
          }, this.timeoutMillis);
          child.on("close", (code) => {
            clearTimeout(timeout);
            if (code === 0) {
              try {
                const responseJson = JSON.parse(output);
                const response = new executable_response_1.ExecutableResponse(responseJson);
                return resolve3(response);
              } catch (error) {
                if (error instanceof executable_response_1.ExecutableResponseError) {
                  return reject(error);
                }
                return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
              }
            } else {
              return reject(new ExecutableError(output, code.toString()));
            }
          });
        });
      }
      /**
       * Checks user provided output file for response from previous run of
       * executable and return the response if it exists, is formatted correctly, and is not expired.
       */
      retrieveCachedResponse() {
        return __async(this, null, function* () {
          if (!this.outputFile || this.outputFile.length === 0) {
            return void 0;
          }
          let filePath;
          try {
            filePath = yield fs12.promises.realpath(this.outputFile);
          } catch (e2) {
            return void 0;
          }
          if (!(yield fs12.promises.lstat(filePath)).isFile()) {
            return void 0;
          }
          const responseString = yield fs12.promises.readFile(filePath, {
            encoding: "utf8"
          });
          if (responseString === "") {
            return void 0;
          }
          try {
            const responseJson = JSON.parse(responseString);
            const response = new executable_response_1.ExecutableResponse(responseJson);
            if (response.isValid()) {
              return new executable_response_1.ExecutableResponse(responseJson);
            }
            return void 0;
          } catch (error) {
            if (error instanceof executable_response_1.ExecutableResponseError) {
              throw error;
            }
            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
          }
        });
      }
      /**
       * Parses given command string into component array, splitting on spaces unless
       * spaces are between quotation marks.
       */
      static parseCommand(command) {
        const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
        if (!components) {
          throw new Error(`Provided command: "${command}" could not be parsed.`);
        }
        for (let i2 = 0; i2 < components.length; i2++) {
          if (components[i2][0] === '"' && components[i2].slice(-1) === '"') {
            components[i2] = components[i2].slice(1, -1);
          }
        }
        return components;
      }
    };
    exports2.PluggableAuthHandler = PluggableAuthHandler;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PluggableAuthClient = exports2.ExecutableError = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var executable_response_1 = require_executable_response();
    var pluggable_auth_handler_1 = require_pluggable_auth_handler();
    var pluggable_auth_handler_2 = require_pluggable_auth_handler();
    Object.defineProperty(exports2, "ExecutableError", { enumerable: true, get: function() {
      return pluggable_auth_handler_2.ExecutableError;
    } });
    var DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1e3;
    var MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1e3;
    var MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1e3;
    var GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
    var MAXIMUM_EXECUTABLE_VERSION = 1;
    var PluggableAuthClient = class extends baseexternalclient_1.BaseExternalAccountClient {
      /**
       * Instantiates a PluggableAuthClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid pluggable auth credential.
       * @param options The external account options object typically loaded from
       *   the external account JSON credential file.
       */
      constructor(options) {
        super(options);
        /**
         * The command used to retrieve the third party token.
         */
        __publicField(this, "command");
        /**
         * The timeout in milliseconds for running executable,
         * set to default if none provided.
         */
        __publicField(this, "timeoutMillis");
        /**
         * The path to file to check for cached executable response.
         */
        __publicField(this, "outputFile");
        /**
         * Executable and output file handler.
         */
        __publicField(this, "handler");
        if (!options.credential_source.executable) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        this.command = options.credential_source.executable.command;
        if (!this.command) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        if (options.credential_source.executable.timeout_millis === void 0) {
          this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
        } else {
          this.timeoutMillis = options.credential_source.executable.timeout_millis;
          if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {
            throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
          }
        }
        this.outputFile = options.credential_source.executable.output_file;
        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
          command: this.command,
          timeoutMillis: this.timeoutMillis,
          outputFile: this.outputFile
        });
        this.credentialSourceType = "executable";
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint.
       * This uses the `options.credential_source` object to figure out how
       * to retrieve the token using the current environment. In this case,
       * this calls a user provided executable which returns the subject token.
       * The logic is summarized as:
       * 1. Validated that the executable is allowed to run. The
       *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
       *    1 for security reasons.
       * 2. If an output file is specified by the user, check the file location
       *    for a response. If the file exists and contains a valid response,
       *    return the subject token from the file.
       * 3. Call the provided executable and return response.
       * @return A promise that resolves with the external subject token.
       */
      retrieveSubjectToken() {
        return __async(this, null, function* () {
          if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") {
            throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
          }
          let executableResponse = void 0;
          if (this.outputFile) {
            executableResponse = yield this.handler.retrieveCachedResponse();
          }
          if (!executableResponse) {
            const envMap = /* @__PURE__ */ new Map();
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
            if (this.outputFile) {
              envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
            }
            const serviceAccountEmail = this.getServiceAccountEmail();
            if (serviceAccountEmail) {
              envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
            }
            executableResponse = yield this.handler.retrieveResponseFromExecutable(envMap);
          }
          if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {
            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
          }
          if (!executableResponse.success) {
            throw new pluggable_auth_handler_1.ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
          }
          if (this.outputFile) {
            if (!executableResponse.expirationTime) {
              throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
            }
          }
          if (executableResponse.isExpired()) {
            throw new Error("Executable response is expired.");
          }
          return executableResponse.subjectToken;
        });
      }
    };
    exports2.PluggableAuthClient = PluggableAuthClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/externalclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExternalAccountClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var identitypoolclient_1 = require_identitypoolclient();
    var awsclient_1 = require_awsclient();
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    var ExternalAccountClient = class {
      constructor() {
        throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
      }
      /**
       * This static method will instantiate the
       * corresponding type of external account credential depending on the
       * underlying credential source.
       *
       * **IMPORTANT**: This method does not validate the credential configuration.
       * A security risk occurs when a credential configuration configured with
       * malicious URLs is used. When the credential configuration is accepted from
       * an untrusted source, you should validate it before using it with this
       * method. For more details, see
       * https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
       *
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       * @return A BaseExternalAccountClient instance or null if the options
       *   provided do not correspond to an external account credential.
       */
      static fromJSON(options) {
        var _a4, _b;
        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          if ((_a4 = options.credential_source) == null ? void 0 : _a4.environment_id) {
            return new awsclient_1.AwsClient(options);
          } else if ((_b = options.credential_source) == null ? void 0 : _b.executable) {
            return new pluggable_auth_client_1.PluggableAuthClient(options);
          } else {
            return new identitypoolclient_1.IdentityPoolClient(options);
          }
        } else {
          return null;
        }
      }
    };
    exports2.ExternalAccountClient = ExternalAccountClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExternalAccountAuthorizedUserClient = exports2.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
    var authclient_1 = require_authclient();
    var oauth2common_1 = require_oauth2common();
    var gaxios_1 = require_src2();
    var stream = require("stream");
    var baseexternalclient_1 = require_baseexternalclient();
    exports2.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";
    var _tokenRefreshEndpoint;
    var _ExternalAccountAuthorizedUserHandler = class _ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
      /**
       * Initializes an ExternalAccountAuthorizedUserHandler instance.
       * @param url The URL of the token refresh endpoint.
       * @param transporter The transporter to use for the refresh request.
       * @param clientAuthentication The client authentication credentials to use
       *   for the refresh request.
       */
      constructor(options) {
        super(options);
        __privateAdd(this, _tokenRefreshEndpoint);
        __privateSet(this, _tokenRefreshEndpoint, options.tokenRefreshEndpoint);
      }
      /**
       * Requests a new access token from the token_url endpoint using the provided
       *   refresh token.
       * @param refreshToken The refresh token to use to generate a new access token.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @return A promise that resolves with the token refresh response containing
       *   the requested access token and its expiration time.
       */
      refreshToken(refreshToken, headers) {
        return __async(this, null, function* () {
          const opts = __spreadProps(__spreadValues({}, _ExternalAccountAuthorizedUserHandler.RETRY_CONFIG), {
            url: __privateGet(this, _tokenRefreshEndpoint),
            method: "POST",
            headers,
            data: new URLSearchParams({
              grant_type: "refresh_token",
              refresh_token: refreshToken
            })
          });
          authclient_1.AuthClient.setMethodName(opts, "refreshToken");
          this.applyClientAuthenticationOptions(opts);
          try {
            const response = yield this.transporter.request(opts);
            const tokenRefreshResponse = response.data;
            tokenRefreshResponse.res = response;
            return tokenRefreshResponse;
          } catch (error) {
            if (error instanceof gaxios_1.GaxiosError && error.response) {
              throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
                error.response.data,
                // Preserve other fields from the original error.
                error
              );
            }
            throw error;
          }
        });
      }
    };
    _tokenRefreshEndpoint = new WeakMap();
    var ExternalAccountAuthorizedUserHandler = _ExternalAccountAuthorizedUserHandler;
    var ExternalAccountAuthorizedUserClient = class extends authclient_1.AuthClient {
      /**
       * Instantiates an ExternalAccountAuthorizedUserClient instances using the
       * provided JSON object loaded from a credentials files.
       * An error is throws if the credential is not valid.
       * @param options The external account authorized user option object typically
       *   from the external accoutn authorized user JSON credential file.
       */
      constructor(options) {
        var _a4;
        super(options);
        __publicField(this, "cachedAccessToken");
        __publicField(this, "externalAccountAuthorizedUserHandler");
        __publicField(this, "refreshToken");
        if (options.universe_domain) {
          this.universeDomain = options.universe_domain;
        }
        this.refreshToken = options.refresh_token;
        const clientAuthentication = {
          confidentialClientType: "basic",
          clientId: options.client_id,
          clientSecret: options.client_secret
        };
        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler({
          tokenRefreshEndpoint: (_a4 = options.token_url) != null ? _a4 : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain),
          transporter: this.transporter,
          clientAuthentication
        });
        this.cachedAccessToken = null;
        this.quotaProjectId = options.quota_project_id;
        if (typeof (options == null ? void 0 : options.eagerRefreshThresholdMillis) !== "number") {
          this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;
        } else {
          this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = !!(options == null ? void 0 : options.forceRefreshOnFailure);
      }
      getAccessToken() {
        return __async(this, null, function* () {
          if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
            yield this.refreshAccessTokenAsync();
          }
          return {
            token: this.cachedAccessToken.access_token,
            res: this.cachedAccessToken.res
          };
        });
      }
      getRequestHeaders() {
        return __async(this, null, function* () {
          const accessTokenResponse = yield this.getAccessToken();
          const headers = new Headers({
            authorization: `Bearer ${accessTokenResponse.token}`
          });
          return this.addSharedMetadataHeaders(headers);
        });
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      requestAsync(opts, reAuthRetried = false) {
        return __async(this, null, function* () {
          let response;
          try {
            const requestHeaders = yield this.getRequestHeaders();
            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
            this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
            response = yield this.transporter.request(opts);
          } catch (e2) {
            const res = e2.response;
            if (res) {
              const statusCode = res.status;
              const isReadableStream = res.config.data instanceof stream.Readable;
              const isAuthErr = statusCode === 401 || statusCode === 403;
              if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
                yield this.refreshAccessTokenAsync();
                return yield this.requestAsync(opts, true);
              }
            }
            throw e2;
          }
          return response;
        });
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * @return A promise that resolves with the refreshed credential.
       */
      refreshAccessTokenAsync() {
        return __async(this, null, function* () {
          const refreshResponse = yield this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
          this.cachedAccessToken = {
            access_token: refreshResponse.access_token,
            expiry_date: (/* @__PURE__ */ new Date()).getTime() + refreshResponse.expires_in * 1e3,
            res: refreshResponse.res
          };
          if (refreshResponse.refresh_token !== void 0) {
            this.refreshToken = refreshResponse.refresh_token;
          }
          return this.cachedAccessToken;
        });
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param credentials The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(credentials) {
        const now2 = (/* @__PURE__ */ new Date()).getTime();
        return credentials.expiry_date ? now2 >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports2.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/googleauth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GoogleAuth = exports2.GoogleAuthExceptionMessages = void 0;
    var child_process_1 = require("child_process");
    var fs12 = require("fs");
    var gaxios_1 = require_src2();
    var gcpMetadata = require_src4();
    var os3 = require("os");
    var path8 = require("path");
    var crypto_1 = require_crypto3();
    var computeclient_1 = require_computeclient();
    var idtokenclient_1 = require_idtokenclient();
    var envDetect_1 = require_envDetect();
    var jwtclient_1 = require_jwtclient();
    var refreshclient_1 = require_refreshclient();
    var impersonated_1 = require_impersonated();
    var externalclient_1 = require_externalclient();
    var baseexternalclient_1 = require_baseexternalclient();
    var authclient_1 = require_authclient();
    var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
    var util_1 = require_util2();
    exports2.GoogleAuthExceptionMessages = {
      API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
      NO_PROJECT_ID_FOUND: "Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_CREDENTIALS_FOUND: "Unable to find credentials in current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
      NO_UNIVERSE_DOMAIN_FOUND: "Unable to detect a Universe Domain in the current environment.\nTo learn more about Universe Domain retrieval, visit: \nhttps://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
    };
    var _pendingAuthClient, _GoogleAuth_instances, prepareAndCacheClient_fn, determineClient_fn;
    var GoogleAuth2 = class {
      /**
       * Configuration is resolved in the following order of precedence:
       * - {@link GoogleAuthOptions.credentials `credentials`}
       * - {@link GoogleAuthOptions.keyFilename `keyFilename`}
       * - {@link GoogleAuthOptions.keyFile `keyFile`}
       *
       * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
       * {@link AuthClient `AuthClient`s}.
       *
       * @param opts
       */
      constructor(opts = {}) {
        __privateAdd(this, _GoogleAuth_instances);
        /**
         * Caches a value indicating whether the auth layer is running on Google
         * Compute Engine.
         * @private
         */
        __publicField(this, "checkIsGCE");
        __publicField(this, "useJWTAccessWithScope");
        __publicField(this, "defaultServicePath");
        __publicField(this, "_findProjectIdPromise");
        __publicField(this, "_cachedProjectId");
        // To save the contents of the JSON credential file
        __publicField(this, "jsonContent", null);
        __publicField(this, "apiKey");
        __publicField(this, "cachedCredential", null);
        /**
         * A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.
         */
        __privateAdd(this, _pendingAuthClient, null);
        /**
         * Scopes populated by the client library by default. We differentiate between
         * these and user defined scopes when deciding whether to use a self-signed JWT.
         */
        __publicField(this, "defaultScopes");
        __publicField(this, "keyFilename");
        __publicField(this, "scopes");
        __publicField(this, "clientOptions", {});
        this._cachedProjectId = opts.projectId || null;
        this.cachedCredential = opts.authClient || null;
        this.keyFilename = opts.keyFilename || opts.keyFile;
        this.scopes = opts.scopes;
        this.clientOptions = opts.clientOptions || {};
        this.jsonContent = opts.credentials || null;
        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
        if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {
          throw new RangeError(exports2.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
        }
        if (opts.universeDomain) {
          this.clientOptions.universeDomain = opts.universeDomain;
        }
      }
      // Note:  this properly is only public to satisfy unit tests.
      // https://github.com/Microsoft/TypeScript/issues/5228
      get isGCE() {
        return this.checkIsGCE;
      }
      // GAPIC client libraries should always use self-signed JWTs. The following
      // variables are set on the JWT client in order to indicate the type of library,
      // and sign the JWT with the correct audience and scopes (if not supplied).
      setGapicJWTValues(client) {
        client.defaultServicePath = this.defaultServicePath;
        client.useJWTAccessWithScope = this.useJWTAccessWithScope;
        client.defaultScopes = this.defaultScopes;
      }
      getProjectId(callback) {
        if (callback) {
          this.getProjectIdAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.getProjectIdAsync();
        }
      }
      /**
       * A temporary method for internal `getProjectId` usages where `null` is
       * acceptable. In a future major release, `getProjectId` should return `null`
       * (as the `Promise<string | null>` base signature describes) and this private
       * method should be removed.
       *
       * @returns Promise that resolves with project id (or `null`)
       */
      getProjectIdOptional() {
        return __async(this, null, function* () {
          try {
            return yield this.getProjectId();
          } catch (e2) {
            if (e2 instanceof Error && e2.message === exports2.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {
              return null;
            } else {
              throw e2;
            }
          }
        });
      }
      /**
       * A private method for finding and caching a projectId.
       *
       * Supports environments in order of precedence:
       * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
       * - GOOGLE_APPLICATION_CREDENTIALS JSON file
       * - Cloud SDK: `gcloud config config-helper --format json`
       * - GCE project ID from metadata server
       *
       * @returns projectId
       */
      findAndCacheProjectId() {
        return __async(this, null, function* () {
          let projectId = null;
          projectId || (projectId = yield this.getProductionProjectId());
          projectId || (projectId = yield this.getFileProjectId());
          projectId || (projectId = yield this.getDefaultServiceProjectId());
          projectId || (projectId = yield this.getGCEProjectId());
          projectId || (projectId = yield this.getExternalAccountClientProjectId());
          if (projectId) {
            this._cachedProjectId = projectId;
            return projectId;
          } else {
            throw new Error(exports2.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
          }
        });
      }
      getProjectIdAsync() {
        return __async(this, null, function* () {
          if (this._cachedProjectId) {
            return this._cachedProjectId;
          }
          if (!this._findProjectIdPromise) {
            this._findProjectIdPromise = this.findAndCacheProjectId();
          }
          return this._findProjectIdPromise;
        });
      }
      /**
       * Retrieves a universe domain from the metadata server via
       * {@link gcpMetadata.universe}.
       *
       * @returns a universe domain
       */
      getUniverseDomainFromMetadataServer() {
        return __async(this, null, function* () {
          var _a4;
          let universeDomain;
          try {
            universeDomain = yield gcpMetadata.universe("universe-domain");
            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);
          } catch (e2) {
            if (e2 && ((_a4 = e2 == null ? void 0 : e2.response) == null ? void 0 : _a4.status) === 404) {
              universeDomain = authclient_1.DEFAULT_UNIVERSE;
            } else {
              throw e2;
            }
          }
          return universeDomain;
        });
      }
      /**
       * Retrieves, caches, and returns the universe domain in the following order
       * of precedence:
       * - The universe domain in {@link GoogleAuth.clientOptions}
       * - An existing or ADC {@link AuthClient}'s universe domain
       * - {@link gcpMetadata.universe}, if {@link Compute} client
       *
       * @returns The universe domain
       */
      getUniverseDomain() {
        return __async(this, null, function* () {
          let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
          try {
            universeDomain != null ? universeDomain : universeDomain = (yield this.getClient()).universeDomain;
          } catch (e2) {
            universeDomain != null ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;
          }
          return universeDomain;
        });
      }
      /**
       * @returns Any scopes (user-specified or default scopes specified by the
       *   client library) that need to be set on the current Auth client.
       */
      getAnyScopes() {
        return this.scopes || this.defaultScopes;
      }
      getApplicationDefault(optionsOrCallback = {}, callback) {
        let options;
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.getApplicationDefaultAsync(options).then((r2) => callback(null, r2.credential, r2.projectId), callback);
        } else {
          return this.getApplicationDefaultAsync(options);
        }
      }
      getApplicationDefaultAsync() {
        return __async(this, arguments, function* (options = {}) {
          if (this.cachedCredential) {
            return yield __privateMethod(this, _GoogleAuth_instances, prepareAndCacheClient_fn).call(this, this.cachedCredential, null);
          }
          let credential;
          credential = yield this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
          if (credential) {
            if (credential instanceof jwtclient_1.JWT) {
              credential.scopes = this.scopes;
            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
              credential.scopes = this.getAnyScopes();
            }
            return yield __privateMethod(this, _GoogleAuth_instances, prepareAndCacheClient_fn).call(this, credential);
          }
          credential = yield this._tryGetApplicationCredentialsFromWellKnownFile(options);
          if (credential) {
            if (credential instanceof jwtclient_1.JWT) {
              credential.scopes = this.scopes;
            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
              credential.scopes = this.getAnyScopes();
            }
            return yield __privateMethod(this, _GoogleAuth_instances, prepareAndCacheClient_fn).call(this, credential);
          }
          if (yield this._checkIsGCE()) {
            options.scopes = this.getAnyScopes();
            return yield __privateMethod(this, _GoogleAuth_instances, prepareAndCacheClient_fn).call(this, new computeclient_1.Compute(options));
          }
          throw new Error(exports2.GoogleAuthExceptionMessages.NO_ADC_FOUND);
        });
      }
      /**
       * Determines whether the auth layer is running on Google Compute Engine.
       * Checks for GCP Residency, then fallback to checking if metadata server
       * is available.
       *
       * @returns A promise that resolves with the boolean.
       * @api private
       */
      _checkIsGCE() {
        return __async(this, null, function* () {
          if (this.checkIsGCE === void 0) {
            this.checkIsGCE = gcpMetadata.getGCPResidency() || (yield gcpMetadata.isAvailable());
          }
          return this.checkIsGCE;
        });
      }
      /**
       * Attempts to load default credentials from the environment variable path..
       * @returns Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
        return __async(this, null, function* () {
          const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
          if (!credentialsPath || credentialsPath.length === 0) {
            return null;
          }
          try {
            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
          } catch (e2) {
            if (e2 instanceof Error) {
              e2.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e2.message}`;
            }
            throw e2;
          }
        });
      }
      /**
       * Attempts to load default credentials from a well-known file location
       * @return Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      _tryGetApplicationCredentialsFromWellKnownFile(options) {
        return __async(this, null, function* () {
          let location = null;
          if (this._isWindows()) {
            location = process.env["APPDATA"];
          } else {
            const home = process.env["HOME"];
            if (home) {
              location = path8.join(home, ".config");
            }
          }
          if (location) {
            location = path8.join(location, "gcloud", "application_default_credentials.json");
            if (!fs12.existsSync(location)) {
              location = null;
            }
          }
          if (!location) {
            return null;
          }
          const client = yield this._getApplicationCredentialsFromFilePath(location, options);
          return client;
        });
      }
      /**
       * Attempts to load default credentials from a file at the given path..
       * @param filePath The path to the file to read.
       * @returns Promise that resolves with the OAuth2Client
       * @api private
       */
      _getApplicationCredentialsFromFilePath(_0) {
        return __async(this, arguments, function* (filePath, options = {}) {
          if (!filePath || filePath.length === 0) {
            throw new Error("The file path is invalid.");
          }
          try {
            filePath = fs12.realpathSync(filePath);
            if (!fs12.lstatSync(filePath).isFile()) {
              throw new Error();
            }
          } catch (err) {
            if (err instanceof Error) {
              err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
            }
            throw err;
          }
          const readStream = fs12.createReadStream(filePath);
          return this.fromStream(readStream, options);
        });
      }
      /**
       * Create a credentials instance using a given impersonated input options.
       * @param json The impersonated input object.
       * @returns JWT or UserRefresh Client with data
       */
      fromImpersonatedJSON(json) {
        var _a4, _b, _c, _d2;
        if (!json) {
          throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
        }
        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          throw new Error(`The incoming JSON object does not have the "${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}" type`);
        }
        if (!json.source_credentials) {
          throw new Error("The incoming JSON object does not contain a source_credentials field");
        }
        if (!json.service_account_impersonation_url) {
          throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
        }
        const sourceClient = this.fromJSON(json.source_credentials);
        if (((_a4 = json.service_account_impersonation_url) == null ? void 0 : _a4.length) > 256) {
          throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);
        }
        const targetPrincipal = (_c = (_b = new RegExp("(?<target>[^/]+):(generateAccessToken|generateIdToken)$").exec(json.service_account_impersonation_url)) == null ? void 0 : _b.groups) == null ? void 0 : _c.target;
        if (!targetPrincipal) {
          throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);
        }
        const targetScopes = (_d2 = this.scopes || json.scopes || this.defaultScopes) != null ? _d2 : [];
        return new impersonated_1.Impersonated(__spreadProps(__spreadValues({}, json), {
          sourceClient,
          targetPrincipal,
          targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
        }));
      }
      /**
       * Create a credentials instance using the given input options.
       * This client is not cached.
       *
       * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
       *
       * @deprecated This method is being deprecated because of a potential security risk.
       *
       * This method does not validate the credential configuration. The security
       * risk occurs when a credential configuration is accepted from a source that
       * is not under your control and used without validation on your side.
       *
       * If you know that you will be loading credential configurations of a
       * specific type, it is recommended to use a credential-type-specific
       * constructor. This will ensure that an unexpected credential type with
       * potential for malicious intent is not loaded unintentionally. You might
       * still have to do validation for certain credential types. Please follow
       * the recommendation for that method. For example, if you want to load only
       * service accounts, you can use the `JWT` constructor:
       * ```
       * const {JWT} = require('google-auth-library');
       * const keys = require('/path/to/key.json');
       * const client = new JWT({
       *   email: keys.client_email,
       *   key: keys.private_key,
       *   scopes: ['https://www.googleapis.com/auth/cloud-platform'],
       * });
       * ```
       *
       * If you are loading your credential configuration from an untrusted source and have
       * not mitigated the risks (e.g. by validating the configuration yourself), make
       * these changes as soon as possible to prevent security risks to your environment.
       *
       * Regardless of the method used, it is always your responsibility to validate
       * configurations received from external sources.
       *
       * For more details, see https://cloud.google.com/docs/authentication/external/externally-sourced-credentials.
       *
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      fromJSON(json, options = {}) {
        let client;
        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {
          client = new refreshclient_1.UserRefreshClient(options);
          client.fromJSON(json);
        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          client = this.fromImpersonatedJSON(json);
        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          client = externalclient_1.ExternalAccountClient.fromJSON(__spreadValues(__spreadValues({}, json), options));
          client.scopes = this.getAnyScopes();
        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {
          client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(__spreadValues(__spreadValues({}, json), options));
        } else {
          options.scopes = this.scopes;
          client = new jwtclient_1.JWT(options);
          this.setGapicJWTValues(client);
          client.fromJSON(json);
        }
        if (preferredUniverseDomain) {
          client.universeDomain = preferredUniverseDomain;
        }
        return client;
      }
      /**
       * Return a JWT or UserRefreshClient from JavaScript object, caching both the
       * object used to instantiate and the client.
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      _cacheClientFromJSON(json, options) {
        const client = this.fromJSON(json, options);
        this.jsonContent = json;
        this.cachedCredential = client;
        return client;
      }
      fromStream(inputStream, optionsOrCallback = {}, callback) {
        let options = {};
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.fromStreamAsync(inputStream, options).then((r2) => callback(null, r2), callback);
        } else {
          return this.fromStreamAsync(inputStream, options);
        }
      }
      fromStreamAsync(inputStream, options) {
        return new Promise((resolve3, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the Google auth settings.");
          }
          const chunks = [];
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
            try {
              try {
                const data = JSON.parse(chunks.join(""));
                const r2 = this._cacheClientFromJSON(data, options);
                return resolve3(r2);
              } catch (err) {
                if (!this.keyFilename)
                  throw err;
                const client = new jwtclient_1.JWT(__spreadProps(__spreadValues({}, this.clientOptions), {
                  keyFile: this.keyFilename
                }));
                this.cachedCredential = client;
                this.setGapicJWTValues(client);
                return resolve3(client);
              }
            } catch (err) {
              return reject(err);
            }
          });
        });
      }
      /**
       * Create a credentials instance using the given API key string.
       * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
       *
       * @param apiKey The API key string
       * @param options An optional options object.
       * @returns A JWT loaded from the key
       */
      fromAPIKey(apiKey, options = {}) {
        return new jwtclient_1.JWT(__spreadProps(__spreadValues({}, options), { apiKey }));
      }
      /**
       * Determines whether the current operating system is Windows.
       * @api private
       */
      _isWindows() {
        const sys = os3.platform();
        if (sys && sys.length >= 3) {
          if (sys.substring(0, 3).toLowerCase() === "win") {
            return true;
          }
        }
        return false;
      }
      /**
       * Run the Google Cloud SDK command that prints the default project ID
       */
      getDefaultServiceProjectId() {
        return __async(this, null, function* () {
          return new Promise((resolve3) => {
            (0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout) => {
              if (!err && stdout) {
                try {
                  const projectId = JSON.parse(stdout).configuration.properties.core.project;
                  resolve3(projectId);
                  return;
                } catch (e2) {
                }
              }
              resolve3(null);
            });
          });
        });
      }
      /**
       * Loads the project id from environment variables.
       * @api private
       */
      getProductionProjectId() {
        return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
      }
      /**
       * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
       * @api private
       */
      getFileProjectId() {
        return __async(this, null, function* () {
          if (this.cachedCredential) {
            return this.cachedCredential.projectId;
          }
          if (this.keyFilename) {
            const creds = yield this.getClient();
            if (creds && creds.projectId) {
              return creds.projectId;
            }
          }
          const r2 = yield this._tryGetApplicationCredentialsFromEnvironmentVariable();
          if (r2) {
            return r2.projectId;
          } else {
            return null;
          }
        });
      }
      /**
       * Gets the project ID from external account client if available.
       */
      getExternalAccountClientProjectId() {
        return __async(this, null, function* () {
          if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
            return null;
          }
          const creds = yield this.getClient();
          return yield creds.getProjectId();
        });
      }
      /**
       * Gets the Compute Engine project ID if it can be inferred.
       */
      getGCEProjectId() {
        return __async(this, null, function* () {
          try {
            const r2 = yield gcpMetadata.project("project-id");
            return r2;
          } catch (e2) {
            return null;
          }
        });
      }
      getCredentials(callback) {
        if (callback) {
          this.getCredentialsAsync().then((r2) => callback(null, r2), callback);
        } else {
          return this.getCredentialsAsync();
        }
      }
      getCredentialsAsync() {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          if (client instanceof impersonated_1.Impersonated) {
            return { client_email: client.getTargetPrincipal() };
          }
          if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {
            const serviceAccountEmail = client.getServiceAccountEmail();
            if (serviceAccountEmail) {
              return {
                client_email: serviceAccountEmail,
                universe_domain: client.universeDomain
              };
            }
          }
          if (this.jsonContent) {
            return {
              client_email: this.jsonContent.client_email,
              private_key: this.jsonContent.private_key,
              universe_domain: this.jsonContent.universe_domain
            };
          }
          if (yield this._checkIsGCE()) {
            const [client_email, universe_domain] = yield Promise.all([
              gcpMetadata.instance("service-accounts/default/email"),
              this.getUniverseDomain()
            ]);
            return { client_email, universe_domain };
          }
          throw new Error(exports2.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
        });
      }
      /**
       * Automatically obtain an {@link AuthClient `AuthClient`} based on the
       * provided configuration. If no options were passed, use Application
       * Default Credentials.
       */
      getClient() {
        return __async(this, null, function* () {
          if (this.cachedCredential) {
            return this.cachedCredential;
          }
          __privateSet(this, _pendingAuthClient, __privateGet(this, _pendingAuthClient) || __privateMethod(this, _GoogleAuth_instances, determineClient_fn).call(this));
          try {
            return yield __privateGet(this, _pendingAuthClient);
          } finally {
            __privateSet(this, _pendingAuthClient, null);
          }
        });
      }
      /**
       * Creates a client which will fetch an ID token for authorization.
       * @param targetAudience the audience for the fetched ID token.
       * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
       */
      getIdTokenClient(targetAudience) {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          if (!("fetchIdToken" in client)) {
            throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
          }
          return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });
        });
      }
      /**
       * Automatically obtain application default credentials, and return
       * an access token for making requests.
       */
      getAccessToken() {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          return (yield client.getAccessToken()).token;
        });
      }
      /**
       * Obtain the HTTP headers that will provide authorization for a given
       * request.
       */
      getRequestHeaders(url) {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          return client.getRequestHeaders(url);
        });
      }
      /**
       * Obtain credentials for a request, then attach the appropriate headers to
       * the request options.
       * @param opts Axios or Request options on which to attach the headers
       */
      authorizeRequest() {
        return __async(this, arguments, function* (opts = {}) {
          const url = opts.url;
          const client = yield this.getClient();
          const headers = yield client.getRequestHeaders(url);
          opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers, headers);
          return opts;
        });
      }
      /**
       * A {@link fetch `fetch`} compliant API for {@link GoogleAuth}.
       *
       * @see {@link GoogleAuth.request} for the classic method.
       *
       * @remarks
       *
       * This is useful as a drop-in replacement for `fetch` API usage.
       *
       * @example
       *
       * ```ts
       * const auth = new GoogleAuth();
       * const fetchWithAuth: typeof fetch = (...args) => auth.fetch(...args);
       * await fetchWithAuth('https://example.com');
       * ```
       *
       * @param args `fetch` API or {@link Gaxios.fetch `Gaxios#fetch`} parameters
       * @returns the {@link GaxiosResponse} with Gaxios-added properties
       */
      fetch(...args) {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          return client.fetch(...args);
        });
      }
      /**
       * Automatically obtain application default credentials, and make an
       * HTTP request using the given options.
       *
       * @see {@link GoogleAuth.fetch} for the modern method.
       *
       * @param opts Axios request options for the HTTP request.
       */
      request(opts) {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          return client.request(opts);
        });
      }
      /**
       * Determine the compute environment in which the code is running.
       */
      getEnv() {
        return (0, envDetect_1.getEnv)();
      }
      /**
       * Sign the given data with the current private key, or go out
       * to the IAM API to sign it.
       * @param data The data to be signed.
       * @param endpoint A custom endpoint to use.
       *
       * @example
       * ```
       * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
       * ```
       */
      sign(data, endpoint) {
        return __async(this, null, function* () {
          const client = yield this.getClient();
          const universe = yield this.getUniverseDomain();
          endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;
          if (client instanceof impersonated_1.Impersonated) {
            const signed = yield client.sign(data);
            return signed.signedBlob;
          }
          const crypto2 = (0, crypto_1.createCrypto)();
          if (client instanceof jwtclient_1.JWT && client.key) {
            const sign = yield crypto2.sign(client.key, data);
            return sign;
          }
          const creds = yield this.getCredentials();
          if (!creds.client_email) {
            throw new Error("Cannot sign data without `client_email`.");
          }
          return this.signBlob(crypto2, creds.client_email, data, endpoint);
        });
      }
      signBlob(crypto2, emailOrUniqueId, data, endpoint) {
        return __async(this, null, function* () {
          const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);
          const res = yield this.request({
            method: "POST",
            url: url.href,
            data: {
              payload: crypto2.encodeBase64StringUtf8(data)
            },
            retry: true,
            retryConfig: {
              httpMethodsToRetry: ["POST"]
            }
          });
          return res.data.signedBlob;
        });
      }
    };
    _pendingAuthClient = new WeakMap();
    _GoogleAuth_instances = new WeakSet();
    prepareAndCacheClient_fn = function(_0) {
      return __async(this, arguments, function* (credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
        const projectId = yield this.getProjectIdOptional();
        if (quotaProjectIdOverride) {
          credential.quotaProjectId = quotaProjectIdOverride;
        }
        this.cachedCredential = credential;
        return { credential, projectId };
      });
    };
    determineClient_fn = function() {
      return __async(this, null, function* () {
        if (this.jsonContent) {
          return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
        } else if (this.keyFilename) {
          const filePath = path8.resolve(this.keyFilename);
          const stream = fs12.createReadStream(filePath);
          return yield this.fromStreamAsync(stream, this.clientOptions);
        } else if (this.apiKey) {
          const client = yield this.fromAPIKey(this.apiKey, this.clientOptions);
          client.scopes = this.scopes;
          const { credential } = yield __privateMethod(this, _GoogleAuth_instances, prepareAndCacheClient_fn).call(this, client);
          return credential;
        } else {
          const { credential } = yield this.getApplicationDefaultAsync(this.clientOptions);
          return credential;
        }
      });
    };
    exports2.GoogleAuth = GoogleAuth2;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/iam.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IAMAuth = void 0;
    var IAMAuth = class {
      /**
       * IAM credentials.
       *
       * @param selector the iam authority selector
       * @param token the token
       * @constructor
       */
      constructor(selector, token) {
        __publicField(this, "selector");
        __publicField(this, "token");
        this.selector = selector;
        this.token = token;
        this.selector = selector;
        this.token = token;
      }
      /**
       * Acquire the HTTP headers required to make an authenticated request.
       */
      getRequestHeaders() {
        return {
          "x-goog-iam-authority-selector": this.selector,
          "x-goog-iam-authorization-token": this.token
        };
      }
    };
    exports2.IAMAuth = IAMAuth;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/downscopedclient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DownscopedClient = exports2.EXPIRATION_TIME_OFFSET = exports2.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
    var gaxios_1 = require_src2();
    var stream = require("stream");
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    exports2.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
    exports2.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    var DownscopedClient = class extends authclient_1.AuthClient {
      /**
       * Instantiates a downscoped client object using the provided source
       * AuthClient and credential access boundary rules.
       * To downscope permissions of a source AuthClient, a Credential Access
       * Boundary that specifies which resources the new credential can access, as
       * well as an upper bound on the permissions that are available on each
       * resource, has to be defined. A downscoped client can then be instantiated
       * using the source AuthClient and the Credential Access Boundary.
       * @param options the {@link DownscopedClientOptions `DownscopedClientOptions`} to use. Passing an `AuthClient` directly is **@DEPRECATED**.
       * @param credentialAccessBoundary **@DEPRECATED**. Provide a {@link DownscopedClientOptions `DownscopedClientOptions`} object in the first parameter instead.
       */
      constructor(options, credentialAccessBoundary = {
        accessBoundary: {
          accessBoundaryRules: []
        }
      }) {
        super(options instanceof authclient_1.AuthClient ? {} : options);
        __publicField(this, "authClient");
        __publicField(this, "credentialAccessBoundary");
        __publicField(this, "cachedDownscopedAccessToken");
        __publicField(this, "stsCredential");
        if (options instanceof authclient_1.AuthClient) {
          this.authClient = options;
          this.credentialAccessBoundary = credentialAccessBoundary;
        } else {
          this.authClient = options.authClient;
          this.credentialAccessBoundary = options.credentialAccessBoundary;
        }
        if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {
          throw new Error("At least one access boundary rule needs to be defined.");
        } else if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports2.MAX_ACCESS_BOUNDARY_RULES_COUNT) {
          throw new Error(`The provided access boundary has more than ${exports2.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
        }
        for (const rule of this.credentialAccessBoundary.accessBoundary.accessBoundaryRules) {
          if (rule.availablePermissions.length === 0) {
            throw new Error("At least one permission should be defined in access boundary rules.");
          }
        }
        this.stsCredential = new sts.StsCredentials({
          tokenExchangeEndpoint: `https://sts.${this.universeDomain}/v1/token`
        });
        this.cachedDownscopedAccessToken = null;
      }
      /**
       * Provides a mechanism to inject Downscoped access tokens directly.
       * The expiry_date field is required to facilitate determination of the token
       * expiration which would make it easier for the token consumer to handle.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        if (!credentials.expiry_date) {
          throw new Error("The access token expiry_date field is missing in the provided credentials.");
        }
        super.setCredentials(credentials);
        this.cachedDownscopedAccessToken = credentials;
      }
      getAccessToken() {
        return __async(this, null, function* () {
          if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {
            yield this.refreshAccessTokenAsync();
          }
          return {
            token: this.cachedDownscopedAccessToken.access_token,
            expirationTime: this.cachedDownscopedAccessToken.expiry_date,
            res: this.cachedDownscopedAccessToken.res
          };
        });
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { authorization: 'Bearer <access_token_value>' }
       */
      getRequestHeaders() {
        return __async(this, null, function* () {
          const accessTokenResponse = yield this.getAccessToken();
          const headers = new Headers({
            authorization: `Bearer ${accessTokenResponse.token}`
          });
          return this.addSharedMetadataHeaders(headers);
        });
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r2) => callback(null, r2), (e2) => {
            return callback(e2, e2.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
       * @return A promise that resolves with the successful response.
       */
      requestAsync(opts, reAuthRetried = false) {
        return __async(this, null, function* () {
          let response;
          try {
            const requestHeaders = yield this.getRequestHeaders();
            opts.headers = gaxios_1.Gaxios.mergeHeaders(opts.headers);
            this.addUserProjectAndAuthHeaders(opts.headers, requestHeaders);
            response = yield this.transporter.request(opts);
          } catch (e2) {
            const res = e2.response;
            if (res) {
              const statusCode = res.status;
              const isReadableStream = res.config.data instanceof stream.Readable;
              const isAuthErr = statusCode === 401 || statusCode === 403;
              if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
                yield this.refreshAccessTokenAsync();
                return yield this.requestAsync(opts, true);
              }
            }
            throw e2;
          }
          return response;
        });
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * GCP access tokens are retrieved from authclient object/source credential.
       * Then GCP access tokens are exchanged for downscoped access tokens via the
       * token exchange endpoint.
       * @return A promise that resolves with the fresh downscoped access token.
       */
      refreshAccessTokenAsync() {
        return __async(this, null, function* () {
          var _a4;
          const subjectToken = (yield this.authClient.getAccessToken()).token;
          const stsCredentialsOptions = {
            grantType: STS_GRANT_TYPE,
            requestedTokenType: STS_REQUEST_TOKEN_TYPE,
            subjectToken,
            subjectTokenType: STS_SUBJECT_TOKEN_TYPE
          };
          const stsResponse = yield this.stsCredential.exchangeToken(stsCredentialsOptions, void 0, this.credentialAccessBoundary);
          const sourceCredExpireDate = ((_a4 = this.authClient.credentials) == null ? void 0 : _a4.expiry_date) || null;
          const expiryDate = stsResponse.expires_in ? (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3 : sourceCredExpireDate;
          this.cachedDownscopedAccessToken = {
            access_token: stsResponse.access_token,
            expiry_date: expiryDate,
            res: stsResponse.res
          };
          this.credentials = {};
          Object.assign(this.credentials, this.cachedDownscopedAccessToken);
          delete this.credentials.res;
          this.emit("tokens", {
            refresh_token: null,
            expiry_date: this.cachedDownscopedAccessToken.expiry_date,
            access_token: this.cachedDownscopedAccessToken.access_token,
            token_type: "Bearer",
            id_token: null
          });
          return this.cachedDownscopedAccessToken;
        });
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param downscopedAccessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(downscopedAccessToken) {
        const now2 = (/* @__PURE__ */ new Date()).getTime();
        return downscopedAccessToken.expiry_date ? now2 >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports2.DownscopedClient = DownscopedClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/auth/passthrough.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PassThroughClient = void 0;
    var authclient_1 = require_authclient();
    var PassThroughClient = class extends authclient_1.AuthClient {
      /**
       * Creates a request without any authentication headers or checks.
       *
       * @remarks
       *
       * In testing environments it may be useful to change the provided
       * {@link AuthClient.transporter} for any desired request overrides/handling.
       *
       * @param opts
       * @returns The response of the request.
       */
      request(opts) {
        return __async(this, null, function* () {
          return this.transporter.request(opts);
        });
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      getAccessToken() {
        return __async(this, null, function* () {
          return {};
        });
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      getRequestHeaders() {
        return __async(this, null, function* () {
          return new Headers();
        });
      }
    };
    exports2.PassThroughClient = PassThroughClient;
  }
});

// ../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/index.js
var require_src6 = __commonJS({
  "../../node_modules/.pnpm/google-auth-library@10.5.0/node_modules/google-auth-library/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GoogleAuth = exports2.auth = exports2.PassThroughClient = exports2.ExternalAccountAuthorizedUserClient = exports2.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = exports2.ExecutableError = exports2.PluggableAuthClient = exports2.DownscopedClient = exports2.BaseExternalAccountClient = exports2.ExternalAccountClient = exports2.IdentityPoolClient = exports2.AwsRequestSigner = exports2.AwsClient = exports2.UserRefreshClient = exports2.LoginTicket = exports2.ClientAuthentication = exports2.OAuth2Client = exports2.CodeChallengeMethod = exports2.Impersonated = exports2.JWT = exports2.JWTAccess = exports2.IdTokenClient = exports2.IAMAuth = exports2.GCPEnv = exports2.Compute = exports2.DEFAULT_UNIVERSE = exports2.AuthClient = exports2.gaxios = exports2.gcpMetadata = void 0;
    var googleauth_1 = require_googleauth();
    Object.defineProperty(exports2, "GoogleAuth", { enumerable: true, get: function() {
      return googleauth_1.GoogleAuth;
    } });
    exports2.gcpMetadata = require_src4();
    exports2.gaxios = require_src2();
    var authclient_1 = require_authclient();
    Object.defineProperty(exports2, "AuthClient", { enumerable: true, get: function() {
      return authclient_1.AuthClient;
    } });
    Object.defineProperty(exports2, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
      return authclient_1.DEFAULT_UNIVERSE;
    } });
    var computeclient_1 = require_computeclient();
    Object.defineProperty(exports2, "Compute", { enumerable: true, get: function() {
      return computeclient_1.Compute;
    } });
    var envDetect_1 = require_envDetect();
    Object.defineProperty(exports2, "GCPEnv", { enumerable: true, get: function() {
      return envDetect_1.GCPEnv;
    } });
    var iam_1 = require_iam();
    Object.defineProperty(exports2, "IAMAuth", { enumerable: true, get: function() {
      return iam_1.IAMAuth;
    } });
    var idtokenclient_1 = require_idtokenclient();
    Object.defineProperty(exports2, "IdTokenClient", { enumerable: true, get: function() {
      return idtokenclient_1.IdTokenClient;
    } });
    var jwtaccess_1 = require_jwtaccess();
    Object.defineProperty(exports2, "JWTAccess", { enumerable: true, get: function() {
      return jwtaccess_1.JWTAccess;
    } });
    var jwtclient_1 = require_jwtclient();
    Object.defineProperty(exports2, "JWT", { enumerable: true, get: function() {
      return jwtclient_1.JWT;
    } });
    var impersonated_1 = require_impersonated();
    Object.defineProperty(exports2, "Impersonated", { enumerable: true, get: function() {
      return impersonated_1.Impersonated;
    } });
    var oauth2client_1 = require_oauth2client();
    Object.defineProperty(exports2, "CodeChallengeMethod", { enumerable: true, get: function() {
      return oauth2client_1.CodeChallengeMethod;
    } });
    Object.defineProperty(exports2, "OAuth2Client", { enumerable: true, get: function() {
      return oauth2client_1.OAuth2Client;
    } });
    Object.defineProperty(exports2, "ClientAuthentication", { enumerable: true, get: function() {
      return oauth2client_1.ClientAuthentication;
    } });
    var loginticket_1 = require_loginticket();
    Object.defineProperty(exports2, "LoginTicket", { enumerable: true, get: function() {
      return loginticket_1.LoginTicket;
    } });
    var refreshclient_1 = require_refreshclient();
    Object.defineProperty(exports2, "UserRefreshClient", { enumerable: true, get: function() {
      return refreshclient_1.UserRefreshClient;
    } });
    var awsclient_1 = require_awsclient();
    Object.defineProperty(exports2, "AwsClient", { enumerable: true, get: function() {
      return awsclient_1.AwsClient;
    } });
    var awsrequestsigner_1 = require_awsrequestsigner();
    Object.defineProperty(exports2, "AwsRequestSigner", { enumerable: true, get: function() {
      return awsrequestsigner_1.AwsRequestSigner;
    } });
    var identitypoolclient_1 = require_identitypoolclient();
    Object.defineProperty(exports2, "IdentityPoolClient", { enumerable: true, get: function() {
      return identitypoolclient_1.IdentityPoolClient;
    } });
    var externalclient_1 = require_externalclient();
    Object.defineProperty(exports2, "ExternalAccountClient", { enumerable: true, get: function() {
      return externalclient_1.ExternalAccountClient;
    } });
    var baseexternalclient_1 = require_baseexternalclient();
    Object.defineProperty(exports2, "BaseExternalAccountClient", { enumerable: true, get: function() {
      return baseexternalclient_1.BaseExternalAccountClient;
    } });
    var downscopedclient_1 = require_downscopedclient();
    Object.defineProperty(exports2, "DownscopedClient", { enumerable: true, get: function() {
      return downscopedclient_1.DownscopedClient;
    } });
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    Object.defineProperty(exports2, "PluggableAuthClient", { enumerable: true, get: function() {
      return pluggable_auth_client_1.PluggableAuthClient;
    } });
    Object.defineProperty(exports2, "ExecutableError", { enumerable: true, get: function() {
      return pluggable_auth_client_1.ExecutableError;
    } });
    var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
    Object.defineProperty(exports2, "EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE", { enumerable: true, get: function() {
      return externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE;
    } });
    Object.defineProperty(exports2, "ExternalAccountAuthorizedUserClient", { enumerable: true, get: function() {
      return externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient;
    } });
    var passthrough_1 = require_passthrough();
    Object.defineProperty(exports2, "PassThroughClient", { enumerable: true, get: function() {
      return passthrough_1.PassThroughClient;
    } });
    var auth = new googleauth_1.GoogleAuth();
    exports2.auth = auth;
  }
});

// lib/v3/understudy/consoleMessage.ts
function formatRemoteObject(obj) {
  var _a4;
  if (!obj) return "";
  if ("value" in obj) {
    const value = obj.value;
    if (value === void 0) return "";
    if (typeof value === "string") return value;
    try {
      return JSON.stringify(value);
    } catch (e2) {
      return String(value);
    }
  }
  if (obj.unserializableValue) return obj.unserializableValue;
  if (obj.description) return obj.description;
  return (_a4 = obj.type) != null ? _a4 : "";
}
var ConsoleMessage;
var init_consoleMessage = __esm({
  "lib/v3/understudy/consoleMessage.ts"() {
    ConsoleMessage = class {
      constructor(event, pageRef) {
        this.event = event;
        this.pageRef = pageRef;
      }
      type() {
        return this.event.type;
      }
      text() {
        const args = this.args();
        if (!args.length) return "";
        return args.map((arg) => formatRemoteObject(arg)).filter((chunk) => chunk.length > 0).join(" ");
      }
      args() {
        return this.event.args ? [...this.event.args] : [];
      }
      location() {
        var _a4, _b;
        const frame = (_b = (_a4 = this.event.stackTrace) == null ? void 0 : _a4.callFrames) == null ? void 0 : _b[0];
        return {
          url: frame == null ? void 0 : frame.url,
          lineNumber: frame == null ? void 0 : frame.lineNumber,
          columnNumber: frame == null ? void 0 : frame.columnNumber
        };
      }
      page() {
        return this.pageRef;
      }
      timestamp() {
        return this.event.timestamp;
      }
      raw() {
        return this.event;
      }
      toString() {
        return this.text();
      }
    };
  }
});

// lib/v3/understudy/response.ts
function isSerializableResponse(value) {
  if (!value || typeof value !== "object") return false;
  const candidate = value;
  if (typeof candidate.requestId !== "string") return false;
  if (!candidate.response || typeof candidate.response !== "object") {
    return false;
  }
  return true;
}
function createDeferred() {
  let resolve3;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve3 = res;
    reject = rej;
  });
  return { promise, resolve: resolve3, reject };
}
function normaliseHeaderName(name) {
  return name.toLowerCase();
}
function splitHeaderValues(value) {
  return value.split(/\r?\n/).map((part) => part.trim()).filter(Boolean);
}
function parseHeadersText(headersText) {
  if (!headersText) return [];
  const lines = headersText.split(/\r?\n/);
  const entries = [];
  for (const line of lines) {
    if (!line || line.startsWith("HTTP/")) continue;
    const index = line.indexOf(":");
    if (index === -1) continue;
    const name = line.slice(0, index).trim();
    const value = line.slice(index + 1).trim();
    entries.push({ name, value });
  }
  return entries;
}
var Response2;
var init_response2 = __esm({
  "lib/v3/understudy/response.ts"() {
    init_sdkErrors();
    Response2 = class _Response {
      /**
       * Build a response wrapper from the CDP notification associated with a
       * navigation. The constructor captures the owning page/session so follow-up
       * methods (body/text/json) can query CDP on-demand. The `response` payload is
       * the raw `Protocol.Network.Response` object emitted by Chrome.
       */
      constructor(params) {
        this.headersArrayCache = null;
        this.allHeadersCache = null;
        this.headerValuesMap = /* @__PURE__ */ new Map();
        this.finishedDeferred = createDeferred();
        this.finishedSettled = false;
        this.extraInfoHeaders = null;
        var _a4;
        this.page = params.page;
        this.session = params.session;
        this.requestId = params.requestId;
        this.frameId = params.frameId;
        this.loaderId = params.loaderId;
        this.response = params.response;
        this.fromServiceWorkerFlag = params.fromServiceWorker;
        if (params.response.remoteIPAddress && params.response.remotePort !== void 0) {
          this.serverAddress = {
            ipAddress: params.response.remoteIPAddress,
            port: params.response.remotePort
          };
        } else {
          this.serverAddress = null;
        }
        this.headersObject = {};
        for (const [name, value] of Object.entries((_a4 = this.response.headers) != null ? _a4 : {})) {
          const lower2 = normaliseHeaderName(name);
          if (value === void 0) continue;
          const values = splitHeaderValues(String(value));
          this.headerValuesMap.set(lower2, values);
          this.headersObject[lower2] = values.join(", ");
        }
      }
      /** URL associated with the navigation request. */
      url() {
        return this.response.url;
      }
      /** HTTP status code reported by Chrome. */
      status() {
        return this.response.status;
      }
      /** Human-readable status text that accompanied the response. */
      statusText() {
        return this.response.statusText;
      }
      /** Convenience predicate that checks for 2xx statuses. */
      ok() {
        const status = this.status();
        return status >= 200 && status <= 299;
      }
      /** Returns the Stagehand frame object that initiated the navigation. */
      frame() {
        if (!this.frameId) return null;
        try {
          return this.page.frameForId(this.frameId);
        } catch (e2) {
          return null;
        }
      }
      /** Indicates whether the response was serviced by a Service Worker. */
      fromServiceWorker() {
        return this.fromServiceWorkerFlag;
      }
      /**
       * Returns TLS security metadata when provided by the browser. In practice
       * this includes certificate issuer, protocol, and validity interval.
       */
      securityDetails() {
        return __async(this, null, function* () {
          var _a4;
          return (_a4 = this.response.securityDetails) != null ? _a4 : null;
        });
      }
      /** Returns the resolved server address for the navigation when available. */
      serverAddr() {
        return __async(this, null, function* () {
          var _a4;
          return (_a4 = this.serverAddress) != null ? _a4 : null;
        });
      }
      /**
       * Returns the response headers normalised to lowercase keys. Matches the
       * behaviour of Playwright's `headers()` by eliding duplicate header entries.
       */
      headers() {
        return __spreadValues({}, this.headersObject);
      }
      /**
       * Returns all headers including those only surfaced through
       * `responseReceivedExtraInfo` such as `set-cookie`. Values are reported as the
       * browser sends them (no further splitting or concatenation).
       */
      allHeaders() {
        return __async(this, null, function* () {
          var _a4, _b;
          if (this.allHeadersCache) return __spreadValues({}, this.allHeadersCache);
          const source = (_b = (_a4 = this.extraInfoHeaders) != null ? _a4 : this.response.headers) != null ? _b : {};
          const map = {};
          for (const [name, value] of Object.entries(source)) {
            map[name] = String(value);
          }
          this.allHeadersCache = map;
          return __spreadValues({}, map);
        });
      }
      /** Returns a concatenated header string for the supplied header name. */
      headerValue(name) {
        return __async(this, null, function* () {
          const values = yield this.headerValues(name);
          if (!values.length) return null;
          return values.join(", ");
        });
      }
      /** Returns all values for a header (case-insensitive lookup). */
      headerValues(name) {
        return __async(this, null, function* () {
          var _a4;
          const lower2 = normaliseHeaderName(name);
          if (this.extraInfoHeaders) {
            const raw = (_a4 = this.extraInfoHeaders[name]) != null ? _a4 : this.extraInfoHeaders[lower2];
            if (raw !== void 0) {
              return splitHeaderValues(String(raw));
            }
          }
          const values = this.headerValuesMap.get(lower2);
          return values ? [...values] : [];
        });
      }
      /**
       * Returns header entries preserving their original wire casing and ordering.
       * Falls back to the CDP object when the raw header text is unavailable.
       */
      headersArray() {
        return __async(this, null, function* () {
          var _a4, _b;
          if (this.headersArrayCache) return [...this.headersArrayCache];
          const entriesFromText = parseHeadersText(this.extraInfoHeadersText);
          if (entriesFromText.length > 0) {
            this.headersArrayCache = entriesFromText;
            return [...entriesFromText];
          }
          const entries = [];
          const source = (_b = (_a4 = this.extraInfoHeaders) != null ? _a4 : this.response.headers) != null ? _b : {};
          for (const [name, value] of Object.entries(source)) {
            const values = splitHeaderValues(String(value));
            for (const val of values) {
              entries.push({ name, value: val });
            }
          }
          this.headersArrayCache = entries;
          return [...entries];
        });
      }
      /**
       * Requests the raw response body from Chrome DevTools Protocol. The method is
       * intentionally lazy because not every caller needs the payload, and CDP only
       * allows retrieving it once the response completes.
       */
      body() {
        return __async(this, null, function* () {
          const result = yield this.session.send(
            "Network.getResponseBody",
            { requestId: this.requestId }
          ).catch((error) => {
            throw new ResponseBodyError(String(error));
          });
          if (result.base64Encoded) {
            return Buffer.from(result.body, "base64");
          }
          return Buffer.from(result.body, "utf-8");
        });
      }
      /** Decodes the response body as UTF-8 text. */
      text() {
        return __async(this, null, function* () {
          const buffer = yield this.body();
          return buffer.toString("utf-8");
        });
      }
      /** Parses the response body as JSON and throws if parsing fails. */
      json() {
        return __async(this, null, function* () {
          const text = yield this.text();
          try {
            return JSON.parse(text);
          } catch (error) {
            throw new ResponseParseError(String(error));
          }
        });
      }
      /**
       * Resolves once the underlying network request completes or fails. Mirrors
       * Playwright's behaviour by resolving to `null` on success and to an `Error`
       * instance when Chrome reports `Network.loadingFailed`.
       */
      finished() {
        return __async(this, null, function* () {
          return this.finishedDeferred.promise;
        });
      }
      /**
       * Internal helper invoked by the navigation tracker when CDP reports extra
       * header information. This keeps the cached header views in sync with the
       * richer metadata.
       */
      applyExtraInfo(event) {
        var _a4;
        this.extraInfoHeaders = event.headers;
        this.extraInfoHeadersText = event.headersText;
        this.allHeadersCache = null;
        this.headersArrayCache = null;
        this.headersObject = {};
        this.headerValuesMap.clear();
        const source = (_a4 = event.headers) != null ? _a4 : {};
        for (const [name, value] of Object.entries(source)) {
          const lower2 = normaliseHeaderName(name);
          const segments = splitHeaderValues(String(value));
          this.headerValuesMap.set(lower2, segments);
          this.headersObject[lower2] = segments.join(", ");
        }
      }
      /**
       * Internal helper for creating a Response object from a Serializable
       * goto response from the Stagehand API
       */
      static fromSerializable(serialized, context) {
        var _a4;
        const reconstructed = new _Response({
          page: context.page,
          session: context.session,
          requestId: serialized.requestId,
          frameId: serialized.frameId,
          loaderId: serialized.loaderId,
          response: serialized.response,
          fromServiceWorker: (_a4 = serialized.fromServiceWorkerFlag) != null ? _a4 : false
        });
        if (serialized.extraInfoHeaders) {
          reconstructed.applyExtraInfo({
            requestId: serialized.requestId,
            headers: serialized.extraInfoHeaders,
            headersText: serialized.extraInfoHeadersText
          });
        }
        if (serialized.finishedSettled) {
          reconstructed.markFinished(null);
        }
        return reconstructed;
      }
      /** Marks the response as finished and resolves the `finished()` promise. */
      markFinished(error) {
        if (this.finishedSettled) return;
        this.finishedSettled = true;
        if (error) {
          this.finishedDeferred.resolve(error);
        } else {
          this.finishedDeferred.resolve(null);
        }
      }
    };
  }
});

// lib/v3/understudy/frame.ts
var Frame;
var init_frame = __esm({
  "lib/v3/understudy/frame.ts"() {
    init_locator();
    init_sdkErrors();
    init_executionContextRegistry();
    Frame = class _Frame {
      constructor(session, frameId, pageId, remoteBrowser) {
        this.session = session;
        this.frameId = frameId;
        this.pageId = pageId;
        this.remoteBrowser = remoteBrowser;
        var _a4;
        this.sessionId = (_a4 = this.session.id) != null ? _a4 : null;
      }
      /** True when the controlled browser runs on a different machine. */
      isBrowserRemote() {
        return this.remoteBrowser;
      }
      /** DOM.getNodeForLocation  DOM.describeNode */
      getNodeAtLocation(x2, y) {
        return __async(this, null, function* () {
          yield this.session.send("DOM.enable");
          const { backendNodeId } = yield this.session.send("DOM.getNodeForLocation", {
            x: x2,
            y,
            includeUserAgentShadowDOM: true,
            ignorePointerEventsNone: false
          });
          const { node } = yield this.session.send("DOM.describeNode", { backendNodeId });
          return node;
        });
      }
      /** CSS selector  DOM.querySelector  DOM.getBoxModel */
      getLocationForSelector(selector) {
        return __async(this, null, function* () {
          yield this.session.send("DOM.enable");
          const { root } = yield this.session.send(
            "DOM.getDocument"
          );
          const { nodeId } = yield this.session.send(
            "DOM.querySelector",
            { nodeId: root.nodeId, selector }
          );
          const { model } = yield this.session.send(
            "DOM.getBoxModel",
            { nodeId }
          );
          const x2 = model.content[0];
          const y = model.content[1];
          const width = model.width;
          const height = model.height;
          return { x: x2, y, width, height };
        });
      }
      /** Accessibility.getFullAXTree (+ recurse into child frames if requested) */
      getAccessibilityTree(withFrames = false) {
        return __async(this, null, function* () {
          var _a4, _b;
          yield this.session.send("Accessibility.enable");
          let nodes = [];
          try {
            ({ nodes } = yield this.session.send("Accessibility.getFullAXTree", { frameId: this.frameId }));
          } catch (e2) {
            const msg = String((_b = (_a4 = e2 == null ? void 0 : e2.message) != null ? _a4 : e2) != null ? _b : "");
            const isFrameScopeError = msg.includes("Frame with the given") || msg.includes("does not belong to the target") || msg.includes("is not found");
            if (!isFrameScopeError) throw e2;
            ({ nodes } = yield this.session.send("Accessibility.getFullAXTree"));
          }
          if (!withFrames) return nodes;
          const children = yield this.childFrames();
          for (const child of children) {
            const childNodes = yield child.getAccessibilityTree(false);
            nodes.push(...childNodes);
          }
          return nodes;
        });
      }
      /**
       * Evaluate a function or expression in this frame's main world.
       * - If a string is provided, treated as a JS expression.
       * - If a function is provided, it is stringified and invoked with the optional argument.
       */
      evaluate(pageFunctionOrExpression, arg) {
        return __async(this, null, function* () {
          var _a4;
          yield this.session.send("Runtime.enable").catch(() => {
          });
          const contextId = yield this.getMainWorldExecutionContextId();
          const isString = typeof pageFunctionOrExpression === "string";
          let expression;
          if (isString) {
            expression = String(pageFunctionOrExpression);
          } else {
            const fnSrc = pageFunctionOrExpression.toString();
            const argJson = JSON.stringify(arg);
            expression = `(() => {
        const __fn = ${fnSrc};
        const __arg = ${argJson};
        try {
          const __res = __fn(__arg);
          return Promise.resolve(__res).then(v => {
            try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
          });
        } catch (e) { throw e; }
      })()`;
          }
          const res = yield this.session.send(
            "Runtime.evaluate",
            {
              expression,
              contextId,
              awaitPromise: true,
              returnByValue: true
            }
          );
          if (res.exceptionDetails) {
            throw new StagehandEvalError(
              (_a4 = res.exceptionDetails.text) != null ? _a4 : "Evaluation failed"
            );
          }
          return res.result.value;
        });
      }
      /** Page.captureScreenshot (frame-scoped session) */
      screenshot(options) {
        return __async(this, null, function* () {
          var _a4;
          yield this.session.send("Page.enable");
          const format = (_a4 = options == null ? void 0 : options.type) != null ? _a4 : "png";
          const params = {
            format,
            fromSurface: true,
            captureBeyondViewport: options == null ? void 0 : options.fullPage
          };
          const clampScale = (value) => Math.min(2, Math.max(0.1, value));
          const normalizedScale = typeof (options == null ? void 0 : options.scale) === "number" ? clampScale(options.scale) : void 0;
          if (options == null ? void 0 : options.clip) {
            const clip = {
              x: options.clip.x,
              y: options.clip.y,
              width: options.clip.width,
              height: options.clip.height,
              scale: normalizedScale != null ? normalizedScale : 1
            };
            params.clip = clip;
          } else if (normalizedScale !== void 0 && normalizedScale !== 1) {
            params.scale = normalizedScale;
          }
          if (format === "jpeg" && typeof (options == null ? void 0 : options.quality) === "number") {
            const q = Math.round(options.quality);
            params.quality = Math.min(100, Math.max(0, q));
          }
          const { data } = yield this.session.send(
            "Page.captureScreenshot",
            params
          );
          return Buffer.from(data, "base64");
        });
      }
      /** Child frames via Page.getFrameTree */
      childFrames() {
        return __async(this, null, function* () {
          const { frameTree } = yield this.session.send("Page.getFrameTree");
          const frames = [];
          const collect = (tree) => {
            var _a4;
            if (tree.frame.parentId === this.frameId) {
              frames.push(
                new _Frame(
                  this.session,
                  tree.frame.id,
                  this.pageId,
                  this.remoteBrowser
                )
              );
            }
            (_a4 = tree.childFrames) == null ? void 0 : _a4.forEach(collect);
          };
          collect(frameTree);
          return frames;
        });
      }
      /** Wait for a lifecycle state (load/domcontentloaded/networkidle) */
      waitForLoadState(state = "load", timeoutMs = 15e3) {
        return __async(this, null, function* () {
          yield this.session.send("Page.enable");
          const targetState = state.toLowerCase();
          const timeout = Math.max(0, timeoutMs);
          yield new Promise((resolve3, reject) => {
            let done = false;
            let timer = null;
            const finish = () => {
              if (done) return;
              done = true;
              this.session.off("Page.lifecycleEvent", handler);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              resolve3();
            };
            const handler = (evt) => {
              var _a4;
              const sameFrame = evt.frameId === this.frameId;
              const lifecycleName = String((_a4 = evt.name) != null ? _a4 : "").toLowerCase();
              if (sameFrame && lifecycleName === targetState) {
                finish();
              }
            };
            this.session.on("Page.lifecycleEvent", handler);
            timer = setTimeout(() => {
              if (done) return;
              done = true;
              this.session.off("Page.lifecycleEvent", handler);
              reject(
                new Error(
                  `waitForLoadState(${state}) timed out after ${timeout}ms for frame ${this.frameId}`
                )
              );
            }, timeout);
          });
        });
      }
      /** Simple placeholder for your own locator abstraction */
      locator(selector, options) {
        return new Locator(this, selector, options);
      }
      /** Resolve the main-world execution context id for this frame. */
      getMainWorldExecutionContextId() {
        return __async(this, null, function* () {
          return executionContexts.waitForMainWorld(this.session, this.frameId, 1e3);
        });
      }
    };
  }
});

// lib/v3/understudy/frameRegistry.ts
function shellFrame(id) {
  return {
    id,
    loaderId: "",
    url: "",
    domainAndRegistry: "",
    securityOrigin: "",
    mimeType: "text/html",
    secureContextType: "InsecureScheme",
    crossOriginIsolatedContextType: "NotIsolated",
    gatedAPIFeatures: []
  };
}
var FrameRegistry;
var init_frameRegistry = __esm({
  "lib/v3/understudy/frameRegistry.ts"() {
    FrameRegistry = class {
      constructor(ownerTargetId, mainFrameId) {
        /** frameId  FrameInfo */
        this.frames = /* @__PURE__ */ new Map();
        /** sessionId  Set<frameId> (inverse map for diagnostics/fast membership checks) */
        this.framesBySession = /* @__PURE__ */ new Map();
        this.ownerTargetId = ownerTargetId;
        this.rootFrameId = mainFrameId;
        this.ensureNode(mainFrameId);
      }
      // ---------------------- Mutators (called by Context/Page bridges) ----------------------
      /**
       * Record that a frame attached. If `parentId` is null and `frameId` differs from the current
       * root, this is a root swap and we rename the root id.
       *
       * IMPORTANT: The emitter's `sessionId` is the **owner** for the new/attached frame.
       */
      onFrameAttached(frameId, parentId, sessionId) {
        if (!parentId && frameId !== this.rootFrameId) {
          this.renameNodeId(this.rootFrameId, frameId);
          this.rootFrameId = frameId;
          this.setOwnerSessionIdInternal(frameId, sessionId);
          return;
        }
        this.ensureNode(frameId);
        if (parentId) this.ensureNode(parentId);
        const info = this.frames.get(frameId);
        info.parentId = parentId != null ? parentId : null;
        if (parentId) {
          this.frames.get(parentId).children.add(frameId);
        }
        this.setOwnerSessionIdInternal(frameId, sessionId);
      }
      /**
       * Record a navigation with the full CDP `Frame`. Also updates ownership based on the emitting
       * session id. Handles root swap if the navigated frame is the new main (no parentId).
       */
      onFrameNavigated(frame, sessionId) {
        this.ensureNode(frame.id);
        const info = this.frames.get(frame.id);
        info.lastSeen = frame;
        this.setOwnerSessionIdInternal(frame.id, sessionId);
        if (!("parentId" in frame) || !frame.parentId) {
          if (frame.id !== this.rootFrameId) {
            this.renameNodeId(this.rootFrameId, frame.id);
            this.rootFrameId = frame.id;
          }
        }
      }
      onNavigatedWithinDocument(frameId, url, sessionId) {
        var _a4;
        this.ensureNode(frameId);
        const info = this.frames.get(frameId);
        const lastSeen = (_a4 = info.lastSeen) != null ? _a4 : shellFrame(frameId);
        info.lastSeen = __spreadProps(__spreadValues({}, lastSeen), { url });
        this.setOwnerSessionIdInternal(frameId, sessionId);
      }
      /**
       * Record that a frame detached. If `reason !== "swap"`, remove the subtree from the graph,
       * and clean the inverse maps. For swap we keep the node to preserve continuity.
       */
      onFrameDetached(frameId, reason = "remove") {
        if (reason === "swap") return;
        const toRemove = [];
        const collect = (fid) => {
          var _a4, _b;
          toRemove.push(fid);
          const kids = (_b = (_a4 = this.frames.get(fid)) == null ? void 0 : _a4.children) != null ? _b : /* @__PURE__ */ new Set();
          for (const k of kids) collect(k);
        };
        collect(frameId);
        for (const fid of toRemove) {
          const info = this.frames.get(fid);
          if (!info) continue;
          if (info.parentId) {
            const p = this.frames.get(info.parentId);
            p == null ? void 0 : p.children.delete(fid);
          }
          if (info.ownerSessionId) {
            const bag = this.framesBySession.get(info.ownerSessionId);
            bag == null ? void 0 : bag.delete(fid);
            if (bag && bag.size === 0)
              this.framesBySession.delete(info.ownerSessionId);
          }
          this.frames.delete(fid);
        }
        if (!this.frames.has(this.rootFrameId)) {
          const iter = this.frames.keys().next();
          if (!iter.done) this.rootFrameId = iter.value;
        }
      }
      /**
       * An adopted OOPIF child session was created whose **main** frame id equals the parent iframes frameId.
       * We mark the entire child subtree as owned by `childSessionId`.
       * (Topology edges remain aligned by the parent sessions `frameAttached` events.)
       */
      adoptChildSession(childSessionId, childMainFrameId) {
        this.setOwnerSessionIdInternal(childMainFrameId, childSessionId);
      }
      /**
       * Seed topology and ownership from an existing `Page.getFrameTree` snapshot, typically right after
       * a session is attached. This is a best-effort: we record frames and set the provided `sessionId`
       * as owner for the subtree **if** an owner isn't already set.
       */
      seedFromFrameTree(sessionId, frameTree) {
        const walk = (tree, parent) => {
          var _a4;
          this.ensureNode(tree.frame.id);
          this.frames.get(tree.frame.id).parentId = parent;
          if (parent) this.frames.get(parent).children.add(tree.frame.id);
          this.frames.get(tree.frame.id).lastSeen = tree.frame;
          if (!this.frames.get(tree.frame.id).ownerSessionId) {
            this.setOwnerSessionIdInternal(tree.frame.id, sessionId);
          }
          for (const c of (_a4 = tree.childFrames) != null ? _a4 : []) walk(c, tree.frame.id);
        };
        walk(frameTree, null);
      }
      /**
       * Set the backendNodeId of the `<iframe>` element for a child frame **as seen from its parent**.
       * This is useful for building absolute XPath prefixes later (from the parent document).
       */
      setOwnerBackendNodeId(childFrameId, backendNodeId) {
        this.ensureNode(childFrameId);
        this.frames.get(childFrameId).ownerBackendNodeId = backendNodeId;
      }
      // ---------------------- Readers (consumed by Page/snapshot/locators) ----------------------
      mainFrameId() {
        return this.rootFrameId;
      }
      /**
       * Return the owner session id for this frame. If unknown, returns `undefined`.
       */
      getOwnerSessionId(frameId) {
        var _a4;
        return (_a4 = this.frames.get(frameId)) == null ? void 0 : _a4.ownerSessionId;
      }
      /**
       * Return the owner backendNodeId (iframe element) if recorded.
       * This is in the **parent** document; pair it with `getParent`.
       */
      getOwnerBackendNodeId(frameId) {
        var _a4;
        return (_a4 = this.frames.get(frameId)) == null ? void 0 : _a4.ownerBackendNodeId;
      }
      /**
       * Return the parent frame id, or null for root/unknown.
       */
      getParent(frameId) {
        var _a4, _b;
        return (_b = (_a4 = this.frames.get(frameId)) == null ? void 0 : _a4.parentId) != null ? _b : null;
      }
      /**
       * List frame ids in root-first DFS order (same shape as CDPs FrameTree traversal).
       */
      listAllFrames() {
        const out = [];
        const dfs = (fid) => {
          var _a4, _b;
          out.push(fid);
          const kids = (_b = (_a4 = this.frames.get(fid)) == null ? void 0 : _a4.children) != null ? _b : /* @__PURE__ */ new Set();
          for (const k of kids) dfs(k);
        };
        if (this.frames.has(this.rootFrameId)) dfs(this.rootFrameId);
        return out;
      }
      /**
       * Serialize to `Protocol.Page.FrameTree` starting at the given root id (typically mainFrameId()).
       */
      asProtocolFrameTree(rootId) {
        const build = (fid) => {
          var _a4, _b;
          const info = this.frames.get(fid);
          const frame = (_a4 = info == null ? void 0 : info.lastSeen) != null ? _a4 : shellFrame(fid);
          const kids = (_b = info == null ? void 0 : info.children) != null ? _b : /* @__PURE__ */ new Set();
          const childFrames = kids.size ? [...kids].map((k) => build(k)) : void 0;
          return childFrames ? { frame, childFrames } : { frame };
        };
        return build(rootId);
      }
      /**
       * For diagnostics: return the current owner sessions for a frame id (0..n),
       * usually 0 or 1, but helpful to see potential inconsistencies during wiring.
       */
      sessionsForFrame(frameId) {
        const info = this.frames.get(frameId);
        return (info == null ? void 0 : info.ownerSessionId) ? [info.ownerSessionId] : [];
      }
      /**
       * For diagnostics: return current frame set per session.
       */
      framesForSession(sessionId) {
        var _a4;
        return [...(_a4 = this.framesBySession.get(sessionId)) != null ? _a4 : /* @__PURE__ */ new Set()];
      }
      // ---------------------- Internal helpers ----------------------
      ensureNode(fid) {
        if (this.frames.has(fid)) return;
        this.frames.set(fid, {
          parentId: null,
          children: /* @__PURE__ */ new Set(),
          lastSeen: shellFrame(fid),
          ownerSessionId: void 0,
          ownerBackendNodeId: void 0
        });
      }
      renameNodeId(oldId, newId) {
        if (oldId === newId) return;
        this.ensureNode(oldId);
        const info = this.frames.get(oldId);
        this.frames.delete(oldId);
        this.frames.set(newId, __spreadValues({}, info));
        if (info.parentId) {
          const p = this.frames.get(info.parentId);
          if (p) {
            p.children.delete(oldId);
            p.children.add(newId);
          }
        }
        for (const c of info.children) {
          const ci = this.frames.get(c);
          if (ci) ci.parentId = newId;
        }
        if (info.ownerSessionId) {
          const bag = this.framesBySession.get(info.ownerSessionId);
          if (bag) {
            bag.delete(oldId);
            bag.add(newId);
          }
        }
      }
      setOwnerSessionIdInternal(frameId, sessionId) {
        var _a4;
        this.ensureNode(frameId);
        const info = this.frames.get(frameId);
        if (info.ownerSessionId === sessionId) return;
        if (info.ownerSessionId) {
          const prev = this.framesBySession.get(info.ownerSessionId);
          prev == null ? void 0 : prev.delete(frameId);
          if (prev && prev.size === 0)
            this.framesBySession.delete(info.ownerSessionId);
        }
        info.ownerSessionId = sessionId;
        const bag = (_a4 = this.framesBySession.get(sessionId)) != null ? _a4 : /* @__PURE__ */ new Set();
        bag.add(frameId);
        this.framesBySession.set(sessionId, bag);
      }
    };
  }
});

// lib/v3/types/private/network.ts
var DEFAULT_IDLE_WAIT, IGNORED_RESOURCE_TYPES;
var init_network = __esm({
  "lib/v3/types/private/network.ts"() {
    DEFAULT_IDLE_WAIT = 500;
    IGNORED_RESOURCE_TYPES = /* @__PURE__ */ new Set(["EventSource", "WebSocket"]);
  }
});

// lib/v3/understudy/networkManager.ts
var NetworkManager;
var init_networkManager = __esm({
  "lib/v3/understudy/networkManager.ts"() {
    init_network();
    NetworkManager = class {
      constructor() {
        this.sessions = /* @__PURE__ */ new Map();
        this.observers = /* @__PURE__ */ new Set();
        this.requests = /* @__PURE__ */ new Map();
        this.documentRequestsByFrame = /* @__PURE__ */ new Map();
      }
      /**
       * Begin tracking network traffic for a CDP session (top-level or OOPIF).
       * Safe to call multiple times; duplicate registrations are ignored.
       */
      trackSession(session) {
        const sid = this.sessionKey(session);
        if (this.sessions.has(sid)) return;
        const onRequest = (evt) => {
          var _a4, _b, _c;
          if (!evt || !evt.requestId) return;
          const info = {
            sessionId: sid,
            requestId: evt.requestId,
            requestKey: this.requestKey(sid, evt.requestId),
            frameId: (_a4 = evt.frameId) != null ? _a4 : void 0,
            loaderId: (_b = evt.loaderId) != null ? _b : void 0,
            url: (_c = evt.request) == null ? void 0 : _c.url,
            timestamp: Date.now(),
            resourceType: evt.type,
            documentRequest: evt.type === "Document"
          };
          this.requests.set(info.requestKey, info);
          if (info.documentRequest && info.frameId) {
            this.documentRequestsByFrame.set(info.frameId, info.requestKey);
          }
          this.emitStart(info);
        };
        const finish = (reqId) => {
          const key = this.requestKey(sid, reqId);
          const stored = this.requests.get(key);
          if (stored == null ? void 0 : stored.frameId) {
            this.documentRequestsByFrame.delete(stored.frameId);
          }
          const info = stored != null ? stored : {
            sessionId: sid,
            requestId: reqId,
            requestKey: key,
            timestamp: Date.now(),
            documentRequest: false
          };
          this.requests.delete(key);
          this.emitFinish(info);
        };
        const fail = (reqId) => {
          const key = this.requestKey(sid, reqId);
          const stored = this.requests.get(key);
          if (stored == null ? void 0 : stored.frameId) {
            this.documentRequestsByFrame.delete(stored.frameId);
          }
          const info = stored != null ? stored : {
            sessionId: sid,
            requestId: reqId,
            requestKey: key,
            timestamp: Date.now(),
            documentRequest: false
          };
          this.requests.delete(key);
          this.emitFailure(info);
        };
        const onFinished = (evt) => {
          if (!(evt == null ? void 0 : evt.requestId)) return;
          finish(evt.requestId);
        };
        const onFailed = (evt) => {
          if (!(evt == null ? void 0 : evt.requestId)) return;
          fail(evt.requestId);
        };
        const onResponse = (evt) => {
          var _a4, _b;
          if (!(evt == null ? void 0 : evt.requestId)) return;
          const url = (_b = (_a4 = evt.response) == null ? void 0 : _a4.url) != null ? _b : "";
          if (url.startsWith("data:")) finish(evt.requestId);
        };
        const onFrameStopped = (evt) => {
          if (!(evt == null ? void 0 : evt.frameId)) return;
          const key = this.documentRequestsByFrame.get(evt.frameId);
          if (!key) return;
          const stored = this.requests.get(key);
          if (!stored) {
            this.documentRequestsByFrame.delete(evt.frameId);
            return;
          }
          this.requests.delete(key);
          this.documentRequestsByFrame.delete(evt.frameId);
          this.emitFinish(__spreadProps(__spreadValues({}, stored), { timestamp: Date.now() }));
        };
        session.on("Network.requestWillBeSent", onRequest);
        session.on("Network.loadingFinished", onFinished);
        session.on("Network.loadingFailed", onFailed);
        session.on("Network.requestServedFromCache", onFinished);
        session.on("Network.responseReceived", onResponse);
        session.on("Page.frameStoppedLoading", onFrameStopped);
        void session.send("Network.enable").catch(() => {
        });
        void session.send("Page.enable").catch(() => {
        });
        this.sessions.set(sid, {
          session,
          detach: () => {
            session.off("Network.requestWillBeSent", onRequest);
            session.off("Network.loadingFinished", onFinished);
            session.off("Network.loadingFailed", onFailed);
            session.off("Network.requestServedFromCache", onFinished);
            session.off("Network.responseReceived", onResponse);
            session.off("Page.frameStoppedLoading", onFrameStopped);
          }
        });
      }
      /**
       * Stop tracking a session and discard any inflight bookkeeping owned by it.
       */
      untrackSession(rawSessionId) {
        const sid = rawSessionId != null ? rawSessionId : "__main__";
        const entry = this.sessions.get(sid);
        if (!entry) return;
        entry.detach();
        this.sessions.delete(sid);
        for (const key of [...this.requests.keys()]) {
          if (key.startsWith(`${sid}:`)) this.requests.delete(key);
        }
        for (const [frameId, key] of [...this.documentRequestsByFrame.entries()]) {
          if (key.startsWith(`${sid}:`)) {
            this.documentRequestsByFrame.delete(frameId);
          }
        }
      }
      /**
       * Register a passive observer for request lifecycle notifications.
       * Returns a disposer that removes the observer.
       */
      addObserver(observer) {
        this.observers.add(observer);
        return () => {
          this.observers.delete(observer);
        };
      }
      /**
       * Resolve once no (filtered) requests are in flight for the given quiet window.
       * The waiter automatically unregisters itself on completion or timeout.
       */
      waitForIdle(options) {
        var _a4, _b, _c, _d2;
        const startTime = (_a4 = options.startTime) != null ? _a4 : Date.now();
        const idleTimeMs = (_b = options.idleTimeMs) != null ? _b : DEFAULT_IDLE_WAIT;
        const timeoutMs = options.timeoutMs;
        const remainingBudgetMs = Number.isFinite(timeoutMs) ? timeoutMs : void 0;
        const originalBudgetMs = Number.isFinite((_c = options.totalBudgetMs) != null ? _c : NaN) ? options.totalBudgetMs : remainingBudgetMs;
        const filter3 = (_d2 = options.filter) != null ? _d2 : ((info) => {
          return !IGNORED_RESOURCE_TYPES.has(info.resourceType);
        });
        const tracked = /* @__PURE__ */ new Set();
        let idleTimer = null;
        let timeoutTimer = null;
        let settled = false;
        let resolveFn = null;
        let rejectFn = null;
        const cleanup = (error) => {
          if (settled) return;
          settled = true;
          if (idleTimer) clearTimeout(idleTimer);
          if (timeoutTimer) clearTimeout(timeoutTimer);
          removeObserver();
          tracked.clear();
          if (error) {
            rejectFn == null ? void 0 : rejectFn(error);
          } else {
            resolveFn == null ? void 0 : resolveFn();
          }
        };
        const maybeIdle = () => {
          if (settled) return;
          if (tracked.size === 0) {
            if (!idleTimer) {
              idleTimer = setTimeout(() => {
                cleanup();
              }, idleTimeMs);
            }
          } else if (idleTimer) {
            clearTimeout(idleTimer);
            idleTimer = null;
          }
        };
        const observer = {
          onRequestStarted: (info) => {
            if (settled) return;
            if (info.timestamp < startTime) return;
            if (!filter3(info)) return;
            tracked.add(info.requestKey);
            if (idleTimer) {
              clearTimeout(idleTimer);
              idleTimer = null;
            }
          },
          onRequestFinished: (info) => {
            if (settled) return;
            if (!tracked.delete(info.requestKey)) return;
            maybeIdle();
          },
          onRequestFailed: (info) => {
            if (settled) return;
            if (!tracked.delete(info.requestKey)) return;
            maybeIdle();
          }
        };
        const removeObserver = this.addObserver(observer);
        const promise = new Promise((resolve3, reject) => {
          resolveFn = resolve3;
          rejectFn = reject;
        });
        maybeIdle();
        if (Number.isFinite(timeoutMs)) {
          timeoutTimer = setTimeout(
            () => {
              const elapsed = Date.now() - startTime;
              const message = originalBudgetMs !== void 0 ? `networkidle timed out after ${originalBudgetMs}ms` : `networkidle timed out after ${elapsed}ms`;
              cleanup(new Error(message));
            },
            Math.max(0, timeoutMs)
          );
        }
        return {
          promise,
          dispose: () => cleanup(new Error("waitForIdle disposed"))
        };
      }
      /**
       * Tear down all session listeners and clear observers/bookkeeping.
       */
      dispose() {
        for (const { detach } of this.sessions.values()) {
          detach();
        }
        this.sessions.clear();
        this.observers.clear();
        this.requests.clear();
        this.documentRequestsByFrame.clear();
      }
      /** Fan-out helper when a tracked request starts. */
      emitStart(info) {
        for (const obs of this.observers) {
          obs.onRequestStarted(info);
        }
      }
      /** Fan-out helper when a tracked request completes successfully. */
      emitFinish(info) {
        for (const obs of this.observers) {
          obs.onRequestFinished(info);
        }
      }
      /** Fan-out helper when a tracked request fails mid-flight. */
      emitFailure(info) {
        for (const obs of this.observers) {
          obs.onRequestFailed(info);
        }
      }
      /** Compute a stable key for a session (falls back to synthetic root id). */
      sessionKey(session) {
        var _a4;
        return (_a4 = session.id) != null ? _a4 : "__main__";
      }
      /** Compose the unique key for tracking a request under a session. */
      requestKey(sessionId, requestId) {
        return `${sessionId}:${requestId}`;
      }
    };
  }
});

// lib/v3/understudy/lifecycleWatcher.ts
var LifecycleWatcher;
var init_lifecycleWatcher = __esm({
  "lib/v3/understudy/lifecycleWatcher.ts"() {
    init_sdkErrors();
    init_network();
    LifecycleWatcher = class {
      /**
       * Create a watcher; callers should subsequently invoke {@link wait}.
       */
      constructor(params) {
        this.cleanupCallbacks = [];
        this.idleHandle = null;
        this.abortReject = null;
        this.abortError = null;
        this.disposed = false;
        this.pendingFollowupNavigation = false;
        this.page = params.page;
        this.mainSession = params.mainSession;
        this.networkManager = params.networkManager;
        this.waitUntil = params.waitUntil;
        this.timeoutMs = params.timeoutMs;
        this.startTime = Date.now();
        this.navigationCommandId = params.navigationCommandId;
        this.idleStartTime = this.startTime;
        this.abortPromise = new Promise((_, reject) => {
          this.abortReject = reject;
        });
        this.installSessionListeners();
      }
      /** Hint the watcher with the loader id returned by Page.navigate. */
      setExpectedLoaderId(loaderId) {
        if (!loaderId) return;
        this.expectedLoaderId = loaderId;
        this.initialLoaderId = loaderId;
        this.currentLoaderId = loaderId;
        this.idleStartTime = Date.now();
      }
      /** Wait for the requested lifecycle state or throw on timeout/abort. */
      wait() {
        return __async(this, null, function* () {
          const deadline = Date.now() + this.timeoutMs;
          try {
            if (this.waitUntil === "domcontentloaded") {
              yield this.awaitWithAbort(
                this.page.waitForMainLoadState(
                  "domcontentloaded",
                  this.timeRemaining(deadline)
                )
              );
              return;
            }
            while (true) {
              yield this.awaitWithAbort(
                this.page.waitForMainLoadState("load", this.timeRemaining(deadline))
              );
              if (this.waitUntil !== "networkidle") break;
              try {
                yield this.awaitWithAbort(this.waitForNetworkIdle(deadline));
                break;
              } catch (error) {
                if (this.shouldRestartAfterFollowup(error)) {
                  continue;
                }
                throw error;
              }
            }
          } finally {
            this.dispose();
          }
          if (this.abortError) throw this.abortError;
        });
      }
      /** Cancel any outstanding network-idle waits and remove event listeners. */
      dispose() {
        if (this.disposed) return;
        this.disposed = true;
        if (this.idleHandle) {
          void this.idleHandle.promise.catch(() => {
          });
          this.idleHandle.dispose();
          this.idleHandle = null;
        }
        for (const fn of this.cleanupCallbacks) {
          try {
            fn();
          } catch (e2) {
          }
        }
        this.cleanupCallbacks = [];
        this.abortReject = null;
      }
      /** Subscribe to main-frame events to detect abort conditions. */
      installSessionListeners() {
        const onFrameNavigated = (evt) => {
          var _a4;
          if (!((_a4 = evt == null ? void 0 : evt.frame) == null ? void 0 : _a4.id)) return;
          const mainFrameId = this.page.mainFrameId();
          if (evt.frame.id !== mainFrameId) return;
          const loaderId = evt.frame.loaderId;
          if (!loaderId) return;
          if (!this.initialLoaderId) {
            this.initialLoaderId = loaderId;
            this.currentLoaderId = loaderId;
            this.idleStartTime = Date.now();
          }
          if (!this.expectedLoaderId) {
            this.expectedLoaderId = loaderId;
            this.currentLoaderId = loaderId;
            this.idleStartTime = Date.now();
            return;
          }
          if (loaderId !== this.expectedLoaderId) {
            if (!this.page.isCurrentNavigationCommand(this.navigationCommandId)) {
              this.triggerAbort(
                new Error("Navigation was superseded by a new request")
              );
              return;
            }
            this.adoptNewMainLoader(loaderId);
          }
        };
        const onFrameDetached = (evt) => {
          if (!(evt == null ? void 0 : evt.frameId)) return;
          const mainFrameId = this.page.mainFrameId();
          if (evt.frameId !== mainFrameId) return;
          if (evt.reason === "swap") return;
          this.triggerAbort(new Error("Main frame was detached"));
        };
        this.mainSession.on("Page.frameNavigated", onFrameNavigated);
        this.cleanupCallbacks.push(() => {
          this.mainSession.off("Page.frameNavigated", onFrameNavigated);
        });
        this.mainSession.on("Page.frameDetached", onFrameDetached);
        this.cleanupCallbacks.push(() => {
          this.mainSession.off("Page.frameDetached", onFrameDetached);
        });
      }
      /** Compute remaining time until the shared deadline elapses. */
      timeRemaining(deadline) {
        const remaining = deadline - Date.now();
        if (remaining <= 0) {
          throw new TimeoutError("Lifecycle wait", this.timeoutMs);
        }
        return remaining;
      }
      /** Await an operation but abort early if navigation replacement fires. */
      awaitWithAbort(operation) {
        return __async(this, null, function* () {
          try {
            return yield Promise.race([operation, this.abortPromise]);
          } catch (error) {
            if (this.abortError) throw this.abortError;
            throw error;
          }
        });
      }
      /** Mark the watcher as aborted and reject any pending waiters. */
      triggerAbort(error) {
        if (this.abortError) return;
        this.abortError = error;
        if (this.abortReject) {
          this.abortReject(error);
          this.abortReject = null;
        }
      }
      waitForNetworkIdle(deadline) {
        this.pendingFollowupNavigation = false;
        const remaining = this.timeRemaining(deadline);
        const idleWindow = Math.min(DEFAULT_IDLE_WAIT, remaining);
        this.idleHandle = this.networkManager.waitForIdle({
          startTime: this.idleStartTime,
          timeoutMs: remaining,
          totalBudgetMs: this.timeoutMs,
          idleTimeMs: idleWindow,
          filter: this.buildIdleFilter()
        });
        return this.idleHandle.promise.catch((error) => {
          if (this.abortError) throw this.abortError;
          throw error;
        });
      }
      shouldRestartAfterFollowup(error) {
        if (!this.pendingFollowupNavigation) return false;
        if (!(error instanceof Error)) return false;
        if (error.message !== "waitForIdle disposed") return false;
        this.pendingFollowupNavigation = false;
        return true;
      }
      adoptNewMainLoader(loaderId) {
        this.expectedLoaderId = loaderId;
        this.currentLoaderId = loaderId;
        this.idleStartTime = Date.now();
        if (this.waitUntil !== "networkidle") return;
        this.pendingFollowupNavigation = true;
        if (this.idleHandle) {
          const handle = this.idleHandle;
          this.idleHandle = null;
          void handle.promise.catch(() => {
          });
          handle.dispose();
        }
      }
      buildIdleFilter() {
        const loaderId = this.currentLoaderId;
        const mainFrameId = this.page.mainFrameId();
        return (info) => {
          if (IGNORED_RESOURCE_TYPES.has(info.resourceType)) return false;
          if (loaderId && info.loaderId) {
            return info.loaderId === loaderId;
          }
          if (!info.loaderId && info.frameId) {
            return info.frameId === mainFrameId;
          }
          return true;
        };
      }
    };
  }
});

// lib/v3/understudy/navigationResponseTracker.ts
var NavigationResponseTracker;
var init_navigationResponseTracker = __esm({
  "lib/v3/understudy/navigationResponseTracker.ts"() {
    init_response2();
    NavigationResponseTracker = class {
      /**
       * Create a tracker bound to a specific navigation command. The tracker begins
       * listening for network events immediately so it should be constructed before
       * the navigation request is dispatched.
       */
      constructor(params) {
        this.selectedRequestId = null;
        this.selectedResponse = null;
        this.acceptNextWithoutLoader = false;
        this.responseResolved = false;
        this.pendingResponsesByLoader = /* @__PURE__ */ new Map();
        this.pendingExtraInfo = /* @__PURE__ */ new Map();
        this.listeners = [];
        this.page = params.page;
        this.session = params.session;
        this.navigationCommandId = params.navigationCommandId;
        this.responsePromise = new Promise((resolve3) => {
          this.resolveResponse = (value) => {
            if (this.responseResolved) return;
            this.responseResolved = true;
            resolve3(value);
          };
        });
        this.installListeners();
      }
      /** Stop listening for CDP events and release any pending bookkeeping. */
      dispose() {
        for (const { event, handler } of this.listeners) {
          this.session.off(event, handler);
        }
        this.listeners.length = 0;
        this.pendingResponsesByLoader.clear();
        this.pendingExtraInfo.clear();
      }
      /**
       * Hint the tracker with the loader id returned by `Page.navigate`. Chrome only
       * emits this once the browser begins navigating, so we store early responses
       * and match them once the loader id is known.
       */
      setExpectedLoaderId(loaderId) {
        if (!loaderId) return;
        this.expectedLoaderId = loaderId;
        const pending = this.pendingResponsesByLoader.get(loaderId);
        if (pending) {
          this.pendingResponsesByLoader.delete(loaderId);
          this.selectResponse(pending);
        }
      }
      /**
       * Some navigation APIs (reload/history traversal) do not provide a loader id
       * up front. This flag instructs the tracker to accept the next qualifying
       * document response even if no loader id has been announced yet.
       */
      expectNavigationWithoutKnownLoader() {
        this.acceptNextWithoutLoader = true;
      }
      /**
       * Returns a promise that resolves with the matched response (or `null` when
       * no document response was observed).
       */
      navigationCompleted() {
        return __async(this, null, function* () {
          if (!this.responseResolved) {
            queueMicrotask(() => {
              if (!this.responseResolved) this.resolveResponse(null);
            });
          }
          return this.responsePromise;
        });
      }
      /** Expose the raw response promise (mainly for tests). */
      response() {
        return __async(this, null, function* () {
          return this.responsePromise;
        });
      }
      /** Register all CDP listeners relevant to navigation tracking. */
      installListeners() {
        this.addListener("Network.responseReceived", (event) => {
          this.onResponseReceived(event);
        });
        this.addListener("Network.responseReceivedExtraInfo", (event) => {
          this.onResponseReceivedExtraInfo(
            event
          );
        });
        this.addListener("Network.loadingFinished", (event) => {
          this.onLoadingFinished(event);
        });
        this.addListener("Network.loadingFailed", (event) => {
          this.onLoadingFailed(event);
        });
      }
      /** Attach a CDP listener and track it for later disposal. */
      addListener(event, handler) {
        this.session.on(event, handler);
        this.listeners.push({ event, handler });
      }
      /** Handle the initial response payload for document navigations. */
      onResponseReceived(event) {
        var _a4;
        if (!this.page.isCurrentNavigationCommand(this.navigationCommandId)) return;
        if (!event || !event.response) return;
        if (event.type !== "Document") return;
        if (event.frameId !== this.page.mainFrameId()) return;
        const loaderId = (_a4 = event.loaderId) != null ? _a4 : "";
        if (this.acceptNextWithoutLoader) {
          this.acceptNextWithoutLoader = false;
          this.selectResponse(event);
          return;
        }
        if (this.expectedLoaderId) {
          if (loaderId && loaderId !== this.expectedLoaderId) {
            this.pendingResponsesByLoader.set(loaderId, event);
            return;
          }
          this.selectResponse(event);
          return;
        }
        if (loaderId) {
          this.pendingResponsesByLoader.set(loaderId, event);
          return;
        }
        this.selectResponse(event);
      }
      /** Merge auxiliary header information once Chrome exposes it. */
      onResponseReceivedExtraInfo(event) {
        var _a4;
        if (!event || !event.requestId) return;
        if (this.selectedRequestId && event.requestId === this.selectedRequestId) {
          (_a4 = this.selectedResponse) == null ? void 0 : _a4.applyExtraInfo(event);
          return;
        }
        this.pendingExtraInfo.set(event.requestId, event);
      }
      /** Resolve the response's finished promise when the request completes. */
      onLoadingFinished(event) {
        var _a4;
        if (!event || !event.requestId) return;
        if (event.requestId !== this.selectedRequestId) return;
        (_a4 = this.selectedResponse) == null ? void 0 : _a4.markFinished(null);
      }
      /** Resolve the response's finished promise with an error on failure. */
      onLoadingFailed(event) {
        var _a4;
        if (!event || !event.requestId) return;
        if (event.requestId !== this.selectedRequestId) return;
        const errorText = event.errorText || "Navigation request failed";
        (_a4 = this.selectedResponse) == null ? void 0 : _a4.markFinished(new Error(errorText));
      }
      /**
       * Create the `Response` wrapper for the chosen document response and
       * resolve awaiting consumers. Subsequent events flesh out the header/body
       * helpers and mark the request as finished.
       */
      selectResponse(event) {
        var _a4, _b, _c, _d2, _e, _f;
        if (event.loaderId) {
          this.pendingResponsesByLoader.delete(event.loaderId);
        }
        if (this.responseResolved) return;
        if (this.selectedResponse) return;
        const protocol = (_c = (_b = (_a4 = event.response) == null ? void 0 : _a4.protocol) == null ? void 0 : _b.toLowerCase()) != null ? _c : "";
        const url = (_e = (_d2 = event.response) == null ? void 0 : _d2.url) != null ? _e : "";
        const isDataUrl = protocol === "data" || url.startsWith("data:");
        const isAboutUrl = protocol === "about" || url.startsWith("about:");
        if (isDataUrl || isAboutUrl) {
          this.pendingExtraInfo.delete(event.requestId);
          this.selectedRequestId = null;
          this.selectedResponse = null;
          this.resolveResponse(null);
          return;
        }
        const response = new Response2({
          page: this.page,
          session: this.session,
          requestId: event.requestId,
          frameId: event.frameId,
          loaderId: event.loaderId,
          response: event.response,
          fromServiceWorker: Boolean((_f = event.response) == null ? void 0 : _f.fromServiceWorker)
        });
        this.selectedRequestId = event.requestId;
        this.selectedResponse = response;
        const extraInfo = this.pendingExtraInfo.get(event.requestId);
        if (extraInfo) {
          response.applyExtraInfo(extraInfo);
          this.pendingExtraInfo.delete(event.requestId);
        }
        this.resolveResponse(response);
      }
    };
  }
});

// lib/v3/understudy/initScripts.ts
function appendSourceURL(source, filePath) {
  const sanitized = filePath.replace(/\n/g, "");
  return `${source}
//# sourceURL=${sanitized}`;
}
function normalizeInitScriptSource(_0, _1) {
  return __async(this, arguments, function* (script, arg, caller = DEFAULT_CALLER) {
    if (typeof script === "function") {
      const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
      return `(${script.toString()})(${argString})`;
    }
    if (!Object.is(arg, void 0)) {
      throw new StagehandInvalidArgumentError(
        `${caller}: 'arg' is only supported when passing a function.`
      );
    }
    if (typeof script === "string") {
      return script;
    }
    if (!script || typeof script !== "object") {
      throw new StagehandInvalidArgumentError(
        `${caller}: provide a string, function, or an object with path/content.`
      );
    }
    if (typeof script.content === "string") {
      return script.content;
    }
    if (typeof script.path === "string" && script.path.trim()) {
      const raw = yield import_fs6.promises.readFile(script.path, "utf8");
      return appendSourceURL(raw, script.path);
    }
    throw new StagehandInvalidArgumentError(
      `${caller}: provide a string, function, or an object with path/content.`
    );
  });
}
var import_fs6, DEFAULT_CALLER;
var init_initScripts = __esm({
  "lib/v3/understudy/initScripts.ts"() {
    import_fs6 = require("fs");
    init_sdkErrors();
    DEFAULT_CALLER = "context.addInitScript";
  }
});

// lib/v3/understudy/screenshotUtils.ts
function collectFramesForScreenshot(page) {
  const seen = /* @__PURE__ */ new Map();
  const main = page.mainFrame();
  seen.set(main.frameId, main);
  for (const frame of page.frames()) {
    seen.set(frame.frameId, frame);
  }
  return Array.from(seen.values());
}
function normalizeScreenshotClip(clip) {
  const x2 = Number(clip.x);
  const y = Number(clip.y);
  const width = Number(clip.width);
  const height = Number(clip.height);
  for (const [key, value] of Object.entries({ x: x2, y, width, height })) {
    if (!Number.isFinite(value)) {
      throw new StagehandInvalidArgumentError(
        `screenshot: clip.${key} must be a finite number`
      );
    }
  }
  if (width <= 0 || height <= 0) {
    throw new StagehandInvalidArgumentError(
      "screenshot: clip width/height must be positive"
    );
  }
  return { x: x2, y, width, height };
}
function computeScreenshotScale(page, mode) {
  return __async(this, null, function* () {
    if (mode !== "css") return void 0;
    try {
      const frame = page.mainFrame();
      const dpr = yield frame.evaluate(() => {
        const ratio = Number(window.devicePixelRatio || 1);
        return Number.isFinite(ratio) && ratio > 0 ? ratio : 1;
      }).catch(() => 1);
      const safeRatio = Number.isFinite(dpr) && dpr > 0 ? dpr : 1;
      return Math.min(2, Math.max(0.1, 1 / safeRatio));
    } catch (e2) {
      return 1;
    }
  });
}
function setTransparentBackground(session) {
  return __async(this, null, function* () {
    yield session.send("Emulation.setDefaultBackgroundColorOverride", {
      color: { r: 0, g: 0, b: 0, a: 0 }
    }).catch(() => {
    });
    return () => __async(null, null, function* () {
      yield session.send("Emulation.setDefaultBackgroundColorOverride", {}).catch(() => {
      });
    });
  });
}
function applyStyleToFrames(frames, css, label) {
  return __async(this, null, function* () {
    const trimmed = css.trim();
    if (!trimmed) return () => __async(null, null, function* () {
    });
    const token = `__v3_style_${label}_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    yield Promise.all(
      frames.map(
        (frame) => frame.evaluate(
          ({ css: css2, token: token2 }) => {
            try {
              const doc = document;
              if (!doc) return;
              const style = doc.createElement("style");
              style.setAttribute("data-stagehand-style", token2);
              style.textContent = css2;
              const parent = doc.head || doc.documentElement || doc.body;
              parent == null ? void 0 : parent.appendChild(style);
            } catch (e2) {
            }
          },
          { css: trimmed, token }
        ).catch(() => {
        })
      )
    );
    return () => __async(null, null, function* () {
      yield Promise.all(
        frames.map(
          (frame) => frame.evaluate((token2) => {
            try {
              const doc = document;
              if (!doc) return;
              const nodes = doc.querySelectorAll(
                `[data-stagehand-style="${token2}"]`
              );
              nodes.forEach((node) => node.remove());
            } catch (e2) {
            }
          }, token).catch(() => {
          })
        )
      );
    });
  });
}
function disableAnimations(frames) {
  return __async(this, null, function* () {
    const css = `
*,
*::before,
*::after {
  animation-delay: 0s !important;
  animation-duration: 0s !important;
  animation-iteration-count: 1 !important;
  animation-play-state: paused !important;
  transition-property: none !important;
  transition-duration: 0s !important;
  transition-delay: 0s !important;
}`;
    const cleanup = yield applyStyleToFrames(frames, css, "animations");
    yield Promise.all(
      frames.map(
        (frame) => frame.evaluate(() => {
          var _a4, _b, _c, _d2, _e;
          try {
            const animations = typeof document.getAnimations === "function" ? document.getAnimations() : [];
            for (const animation of animations) {
              try {
                const details = (_b = (_a4 = animation.effect) == null ? void 0 : _a4.getComputedTiming) == null ? void 0 : _b.call(_a4);
                if (details && details.iterations !== Infinity) {
                  (_c = animation.finish) == null ? void 0 : _c.call(animation);
                } else {
                  (_d2 = animation.cancel) == null ? void 0 : _d2.call(animation);
                }
              } catch (e2) {
                (_e = animation.cancel) == null ? void 0 : _e.call(animation);
              }
            }
          } catch (e2) {
          }
        }).catch(() => {
        })
      )
    );
    return cleanup;
  });
}
function hideCaret(frames) {
  return __async(this, null, function* () {
    const css = `
input,
textarea,
[contenteditable],
[contenteditable=""],
[contenteditable="true"],
[contenteditable="plaintext-only"],
*:focus {
  caret-color: transparent !important;
}`;
    return applyStyleToFrames(frames, css, "caret");
  });
}
function applyMaskOverlays(locators, color) {
  return __async(this, null, function* () {
    var _a4;
    const rectsByFrame = /* @__PURE__ */ new Map();
    for (const locator of locators) {
      try {
        const info = yield resolveMaskRect(locator);
        if (!info) continue;
        const list = (_a4 = rectsByFrame.get(info.frame)) != null ? _a4 : [];
        list.push(info.rect);
        rectsByFrame.set(info.frame, list);
      } catch (e2) {
      }
    }
    if (rectsByFrame.size === 0) {
      return () => __async(null, null, function* () {
      });
    }
    const token = `__v3_mask_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    yield Promise.all(
      Array.from(rectsByFrame.entries()).map(
        ([frame, rects]) => frame.evaluate(
          ({ rects: rects2, color: color2, token: token2 }) => {
            try {
              const doc = document;
              if (!doc) return;
              const root = doc.documentElement || doc.body;
              if (!root) return;
              for (const rect of rects2) {
                const el = doc.createElement("div");
                el.setAttribute("data-stagehand-mask", token2);
                el.style.position = "absolute";
                el.style.left = `${rect.x}px`;
                el.style.top = `${rect.y}px`;
                el.style.width = `${rect.width}px`;
                el.style.height = `${rect.height}px`;
                el.style.backgroundColor = color2;
                el.style.pointerEvents = "none";
                el.style.zIndex = "2147483647";
                el.style.opacity = "1";
                el.style.mixBlendMode = "normal";
                root.appendChild(el);
              }
            } catch (e2) {
            }
          },
          { rects, color, token }
        ).catch(() => {
        })
      )
    );
    return () => __async(null, null, function* () {
      yield Promise.all(
        Array.from(rectsByFrame.keys()).map(
          (frame) => frame.evaluate((token2) => {
            try {
              const doc = document;
              if (!doc) return;
              const nodes = doc.querySelectorAll(
                `[data-stagehand-mask="${token2}"]`
              );
              nodes.forEach((node) => node.remove());
            } catch (e2) {
            }
          }, token).catch(() => {
          })
        )
      );
    });
  });
}
function resolveMaskRect(locator) {
  return __async(this, null, function* () {
    const frame = locator.getFrame();
    const session = frame.session;
    let objectId = null;
    try {
      const resolved = yield locator.resolveNode();
      objectId = resolved.objectId;
      const result = yield session.send(
        "Runtime.callFunctionOn",
        {
          objectId,
          functionDeclaration: `function() {
          if (!this || typeof this.getBoundingClientRect !== 'function') return null;
          const rect = this.getBoundingClientRect();
          if (!rect) return null;
          const style = window.getComputedStyle(this);
          if (!style) return null;
          if (style.visibility === 'hidden' || style.display === 'none') return null;
          if (rect.width <= 0 || rect.height <= 0) return null;
          return {
            x: rect.left + window.scrollX,
            y: rect.top + window.scrollY,
            width: rect.width,
            height: rect.height,
          };
        }`,
          returnByValue: true
        }
      );
      if (result.exceptionDetails) {
        return null;
      }
      const rect = result.result.value;
      if (!rect) return null;
      const { x: x2, y, width, height } = rect;
      if (!Number.isFinite(x2) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return null;
      }
      return { frame, rect: { x: x2, y, width, height } };
    } catch (e2) {
      return null;
    } finally {
      if (objectId) {
        yield session.send("Runtime.releaseObject", { objectId }).catch(() => {
        });
      }
    }
  });
}
function runScreenshotCleanups(cleanups) {
  return __async(this, null, function* () {
    for (let i2 = cleanups.length - 1; i2 >= 0; i2 -= 1) {
      const fn = cleanups[i2];
      if (!fn) continue;
      try {
        const result = fn();
        if (result && typeof result.then === "function") {
          yield result;
        }
      } catch (e2) {
      }
    }
  });
}
function withScreenshotTimeout(timeoutMs, task) {
  return __async(this, null, function* () {
    if (!timeoutMs || timeoutMs <= 0) return task();
    let timer = null;
    const timeoutPromise = new Promise((_, reject) => {
      timer = setTimeout(() => {
        reject(new Error(`screenshot: timeout of ${timeoutMs}ms exceeded`));
      }, timeoutMs);
    });
    try {
      return yield Promise.race([task(), timeoutPromise]);
    } finally {
      if (timer) clearTimeout(timer);
    }
  });
}
var init_screenshotUtils = __esm({
  "lib/v3/understudy/screenshotUtils.ts"() {
    init_sdkErrors();
  }
});

// lib/v3/understudy/page.ts
var page_exports = {};
__export(page_exports, {
  Page: () => Page
});
var import_fs7, LIFECYCLE_NAME, _keyPress_dec, _type_dec, _dragAndDrop_dec, _scroll_dec, _hover_dec, _click_dec, _evaluate_dec, _waitForLoadState_dec, _screenshot_dec, _goForward_dec, _goBack_dec, _reload_dec, _goto_dec, _close_dec, _init, _Page, Page;
var init_page = __esm({
  "lib/v3/understudy/page.ts"() {
    import_fs7 = require("fs");
    init_logger();
    init_flowLogger();
    init_frame();
    init_frameLocator();
    init_deepLocator();
    init_snapshot();
    init_frameRegistry();
    init_executionContextRegistry();
    init_networkManager();
    init_lifecycleWatcher();
    init_navigationResponseTracker();
    init_response2();
    init_consoleMessage();
    init_sdkErrors();
    init_initScripts();
    init_screenshotUtils();
    LIFECYCLE_NAME = {
      load: "load",
      domcontentloaded: "DOMContentLoaded",
      networkidle: "networkIdle"
    };
    _close_dec = [logAction("Page.close")], _goto_dec = [logAction("Page.goto")], _reload_dec = [logAction("Page.reload")], _goBack_dec = [logAction("Page.goBack")], _goForward_dec = [logAction("Page.goForward")], _screenshot_dec = [logAction("Page.screenshot")], _waitForLoadState_dec = [logAction("Page.waitForLoadState")], _evaluate_dec = [logAction("Page.evaluate")], _click_dec = [logAction("Page.click")], _hover_dec = [logAction("Page.hover")], _scroll_dec = [logAction("Page.scroll")], _dragAndDrop_dec = [logAction("Page.dragAndDrop")], _type_dec = [logAction("Page.type")], _keyPress_dec = [logAction("Page.keyPress")];
    _Page = class _Page {
      constructor(conn, mainSession, _targetId, mainFrameId, apiClient, browserIsRemote = false) {
        this.conn = conn;
        this.mainSession = mainSession;
        this._targetId = _targetId;
        __runInitializers(_init, 5, this);
        /** Every CDP child session this page owns (top-level + adopted OOPIF sessions). */
        this.sessions = /* @__PURE__ */ new Map();
        // sessionId -> session
        /** Unified truth for frame topology + ownership. */
        this.registry = void 0;
        /** A convenience wrapper bound to the current main frame id (top-level session). */
        this.mainFrameWrapper = void 0;
        /** Compact ordinal per frameId (used by snapshot encoding). */
        this.frameOrdinals = /* @__PURE__ */ new Map();
        this.nextOrdinal = 0;
        /** cache Frames per frameId so everyone uses the same one */
        this.frameCache = /* @__PURE__ */ new Map();
        this.browserIsRemote = void 0;
        /** Stable id for Frames created by this Page (use top-level TargetId). */
        this.pageId = void 0;
        /** Cached current URL for synchronous page.url() */
        this._currentUrl = "about:blank";
        this.navigationCommandSeq = 0;
        this.latestNavigationCommandId = 0;
        this.networkManager = void 0;
        /** Optional API client for routing page operations to the API */
        this.apiClient = null;
        this.consoleListeners = /* @__PURE__ */ new Set();
        this.consoleHandlers = /* @__PURE__ */ new Map();
        /** Document-start scripts installed across every session this page owns. */
        this.initScripts = [];
        // --- Optional visual cursor overlay management ---
        this.cursorEnabled = false;
        // Track pressed modifier keys
        this._pressedModifiers = /* @__PURE__ */ new Set();
        this.pageId = _targetId;
        this.apiClient = apiClient != null ? apiClient : null;
        this.browserIsRemote = browserIsRemote;
        if (mainSession.id) this.sessions.set(mainSession.id, mainSession);
        this.registry = new FrameRegistry(_targetId, mainFrameId);
        this.mainFrameWrapper = new Frame(
          this.mainSession,
          mainFrameId,
          this.pageId,
          this.browserIsRemote
        );
        this.networkManager = new NetworkManager();
        this.networkManager.trackSession(this.mainSession);
      }
      // Send a single init script to a specific CDP session.
      installInitScriptOnSession(session, source) {
        return __async(this, null, function* () {
          yield session.send("Page.addScriptToEvaluateOnNewDocument", {
            source
          });
        });
      }
      // Replay every previously registered init script onto a newly adopted session.
      applyInitScriptsToSession(session) {
        return __async(this, null, function* () {
          for (const source of this.initScripts) {
            yield this.installInitScriptOnSession(session, source);
          }
        });
      }
      // Register a new init script and fan it out to all active sessions for this page.
      registerInitScript(source) {
        return __async(this, null, function* () {
          if (this.initScripts.includes(source)) return;
          this.initScripts.push(source);
          const installs = [];
          installs.push(this.installInitScriptOnSession(this.mainSession, source));
          for (const session of this.sessions.values()) {
            if (session === this.mainSession) continue;
            installs.push(this.installInitScriptOnSession(session, source));
          }
          yield Promise.all(installs);
        });
      }
      ensureCursorScript() {
        return __async(this, null, function* () {
          const script = `(() => {
      const ID = '__v3_cursor_overlay__';
      const state = { el: null, last: null };
      // Expose API early so move() calls before install are buffered
      try {
        if (!window.__v3Cursor || !window.__v3Cursor.__installed) {
          const api = {
            __installed: false,
            move(x, y) {
              if (state.el) {
                state.el.style.left = Math.max(0, x) + 'px';
                state.el.style.top = Math.max(0, y) + 'px';
              } else {
                state.last = [x, y];
              }
            },
            show() { if (state.el) state.el.style.display = 'block'; },
            hide() { if (state.el) state.el.style.display = 'none'; },
          };
          window.__v3Cursor = api;
        }
      } catch {}

      function install() {
        try {
          if (state.el) return; // already installed
          let el = document.getElementById(ID);
          if (!el) {
            const root = document.documentElement || document.body || document.head;
            if (!root) { setTimeout(install, 50); return; }
            el = document.createElement('div');
            el.id = ID;
            el.style.position = 'fixed';
            el.style.left = '0px';
            el.style.top = '0px';
            el.style.width = '16px';
            el.style.height = '24px';
            el.style.zIndex = '2147483647';
            el.style.pointerEvents = 'none';
            el.style.userSelect = 'none';
            el.style.mixBlendMode = 'normal';
            el.style.contain = 'layout style paint';
            el.style.willChange = 'transform,left,top';
            el.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="24" viewBox="0 0 16 24"><path d="M1 0 L1 22 L6 14 L15 14 Z" fill="black" stroke="white" stroke-width="0.7"/></svg>';
            root.appendChild(el);
          }
          state.el = el;
          try { window.__v3Cursor.__installed = true; } catch {}
          if (state.last) {
            window.__v3Cursor.move(state.last[0], state.last[1]);
            state.last = null;
          }
        } catch {}
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        install();
      } else {
        document.addEventListener('DOMContentLoaded', install, { once: true });
        setTimeout(install, 100);
      }
    })();`;
          yield this.mainSession.send("Page.addScriptToEvaluateOnNewDocument", { source: script }).catch(() => {
          });
          yield this.mainSession.send("Runtime.evaluate", {
            expression: script,
            includeCommandLineAPI: false
          }).catch(() => {
          });
        });
      }
      enableCursorOverlay() {
        return __async(this, null, function* () {
          if (this.cursorEnabled) return;
          yield this.ensureCursorScript();
          this.cursorEnabled = true;
        });
      }
      updateCursor(x2, y) {
        return __async(this, null, function* () {
          if (!this.cursorEnabled) return;
          try {
            yield this.mainSession.send("Runtime.evaluate", {
              expression: `typeof window.__v3Cursor!=="undefined"&&window.__v3Cursor.move(${Math.round(x2)}, ${Math.round(y)})`
            });
          } catch (e2) {
          }
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield normalizeInitScriptSource(
            script,
            arg,
            "page.addInitScript"
          );
          yield this.registerInitScript(source);
        });
      }
      /**
       * Factory: create Page and seed registry with the shallow tree from Page.getFrameTree.
       * Assumes Page domain is already enabled on the session passed in.
       */
      static create(conn, session, targetId, apiClient, localBrowserLaunchOptions, browserIsRemote = false) {
        return __async(this, null, function* () {
          var _a4, _b, _c, _d2;
          yield session.send("Page.enable").catch(() => {
          });
          yield session.send("Page.setLifecycleEventsEnabled", { enabled: true }).catch(() => {
          });
          const { frameTree } = yield session.send("Page.getFrameTree");
          const mainFrameId = frameTree.frame.id;
          const page = new _Page(
            conn,
            session,
            targetId,
            mainFrameId,
            apiClient,
            browserIsRemote
          );
          try {
            page._currentUrl = String((_b = (_a4 = frameTree == null ? void 0 : frameTree.frame) == null ? void 0 : _a4.url) != null ? _b : page._currentUrl);
            if (localBrowserLaunchOptions == null ? void 0 : localBrowserLaunchOptions.viewport) {
              yield page.setViewportSize(
                localBrowserLaunchOptions.viewport.width,
                localBrowserLaunchOptions.viewport.height,
                {
                  deviceScaleFactor: (_c = localBrowserLaunchOptions.deviceScaleFactor) != null ? _c : 1
                }
              );
            }
          } catch (e2) {
          }
          page.registry.seedFromFrameTree((_d2 = session.id) != null ? _d2 : "root", frameTree);
          return page;
        });
      }
      // ---------------- Event-driven updates from Context ----------------
      /**
       * Parent/child session emitted a `frameAttached`.
       * Topology update + ownership stamped to **emitting session**.
       */
      onFrameAttached(frameId, parentId, session) {
        var _a4;
        this.ensureOrdinal(frameId);
        this.registry.onFrameAttached(frameId, parentId, (_a4 = session.id) != null ? _a4 : "root");
        this.frameCache.delete(frameId);
      }
      /**
       * Parent/child session emitted a `frameDetached`.
       */
      onFrameDetached(frameId, reason = "remove") {
        this.registry.onFrameDetached(frameId, reason);
        this.frameCache.delete(frameId);
      }
      /**
       * Parent/child session emitted a `frameNavigated`.
       * Topology + ownership update. Handles root swaps.
       */
      onFrameNavigated(frame, session) {
        var _a4, _b, _c;
        const prevRoot = this.mainFrameId();
        this.registry.onFrameNavigated(frame, (_a4 = session.id) != null ? _a4 : "root");
        const newRoot = this.mainFrameId();
        if (newRoot !== prevRoot) {
          const oldOrd = (_b = this.frameOrdinals.get(prevRoot)) != null ? _b : 0;
          this.frameOrdinals.set(newRoot, oldOrd);
          this.mainFrameWrapper = new Frame(
            this.mainSession,
            newRoot,
            this.pageId,
            this.browserIsRemote
          );
        }
        if (frame.id === this.mainFrameId()) {
          try {
            this._currentUrl = String(
              (_c = frame == null ? void 0 : frame.url) != null ? _c : this._currentUrl
            );
          } catch (e2) {
          }
        }
        this.frameCache.delete(frame.id);
      }
      onNavigatedWithinDocument(frameId, url, session) {
        var _a4;
        const normalized = String(url != null ? url : "").trim();
        if (!normalized) return;
        this.registry.onNavigatedWithinDocument(
          frameId,
          normalized,
          (_a4 = session.id) != null ? _a4 : "root"
        );
        if (frameId === this.mainFrameId()) {
          this._currentUrl = normalized;
        }
      }
      /**
       * An OOPIF child session whose **main** frame id equals the parent iframes frameId
       * has been attached; adopt the session into this Page and seed ownership for its subtree.
       */
      adoptOopifSession(childSession, childMainFrameId) {
        var _a4;
        if (childSession.id) this.sessions.set(childSession.id, childSession);
        this.networkManager.trackSession(childSession);
        void this.applyInitScriptsToSession(childSession).catch(() => {
        });
        if (this.consoleListeners.size > 0) {
          this.installConsoleTap(childSession);
        }
        this.registry.adoptChildSession(
          (_a4 = childSession.id) != null ? _a4 : "child",
          childMainFrameId
        );
        this.frameCache.delete(childMainFrameId);
        childSession.on(
          "Page.frameNavigated",
          (evt) => {
            this.onFrameNavigated(evt.frame, childSession);
          }
        );
        childSession.on(
          "Page.frameAttached",
          (evt) => {
            var _a5;
            this.onFrameAttached(
              evt.frameId,
              (_a5 = evt.parentFrameId) != null ? _a5 : null,
              childSession
            );
          }
        );
        childSession.on(
          "Page.frameDetached",
          (evt) => {
            var _a5;
            this.onFrameDetached(evt.frameId, (_a5 = evt.reason) != null ? _a5 : "remove");
          }
        );
        void (() => __async(this, null, function* () {
          var _a5;
          try {
            yield childSession.send("Page.enable").catch(() => {
            });
            let { frameTree } = yield childSession.send(
              "Page.getFrameTree"
            );
            if (frameTree.frame.id !== childMainFrameId) {
              frameTree = __spreadProps(__spreadValues({}, frameTree), {
                frame: __spreadProps(__spreadValues({}, frameTree.frame), { id: childMainFrameId })
              });
            }
            this.registry.seedFromFrameTree((_a5 = childSession.id) != null ? _a5 : "child", frameTree);
          } catch (e2) {
          }
        }))();
      }
      /** Detach an adopted child session and prune its subtree */
      detachOopifSession(sessionId) {
        for (const fid of this.registry.framesForSession(sessionId)) {
          this.registry.onFrameDetached(fid, "remove");
          this.frameCache.delete(fid);
        }
        this.teardownConsoleTap(sessionId);
        this.sessions.delete(sessionId);
        this.networkManager.untrackSession(sessionId);
      }
      // ---------------- Ownership helpers / lookups ----------------
      /** Return the owning CDP session for a frameId (falls back to main session) */
      getSessionForFrame(frameId) {
        var _a4;
        const sid = this.registry.getOwnerSessionId(frameId);
        if (!sid) return this.mainSession;
        return (_a4 = this.sessions.get(sid)) != null ? _a4 : this.mainSession;
      }
      /** Always returns a Frame bound to the owning session */
      frameForId(frameId) {
        const hit = this.frameCache.get(frameId);
        if (hit) return hit;
        const sess = this.getSessionForFrame(frameId);
        const f3 = new Frame(sess, frameId, this.pageId, this.browserIsRemote);
        this.frameCache.set(frameId, f3);
        return f3;
      }
      /** Expose a session by id (used by snapshot to resolve session id -> session) */
      getSessionById(id) {
        return this.sessions.get(id);
      }
      registerSessionForNetwork(session) {
        this.networkManager.trackSession(session);
      }
      unregisterSessionForNetwork(sessionId) {
        this.networkManager.untrackSession(sessionId);
      }
      on(event, listener) {
        if (event !== "console") {
          throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
        }
        const firstListener = this.consoleListeners.size === 0;
        this.consoleListeners.add(listener);
        if (firstListener) {
          this.ensureConsoleTaps();
        }
        return this;
      }
      once(event, listener) {
        if (event !== "console") {
          throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
        }
        const wrapper = (message) => {
          this.off("console", wrapper);
          listener(message);
        };
        return this.on("console", wrapper);
      }
      off(event, listener) {
        if (event !== "console") {
          throw new StagehandInvalidArgumentError(`Unsupported event: ${event}`);
        }
        this.consoleListeners.delete(listener);
        if (this.consoleListeners.size === 0) {
          this.removeAllConsoleTaps();
        }
        return this;
      }
      // ---------------- MAIN APIs ----------------
      targetId() {
        return this._targetId;
      }
      /**
       * Send a CDP command through the main session.
       * Allows external consumers to execute arbitrary Chrome DevTools Protocol commands.
       *
       * @param method - The CDP method name (e.g., "Page.enable", "Runtime.evaluate")
       * @param params - Optional parameters for the CDP command
       * @returns Promise resolving to the typed CDP response
       *
       * @example
       * // Enable the Runtime domain
       * await page.sendCDP("Runtime.enable");
       *
       * @example
       * // Evaluate JavaScript with typed response
       * const result = await page.sendCDP<Protocol.Runtime.EvaluateResponse>(
       *   "Runtime.evaluate",
       *   { expression: "1 + 1" }
       * );
       */
      sendCDP(method, params) {
        return __async(this, null, function* () {
          return this.mainSession.send(method, params);
        });
      }
      /** Seed the cached URL before navigation events converge. */
      seedCurrentUrl(url) {
        if (!url) return;
        try {
          const normalized = String(url).trim();
          if (!normalized) return;
          this._currentUrl = normalized;
        } catch (e2) {
        }
      }
      mainFrameId() {
        return this.registry.mainFrameId();
      }
      mainFrame() {
        return this.mainFrameWrapper;
      }
      close() {
        return __async(this, null, function* () {
          try {
            yield this.conn.send("Target.closeTarget", { targetId: this._targetId });
          } catch (e2) {
          }
          const deadline = Date.now() + 2e3;
          while (Date.now() < deadline) {
            try {
              const targets = yield this.conn.getTargets();
              if (!targets.some((t2) => t2.targetId === this._targetId)) {
                this.networkManager.dispose();
                return;
              }
            } catch (e2) {
            }
            yield new Promise((r2) => setTimeout(r2, 25));
          }
          this.networkManager.dispose();
          this.removeAllConsoleTaps();
          this.consoleListeners.clear();
        });
      }
      getFullFrameTree() {
        return this.asProtocolFrameTree(this.mainFrameId());
      }
      asProtocolFrameTree(rootMainFrameId) {
        return this.registry.asProtocolFrameTree(rootMainFrameId);
      }
      ensureOrdinal(frameId) {
        const hit = this.frameOrdinals.get(frameId);
        if (hit !== void 0) return hit;
        const ord = this.nextOrdinal++;
        this.frameOrdinals.set(frameId, ord);
        return ord;
      }
      /** Public getter for snapshot code / handlers. */
      getOrdinal(frameId) {
        return this.ensureOrdinal(frameId);
      }
      listAllFrameIds() {
        return this.registry.listAllFrames();
      }
      ensureConsoleTaps() {
        if (this.consoleListeners.size === 0) return;
        this.installConsoleTap(this.mainSession);
        for (const session of this.sessions.values()) {
          this.installConsoleTap(session);
        }
      }
      installConsoleTap(session) {
        const key = this.sessionKey(session);
        if (this.consoleHandlers.has(key)) return;
        void session.send("Runtime.enable").catch(() => {
        });
        const handler = (evt) => {
          this.emitConsole(evt);
        };
        session.on(
          "Runtime.consoleAPICalled",
          handler
        );
        this.consoleHandlers.set(key, handler);
      }
      sessionKey(session) {
        var _a4;
        return (_a4 = session.id) != null ? _a4 : "__root__";
      }
      resolveSessionByKey(key) {
        if (this.mainSession.id) {
          if (this.mainSession.id === key) return this.mainSession;
        } else if (key === "__root__") {
          return this.mainSession;
        }
        return this.sessions.get(key);
      }
      teardownConsoleTap(key) {
        const handler = this.consoleHandlers.get(key);
        if (!handler) return;
        const session = this.resolveSessionByKey(key);
        session == null ? void 0 : session.off("Runtime.consoleAPICalled", handler);
        this.consoleHandlers.delete(key);
      }
      removeAllConsoleTaps() {
        for (const key of [...this.consoleHandlers.keys()]) {
          this.teardownConsoleTap(key);
        }
      }
      emitConsole(evt) {
        if (this.consoleListeners.size === 0) return;
        const message = new ConsoleMessage(evt, this);
        const listeners = [...this.consoleListeners];
        for (const listener of listeners) {
          try {
            listener(message);
          } catch (error) {
            v3Logger({
              category: "page",
              message: "Console listener threw",
              level: 2,
              auxiliary: {
                error: { value: String(error), type: "string" },
                type: { value: evt.type, type: "string" }
              }
            });
          }
        }
      }
      goto(url, options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const waitUntil = (_a4 = options == null ? void 0 : options.waitUntil) != null ? _a4 : "domcontentloaded";
          const timeout = (_b = options == null ? void 0 : options.timeoutMs) != null ? _b : 15e3;
          const navigationCommandId = this.beginNavigationCommand();
          const tracker = new NavigationResponseTracker({
            page: this,
            session: this.mainSession,
            navigationCommandId
          });
          const watcher = new LifecycleWatcher({
            page: this,
            mainSession: this.mainSession,
            networkManager: this.networkManager,
            waitUntil,
            timeoutMs: timeout,
            navigationCommandId
          });
          try {
            if (this.apiClient) {
              const result = yield this.apiClient.goto(
                url,
                { waitUntil: options == null ? void 0 : options.waitUntil },
                this.mainFrameId()
              );
              this._currentUrl = url;
              if (isSerializableResponse(result)) {
                return Response2.fromSerializable(result, {
                  page: this,
                  session: this.mainSession
                });
              }
              return result;
            }
            const response = yield this.mainSession.send(
              "Page.navigate",
              { url }
            );
            this._currentUrl = url;
            if (response == null ? void 0 : response.loaderId) {
              watcher.setExpectedLoaderId(response.loaderId);
              tracker.setExpectedLoaderId(response.loaderId);
            }
            yield watcher.wait();
            return yield tracker.navigationCompleted();
          } finally {
            watcher.dispose();
            tracker.dispose();
          }
        });
      }
      reload(options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const waitUntil = options == null ? void 0 : options.waitUntil;
          const timeout = (_a4 = options == null ? void 0 : options.timeoutMs) != null ? _a4 : 15e3;
          const navigationCommandId = this.beginNavigationCommand();
          const tracker = new NavigationResponseTracker({
            page: this,
            session: this.mainSession,
            navigationCommandId
          });
          tracker.expectNavigationWithoutKnownLoader();
          const watcher = waitUntil ? new LifecycleWatcher({
            page: this,
            mainSession: this.mainSession,
            networkManager: this.networkManager,
            waitUntil,
            timeoutMs: timeout,
            navigationCommandId
          }) : null;
          try {
            yield this.mainSession.send("Page.reload", {
              ignoreCache: (_b = options == null ? void 0 : options.ignoreCache) != null ? _b : false
            });
            if (watcher) {
              yield watcher.wait();
            }
            return yield tracker.navigationCompleted();
          } finally {
            watcher == null ? void 0 : watcher.dispose();
            tracker.dispose();
          }
        });
      }
      goBack(options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const { entries, currentIndex } = yield this.mainSession.send(
            "Page.getNavigationHistory"
          );
          const prev = entries[currentIndex - 1];
          if (!prev) return null;
          const waitUntil = options == null ? void 0 : options.waitUntil;
          const timeout = (_a4 = options == null ? void 0 : options.timeoutMs) != null ? _a4 : 15e3;
          const navigationCommandId = this.beginNavigationCommand();
          const tracker = new NavigationResponseTracker({
            page: this,
            session: this.mainSession,
            navigationCommandId
          });
          tracker.expectNavigationWithoutKnownLoader();
          const watcher = waitUntil ? new LifecycleWatcher({
            page: this,
            mainSession: this.mainSession,
            networkManager: this.networkManager,
            waitUntil,
            timeoutMs: timeout,
            navigationCommandId
          }) : null;
          try {
            yield this.mainSession.send("Page.navigateToHistoryEntry", {
              entryId: prev.id
            });
            this._currentUrl = (_b = prev.url) != null ? _b : this._currentUrl;
            if (watcher) {
              yield watcher.wait();
            }
            return yield tracker.navigationCompleted();
          } finally {
            watcher == null ? void 0 : watcher.dispose();
            tracker.dispose();
          }
        });
      }
      goForward(options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const { entries, currentIndex } = yield this.mainSession.send(
            "Page.getNavigationHistory"
          );
          const next = entries[currentIndex + 1];
          if (!next) return null;
          const waitUntil = options == null ? void 0 : options.waitUntil;
          const timeout = (_a4 = options == null ? void 0 : options.timeoutMs) != null ? _a4 : 15e3;
          const navigationCommandId = this.beginNavigationCommand();
          const tracker = new NavigationResponseTracker({
            page: this,
            session: this.mainSession,
            navigationCommandId
          });
          tracker.expectNavigationWithoutKnownLoader();
          const watcher = waitUntil ? new LifecycleWatcher({
            page: this,
            mainSession: this.mainSession,
            networkManager: this.networkManager,
            waitUntil,
            timeoutMs: timeout,
            navigationCommandId
          }) : null;
          try {
            yield this.mainSession.send("Page.navigateToHistoryEntry", {
              entryId: next.id
            });
            this._currentUrl = (_b = next.url) != null ? _b : this._currentUrl;
            if (watcher) {
              yield watcher.wait();
            }
            return yield tracker.navigationCompleted();
          } finally {
            watcher == null ? void 0 : watcher.dispose();
            tracker.dispose();
          }
        });
      }
      /**
       * Return the current page URL (synchronous, cached from navigation events).
       */
      url() {
        return this._currentUrl;
      }
      beginNavigationCommand() {
        const id = ++this.navigationCommandSeq;
        this.latestNavigationCommandId = id;
        return id;
      }
      isCurrentNavigationCommand(id) {
        return this.latestNavigationCommandId === id;
      }
      /**
       * Return the current page title.
       * Prefers reading from the active document via Runtime.evaluate to reflect dynamic changes.
       * Falls back to navigation history title if evaluation is unavailable.
       */
      title() {
        return __async(this, null, function* () {
          var _a4, _b, _c;
          try {
            yield this.mainSession.send("Runtime.enable").catch(() => {
            });
            const ctxId = yield this.mainWorldExecutionContextId();
            const { result } = yield this.mainSession.send(
              "Runtime.evaluate",
              {
                expression: "document.title",
                contextId: ctxId,
                returnByValue: true
              }
            );
            return String((_a4 = result == null ? void 0 : result.value) != null ? _a4 : "");
          } catch (e2) {
            try {
              const { entries, currentIndex } = yield this.mainSession.send(
                "Page.getNavigationHistory"
              );
              return (_c = (_b = entries[currentIndex]) == null ? void 0 : _b.title) != null ? _c : "";
            } catch (e3) {
              return "";
            }
          }
        });
      }
      screenshot(options) {
        return __async(this, null, function* () {
          var _a4, _b, _c, _d2, _e;
          const opts = options != null ? options : {};
          const type = (_a4 = opts.type) != null ? _a4 : "png";
          if (type !== "png" && type !== "jpeg") {
            throw new StagehandInvalidArgumentError(
              `screenshot: unsupported image type "${type}"`
            );
          }
          if (opts.fullPage && opts.clip) {
            throw new StagehandInvalidArgumentError(
              "screenshot: clip and fullPage cannot be used together"
            );
          }
          if (type === "png" && typeof opts.quality === "number") {
            throw new StagehandInvalidArgumentError(
              'screenshot: quality option is only valid for type="jpeg"'
            );
          }
          const caretMode = (_b = opts.caret) != null ? _b : "hide";
          const animationsMode = (_c = opts.animations) != null ? _c : "allow";
          const scaleMode = (_d2 = opts.scale) != null ? _d2 : "device";
          const frames = collectFramesForScreenshot(this);
          const clip = opts.clip ? normalizeScreenshotClip(opts.clip) : void 0;
          const captureScale = yield computeScreenshotScale(this, scaleMode);
          const maskLocators = ((_e = opts.mask) != null ? _e : []).filter(
            (locator) => Boolean(locator)
          );
          const cleanupTasks = [];
          const exec = () => __async(this, null, function* () {
            var _a5;
            try {
              if (opts.omitBackground) {
                cleanupTasks.push(yield setTransparentBackground(this.mainSession));
              }
              if (animationsMode === "disabled") {
                cleanupTasks.push(yield disableAnimations(frames));
              }
              if (caretMode === "hide") {
                cleanupTasks.push(yield hideCaret(frames));
              }
              if (opts.style && opts.style.trim()) {
                cleanupTasks.push(
                  yield applyStyleToFrames(frames, opts.style, "custom")
                );
              }
              if (maskLocators.length > 0) {
                cleanupTasks.push(
                  yield applyMaskOverlays(maskLocators, (_a5 = opts.maskColor) != null ? _a5 : "#FF00FF")
                );
              }
              const buffer = yield this.mainFrameWrapper.screenshot({
                fullPage: opts.fullPage,
                clip,
                type,
                quality: type === "jpeg" ? opts.quality : void 0,
                scale: captureScale
              });
              if (opts.path) {
                yield import_fs7.promises.writeFile(opts.path, buffer);
              }
              return buffer;
            } finally {
              yield runScreenshotCleanups(cleanupTasks);
            }
          });
          return withScreenshotTimeout(opts.timeout, exec);
        });
      }
      /**
       * Create a locator bound to the current main frame.
       */
      locator(selector) {
        return this.mainFrameWrapper.locator(selector);
      }
      /**
       * Deep locator that supports cross-iframe traversal.
       * - Recognizes '>>' hop notation to enter iframe contexts.
       * - Supports deep XPath that includes iframe steps (e.g., '/html/body/iframe[2]//div').
       * Returns a Locator scoped to the appropriate frame.
       */
      deepLocator(selector) {
        return deepLocatorFromPage(this, this.mainFrameWrapper, selector);
      }
      /**
       * Frame locator similar to Playwright: targets iframe elements and scopes
       * subsequent locators to that frame. Supports chaining.
       */
      frameLocator(selector) {
        return new FrameLocator(this, selector);
      }
      /**
       * List all frames belonging to this page as Frame objects bound to their owning sessions.
       * The list is ordered by a stable ordinal assigned during the page lifetime.
       */
      frames() {
        const ids = this.listAllFrameIds();
        const withOrd = ids.map((id) => ({ id, ord: this.getOrdinal(id) }));
        withOrd.sort((a, b) => a.ord - b.ord);
        return withOrd.map(({ id }) => this.frameForId(id));
      }
      waitForLoadState(state, timeoutMs) {
        return __async(this, null, function* () {
          yield this.waitForMainLoadState(state, timeoutMs != null ? timeoutMs : 15e3);
        });
      }
      evaluate(pageFunctionOrExpression, arg) {
        return __async(this, null, function* () {
          var _a4;
          yield this.mainSession.send("Runtime.enable").catch(() => {
          });
          const ctxId = yield this.mainWorldExecutionContextId();
          const isString = typeof pageFunctionOrExpression === "string";
          let expression;
          if (isString) {
            expression = String(pageFunctionOrExpression);
          } else {
            const fnSrc = pageFunctionOrExpression.toString();
            const argJson = JSON.stringify(arg);
            expression = `(() => {
          const __fn = ${fnSrc};
          const __arg = ${argJson};
          try {
            const __res = __fn(__arg);
            return Promise.resolve(__res).then(v => {
              try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
            });
          } catch (e) { throw e; }
        })()`;
          }
          const { result, exceptionDetails } = yield this.mainSession.send(
            "Runtime.evaluate",
            {
              expression,
              contextId: ctxId,
              returnByValue: true,
              awaitPromise: true
            }
          );
          if (exceptionDetails) {
            const msg = exceptionDetails.text || ((_a4 = exceptionDetails.exception) == null ? void 0 : _a4.description) || "Evaluation failed";
            throw new StagehandEvalError(msg);
          }
          return result == null ? void 0 : result.value;
        });
      }
      /**
       * Force the page viewport to an exact CSS size and device scale factor.
       * Ensures screenshots match width x height pixels when deviceScaleFactor = 1.
       */
      // @logAction("Page.setViewportSize")  // disabled because it's pretty noisy, can always re-enable if needed for debugging
      setViewportSize(width, height, options) {
        return __async(this, null, function* () {
          var _a4;
          const dsf = Math.max(0.01, (_a4 = options == null ? void 0 : options.deviceScaleFactor) != null ? _a4 : 1);
          yield this.mainSession.send("Emulation.setDeviceMetricsOverride", {
            width,
            height,
            deviceScaleFactor: dsf,
            mobile: false,
            screenWidth: width,
            screenHeight: height,
            positionX: 0,
            positionY: 0,
            scale: 1
          }).catch(() => {
          });
          yield this.mainSession.send("Emulation.setVisibleSize", { width, height }).catch(() => {
          });
        });
      }
      click(x2, y, options) {
        return __async(this, null, function* () {
          var _a4, _b;
          const button = (_a4 = options == null ? void 0 : options.button) != null ? _a4 : "left";
          const clickCount = (_b = options == null ? void 0 : options.clickCount) != null ? _b : 1;
          let xpathResult;
          if (options == null ? void 0 : options.returnXpath) {
            try {
              const hit = yield resolveXpathForLocation(this, x2, y);
              if (hit) {
                v3Logger({
                  category: "page",
                  message: "click resolved hit",
                  level: 2,
                  auxiliary: {
                    frameId: { value: String(hit.frameId), type: "string" },
                    backendNodeId: {
                      value: String(hit.backendNodeId),
                      type: "string"
                    },
                    x: { value: String(x2), type: "integer" },
                    y: { value: String(y), type: "integer" }
                  }
                });
                xpathResult = hit.absoluteXPath;
                v3Logger({
                  category: "page",
                  message: `click resolved xpath`,
                  level: 2,
                  auxiliary: {
                    xpath: { value: String(xpathResult != null ? xpathResult : ""), type: "string" }
                  }
                });
              }
            } catch (e2) {
            }
          }
          yield this.updateCursor(x2, y);
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            x: x2,
            y,
            button: "none"
          });
          for (let i2 = 1; i2 <= clickCount; i2++) {
            yield this.mainSession.send("Input.dispatchMouseEvent", {
              type: "mousePressed",
              x: x2,
              y,
              button,
              clickCount: i2
            });
            yield this.mainSession.send("Input.dispatchMouseEvent", {
              type: "mouseReleased",
              x: x2,
              y,
              button,
              clickCount: i2
            });
          }
          return xpathResult != null ? xpathResult : "";
        });
      }
      hover(x2, y, options) {
        return __async(this, null, function* () {
          let xpathResult;
          if (options == null ? void 0 : options.returnXpath) {
            try {
              const hit = yield resolveXpathForLocation(this, x2, y);
              if (hit) {
                v3Logger({
                  category: "page",
                  message: "hover resolved hit",
                  level: 2,
                  auxiliary: {
                    frameId: { value: String(hit.frameId), type: "string" },
                    backendNodeId: {
                      value: String(hit.backendNodeId),
                      type: "string"
                    },
                    x: { value: String(x2), type: "integer" },
                    y: { value: String(y), type: "integer" }
                  }
                });
                xpathResult = hit.absoluteXPath;
              }
            } catch (e2) {
              v3Logger({
                category: "page",
                message: "Failed to resolve xpath for hover",
                level: 2,
                auxiliary: {
                  x: { value: String(x2), type: "integer" },
                  y: { value: String(y), type: "integer" }
                }
              });
            }
          }
          yield this.updateCursor(x2, y);
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            x: x2,
            y,
            button: "none"
          });
          return xpathResult != null ? xpathResult : "";
        });
      }
      scroll(x2, y, deltaX, deltaY, options) {
        return __async(this, null, function* () {
          let xpathResult;
          if (options == null ? void 0 : options.returnXpath) {
            try {
              const hit = yield resolveXpathForLocation(this, x2, y);
              if (hit) xpathResult = hit.absoluteXPath;
            } catch (e2) {
            }
          }
          yield this.updateCursor(x2, y);
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            x: x2,
            y,
            button: "none"
          });
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            x: x2,
            y,
            button: "none",
            deltaX,
            deltaY
          });
          return xpathResult != null ? xpathResult : "";
        });
      }
      dragAndDrop(fromX, fromY, toX, toY, options) {
        return __async(this, null, function* () {
          var _a4, _b, _c;
          const button = (_a4 = options == null ? void 0 : options.button) != null ? _a4 : "left";
          const steps = Math.max(1, Math.floor((_b = options == null ? void 0 : options.steps) != null ? _b : 1));
          const delay2 = Math.max(0, (_c = options == null ? void 0 : options.delay) != null ? _c : 0);
          const sleep = (ms) => new Promise((r2) => ms > 0 ? setTimeout(r2, ms) : r2());
          const buttonMask = (b) => {
            switch (b) {
              case "left":
                return 1;
              case "right":
                return 2;
              case "middle":
                return 4;
              default:
                return 1;
            }
          };
          let fromXpath;
          let toXpath;
          if (options == null ? void 0 : options.returnXpath) {
            try {
              const start = yield resolveXpathForLocation(this, fromX, fromY);
              if (start) fromXpath = start.absoluteXPath;
            } catch (e2) {
            }
            try {
              const end = yield resolveXpathForLocation(this, toX, toY);
              if (end) toXpath = end.absoluteXPath;
            } catch (e2) {
            }
          }
          yield this.updateCursor(fromX, fromY);
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            x: fromX,
            y: fromY,
            button: "none"
          });
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            x: fromX,
            y: fromY,
            button,
            buttons: buttonMask(button),
            clickCount: 1
          });
          for (let i2 = 1; i2 <= steps; i2++) {
            const t2 = i2 / steps;
            const x2 = fromX + (toX - fromX) * t2;
            const y = fromY + (toY - fromY) * t2;
            yield this.updateCursor(x2, y);
            yield this.mainSession.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              x: x2,
              y,
              button,
              buttons: buttonMask(button)
            });
            if (delay2) yield sleep(delay2);
          }
          yield this.updateCursor(toX, toY);
          yield this.mainSession.send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            x: toX,
            y: toY,
            button,
            buttons: buttonMask(button),
            clickCount: 1
          });
          return [fromXpath != null ? fromXpath : "", toXpath != null ? toXpath : ""];
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          var _a4;
          const delay2 = Math.max(0, (_a4 = options == null ? void 0 : options.delay) != null ? _a4 : 0);
          const withMistakes = !!(options == null ? void 0 : options.withMistakes);
          const sleep = (ms) => new Promise((r2) => ms > 0 ? setTimeout(r2, ms) : r2());
          const keyStroke = (ch, override) => __async(this, null, function* () {
            if (override) {
              const base = {
                type: "keyDown",
                key: override.key,
                code: override.code,
                windowsVirtualKeyCode: override.windowsVirtualKeyCode
              };
              yield this.mainSession.send("Input.dispatchKeyEvent", base);
              yield this.mainSession.send("Input.dispatchKeyEvent", __spreadProps(__spreadValues({}, base), {
                type: "keyUp"
              }));
              return;
            }
            const isLetter = /^[a-zA-Z]$/.test(ch);
            const isDigit = /^[0-9]$/.test(ch);
            let key = ch;
            let code = "";
            let windowsVirtualKeyCode;
            if (isLetter) {
              key = ch;
              code = `Key${ch.toUpperCase()}`;
              windowsVirtualKeyCode = ch.toUpperCase().charCodeAt(0);
            } else if (isDigit) {
              key = ch;
              code = `Digit${ch}`;
              windowsVirtualKeyCode = ch.charCodeAt(0);
            } else if (ch === " ") {
              key = " ";
              code = "Space";
              windowsVirtualKeyCode = 32;
            }
            const down = {
              type: "keyDown",
              key,
              code: code || void 0,
              text: ch,
              unmodifiedText: ch,
              windowsVirtualKeyCode
            };
            yield this.mainSession.send("Input.dispatchKeyEvent", down);
            yield this.mainSession.send("Input.dispatchKeyEvent", {
              type: "keyUp",
              key,
              code: code || void 0,
              windowsVirtualKeyCode
            });
          });
          const pressBackspace = () => __async(this, null, function* () {
            return keyStroke("\b", {
              key: "Backspace",
              code: "Backspace",
              windowsVirtualKeyCode: 8
            });
          });
          const randomPrintable = (avoid) => {
            const pool = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,;:'\"!?@#$%^&*()-_=+[]{}<>/\\|`~";
            let c = avoid;
            while (c === avoid) {
              c = pool[Math.floor(Math.random() * pool.length)];
            }
            return c;
          };
          for (const ch of text) {
            if (ch === "\n" || ch === "\r") {
              yield keyStroke(ch, {
                key: "Enter",
                code: "Enter",
                windowsVirtualKeyCode: 13
              });
            } else if (ch === "	") {
              yield keyStroke(ch, {
                key: "Tab",
                code: "Tab",
                windowsVirtualKeyCode: 9
              });
            } else {
              if (withMistakes && Math.random() < 0.12) {
                const wrong = randomPrintable(ch);
                yield keyStroke(wrong);
                if (delay2) yield sleep(delay2);
                yield pressBackspace();
                if (delay2) yield sleep(delay2);
              }
              yield keyStroke(ch);
            }
            if (delay2) yield sleep(delay2);
          }
        });
      }
      keyPress(key, options) {
        return __async(this, null, function* () {
          var _a4;
          const delay2 = Math.max(0, (_a4 = options == null ? void 0 : options.delay) != null ? _a4 : 0);
          const sleep = (ms) => new Promise((r2) => ms > 0 ? setTimeout(r2, ms) : r2());
          function split(keyString) {
            if (keyString === "+") {
              return ["+"];
            }
            const keys = [];
            let building = "";
            for (const char of keyString) {
              if (char === "+" && building) {
                keys.push(building);
                building = "";
              } else {
                building += char;
              }
            }
            if (building) {
              keys.push(building);
            }
            return keys;
          }
          const tokens = split(key);
          const mainKey = tokens[tokens.length - 1];
          const modifierKeys = tokens.slice(0, -1);
          try {
            for (const modKey of modifierKeys) {
              yield this.keyDown(modKey);
            }
            yield this.keyDown(mainKey);
            if (delay2) yield sleep(delay2);
            yield this.keyUp(mainKey);
            for (let i2 = modifierKeys.length - 1; i2 >= 0; i2--) {
              yield this.keyUp(modifierKeys[i2]);
            }
          } catch (error) {
            this._pressedModifiers.clear();
            throw error;
          }
        });
      }
      /** Press a key down without releasing it */
      keyDown(key) {
        return __async(this, null, function* () {
          var _a4, _b, _c;
          const normalizedKey = this.normalizeModifierKey(key);
          const modifierKeys = ["Alt", "Control", "Meta", "Shift"];
          if (modifierKeys.includes(normalizedKey)) {
            this._pressedModifiers.add(normalizedKey);
          }
          let modifiers = 0;
          if (this._pressedModifiers.has("Alt")) modifiers |= 1;
          if (this._pressedModifiers.has("Control")) modifiers |= 2;
          if (this._pressedModifiers.has("Meta")) modifiers |= 4;
          if (this._pressedModifiers.has("Shift")) modifiers |= 8;
          const named = this.getNamedKeys();
          if (normalizedKey.length === 1) {
            const hasNonShiftModifier = this._pressedModifiers.has("Alt") || this._pressedModifiers.has("Control") || this._pressedModifiers.has("Meta");
            if (hasNonShiftModifier) {
              const desc = this.describePrintableKey(normalizedKey);
              const macCommands = this.isMacOS() ? this.macCommandsFor((_a4 = desc.code) != null ? _a4 : "") : [];
              const req = __spreadValues(__spreadValues(__spreadValues({
                type: "rawKeyDown",
                modifiers,
                key: desc.key
              }, desc.code ? { code: desc.code } : {}), typeof desc.vk === "number" ? { windowsVirtualKeyCode: desc.vk } : {}), macCommands.length ? { commands: macCommands } : {});
              yield this.mainSession.send("Input.dispatchKeyEvent", req);
            } else {
              yield this.mainSession.send("Input.dispatchKeyEvent", {
                type: "keyDown",
                text: normalizedKey,
                unmodifiedText: normalizedKey,
                modifiers
              });
            }
            return;
          }
          const entry = (_b = named[normalizedKey]) != null ? _b : null;
          if (entry) {
            const macCommands = this.isMacOS() ? this.macCommandsFor(entry.code) : [];
            const includeText = !!entry.text && modifiers === 0;
            const keyDown = __spreadValues(__spreadValues({
              type: includeText ? "keyDown" : "rawKeyDown",
              key: entry.key,
              code: entry.code,
              windowsVirtualKeyCode: entry.vk,
              modifiers
            }, includeText ? {
              text: entry.text,
              unmodifiedText: (_c = entry.unmodifiedText) != null ? _c : entry.text
            } : {}), macCommands.length ? { commands: macCommands } : {});
            yield this.mainSession.send("Input.dispatchKeyEvent", keyDown);
            return;
          }
          yield this.mainSession.send("Input.dispatchKeyEvent", {
            type: "keyDown",
            key: normalizedKey,
            modifiers
          });
        });
      }
      /** Release a pressed key */
      keyUp(key) {
        return __async(this, null, function* () {
          var _a4;
          const normalizedKey = this.normalizeModifierKey(key);
          let modifiers = 0;
          if (this._pressedModifiers.has("Alt")) modifiers |= 1;
          if (this._pressedModifiers.has("Control")) modifiers |= 2;
          if (this._pressedModifiers.has("Meta")) modifiers |= 4;
          if (this._pressedModifiers.has("Shift")) modifiers |= 8;
          const modifierKeys = ["Alt", "Control", "Meta", "Shift"];
          if (modifierKeys.includes(normalizedKey)) {
            this._pressedModifiers.delete(normalizedKey);
          }
          const named = this.getNamedKeys();
          if (normalizedKey.length === 1) {
            const desc = this.describePrintableKey(normalizedKey);
            yield this.mainSession.send("Input.dispatchKeyEvent", {
              type: "keyUp",
              key: desc.key,
              code: desc.code,
              windowsVirtualKeyCode: typeof desc.vk === "number" ? desc.vk : void 0,
              modifiers
            });
            return;
          }
          const entry = (_a4 = named[normalizedKey]) != null ? _a4 : null;
          if (entry) {
            yield this.mainSession.send("Input.dispatchKeyEvent", {
              type: "keyUp",
              key: entry.key,
              code: entry.code,
              windowsVirtualKeyCode: entry.vk,
              modifiers
            });
            return;
          }
          yield this.mainSession.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            key: normalizedKey,
            modifiers
          });
        });
      }
      /** Normalize key names to match CDP expectations */
      normalizeModifierKey(key) {
        const lower2 = key.toLowerCase();
        switch (lower2) {
          // Modifier keys
          case "cmd":
          case "command":
            return this.isMacOS() ? "Meta" : "Control";
          case "win":
          case "windows":
            return "Meta";
          case "ctrl":
          case "control":
            return "Control";
          case "option":
          case "alt":
            return "Alt";
          case "shift":
            return "Shift";
          case "meta":
            return "Meta";
          // Action keys
          case "enter":
          case "return":
            return "Enter";
          case "esc":
          case "escape":
            return "Escape";
          case "backspace":
            return "Backspace";
          case "tab":
            return "Tab";
          case "space":
          case "spacebar":
            return " ";
          case "delete":
          case "del":
            return "Delete";
          // Arrow keys
          case "left":
          case "arrowleft":
            return "ArrowLeft";
          case "right":
          case "arrowright":
            return "ArrowRight";
          case "up":
          case "arrowup":
            return "ArrowUp";
          case "down":
          case "arrowdown":
            return "ArrowDown";
          // Navigation keys
          case "home":
            return "Home";
          case "end":
            return "End";
          case "pageup":
          case "pgup":
            return "PageUp";
          case "pagedown":
          case "pgdn":
            return "PageDown";
          default:
            return key;
        }
      }
      /**
       * Get the map of named keys with their properties
       */
      getNamedKeys() {
        return {
          Enter: {
            key: "Enter",
            code: "Enter",
            vk: 13,
            text: "\r",
            unmodifiedText: "\r"
          },
          Tab: { key: "Tab", code: "Tab", vk: 9 },
          Backspace: { key: "Backspace", code: "Backspace", vk: 8 },
          Escape: { key: "Escape", code: "Escape", vk: 27 },
          Delete: { key: "Delete", code: "Delete", vk: 46 },
          ArrowLeft: { key: "ArrowLeft", code: "ArrowLeft", vk: 37 },
          ArrowUp: { key: "ArrowUp", code: "ArrowUp", vk: 38 },
          ArrowRight: { key: "ArrowRight", code: "ArrowRight", vk: 39 },
          ArrowDown: { key: "ArrowDown", code: "ArrowDown", vk: 40 },
          Home: { key: "Home", code: "Home", vk: 36 },
          End: { key: "End", code: "End", vk: 35 },
          PageUp: { key: "PageUp", code: "PageUp", vk: 33 },
          PageDown: { key: "PageDown", code: "PageDown", vk: 34 },
          // Modifier keys
          Alt: { key: "Alt", code: "AltLeft", vk: 18 },
          Control: { key: "Control", code: "ControlLeft", vk: 17 },
          Meta: { key: "Meta", code: "MetaLeft", vk: 91 },
          Shift: { key: "Shift", code: "ShiftLeft", vk: 16 }
        };
      }
      /**
       * Minimal description for printable keys (letters/digits/space) to provide code and VK.
       * Used when non-Shift modifiers are pressed to avoid sending text while keeping accelerator info.
       */
      describePrintableKey(ch) {
        const shiftDown = this._pressedModifiers.has("Shift");
        const isLetter = /^[a-zA-Z]$/.test(ch);
        const isDigit = /^[0-9]$/.test(ch);
        if (isLetter) {
          const upper = ch.toUpperCase();
          return {
            key: shiftDown ? upper : upper.toLowerCase(),
            code: `Key${upper}`,
            vk: upper.charCodeAt(0)
            // 'A'..'Z' => 65..90
          };
        }
        if (isDigit) {
          return {
            key: ch,
            code: `Digit${ch}`,
            vk: ch.charCodeAt(0)
            // '0'..'9' => 48..57
          };
        }
        if (ch === " ") {
          return { key: " ", code: "Space", vk: 32 };
        }
        return {
          key: shiftDown ? ch.toUpperCase() : ch,
          vk: ch.toUpperCase().charCodeAt(0)
        };
      }
      isMacOS() {
        try {
          return process.platform === "darwin";
        } catch (e2) {
          return false;
        }
      }
      /**
       * Return Chromium mac editing commands (without trailing ':') for a given code like 'KeyA'
       * Only used on macOS to trigger system editing shortcuts (e.g., selectAll, copy, paste...).
       */
      macCommandsFor(code) {
        if (!this.isMacOS()) return [];
        const parts = [];
        if (this._pressedModifiers.has("Shift")) parts.push("Shift");
        if (this._pressedModifiers.has("Control")) parts.push("Control");
        if (this._pressedModifiers.has("Alt")) parts.push("Alt");
        if (this._pressedModifiers.has("Meta")) parts.push("Meta");
        parts.push(code);
        const shortcut = parts.join("+");
        const table = {
          "Meta+KeyA": "selectAll:",
          "Meta+KeyC": "copy:",
          "Meta+KeyX": "cut:",
          "Meta+KeyV": "paste:",
          "Meta+KeyZ": "undo:"
        };
        const value = table[shortcut];
        if (!value) return [];
        const list = Array.isArray(value) ? value : [value];
        return list.filter((c) => !c.startsWith("insert")).map((c) => c.substring(0, c.length - 1));
      }
      // ---- Page-level lifecycle waiter that follows main frame id swaps ----
      /** Resolve the main-world execution context for the current main frame. */
      mainWorldExecutionContextId() {
        return __async(this, null, function* () {
          return executionContexts.waitForMainWorld(
            this.mainSession,
            this.mainFrameId(),
            1e3
          );
        });
      }
      /**
       * Wait until the **current** main frame reaches a lifecycle state.
       * - Fast path via `document.readyState`.
       * - Event path listens at the session level and compares incoming `frameId`
       *   to `mainFrameId()` **at event time** to follow root swaps.
       */
      waitForMainLoadState(state, timeoutMs = 15e3) {
        return __async(this, null, function* () {
          var _a4;
          yield this.mainSession.send("Page.setLifecycleEventsEnabled", { enabled: true }).catch(() => {
          });
          try {
            const ctxId = yield this.mainWorldExecutionContextId();
            const { result } = yield this.mainSession.send(
              "Runtime.evaluate",
              {
                expression: "document.readyState",
                contextId: ctxId,
                returnByValue: true
              }
            );
            const rs = String((_a4 = result == null ? void 0 : result.value) != null ? _a4 : "");
            if (state === "domcontentloaded" && (rs === "interactive" || rs === "complete") || state === "load" && rs === "complete") {
              return;
            }
          } catch (e2) {
          }
          const wanted = LIFECYCLE_NAME[state];
          return new Promise((resolve3, reject) => {
            let done = false;
            let timer = null;
            const off = () => {
              this.mainSession.off("Page.lifecycleEvent", onLifecycle);
              this.mainSession.off("Page.domContentEventFired", onDomContent);
              this.mainSession.off("Page.loadEventFired", onLoad);
            };
            const finish = () => {
              if (done) return;
              done = true;
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              off();
              resolve3();
            };
            const onLifecycle = (evt) => {
              if (evt.name !== wanted) return;
              if (evt.frameId === this.mainFrameId()) finish();
            };
            const onDomContent = () => {
              if (state === "domcontentloaded") finish();
            };
            const onLoad = () => {
              if (state === "load") finish();
            };
            this.mainSession.on("Page.lifecycleEvent", onLifecycle);
            this.mainSession.on("Page.domContentEventFired", onDomContent);
            this.mainSession.on("Page.loadEventFired", onLoad);
            timer = setTimeout(() => {
              if (done) return;
              done = true;
              off();
              reject(
                new Error(
                  `waitForMainLoadState(${state}) timed out after ${timeoutMs}ms`
                )
              );
            }, timeoutMs);
          });
        });
      }
    };
    _init = __decoratorStart(null);
    __decorateElement(_init, 1, "close", _close_dec, _Page);
    __decorateElement(_init, 1, "goto", _goto_dec, _Page);
    __decorateElement(_init, 1, "reload", _reload_dec, _Page);
    __decorateElement(_init, 1, "goBack", _goBack_dec, _Page);
    __decorateElement(_init, 1, "goForward", _goForward_dec, _Page);
    __decorateElement(_init, 1, "screenshot", _screenshot_dec, _Page);
    __decorateElement(_init, 1, "waitForLoadState", _waitForLoadState_dec, _Page);
    __decorateElement(_init, 1, "evaluate", _evaluate_dec, _Page);
    __decorateElement(_init, 1, "click", _click_dec, _Page);
    __decorateElement(_init, 1, "hover", _hover_dec, _Page);
    __decorateElement(_init, 1, "scroll", _scroll_dec, _Page);
    __decorateElement(_init, 1, "dragAndDrop", _dragAndDrop_dec, _Page);
    __decorateElement(_init, 1, "type", _type_dec, _Page);
    __decorateElement(_init, 1, "keyPress", _keyPress_dec, _Page);
    __decoratorMetadata(_init, _Page);
    Page = _Page;
  }
});

// lib/v3/index.ts
var v3_exports = {};
__export(v3_exports, {
  AISdkClient: () => AISdkClient2,
  AVAILABLE_CUA_MODELS: () => AVAILABLE_CUA_MODELS,
  ActTimeoutError: () => ActTimeoutError,
  AgentAbortError: () => AgentAbortError,
  AgentProvider: () => AgentProvider,
  AgentScreenshotProviderError: () => AgentScreenshotProviderError,
  AnnotatedScreenshotText: () => AnnotatedScreenshotText,
  Api: () => api_exports,
  BrowserbaseSessionNotFoundError: () => BrowserbaseSessionNotFoundError,
  CaptchaTimeoutError: () => CaptchaTimeoutError,
  ConnectionTimeoutError: () => ConnectionTimeoutError,
  ConsoleMessage: () => ConsoleMessage,
  ContentFrameNotFoundError: () => ContentFrameNotFoundError,
  CreateChatCompletionResponseError: () => CreateChatCompletionResponseError,
  CuaModelRequiredError: () => CuaModelRequiredError,
  ElementNotVisibleError: () => ElementNotVisibleError,
  ExperimentalApiConflictError: () => ExperimentalApiConflictError,
  ExperimentalNotConfiguredError: () => ExperimentalNotConfiguredError,
  ExtractTimeoutError: () => ExtractTimeoutError,
  HandlerNotInitializedError: () => HandlerNotInitializedError,
  InvalidAISDKModelFormatError: () => InvalidAISDKModelFormatError,
  LLMClient: () => LLMClient,
  LLMResponseError: () => LLMResponseError,
  LOG_LEVEL_NAMES: () => LOG_LEVEL_NAMES,
  MCPConnectionError: () => MCPConnectionError,
  MissingEnvironmentVariableError: () => MissingEnvironmentVariableError,
  MissingLLMConfigurationError: () => MissingLLMConfigurationError,
  ObserveTimeoutError: () => ObserveTimeoutError,
  PageNotFoundError: () => PageNotFoundError,
  Response: () => Response2,
  ResponseBodyError: () => ResponseBodyError,
  ResponseParseError: () => ResponseParseError,
  Stagehand: () => V3,
  StagehandAPIError: () => StagehandAPIError,
  StagehandAPIUnauthorizedError: () => StagehandAPIUnauthorizedError,
  StagehandClickError: () => StagehandClickError,
  StagehandClosedError: () => StagehandClosedError,
  StagehandDefaultError: () => StagehandDefaultError,
  StagehandDomProcessError: () => StagehandDomProcessError,
  StagehandElementNotFoundError: () => StagehandElementNotFoundError,
  StagehandEnvironmentError: () => StagehandEnvironmentError,
  StagehandError: () => StagehandError,
  StagehandEvalError: () => StagehandEvalError,
  StagehandHttpError: () => StagehandHttpError,
  StagehandIframeError: () => StagehandIframeError,
  StagehandInitError: () => StagehandInitError,
  StagehandInvalidArgumentError: () => StagehandInvalidArgumentError,
  StagehandMissingArgumentError: () => StagehandMissingArgumentError,
  StagehandNotInitializedError: () => StagehandNotInitializedError,
  StagehandResponseBodyError: () => StagehandResponseBodyError,
  StagehandResponseParseError: () => StagehandResponseParseError,
  StagehandServerError: () => StagehandServerError,
  StagehandShadowRootMissingError: () => StagehandShadowRootMissingError,
  StagehandShadowSegmentEmptyError: () => StagehandShadowSegmentEmptyError,
  StagehandShadowSegmentNotFoundError: () => StagehandShadowSegmentNotFoundError,
  StreamingCallbacksInNonStreamingModeError: () => StreamingCallbacksInNonStreamingModeError,
  TimeoutError: () => TimeoutError,
  UnsupportedAISDKModelProviderError: () => UnsupportedAISDKModelProviderError,
  UnsupportedModelError: () => UnsupportedModelError,
  UnsupportedModelProviderError: () => UnsupportedModelProviderError,
  V3: () => V3,
  V3Evaluator: () => V3Evaluator,
  V3FunctionName: () => V3FunctionName,
  XPathResolutionError: () => XPathResolutionError,
  ZodSchemaValidationError: () => ZodSchemaValidationError,
  connectToMCPServer: () => connectToMCPServer,
  defaultExtractSchema: () => defaultExtractSchema,
  getZodType: () => getZodType,
  injectUrls: () => injectUrls,
  isRunningInBun: () => isRunningInBun,
  isZod3Schema: () => isZod3Schema,
  isZod4Schema: () => isZod4Schema,
  jsonSchemaToZod: () => jsonSchemaToZod,
  loadApiKeyFromEnv: () => loadApiKeyFromEnv,
  localBrowserLaunchOptionsSchema: () => localBrowserLaunchOptionsSchema,
  modelToAgentProviderMap: () => modelToAgentProviderMap,
  pageTextSchema: () => pageTextSchema,
  providerEnvVarMap: () => providerEnvVarMap,
  toGeminiSchema: () => toGeminiSchema,
  toJsonSchema: () => toJsonSchema,
  transformSchema: () => transformSchema,
  trimTrailingTextNode: () => trimTrailingTextNode,
  validateZodSchema: () => validateZodSchema
});
module.exports = __toCommonJS(v3_exports);

// lib/v3/v3.ts
var import_dotenv = __toESM(require("dotenv"));
var import_events2 = require("events");
var import_fs8 = __toESM(require("fs"));
var import_os2 = __toESM(require("os"));
var import_path6 = __toESM(require("path"));
var import_process2 = __toESM(require("process"));
var import_uuid6 = require("uuid");

// lib/v3/zodCompat.ts
var import_zod = require("zod");
var import_zod_to_json_schema = __toESM(require("zod-to-json-schema"));
var isZod4Schema = (schema) => typeof schema._zod !== "undefined";
var isZod3Schema = (schema) => !isZod4Schema(schema);
function toJsonSchema(schema) {
  if (!isZod4Schema(schema)) {
    return (0, import_zod_to_json_schema.default)(schema);
  }
  const zodWithJsonSchema = import_zod.z;
  if (zodWithJsonSchema.toJSONSchema) {
    return zodWithJsonSchema.toJSONSchema(schema);
  }
  throw new Error("Zod v4 toJSONSchema method not found");
}

// lib/utils.ts
init_sdkErrors();
var import_genai = require("@google/genai");
var import_zod2 = require("zod");
var import_v3 = __toESM(require("zod/v3"));
var ID_PATTERN = /^\d+-\d+$/;
var zFactories = {
  v4: import_zod2.z,
  v3: import_v3.default
};
function getZFactory(schema) {
  return isZod4Schema(schema) ? zFactories.v4 : zFactories.v3;
}
var TYPE_NAME_MAP = {
  ZodString: "string",
  string: "string",
  ZodNumber: "number",
  number: "number",
  ZodBoolean: "boolean",
  boolean: "boolean",
  ZodObject: "object",
  object: "object",
  ZodArray: "array",
  array: "array",
  ZodUnion: "union",
  union: "union",
  ZodIntersection: "intersection",
  intersection: "intersection",
  ZodOptional: "optional",
  optional: "optional",
  ZodNullable: "nullable",
  nullable: "nullable",
  ZodLiteral: "literal",
  literal: "literal",
  ZodEnum: "enum",
  enum: "enum",
  ZodDefault: "default",
  default: "default",
  ZodEffects: "effects",
  effects: "effects",
  pipe: "pipe"
};
function getZ4Def(schema) {
  var _a4;
  return (_a4 = schema._zod) == null ? void 0 : _a4.def;
}
function getZ4Bag(schema) {
  var _a4;
  return (_a4 = schema._zod) == null ? void 0 : _a4.bag;
}
function getZ3Def(schema) {
  return schema._def;
}
function getObjectShape(schema) {
  var _a4, _b;
  const z4Shape = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.shape;
  if (z4Shape) {
    return z4Shape;
  }
  const z3Shape = (_b = getZ3Def(schema)) == null ? void 0 : _b.shape;
  if (!z3Shape) {
    return void 0;
  }
  if (typeof z3Shape === "function") {
    return z3Shape();
  }
  return z3Shape;
}
function getArrayElement(schema) {
  var _a4, _b, _c;
  return (_c = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.element) != null ? _c : (_b = getZ3Def(schema)) == null ? void 0 : _b.type;
}
function getInnerType(schema) {
  var _a4, _b, _c;
  return (_c = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.innerType) != null ? _c : (_b = getZ3Def(schema)) == null ? void 0 : _b.innerType;
}
function getUnionOptions(schema) {
  var _a4, _b;
  const z4Options = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.options;
  if (Array.isArray(z4Options)) {
    return z4Options;
  }
  const z3Options = (_b = getZ3Def(schema)) == null ? void 0 : _b.options;
  return Array.isArray(z3Options) ? z3Options : void 0;
}
function getIntersectionSides(schema) {
  const z4Def = getZ4Def(schema);
  if ((z4Def == null ? void 0 : z4Def.left) || (z4Def == null ? void 0 : z4Def.right)) {
    return {
      left: z4Def == null ? void 0 : z4Def.left,
      right: z4Def == null ? void 0 : z4Def.right
    };
  }
  const z3Def = getZ3Def(schema);
  return {
    left: z3Def == null ? void 0 : z3Def.left,
    right: z3Def == null ? void 0 : z3Def.right
  };
}
function getEnumValues(schema) {
  var _a4, _b;
  const z4Entries = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.entries;
  if (z4Entries && typeof z4Entries === "object") {
    return Object.values(z4Entries);
  }
  const z3Values = (_b = getZ3Def(schema)) == null ? void 0 : _b.values;
  return Array.isArray(z3Values) ? z3Values : void 0;
}
function getLiteralValues(schema) {
  var _a4, _b;
  const z4Values = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.values;
  if (Array.isArray(z4Values)) {
    return z4Values;
  }
  const value = (_b = getZ3Def(schema)) == null ? void 0 : _b.value;
  return typeof value !== "undefined" ? [value] : [];
}
function getStringChecks(schema) {
  var _a4, _b;
  const z4Checks = (_a4 = getZ4Def(schema)) == null ? void 0 : _a4.checks;
  if (Array.isArray(z4Checks)) {
    return z4Checks;
  }
  const z3Checks = (_b = getZ3Def(schema)) == null ? void 0 : _b.checks;
  return Array.isArray(z3Checks) ? z3Checks : [];
}
function getStringFormat(schema) {
  var _a4, _b, _c;
  const bagFormat = (_a4 = getZ4Bag(schema)) == null ? void 0 : _a4.format;
  if (typeof bagFormat === "string") {
    return bagFormat;
  }
  const z4Format = (_b = getZ4Def(schema)) == null ? void 0 : _b.format;
  if (typeof z4Format === "string") {
    return z4Format;
  }
  const z3Format = (_c = getZ3Def(schema)) == null ? void 0 : _c.format;
  return typeof z3Format === "string" ? z3Format : void 0;
}
function getPipeEndpoints(schema) {
  const z4Def = getZ4Def(schema);
  if ((z4Def == null ? void 0 : z4Def.in) || (z4Def == null ? void 0 : z4Def.out)) {
    return {
      in: z4Def == null ? void 0 : z4Def.in,
      out: z4Def == null ? void 0 : z4Def.out
    };
  }
  return {};
}
function getEffectsBaseSchema(schema) {
  var _a4;
  return (_a4 = getZ3Def(schema)) == null ? void 0 : _a4.schema;
}
function validateZodSchema(schema, data) {
  const result = schema.safeParse(data);
  if (result.success) {
    return true;
  }
  throw new ZodSchemaValidationError(data, result.error.format());
}
function isRunningInBun() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && "bun" in process.versions;
}
function decorateGeminiSchema(geminiSchema, zodSchema3) {
  if (geminiSchema.nullable === void 0) {
    geminiSchema.nullable = zodSchema3.isOptional();
  }
  if (zodSchema3.description) {
    geminiSchema.description = zodSchema3.description;
  }
  return geminiSchema;
}
function toGeminiSchema(zodSchema3) {
  var _a4, _b;
  const normalizedSchema = zodSchema3;
  const zodType = getZodType(zodSchema3);
  switch (zodType) {
    case "array": {
      const element = (_a4 = getArrayElement(zodSchema3)) != null ? _a4 : import_zod2.z.any();
      return decorateGeminiSchema(
        {
          type: import_genai.Type.ARRAY,
          items: toGeminiSchema(element)
        },
        normalizedSchema
      );
    }
    case "object": {
      const properties = {};
      const required = [];
      const shape = getObjectShape(zodSchema3);
      if (shape) {
        Object.entries(shape).forEach(
          ([key, value]) => {
            properties[key] = toGeminiSchema(value);
            if (getZodType(value) !== "optional") {
              required.push(key);
            }
          }
        );
      }
      return decorateGeminiSchema(
        {
          type: import_genai.Type.OBJECT,
          properties,
          required: required.length > 0 ? required : void 0
        },
        normalizedSchema
      );
    }
    case "string":
      return decorateGeminiSchema(
        {
          type: import_genai.Type.STRING
        },
        normalizedSchema
      );
    case "number":
      return decorateGeminiSchema(
        {
          type: import_genai.Type.NUMBER
        },
        normalizedSchema
      );
    case "boolean":
      return decorateGeminiSchema(
        {
          type: import_genai.Type.BOOLEAN
        },
        normalizedSchema
      );
    case "enum": {
      const values = getEnumValues(zodSchema3);
      return decorateGeminiSchema(
        {
          type: import_genai.Type.STRING,
          enum: values
        },
        normalizedSchema
      );
    }
    case "default":
    case "nullable":
    case "optional": {
      const innerType = (_b = getInnerType(zodSchema3)) != null ? _b : import_zod2.z.any();
      const innerSchema = toGeminiSchema(innerType);
      return decorateGeminiSchema(
        __spreadProps(__spreadValues({}, innerSchema), {
          nullable: true
        }),
        normalizedSchema
      );
    }
    case "literal": {
      const values = getLiteralValues(zodSchema3);
      return decorateGeminiSchema(
        {
          type: import_genai.Type.STRING,
          enum: values
        },
        normalizedSchema
      );
    }
    case "pipe": {
      const endpoints = getPipeEndpoints(zodSchema3);
      if (endpoints.in) {
        return toGeminiSchema(endpoints.in);
      }
      return decorateGeminiSchema(
        {
          type: import_genai.Type.STRING
        },
        normalizedSchema
      );
    }
    // Standalone transforms and any unknown types fall through to default
    default:
      return decorateGeminiSchema(
        {
          type: import_genai.Type.STRING
        },
        normalizedSchema
      );
  }
}
function getZodType(schema) {
  var _a4, _b, _c, _d2, _e, _f, _g;
  const schemaWithDef = schema;
  const rawType = (_f = (_d2 = (_b = (_a4 = schemaWithDef._zod) == null ? void 0 : _a4.def) == null ? void 0 : _b.type) != null ? _d2 : (_c = schemaWithDef._def) == null ? void 0 : _c.typeName) != null ? _f : (_e = schemaWithDef._def) == null ? void 0 : _e.type;
  if (!rawType) {
    return "unknown";
  }
  return (_g = TYPE_NAME_MAP[rawType]) != null ? _g : rawType;
}
function transformSchema(schema, currentPath) {
  if (isKind(schema, "string")) {
    const checks = getStringChecks(schema);
    const format = getStringFormat(schema);
    const hasUrlCheck = checks.some((check) => {
      var _a4, _b, _c, _d2;
      const candidate = check;
      return candidate.kind === "url" || candidate.format === "url" || ((_b = (_a4 = candidate._zod) == null ? void 0 : _a4.def) == null ? void 0 : _b.check) === "url" || ((_d2 = (_c = candidate._zod) == null ? void 0 : _c.def) == null ? void 0 : _d2.format) === "url";
    }) || format === "url";
    if (hasUrlCheck) {
      return [makeIdStringSchema(schema), [{ segments: [] }]];
    }
    return [schema, []];
  }
  if (isKind(schema, "object")) {
    const shape = getObjectShape(schema);
    if (!shape) {
      return [schema, []];
    }
    const newShape = {};
    const urlPaths = [];
    let changed = false;
    for (const key of Object.keys(shape)) {
      const child = shape[key];
      const [transformedChild, childPaths] = transformSchema(child, [
        ...currentPath,
        key
      ]);
      if (transformedChild !== child) {
        changed = true;
      }
      newShape[key] = transformedChild;
      childPaths.forEach((cp) => {
        urlPaths.push({ segments: [key, ...cp.segments] });
      });
    }
    if (changed) {
      const factory6 = getZFactory(schema);
      return [
        factory6.object(newShape),
        urlPaths
      ];
    }
    return [schema, urlPaths];
  }
  if (isKind(schema, "array")) {
    const itemType = getArrayElement(schema);
    if (!itemType) {
      return [schema, []];
    }
    const [transformedItem, childPaths] = transformSchema(itemType, [
      ...currentPath,
      "*"
    ]);
    const arrayPaths = childPaths.map((cp) => ({
      segments: ["*", ...cp.segments]
    }));
    if (transformedItem !== itemType) {
      const factory6 = getZFactory(schema);
      return [
        factory6.array(transformedItem),
        arrayPaths
      ];
    }
    return [schema, arrayPaths];
  }
  if (isKind(schema, "union")) {
    const unionOptions = getUnionOptions(schema);
    if (!unionOptions || unionOptions.length === 0) {
      return [schema, []];
    }
    const newOptions = [];
    let changed = false;
    let allPaths = [];
    unionOptions.forEach((option, idx) => {
      const [newOption, childPaths] = transformSchema(option, [
        ...currentPath,
        `union_${idx}`
      ]);
      if (newOption !== option) {
        changed = true;
      }
      newOptions.push(newOption);
      allPaths = [...allPaths, ...childPaths];
    });
    if (changed) {
      const factory6 = getZFactory(schema);
      return [
        factory6.union(
          newOptions
        ),
        allPaths
      ];
    }
    return [schema, allPaths];
  }
  if (isKind(schema, "intersection")) {
    const { left, right } = getIntersectionSides(schema);
    if (!left || !right) {
      return [schema, []];
    }
    const [newLeft, leftPaths] = transformSchema(left, [
      ...currentPath,
      "intersection_left"
    ]);
    const [newRight, rightPaths] = transformSchema(right, [
      ...currentPath,
      "intersection_right"
    ]);
    const changed = newLeft !== left || newRight !== right;
    const allPaths = [...leftPaths, ...rightPaths];
    if (changed) {
      const factory6 = getZFactory(schema);
      return [
        factory6.intersection(
          newLeft,
          newRight
        ),
        allPaths
      ];
    }
    return [schema, allPaths];
  }
  if (isKind(schema, "optional")) {
    const innerType = getInnerType(schema);
    if (!innerType) {
      return [schema, []];
    }
    const [inner, innerPaths] = transformSchema(innerType, currentPath);
    if (inner !== innerType) {
      return [
        inner.optional(),
        innerPaths
      ];
    }
    return [schema, innerPaths];
  }
  if (isKind(schema, "nullable")) {
    const innerType = getInnerType(schema);
    if (!innerType) {
      return [schema, []];
    }
    const [inner, innerPaths] = transformSchema(innerType, currentPath);
    if (inner !== innerType) {
      return [
        inner.nullable(),
        innerPaths
      ];
    }
    return [schema, innerPaths];
  }
  if (isKind(schema, "pipe") && isZod4Schema(schema)) {
    const { in: inSchema, out: outSchema } = getPipeEndpoints(schema);
    if (!inSchema || !outSchema) {
      return [schema, []];
    }
    const [newIn, inPaths] = transformSchema(inSchema, currentPath);
    const [newOut, outPaths] = transformSchema(outSchema, currentPath);
    const allPaths = [...inPaths, ...outPaths];
    if (newIn !== inSchema || newOut !== outSchema) {
      const result = import_zod2.z.pipe(
        newIn,
        newOut
      );
      return [result, allPaths];
    }
    return [schema, allPaths];
  }
  if (isKind(schema, "effects")) {
    const baseSchema = getEffectsBaseSchema(schema);
    if (!baseSchema) {
      return [schema, []];
    }
    return transformSchema(baseSchema, currentPath);
  }
  return [schema, []];
}
function injectUrls(obj, path8, idToUrlMapping) {
  var _a4, _b;
  if (path8.length === 0) return;
  const toId = (value) => {
    if (typeof value === "number") {
      return String(value);
    }
    if (typeof value === "string" && ID_PATTERN.test(value)) {
      return value;
    }
    return void 0;
  };
  const [key, ...rest] = path8;
  if (key === "*") {
    if (Array.isArray(obj)) {
      if (rest.length === 0) {
        for (let i2 = 0; i2 < obj.length; i2 += 1) {
          const id = toId(obj[i2]);
          if (id !== void 0) {
            obj[i2] = (_a4 = idToUrlMapping[id]) != null ? _a4 : "";
          }
        }
      } else {
        for (const item of obj) injectUrls(item, rest, idToUrlMapping);
      }
    }
    return;
  }
  if (obj && typeof obj === "object") {
    const record = obj;
    if (path8.length === 1) {
      const fieldValue = record[key];
      const id = toId(fieldValue);
      if (id !== void 0) {
        record[key] = (_b = idToUrlMapping[id]) != null ? _b : "";
      }
    } else {
      injectUrls(record[key], rest, idToUrlMapping);
    }
  }
}
function isKind(s2, kind) {
  try {
    return getZodType(s2) === kind;
  } catch (e2) {
    return false;
  }
}
function makeIdStringSchema(orig) {
  var _a4;
  const userDesc = (_a4 = orig.description) != null ? _a4 : "";
  const base = `This field must be the element-ID in the form 'frameId-backendId' (e.g. "0-432").`;
  const composed = userDesc.trim().length > 0 ? `${base} that follows this user-defined description: ${userDesc}` : base;
  const factory6 = getZFactory(orig);
  return factory6.string().regex(ID_PATTERN).describe(composed);
}
var providerEnvVarMap = {
  openai: "OPENAI_API_KEY",
  anthropic: "ANTHROPIC_API_KEY",
  google: ["GEMINI_API_KEY", "GOOGLE_GENERATIVE_AI_API_KEY", "GOOGLE_API_KEY"],
  vertex: "GOOGLE_VERTEX_AI_API_KEY",
  groq: "GROQ_API_KEY",
  cerebras: "CEREBRAS_API_KEY",
  togetherai: "TOGETHER_AI_API_KEY",
  mistral: "MISTRAL_API_KEY",
  deepseek: "DEEPSEEK_API_KEY",
  perplexity: "PERPLEXITY_API_KEY",
  azure: "AZURE_API_KEY",
  xai: "XAI_API_KEY",
  google_legacy: "GOOGLE_API_KEY"
};
function loadApiKeyFromEnv(provider, logger) {
  if (!provider) {
    return void 0;
  }
  const envVarName = providerEnvVarMap[provider];
  if (!envVarName) {
    logger({
      category: "init",
      message: `No known environment variable for provider '${provider}'`,
      level: 0
    });
    return void 0;
  }
  const apiKeyFromEnv = Array.isArray(envVarName) ? envVarName.map((name) => process.env[name]).find((key) => key && key.length > 0) : process.env[envVarName];
  if (typeof apiKeyFromEnv === "string" && apiKeyFromEnv.length > 0) {
    return apiKeyFromEnv;
  }
  return void 0;
}
function trimTrailingTextNode(path8) {
  return path8 == null ? void 0 : path8.replace(/\/text\(\)(\[\d+\])?$/iu, "");
}
function jsonSchemaToZod(schema) {
  switch (schema.type) {
    case "object":
      if (schema.properties) {
        const shape = {};
        for (const key in schema.properties) {
          shape[key] = jsonSchemaToZod(schema.properties[key]);
        }
        let zodObject = import_zod2.z.object(shape);
        if (schema.required && Array.isArray(schema.required)) {
          const requiredFields = schema.required.reduce(
            (acc, field) => __spreadProps(__spreadValues({}, acc), { [field]: true }),
            {}
          );
          zodObject = zodObject.partial().required(requiredFields);
        }
        if (schema.description) {
          zodObject = zodObject.describe(schema.description);
        }
        return zodObject;
      } else {
        return import_zod2.z.object({});
      }
    case "array":
      if (schema.items) {
        let zodArray = import_zod2.z.array(jsonSchemaToZod(schema.items));
        if (schema.description) {
          zodArray = zodArray.describe(schema.description);
        }
        return zodArray;
      } else {
        return import_zod2.z.array(import_zod2.z.any());
      }
    case "string": {
      if (schema.enum) {
        return import_zod2.z.string().refine((val) => schema.enum.includes(val));
      }
      let zodString = import_zod2.z.string();
      if (schema.format === "uri" || schema.format === "url") {
        zodString = zodString.url();
      } else if (schema.format === "email") {
        zodString = zodString.email();
      } else if (schema.format === "uuid") {
        zodString = zodString.uuid();
      }
      if (schema.description) {
        zodString = zodString.describe(schema.description);
      }
      return zodString;
    }
    case "number": {
      let zodNumber = import_zod2.z.number();
      if (schema.minimum !== void 0) {
        zodNumber = zodNumber.min(schema.minimum);
      }
      if (schema.maximum !== void 0) {
        zodNumber = zodNumber.max(schema.maximum);
      }
      if (schema.description) {
        zodNumber = zodNumber.describe(schema.description);
      }
      return zodNumber;
    }
    case "boolean": {
      let zodBoolean = import_zod2.z.boolean();
      if (schema.description) {
        zodBoolean = zodBoolean.describe(schema.description);
      }
      return zodBoolean;
    }
    default:
      return import_zod2.z.any();
  }
}

// lib/logger.ts
var import_pino = __toESM(require("pino"));
var levelMapping = {
  0: "error",
  // Critical/important messages
  1: "info",
  // Standard information
  2: "debug"
  // Detailed debugging information
};
function createLogger(options = {}) {
  const loggerConfig = {
    level: options.level || "info",
    base: void 0,
    // Don't include pid and hostname
    browser: {
      asObject: true
    },
    // Disable worker threads to avoid issues in tests
    transport: void 0
  };
  if (options.pretty && !isTestEnvironment()) {
    try {
      const transport = {
        transport: {
          target: "pino-pretty",
          options: {
            colorize: true,
            translateTime: "SYS:standard",
            ignore: "pid,hostname"
          }
        }
      };
      Object.assign(loggerConfig, transport);
    } catch (e2) {
      console.warn(
        "pino-pretty not available, falling back to standard logging"
      );
    }
  }
  return (0, import_pino.default)(loggerConfig, options.destination);
}
function isTestEnvironment() {
  return process.env.NODE_ENV === "test" || process.env.JEST_WORKER_ID !== void 0 || process.env.PLAYWRIGHT_TEST_BASE_DIR !== void 0 || // Check if we're in a CI environment
  process.env.CI === "true";
}
var _StagehandLogger = class _StagehandLogger {
  constructor(options = {}, externalLogger) {
    this.isTest = isTestEnvironment();
    this.externalLogger = externalLogger;
    const externalProvided = typeof externalLogger === "function";
    const explicitUsePino = options.usePino;
    if (this.isTest) {
      this.usePino = false;
    } else if (explicitUsePino === true) {
      this.usePino = true;
    } else if (explicitUsePino === false) {
      this.usePino = false;
    } else {
      this.usePino = !externalProvided;
    }
    if (this.usePino) {
      if (!_StagehandLogger.sharedPinoLogger) {
        _StagehandLogger.sharedPinoLogger = createLogger(options);
      }
      this.logger = _StagehandLogger.sharedPinoLogger;
    }
    this.verbose = 1;
  }
  /**
   * Set the verbosity level
   */
  setVerbosity(level) {
    this.verbose = level;
    if (this.usePino && this.logger) {
      switch (level) {
        case 0:
          this.logger.level = "error";
          break;
        case 1:
          this.logger.level = "info";
          break;
        case 2:
          this.logger.level = "debug";
          break;
      }
    }
  }
  /**
   * Log a message using our LogLine format
   */
  log(logLine) {
    var _a4, _b, _c, _d2;
    if (((_a4 = logLine.level) != null ? _a4 : 1) > this.verbose) {
      return;
    }
    const shouldFallbackToConsole = !this.usePino && !this.externalLogger || this.isTest && !this.externalLogger;
    if (shouldFallbackToConsole) {
      const level = (_b = logLine.level) != null ? _b : 1;
      const ts = (_c = logLine.timestamp) != null ? _c : (/* @__PURE__ */ new Date()).toISOString();
      const levelStr = level === 0 ? "ERROR" : level === 2 ? "DEBUG" : "INFO";
      let output = `[${ts}] ${levelStr}: ${logLine.message}`;
      if (logLine.auxiliary) {
        const formattedData = this.formatAuxiliaryData(logLine.auxiliary);
        for (const [key, value] of Object.entries(formattedData)) {
          let formattedValue;
          if (typeof value === "object" && value !== null) {
            formattedValue = JSON.stringify(value, null, 2).split("\n").map((line, i2) => i2 === 0 ? line : `    ${line}`).join("\n");
          } else {
            formattedValue = String(value);
          }
          output += `
    ${key}: ${formattedValue}`;
        }
      }
      switch (level) {
        case 0:
          console.error(output);
          break;
        case 1:
          console.log(output);
          break;
        case 2:
          console.debug(output);
          break;
      }
      return;
    }
    if (this.usePino && this.logger) {
      const pinoLevel = levelMapping[(_d2 = logLine.level) != null ? _d2 : 1] || "info";
      const logData = __spreadValues({
        category: logLine.category,
        timestamp: logLine.timestamp || (/* @__PURE__ */ new Date()).toISOString()
      }, this.formatAuxiliaryData(logLine.auxiliary));
      if (pinoLevel === "error") {
        this.logger.error(logData, logLine.message);
      } else if (pinoLevel === "info") {
        this.logger.info(logData, logLine.message);
      } else if (pinoLevel === "debug") {
        this.logger.debug(logData, logLine.message);
      } else if (pinoLevel === "warn") {
        this.logger.warn(logData, logLine.message);
      } else if (pinoLevel === "trace") {
        this.logger.trace(logData, logLine.message);
      } else {
        this.logger.info(logData, logLine.message);
      }
    }
    if (this.externalLogger) {
      this.externalLogger(logLine);
    }
  }
  /**
   * Helper to format auxiliary data for structured logging
   */
  formatAuxiliaryData(auxiliary) {
    if (!auxiliary) return {};
    const formattedData = {};
    for (const [key, { value, type }] of Object.entries(auxiliary)) {
      let formattedValue;
      switch (type) {
        case "integer":
          formattedValue = parseInt(value, 10);
          break;
        case "float":
          formattedValue = parseFloat(value);
          break;
        case "boolean":
          formattedValue = value === "true";
          break;
        case "object":
          try {
            formattedValue = JSON.parse(value);
          } catch (e2) {
            formattedValue = value;
          }
          break;
        default:
          formattedValue = value;
      }
      if (formattedValue === void 0) continue;
      if (typeof formattedValue === "object" && formattedValue !== null) {
        const isEmpty = Array.isArray(formattedValue) ? formattedValue.length === 0 : Object.keys(formattedValue).length === 0;
        if (isEmpty) continue;
      }
      formattedData[key] = formattedValue;
    }
    return formattedData;
  }
  /**
   * Convenience methods for different log levels
   */
  error(message, data) {
    this.log({
      message,
      level: 0,
      auxiliary: this.convertToAuxiliary(data)
    });
  }
  warn(message, data) {
    this.log({
      message,
      level: 1,
      category: "warning",
      auxiliary: this.convertToAuxiliary(data)
    });
  }
  info(message, data) {
    this.log({
      message,
      level: 1,
      auxiliary: this.convertToAuxiliary(data)
    });
  }
  debug(message, data) {
    this.log({
      message,
      level: 2,
      auxiliary: this.convertToAuxiliary(data)
    });
  }
  /**
   * Convert a plain object to our auxiliary format
   */
  convertToAuxiliary(data) {
    if (!data) return void 0;
    const auxiliary = {};
    for (const [key, value] of Object.entries(data)) {
      if (value === void 0) continue;
      const type = typeof value;
      auxiliary[key] = {
        value: type === "object" ? JSON.stringify(value) : String(value),
        type: type === "number" ? Number.isInteger(value) ? "integer" : "float" : type === "boolean" ? "boolean" : type === "object" ? "object" : "string"
      };
    }
    return auxiliary;
  }
};
/**
 * Shared Pino logger instance across all StagehandLogger instances.
 * First instance to enable Pino creates it, subsequent instances reuse it.
 */
_StagehandLogger.sharedPinoLogger = null;
var StagehandLogger = _StagehandLogger;

// lib/v3/cache/ActCache.ts
var import_crypto = require("crypto");

// lib/v3/cache/utils.ts
function cloneForCache(value) {
  return JSON.parse(JSON.stringify(value));
}
function safeGetPageUrl(page) {
  return __async(this, null, function* () {
    try {
      return page.url();
    } catch (e2) {
      return "";
    }
  });
}

// lib/v3/cache/ActCache.ts
init_sdkErrors();
var ActCache = class {
  constructor({
    storage,
    logger,
    getActHandler,
    getDefaultLlmClient,
    domSettleTimeoutMs
  }) {
    this.storage = storage;
    this.logger = logger;
    this.getActHandler = getActHandler;
    this.getDefaultLlmClient = getDefaultLlmClient;
    this.domSettleTimeoutMs = domSettleTimeoutMs;
  }
  get enabled() {
    return this.storage.enabled;
  }
  prepareContext(instruction, page, variables) {
    return __async(this, null, function* () {
      if (!this.enabled) return null;
      const sanitizedInstruction = instruction.trim();
      const sanitizedVariables = variables ? __spreadValues({}, variables) : void 0;
      const variableKeys = sanitizedVariables ? Object.keys(sanitizedVariables).sort() : [];
      const pageUrl = yield safeGetPageUrl(page);
      const cacheKey = this.buildActCacheKey(
        sanitizedInstruction,
        pageUrl,
        variableKeys
      );
      return {
        instruction: sanitizedInstruction,
        cacheKey,
        pageUrl,
        variableKeys,
        variables: sanitizedVariables
      };
    });
  }
  tryReplay(context, page, timeout) {
    return __async(this, null, function* () {
      var _a4;
      if (!this.enabled) return null;
      const {
        value: entry,
        error,
        path: path8
      } = yield this.storage.readJson(`${context.cacheKey}.json`);
      if (error && path8) {
        this.logger({
          category: "cache",
          message: `failed to read act cache entry: ${path8}`,
          level: 2,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return null;
      }
      if (!entry) return null;
      if (entry.version !== 1) return null;
      if (!Array.isArray(entry.actions) || entry.actions.length === 0) {
        return null;
      }
      const entryVariableKeys = Array.isArray(entry.variableKeys) ? [...entry.variableKeys].sort() : [];
      const contextVariableKeys = [...context.variableKeys];
      if (!this.doVariableKeysMatch(entryVariableKeys, contextVariableKeys)) {
        return null;
      }
      if (contextVariableKeys.length > 0 && (!context.variables || !this.hasAllVariableValues(contextVariableKeys, context.variables))) {
        this.logger({
          category: "cache",
          message: "act cache miss: missing variables for replay",
          level: 2,
          auxiliary: {
            instruction: { value: context.instruction, type: "string" }
          }
        });
        return null;
      }
      this.logger({
        category: "cache",
        message: "act cache hit",
        level: 1,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          url: {
            value: (_a4 = entry.url) != null ? _a4 : context.pageUrl,
            type: "string"
          }
        }
      });
      return yield this.replayCachedActions(context, entry, page, timeout);
    });
  }
  store(context, result) {
    return __async(this, null, function* () {
      var _a4;
      if (!this.enabled) return;
      const entry = {
        version: 1,
        instruction: context.instruction,
        url: context.pageUrl,
        variableKeys: context.variableKeys,
        actions: (_a4 = result.actions) != null ? _a4 : [],
        actionDescription: result.actionDescription,
        message: result.message
      };
      const { error, path: path8 } = yield this.storage.writeJson(
        `${context.cacheKey}.json`,
        entry
      );
      if (error && path8) {
        this.logger({
          category: "cache",
          message: "failed to write act cache entry",
          level: 1,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return;
      }
      this.logger({
        category: "cache",
        message: "act cache stored",
        level: 2,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          url: { value: context.pageUrl, type: "string" }
        }
      });
    });
  }
  buildActCacheKey(instruction, url, variableKeys) {
    const payload = JSON.stringify({
      instruction,
      url,
      variableKeys
    });
    return (0, import_crypto.createHash)("sha256").update(payload).digest("hex");
  }
  replayCachedActions(context, entry, page, timeout) {
    return __async(this, null, function* () {
      const handler = this.getActHandler();
      if (!handler) {
        throw new StagehandNotInitializedError("act()");
      }
      const execute = () => __async(this, null, function* () {
        var _a4, _b, _c;
        const actionResults = [];
        for (const action of entry.actions) {
          const result = yield handler.takeDeterministicAction(
            action,
            page,
            this.domSettleTimeoutMs,
            this.getDefaultLlmClient(),
            void 0,
            context.variables
          );
          actionResults.push(result);
          if (!result.success) {
            break;
          }
        }
        if (actionResults.length === 0) {
          return {
            success: false,
            message: "Failed to perform act: cached entry has no actions",
            actionDescription: (_a4 = entry.actionDescription) != null ? _a4 : entry.instruction,
            actions: []
          };
        }
        const success = actionResults.every((r2) => r2.success);
        const actions = actionResults.flatMap((r2) => {
          var _a5;
          return (_a5 = r2.actions) != null ? _a5 : [];
        });
        const message = actionResults.map((r2) => r2.message).filter((m2) => m2 && m2.trim().length > 0).join(" \u2192 ") || entry.message || `Replayed ${entry.actions.length} cached action${entry.actions.length === 1 ? "" : "s"}.`;
        const actionDescription = entry.actionDescription || ((_b = actionResults[actionResults.length - 1]) == null ? void 0 : _b.actionDescription) || ((_c = entry.actions[entry.actions.length - 1]) == null ? void 0 : _c.description) || entry.instruction;
        if (success && actions.length > 0 && this.haveActionsChanged(entry.actions, actions)) {
          yield this.refreshCacheEntry(context, __spreadProps(__spreadValues({}, entry), {
            actions,
            message,
            actionDescription
          }));
        }
        return {
          success,
          message,
          actionDescription,
          actions
        };
      });
      return yield this.runWithTimeout(execute, timeout);
    });
  }
  haveActionsChanged(original, updated) {
    var _a4, _b, _c, _d2;
    if (original.length !== updated.length) {
      return true;
    }
    for (let i2 = 0; i2 < original.length; i2 += 1) {
      const orig = original[i2];
      const next = updated[i2];
      if (!next) {
        return true;
      }
      if (orig.selector !== next.selector) {
        return true;
      }
      if (orig.description !== next.description) {
        return true;
      }
      if (((_a4 = orig.method) != null ? _a4 : "") !== ((_b = next.method) != null ? _b : "")) {
        return true;
      }
      const origArgs = (_c = orig.arguments) != null ? _c : [];
      const nextArgs = (_d2 = next.arguments) != null ? _d2 : [];
      if (origArgs.length !== nextArgs.length) {
        return true;
      }
      for (let j = 0; j < origArgs.length; j += 1) {
        if (origArgs[j] !== nextArgs[j]) {
          return true;
        }
      }
    }
    return false;
  }
  refreshCacheEntry(context, entry) {
    return __async(this, null, function* () {
      const { error, path: path8 } = yield this.storage.writeJson(
        `${context.cacheKey}.json`,
        __spreadProps(__spreadValues({}, entry), {
          variableKeys: context.variableKeys
        })
      );
      if (error && path8) {
        this.logger({
          category: "cache",
          message: "failed to update act cache entry after self-heal",
          level: 0,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return;
      }
      this.logger({
        category: "cache",
        message: "act cache entry updated after self-heal",
        level: 2,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          url: { value: context.pageUrl, type: "string" }
        }
      });
    });
  }
  doVariableKeysMatch(entryKeys, contextKeys) {
    if (entryKeys.length !== contextKeys.length) {
      return false;
    }
    for (let i2 = 0; i2 < entryKeys.length; i2 += 1) {
      if (entryKeys[i2] !== contextKeys[i2]) {
        return false;
      }
    }
    return true;
  }
  hasAllVariableValues(variableKeys, variables) {
    for (const key of variableKeys) {
      if (!(key in variables)) {
        return false;
      }
    }
    return true;
  }
  runWithTimeout(run, timeout) {
    return __async(this, null, function* () {
      if (!timeout) {
        return yield run();
      }
      return yield new Promise((resolve3, reject) => {
        const timer = setTimeout(() => {
          reject(new Error(`act() timed out after ${timeout}ms`));
        }, timeout);
        void run().then(
          (value) => {
            clearTimeout(timer);
            resolve3(value);
          },
          (err) => {
            clearTimeout(timer);
            reject(err);
          }
        );
      });
    });
  }
};

// lib/v3/cache/AgentCache.ts
var import_crypto2 = require("crypto");
var SENSITIVE_CONFIG_KEYS = /* @__PURE__ */ new Set(["apikey", "api_key", "api-key"]);
var AgentCache = class {
  constructor({
    storage,
    logger,
    getActHandler,
    getContext,
    getDefaultLlmClient,
    getBaseModelName,
    getSystemPrompt,
    domSettleTimeoutMs,
    act: act2
  }) {
    this.recording = null;
    this.storage = storage;
    this.logger = logger;
    this.getActHandler = getActHandler;
    this.getContext = getContext;
    this.getDefaultLlmClient = getDefaultLlmClient;
    this.getBaseModelName = getBaseModelName;
    this.getSystemPrompt = getSystemPrompt;
    this.domSettleTimeoutMs = domSettleTimeoutMs;
    this.act = act2;
  }
  get enabled() {
    return this.storage.enabled;
  }
  shouldAttemptCache(instruction) {
    return this.enabled && instruction.trim().length > 0;
  }
  sanitizeExecuteOptions(options) {
    if (!options) return {};
    const sanitized = {};
    if (typeof options.maxSteps === "number") {
      sanitized.maxSteps = options.maxSteps;
    }
    if ("highlightCursor" in options && typeof options.highlightCursor === "boolean") {
      sanitized.highlightCursor = options.highlightCursor;
    }
    return sanitized;
  }
  buildConfigSignature(agentOptions) {
    var _a4, _b;
    const toolKeys = (agentOptions == null ? void 0 : agentOptions.tools) ? Object.keys(agentOptions.tools).sort() : void 0;
    const integrationSignatures = (agentOptions == null ? void 0 : agentOptions.integrations) ? agentOptions.integrations.map(
      (integration) => typeof integration === "string" ? integration : "client"
    ) : void 0;
    const serializedModel = this.serializeAgentModelForCache(
      agentOptions == null ? void 0 : agentOptions.model
    );
    const serializedExecutionModel = this.serializeAgentModelForCache(
      agentOptions == null ? void 0 : agentOptions.executionModel
    );
    const isCuaMode = (agentOptions == null ? void 0 : agentOptions.mode) === "cua" || (agentOptions == null ? void 0 : agentOptions.cua) === true;
    return JSON.stringify({
      v3Model: this.getBaseModelName(),
      systemPrompt: (_a4 = this.getSystemPrompt()) != null ? _a4 : "",
      agent: {
        cua: isCuaMode,
        model: serializedModel != null ? serializedModel : null,
        executionModel: isCuaMode ? null : serializedExecutionModel,
        systemPrompt: (_b = agentOptions == null ? void 0 : agentOptions.systemPrompt) != null ? _b : null,
        toolKeys,
        integrations: integrationSignatures
      }
    });
  }
  prepareContext(params) {
    return __async(this, null, function* () {
      if (!this.shouldAttemptCache(params.instruction)) {
        return null;
      }
      const instruction = params.instruction.trim();
      const startUrl = yield safeGetPageUrl(params.page);
      const cacheKey = this.buildAgentCacheKey(
        instruction,
        startUrl,
        params.options,
        params.configSignature
      );
      return {
        instruction,
        startUrl,
        options: params.options,
        configSignature: params.configSignature,
        cacheKey
      };
    });
  }
  tryReplay(context) {
    return __async(this, null, function* () {
      if (!this.enabled) return null;
      const {
        value: entry,
        error,
        path: path8
      } = yield this.storage.readJson(
        `agent-${context.cacheKey}.json`
      );
      if (error && path8) {
        this.logger({
          category: "cache",
          message: `failed to read agent cache entry: ${path8}`,
          level: 1,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return null;
      }
      if (!entry || entry.version !== 1) {
        return null;
      }
      this.logger({
        category: "cache",
        message: "agent cache hit",
        level: 1,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          url: { value: context.startUrl, type: "string" }
        }
      });
      return yield this.replayAgentCacheEntry(context, entry);
    });
  }
  /**
   * Attempts to replay a cached agent execution and returns it as a stream result.
   *
   * This method exists because the agent API exposes two execution modes:
   * - `execute()` - Returns a Promise<AgentResult> directly
   * - `stream()` - Returns an AgentStreamResult with async iterables for real-time output
   *
   * When a cache hit occurs, we need to return the appropriate type for each mode:
   * - For `execute()`, we use `tryReplay()` which returns AgentResult
   * - For `stream()`, we use `tryReplayAsStream()` which wraps the result in a
   *   stream-compatible interface
   *
   * This ensures consumers using `stream()` can still iterate over `textStream`
   * and await `result` even when the response comes from cache, maintaining
   * API consistency regardless of whether the result was cached or live.
   */
  tryReplayAsStream(context) {
    return __async(this, null, function* () {
      const result = yield this.tryReplay(context);
      if (!result) return null;
      return this.createCachedStreamResult(result);
    });
  }
  /**
     * Creates a mock AgentStreamResult that wraps a cached AgentResult.
     *
     * AgentStreamResult (from the AI SDK) is a complex type with multiple async
     * iterables and promises. When serving from cache, we don't have an actual
     * LLM stream to consume - we just have the final result. This method creates
     * a "fake" stream
  
     * This approach lets cached responses be transparent to the consumer -
     * they can use the same iteration patterns whether the result is live or cached.
     */
  createCachedStreamResult(cachedResult) {
    var _a4;
    const message = (_a4 = cachedResult.message) != null ? _a4 : "";
    function textStreamGenerator() {
      return __asyncGenerator(this, null, function* () {
        yield message;
      });
    }
    function fullStreamGenerator() {
      return __asyncGenerator(this, null, function* () {
        yield { type: "text-delta", textDelta: message };
        yield { type: "finish" };
      });
    }
    const mockStreamResult = {
      textStream: textStreamGenerator(),
      fullStream: fullStreamGenerator(),
      result: Promise.resolve(cachedResult),
      text: Promise.resolve(message),
      usage: Promise.resolve({
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0
      }),
      finishReason: Promise.resolve("stop"),
      experimental_providerMetadata: Promise.resolve(void 0),
      response: Promise.resolve({
        id: "cached",
        timestamp: /* @__PURE__ */ new Date(),
        modelId: "cached"
      }),
      rawResponse: Promise.resolve({ headers: {} }),
      warnings: Promise.resolve([]),
      steps: Promise.resolve([]),
      toolCalls: Promise.resolve([]),
      toolResults: Promise.resolve([]),
      [Symbol.asyncIterator]: () => textStreamGenerator()
    };
    return mockStreamResult;
  }
  /**
   * Wraps an AgentStreamResult with caching logic.
   *
   * This method handles the complexity of caching for streaming responses:
   * 1. Begins recording agent replay steps
   * 2. Wraps the stream's result promise to capture completion
   * 3. On success: ends recording and stores the cache entry
   * 4. On error: discards the recording
   *
   * This keeps the caching orchestration in AgentCache rather than
   * spreading it across the V3 class.
   *
   * @param context - The cache context for this execution
   * @param streamResult - The stream result from the agent handler
   * @param beginRecording - Callback to start recording (from V3)
   * @param endRecording - Callback to end recording and get steps (from V3)
   * @param discardRecording - Callback to discard recording on error (from V3)
   * @returns The wrapped stream result with caching enabled
   */
  wrapStreamForCaching(context, streamResult, beginRecording, endRecording, discardRecording) {
    beginRecording();
    const originalResultPromise = streamResult.result;
    const wrappedResultPromise = originalResultPromise.then(
      (result) => __async(this, null, function* () {
        const agentSteps = endRecording();
        if (result.success && agentSteps.length > 0) {
          yield this.store(context, agentSteps, result);
        }
        return result;
      }),
      (error) => {
        discardRecording();
        throw error;
      }
    );
    streamResult.result = wrappedResultPromise;
    return streamResult;
  }
  store(context, steps, result) {
    return __async(this, null, function* () {
      if (!this.enabled) return;
      const entry = {
        version: 1,
        instruction: context.instruction,
        startUrl: context.startUrl,
        options: context.options,
        configSignature: context.configSignature,
        steps: cloneForCache(steps),
        result: this.pruneAgentResult(result),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      const { error, path: path8 } = yield this.storage.writeJson(
        `agent-${context.cacheKey}.json`,
        entry
      );
      if (error && path8) {
        this.logger({
          category: "cache",
          message: "failed to write agent cache entry",
          level: 1,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return;
      }
      this.logger({
        category: "cache",
        message: "agent cache stored",
        level: 2,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          steps: { value: String(steps.length), type: "string" }
        }
      });
    });
  }
  /**
   * Clone the agent result and prune bulky fields (e.g. screenshot base64 blobs)
   * before persisting it to disk. This keeps cache entries compact without
   * mutating the live AgentResult returned to callers.
   */
  pruneAgentResult(result) {
    const cloned = cloneForCache(result);
    if (!Array.isArray(cloned.actions)) {
      return cloned;
    }
    for (const action of cloned.actions) {
      if ((action == null ? void 0 : action.type) === "screenshot") {
        delete action.base64;
      }
    }
    return cloned;
  }
  beginRecording() {
    this.recording = [];
  }
  endRecording() {
    if (!this.recording) return [];
    const steps = cloneForCache(this.recording);
    this.recording = null;
    return steps;
  }
  discardRecording() {
    this.recording = null;
  }
  isRecording() {
    return Array.isArray(this.recording);
  }
  recordStep(step) {
    if (!this.isRecording()) return;
    try {
      this.recording.push(cloneForCache(step));
    } catch (err) {
      this.logger({
        category: "cache",
        message: "failed to record agent replay step",
        level: 2,
        auxiliary: {
          error: { value: String(err), type: "string" }
        }
      });
    }
  }
  isReplayActive() {
    return this.isRecording();
  }
  serializeAgentModelForCache(model) {
    if (!model) return null;
    if (typeof model === "string") return model;
    const _a4 = model, { modelName } = _a4, modelOptions = __objRest(_a4, ["modelName"]);
    const sanitizedOptions = Object.keys(modelOptions).length > 0 ? this.sanitizeModelOptionsForCache(
      modelOptions
    ) : void 0;
    return sanitizedOptions ? { modelName, options: sanitizedOptions } : modelName;
  }
  buildAgentCacheKey(instruction, startUrl, options, configSignature) {
    const payload = {
      instruction,
      startUrl,
      options,
      configSignature
    };
    return (0, import_crypto2.createHash)("sha256").update(JSON.stringify(payload)).digest("hex");
  }
  sanitizeModelOptionsForCache(value) {
    const sanitizedEntries = {};
    for (const [key, rawValue] of Object.entries(value)) {
      if (SENSITIVE_CONFIG_KEYS.has(key.toLowerCase())) {
        continue;
      }
      const sanitizedValue = this.sanitizeModelValueForCache(rawValue);
      if (sanitizedValue !== void 0) {
        sanitizedEntries[key] = sanitizedValue;
      }
    }
    return Object.keys(sanitizedEntries).length > 0 ? sanitizedEntries : void 0;
  }
  sanitizeModelValueForCache(value) {
    if (Array.isArray(value)) {
      const sanitizedArray = value.map((item) => this.sanitizeModelValueForCache(item)).filter((item) => item !== void 0);
      return sanitizedArray;
    }
    if (value && typeof value === "object") {
      return this.sanitizeModelOptionsForCache(
        value
      );
    }
    return value;
  }
  replayAgentCacheEntry(context, entry) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const ctx = this.getContext();
      const handler = this.getActHandler();
      if (!ctx || !handler) return null;
      try {
        const updatedSteps = [];
        let stepsChanged = false;
        for (const step of (_a4 = entry.steps) != null ? _a4 : []) {
          const replayedStep = (_b = yield this.executeAgentReplayStep(step, ctx, handler)) != null ? _b : step;
          stepsChanged || (stepsChanged = replayedStep !== step);
          updatedSteps.push(replayedStep);
        }
        const result = cloneForCache(entry.result);
        result.usage = {
          input_tokens: 0,
          output_tokens: 0,
          reasoning_tokens: 0,
          cached_input_tokens: 0,
          inference_time_ms: 0
        };
        result.metadata = __spreadProps(__spreadValues({}, (_c = result.metadata) != null ? _c : {}), {
          cacheHit: true,
          cacheTimestamp: entry.timestamp
        });
        if (stepsChanged) {
          yield this.refreshAgentCacheEntry(context, entry, updatedSteps);
        }
        return result;
      } catch (err) {
        this.logger({
          category: "cache",
          message: "agent cache replay failed",
          level: 1,
          auxiliary: {
            error: { value: String(err), type: "string" }
          }
        });
        return null;
      }
    });
  }
  executeAgentReplayStep(step, ctx, handler) {
    return __async(this, null, function* () {
      switch (step.type) {
        case "act":
          return yield this.replayAgentActStep(
            step,
            ctx,
            handler
          );
        case "fillForm":
          return yield this.replayAgentFillFormStep(
            step,
            ctx,
            handler
          );
        case "goto":
          yield this.replayAgentGotoStep(step, ctx);
          return step;
        case "scroll":
          yield this.replayAgentScrollStep(step, ctx);
          return step;
        case "wait":
          yield this.replayAgentWaitStep(step);
          return step;
        case "navback":
          yield this.replayAgentNavBackStep(step, ctx);
          return step;
        case "keys":
          yield this.replayAgentKeysStep(step, ctx);
          return step;
        case "close":
        case "extract":
        case "screenshot":
        case "ariaTree":
          return step;
        default:
          this.logger({
            category: "cache",
            message: `agent cache skipping step type: ${step.type}`,
            level: 2
          });
          return step;
      }
    });
  }
  replayAgentActStep(step, ctx, handler) {
    return __async(this, null, function* () {
      const actions = Array.isArray(step.actions) ? step.actions : [];
      if (actions.length > 0) {
        const page = yield ctx.awaitActivePage();
        const updatedActions = [];
        for (const action of actions) {
          const result = yield handler.takeDeterministicAction(
            action,
            page,
            this.domSettleTimeoutMs,
            this.getDefaultLlmClient()
          );
          if (result.success && Array.isArray(result.actions)) {
            updatedActions.push(...cloneForCache(result.actions));
          } else {
            updatedActions.push(cloneForCache(action));
          }
        }
        if (this.haveActionsChanged(actions, updatedActions)) {
          return __spreadProps(__spreadValues({}, step), { actions: updatedActions });
        }
        return step;
      }
      yield this.act(step.instruction, { timeout: step.timeout });
      return step;
    });
  }
  replayAgentFillFormStep(step, ctx, handler) {
    return __async(this, null, function* () {
      var _a4;
      const actions = Array.isArray(step.actions) && step.actions.length > 0 ? step.actions : (_a4 = step.observeResults) != null ? _a4 : [];
      if (!Array.isArray(actions) || actions.length === 0) {
        return step;
      }
      const page = yield ctx.awaitActivePage();
      const updatedActions = [];
      for (const action of actions) {
        const result = yield handler.takeDeterministicAction(
          action,
          page,
          this.domSettleTimeoutMs,
          this.getDefaultLlmClient()
        );
        if (result.success && Array.isArray(result.actions)) {
          updatedActions.push(...cloneForCache(result.actions));
        } else {
          updatedActions.push(cloneForCache(action));
        }
      }
      if (this.haveActionsChanged(actions, updatedActions)) {
        return __spreadProps(__spreadValues({}, step), { actions: updatedActions });
      }
      return step;
    });
  }
  replayAgentGotoStep(step, ctx) {
    return __async(this, null, function* () {
      var _a4;
      const page = yield ctx.awaitActivePage();
      yield page.goto(step.url, { waitUntil: (_a4 = step.waitUntil) != null ? _a4 : "load" });
    });
  }
  replayAgentScrollStep(step, ctx) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2;
      const page = yield ctx.awaitActivePage();
      let anchor = step.anchor;
      if (!anchor) {
        anchor = yield page.mainFrame().evaluate(() => ({
          x: Math.max(0, Math.floor(window.innerWidth / 2)),
          y: Math.max(0, Math.floor(window.innerHeight / 2))
        }));
      }
      const deltaX = (_a4 = step.deltaX) != null ? _a4 : 0;
      const deltaY = (_b = step.deltaY) != null ? _b : 0;
      yield page.scroll(
        Math.round((_c = anchor.x) != null ? _c : 0),
        Math.round((_d2 = anchor.y) != null ? _d2 : 0),
        deltaX,
        deltaY
      );
    });
  }
  replayAgentWaitStep(step) {
    return __async(this, null, function* () {
      if (!step.timeMs || step.timeMs <= 0) return;
      yield new Promise((resolve3) => setTimeout(resolve3, step.timeMs));
    });
  }
  replayAgentNavBackStep(step, ctx) {
    return __async(this, null, function* () {
      var _a4;
      const page = yield ctx.awaitActivePage();
      yield page.goBack({ waitUntil: (_a4 = step.waitUntil) != null ? _a4 : "domcontentloaded" });
    });
  }
  replayAgentKeysStep(step, ctx) {
    return __async(this, null, function* () {
      const page = yield ctx.awaitActivePage();
      const { method, text, keys, times } = step.playwrightArguments;
      const repeatCount = Math.max(1, times != null ? times : 1);
      if (method === "type" && text) {
        for (let i2 = 0; i2 < repeatCount; i2++) {
          yield page.type(text, { delay: 100 });
        }
      } else if (method === "press" && keys) {
        for (let i2 = 0; i2 < repeatCount; i2++) {
          yield page.keyPress(keys, { delay: 100 });
        }
      }
    });
  }
  haveActionsChanged(original, updated) {
    var _a4, _b, _c, _d2;
    if (original.length !== updated.length) {
      return true;
    }
    for (let i2 = 0; i2 < original.length; i2 += 1) {
      const orig = original[i2];
      const next = updated[i2];
      if (!orig || !next) {
        return true;
      }
      if (orig.selector !== next.selector) {
        return true;
      }
      if (((_a4 = orig.description) != null ? _a4 : "") !== ((_b = next.description) != null ? _b : "")) {
        return true;
      }
      if (((_c = orig.method) != null ? _c : "") !== ((_d2 = next.method) != null ? _d2 : "")) {
        return true;
      }
      const origArgs = Array.isArray(orig.arguments) ? orig.arguments : [];
      const nextArgs = Array.isArray(next.arguments) ? next.arguments : [];
      if (origArgs.length !== nextArgs.length) {
        return true;
      }
      for (let j = 0; j < origArgs.length; j += 1) {
        if (origArgs[j] !== nextArgs[j]) {
          return true;
        }
      }
    }
    return false;
  }
  refreshAgentCacheEntry(context, entry, updatedSteps) {
    return __async(this, null, function* () {
      const updatedEntry = __spreadProps(__spreadValues({}, entry), {
        steps: cloneForCache(updatedSteps),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      const { error, path: path8 } = yield this.storage.writeJson(
        `agent-${context.cacheKey}.json`,
        updatedEntry
      );
      if (error && path8) {
        this.logger({
          category: "cache",
          message: "failed to update agent cache entry after self-heal",
          level: 0,
          auxiliary: {
            error: { value: String(error), type: "string" }
          }
        });
        return;
      }
      this.logger({
        category: "cache",
        message: "agent cache entry updated after self-heal",
        level: 2,
        auxiliary: {
          instruction: { value: context.instruction, type: "string" },
          steps: { value: String(updatedSteps.length), type: "string" }
        }
      });
    });
  }
};

// lib/v3/cache/CacheStorage.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var CacheStorage = class _CacheStorage {
  constructor(logger, dir) {
    this.logger = logger;
    this.dir = dir;
  }
  static create(cacheDir, logger, options) {
    var _a4;
    if (!cacheDir) {
      return new _CacheStorage(logger);
    }
    const resolved = import_path.default.resolve(cacheDir);
    try {
      import_fs.default.mkdirSync(resolved, { recursive: true });
      return new _CacheStorage(logger, resolved);
    } catch (err) {
      const label = (_a4 = options == null ? void 0 : options.label) != null ? _a4 : "cache directory";
      logger({
        category: "cache",
        message: `unable to initialize ${label}: ${resolved}`,
        level: 1,
        auxiliary: {
          error: { value: String(err), type: "string" }
        }
      });
      return new _CacheStorage(logger);
    }
  }
  get directory() {
    return this.dir;
  }
  get enabled() {
    return !!this.dir;
  }
  resolvePath(fileName) {
    if (!this.dir) return null;
    return import_path.default.join(this.dir, fileName);
  }
  readJson(fileName) {
    return __async(this, null, function* () {
      const filePath = this.resolvePath(fileName);
      if (!filePath) {
        return { value: null };
      }
      try {
        const raw = yield import_fs.default.promises.readFile(filePath, "utf8");
        return { value: JSON.parse(raw) };
      } catch (err) {
        const code = err == null ? void 0 : err.code;
        if (code === "ENOENT") {
          return { value: null };
        }
        return { value: null, error: err, path: filePath };
      }
    });
  }
  writeJson(fileName, data) {
    return __async(this, null, function* () {
      const filePath = this.resolvePath(fileName);
      if (!filePath) {
        return {};
      }
      try {
        yield import_fs.default.promises.mkdir(import_path.default.dirname(filePath), { recursive: true });
        yield import_fs.default.promises.writeFile(
          filePath,
          JSON.stringify(data, null, 2),
          "utf8"
        );
        return {};
      } catch (err) {
        return { error: err, path: filePath };
      }
    });
  }
};

// lib/inference.ts
var import_zod3 = require("zod");

// lib/prompt.ts
function buildUserInstructionsString(userProvidedInstructions) {
  if (!userProvidedInstructions) {
    return "";
  }
  return `

# Custom Instructions Provided by the User
    
Please keep the user's instructions in mind when performing actions. If the user's instructions are not relevant to the current task, ignore them.

User Instructions:
${userProvidedInstructions}`;
}
function buildExtractSystemPrompt(isUsingPrintExtractedDataTool = false, userProvidedInstructions) {
  const baseContent = `You are extracting content on behalf of a user.
  If a user asks you to extract a 'list' of information, or 'all' information, 
  YOU MUST EXTRACT ALL OF THE INFORMATION THAT THE USER REQUESTS.
   
  You will be given:
1. An instruction
2. `;
  const contentDetail = `A list of DOM elements to extract from.`;
  const instructions = `
Print the exact text from the DOM elements with all symbols, characters, and endlines as is.
Print null or an empty string if no new information is found.
  `.trim();
  const toolInstructions = isUsingPrintExtractedDataTool ? `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.
  `.trim() : "";
  const additionalInstructions = "If a user is attempting to extract links or URLs, you MUST respond with ONLY the IDs of the link elements. \nDo not attempt to extract links directly from the text unless absolutely necessary. ";
  const userInstructions = buildUserInstructionsString(
    userProvidedInstructions
  );
  const content = `${baseContent}${contentDetail}

${instructions}
${toolInstructions}${additionalInstructions ? `

${additionalInstructions}` : ""}${userInstructions ? `

${userInstructions}` : ""}`.replace(/\s+/g, " ");
  return {
    role: "system",
    content
  };
}
function buildExtractUserPrompt(instruction, domElements, isUsingPrintExtractedDataTool = false) {
  let content = `Instruction: ${instruction}
DOM: ${domElements}`;
  if (isUsingPrintExtractedDataTool) {
    content += `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.`;
  }
  return {
    role: "user",
    content
  };
}
var metadataSystemPrompt = `You are an AI assistant tasked with evaluating the progress and completion status of an extraction task.
Analyze the extraction response and determine if the task is completed or if more information is needed.
Strictly abide by the following criteria:
1. Once the instruction has been satisfied by the current extraction response, ALWAYS set completion status to true and stop processing, regardless of remaining chunks.
2. Only set completion status to false if BOTH of these conditions are true:
   - The instruction has not been satisfied yet
   - There are still chunks left to process (chunksTotal > chunksSeen)`;
function buildMetadataSystemPrompt() {
  return {
    role: "system",
    content: metadataSystemPrompt
  };
}
function buildMetadataPrompt(instruction, extractionResponse) {
  return {
    role: "user",
    content: `Instruction: ${instruction}
Extracted content: ${JSON.stringify(extractionResponse, null, 2)}`
  };
}
function buildObserveSystemPrompt(userProvidedInstructions) {
  const observeSystemPrompt = `
You are helping the user automate the browser by finding elements based on what the user wants to observe in the page.

You will be given:
1. a instruction of elements to observe
2. a hierarchical accessibility tree showing the semantic structure of the page. The tree is a hybrid of the DOM and the accessibility tree.

Return an array of elements that match the instruction if they exist, otherwise return an empty array.`;
  const content = observeSystemPrompt.replace(/\s+/g, " ");
  return {
    role: "system",
    content: [content, buildUserInstructionsString(userProvidedInstructions)].filter(Boolean).join("\n\n")
  };
}
function buildObserveUserMessage(instruction, domElements) {
  return {
    role: "user",
    content: `instruction: ${instruction}
Accessibility Tree: 
${domElements}
`
  };
}
function buildActSystemPrompt(userProvidedInstructions) {
  const actSystemPrompt = `
You are helping the user automate the browser by finding elements based on what action the user wants to take on the page

You will be given:
1. a user defined instruction about what action to take
2. a hierarchical accessibility tree showing the semantic structure of the page. The tree is a hybrid of the DOM and the accessibility tree.

Return the element that matches the instruction if it exists. Otherwise, return an empty object.`;
  const content = actSystemPrompt.replace(/\s+/g, " ");
  return {
    role: "system",
    content: [content, buildUserInstructionsString(userProvidedInstructions)].filter(Boolean).join("\n\n")
  };
}
function buildActPrompt(action, supportedActions, variables) {
  let instruction = `Find the most relevant element to perform an action on given the following action: ${action}.  
  IF AND ONLY IF the action EXPLICITLY includes the word 'dropdown' and implies choosing/selecting an option from a dropdown, ignore the 'General Instructions' section, and follow the 'Dropdown Specific Instructions' section carefully.
  
  General Instructions: 
    Provide an action for this element such as ${supportedActions.join(", ")}. Remember that to users, buttons and links look the same in most cases.
    If the action is completely unrelated to a potential action to be taken on the page, return an empty object. 
    ONLY return one action. If multiple actions are relevant, return the most relevant one. 
    If the user is asking to scroll to a position on the page, e.g., 'halfway' or 0.75, etc, you must return the argument formatted as the correct percentage, e.g., '50%' or '75%', etc.
    If the user is asking to scroll to the next chunk/previous chunk, choose the nextChunk/prevChunk method. No arguments are required here.
    If the action implies a key press, e.g., 'press enter', 'press a', 'press space', etc., always choose the press method with the appropriate key as argument \u2014 e.g. 'a', 'Enter', 'Space'. Do not choose a click action on an on-screen keyboard. Capitalize the first character like 'Enter', 'Tab', 'Escape' only for special keys. 
  
  Dropdown Specific Instructions:
    For interacting with dropdowns, there are two specific cases that you need to handle. 
    
    CASE 1: the element is a 'select' element. 
      - choose the selectOptionFromDropdown method,
      - set the argument to the exact text of the option that should be selected,
      - set twoStep to false.
    CASE 2: the element is NOT a 'select' element:
      - do not attempt to directly choose the element from the dropdown. You will need to click to expand the dropdown first. You will achieve this by following these instructions:
        - choose the node that most closely corresponds to the given instruction EVEN if it is a 'StaticText' element, or otherwise does not appear to be interactable.  
        - choose the 'click' method
        - set twoStep to true.
  `;
  if (variables && Object.keys(variables).length > 0) {
    const variableNames = Object.keys(variables).map((key) => `%${key}%`).join(", ");
    const variablesPrompt = `The following variables are available to use in the action: ${variableNames}. Fill the argument variables with the variable name.`;
    instruction += ` ${variablesPrompt}`;
  }
  return instruction;
}
function buildStepTwoPrompt(originalUserAction, previousAction, supportedActions, variables) {
  let instruction = `
  The original user action was: ${originalUserAction}.
  You have just taken the following action which completed step 1 of 2: ${previousAction}.
  
  Now, you must find the most relevant element to perform an action on in order to complete step 2 of 2. 
  
  General Instructions: 
  Provide an action for this element such as ${supportedActions.join(", ")}. Remember that to users, buttons and links look the same in most cases.
  If the action is completely unrelated to a potential action to be taken on the page, return an empty object. 
  ONLY return one action. If multiple actions are relevant, return the most relevant one. 
  If the user is asking to scroll to a position on the page, e.g., 'halfway' or 0.75, etc, you must return the argument formatted as the correct percentage, e.g., '50%' or '75%', etc.
  If the user is asking to scroll to the next chunk/previous chunk, choose the nextChunk/prevChunk method. No arguments are required here.
  If the action implies a key press, e.g., 'press enter', 'press a', 'press space', etc., always choose the press method with the appropriate key as argument \u2014 e.g. 'a', 'Enter', 'Space'. Do not choose a click action on an on-screen keyboard. Capitalize the first character like 'Enter', 'Tab', 'Escape' only for special keys. 
  `;
  if (variables && Object.keys(variables).length > 0) {
    const variableNames = Object.keys(variables).map((key) => `%${key}%`).join(", ");
    const variablesPrompt = `The following variables are available to use in the action: ${variableNames}. Fill the argument variables with the variable name.`;
    instruction += ` ${variablesPrompt}`;
  }
  return instruction;
}
function buildGoogleCUASystemPrompt() {
  return {
    role: "system",
    content: `You are a general-purpose browser agent whose job is to accomplish the user's goal.
Today's date is ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.
You have access to a search tool; however, in most cases you should operate within the page/url the user has provided. ONLY use the search tool if you're stuck or the task is impossible to complete within the current page.
You will be given a goal and a list of steps that have been taken so far. Avoid requesting the user for input as much as possible. Good luck!
`
  };
}

// lib/inferenceLogUtils.ts
var import_fs2 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
function ensureInferenceSummaryDir() {
  const inferenceDir = import_path2.default.join(process.cwd(), "inference_summary");
  if (!import_fs2.default.existsSync(inferenceDir)) {
    import_fs2.default.mkdirSync(inferenceDir, { recursive: true });
  }
  return inferenceDir;
}
function appendSummary(inferenceType, entry) {
  const summaryPath = getSummaryJsonPath(inferenceType);
  const arrayKey = `${inferenceType}_summary`;
  const existingData = readSummaryFile(inferenceType);
  existingData[arrayKey].push(entry);
  import_fs2.default.writeFileSync(summaryPath, JSON.stringify(existingData, null, 2));
}
function getTimestamp() {
  return (/* @__PURE__ */ new Date()).toISOString().replace(/[^0-9T]/g, "").replace("T", "_");
}
function writeTimestampedTxtFile(directory, prefix, data) {
  const baseDir = ensureInferenceSummaryDir();
  const subDir = import_path2.default.join(baseDir, directory);
  if (!import_fs2.default.existsSync(subDir)) {
    import_fs2.default.mkdirSync(subDir, { recursive: true });
  }
  const timestamp = getTimestamp();
  const fileName = `${timestamp}_${prefix}.txt`;
  const filePath = import_path2.default.join(subDir, fileName);
  import_fs2.default.writeFileSync(
    filePath,
    JSON.stringify(data, null, 2).replace(/\\n/g, "\n")
  );
  return { fileName, timestamp };
}
function getSummaryJsonPath(inferenceType) {
  const baseDir = ensureInferenceSummaryDir();
  const subDir = import_path2.default.join(baseDir, `${inferenceType}_summary`);
  if (!import_fs2.default.existsSync(subDir)) {
    import_fs2.default.mkdirSync(subDir, { recursive: true });
  }
  return import_path2.default.join(subDir, `${inferenceType}_summary.json`);
}
function readSummaryFile(inferenceType) {
  const summaryPath = getSummaryJsonPath(inferenceType);
  const arrayKey = `${inferenceType}_summary`;
  if (!import_fs2.default.existsSync(summaryPath)) {
    return { [arrayKey]: [] };
  }
  try {
    const raw = import_fs2.default.readFileSync(summaryPath, "utf8");
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === "object" && Array.isArray(parsed[arrayKey])) {
      return parsed;
    }
  } catch (e2) {
  }
  return { [arrayKey]: [] };
}

// lib/inference.ts
function extract(_0) {
  return __async(this, arguments, function* ({
    instruction,
    domElements,
    schema,
    llmClient,
    logger,
    userProvidedInstructions,
    logInferenceToFile = false
  }) {
    var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    const metadataSchema = import_zod3.z.object({
      progress: import_zod3.z.string().describe(
        "progress of what has been extracted so far, as concise as possible"
      ),
      completed: import_zod3.z.boolean().describe(
        "true if the goal is now accomplished. Use this conservatively, only when sure that the goal has been completed."
      )
    });
    const isUsingAnthropic = llmClient.type === "anthropic";
    const isGPT5 = llmClient.modelName.includes("gpt-5");
    const extractCallMessages = [
      buildExtractSystemPrompt(isUsingAnthropic, userProvidedInstructions),
      buildExtractUserPrompt(instruction, domElements, isUsingAnthropic)
    ];
    let extractCallFile = "";
    let extractCallTimestamp = "";
    if (logInferenceToFile) {
      const { fileName, timestamp } = writeTimestampedTxtFile(
        "extract_summary",
        "extract_call",
        {
          modelCall: "extract",
          messages: extractCallMessages
        }
      );
      extractCallFile = fileName;
      extractCallTimestamp = timestamp;
    }
    const extractStartTime = Date.now();
    const extractionResponse = yield llmClient.createChatCompletion({
      options: {
        messages: extractCallMessages,
        response_model: {
          schema,
          name: "Extraction"
        },
        temperature: isGPT5 ? 1 : 0.1,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      },
      logger
    });
    const extractEndTime = Date.now();
    const { data: extractedData, usage: extractUsage } = extractionResponse;
    let extractResponseFile = "";
    if (logInferenceToFile) {
      const { fileName } = writeTimestampedTxtFile(
        "extract_summary",
        "extract_response",
        {
          modelResponse: "extract",
          rawResponse: extractedData
        }
      );
      extractResponseFile = fileName;
      appendSummary("extract", {
        extract_inference_type: "extract",
        timestamp: extractCallTimestamp,
        LLM_input_file: extractCallFile,
        LLM_output_file: extractResponseFile,
        prompt_tokens: (_a4 = extractUsage == null ? void 0 : extractUsage.prompt_tokens) != null ? _a4 : 0,
        completion_tokens: (_b = extractUsage == null ? void 0 : extractUsage.completion_tokens) != null ? _b : 0,
        reasoning_tokens: (_c = extractUsage == null ? void 0 : extractUsage.reasoning_tokens) != null ? _c : 0,
        cached_input_tokens: (_d2 = extractUsage == null ? void 0 : extractUsage.cached_input_tokens) != null ? _d2 : 0,
        inference_time_ms: extractEndTime - extractStartTime
      });
    }
    const metadataCallMessages = [
      buildMetadataSystemPrompt(),
      buildMetadataPrompt(instruction, extractedData)
    ];
    let metadataCallFile = "";
    let metadataCallTimestamp = "";
    if (logInferenceToFile) {
      const { fileName, timestamp } = writeTimestampedTxtFile(
        "extract_summary",
        "metadata_call",
        {
          modelCall: "metadata",
          messages: metadataCallMessages
        }
      );
      metadataCallFile = fileName;
      metadataCallTimestamp = timestamp;
    }
    const metadataStartTime = Date.now();
    const metadataResponse = yield llmClient.createChatCompletion({
      options: {
        messages: metadataCallMessages,
        response_model: {
          name: "Metadata",
          schema: metadataSchema
        },
        temperature: isGPT5 ? 1 : 0.1,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      },
      logger
    });
    const metadataEndTime = Date.now();
    const {
      data: {
        completed: metadataResponseCompleted,
        progress: metadataResponseProgress
      },
      usage: metadataResponseUsage
    } = metadataResponse;
    let metadataResponseFile = "";
    if (logInferenceToFile) {
      const { fileName } = writeTimestampedTxtFile(
        "extract_summary",
        "metadata_response",
        {
          modelResponse: "metadata",
          completed: metadataResponseCompleted,
          progress: metadataResponseProgress
        }
      );
      metadataResponseFile = fileName;
      appendSummary("extract", {
        extract_inference_type: "metadata",
        timestamp: metadataCallTimestamp,
        LLM_input_file: metadataCallFile,
        LLM_output_file: metadataResponseFile,
        prompt_tokens: (_e = metadataResponseUsage == null ? void 0 : metadataResponseUsage.prompt_tokens) != null ? _e : 0,
        completion_tokens: (_f = metadataResponseUsage == null ? void 0 : metadataResponseUsage.completion_tokens) != null ? _f : 0,
        reasoning_tokens: (_g = metadataResponseUsage == null ? void 0 : metadataResponseUsage.reasoning_tokens) != null ? _g : 0,
        cached_input_tokens: (_h = metadataResponseUsage == null ? void 0 : metadataResponseUsage.cached_input_tokens) != null ? _h : 0,
        inference_time_ms: metadataEndTime - metadataStartTime
      });
    }
    const totalPromptTokens = ((_i = extractUsage == null ? void 0 : extractUsage.prompt_tokens) != null ? _i : 0) + ((_j = metadataResponseUsage == null ? void 0 : metadataResponseUsage.prompt_tokens) != null ? _j : 0);
    const totalCompletionTokens = ((_k = extractUsage == null ? void 0 : extractUsage.completion_tokens) != null ? _k : 0) + ((_l = metadataResponseUsage == null ? void 0 : metadataResponseUsage.completion_tokens) != null ? _l : 0);
    const totalInferenceTimeMs = extractEndTime - extractStartTime + (metadataEndTime - metadataStartTime);
    const totalReasoningTokens = ((_m = extractUsage == null ? void 0 : extractUsage.reasoning_tokens) != null ? _m : 0) + ((_n = metadataResponseUsage == null ? void 0 : metadataResponseUsage.reasoning_tokens) != null ? _n : 0);
    const totalCachedInputTokens = ((_o = extractUsage == null ? void 0 : extractUsage.cached_input_tokens) != null ? _o : 0) + ((_p = metadataResponseUsage == null ? void 0 : metadataResponseUsage.cached_input_tokens) != null ? _p : 0);
    return __spreadProps(__spreadValues({}, extractedData), {
      metadata: {
        completed: metadataResponseCompleted,
        progress: metadataResponseProgress
      },
      prompt_tokens: totalPromptTokens,
      completion_tokens: totalCompletionTokens,
      reasoning_tokens: totalReasoningTokens,
      cached_input_tokens: totalCachedInputTokens,
      inference_time_ms: totalInferenceTimeMs
    });
  });
}
function observe(_0) {
  return __async(this, arguments, function* ({
    instruction,
    domElements,
    llmClient,
    userProvidedInstructions,
    logger,
    logInferenceToFile = false
  }) {
    var _a4, _b, _c, _d2, _e, _f;
    const isGPT5 = llmClient.modelName.includes("gpt-5");
    const observeSchema = import_zod3.z.object({
      elements: import_zod3.z.array(
        import_zod3.z.object({
          elementId: import_zod3.z.string().describe(
            "the ID string associated with the element. Never include surrounding square brackets. This field must follow the format of 'number-number'."
          ),
          description: import_zod3.z.string().describe(
            "a description of the accessible element and its purpose"
          ),
          method: import_zod3.z.string().describe(
            "the candidate method/action to interact with the element. Select one of the available Playwright interaction methods."
          ),
          arguments: import_zod3.z.array(
            import_zod3.z.string().describe(
              "the arguments to pass to the method. For example, for a click, the arguments are empty, but for a fill, the arguments are the value to fill in."
            )
          )
        })
      ).describe("an array of accessible elements that match the instruction")
    });
    const messages = [
      buildObserveSystemPrompt(userProvidedInstructions),
      buildObserveUserMessage(instruction, domElements)
    ];
    let callTimestamp = "";
    let callFile = "";
    if (logInferenceToFile) {
      const { fileName, timestamp } = writeTimestampedTxtFile(
        `observe_summary`,
        `observe_call`,
        {
          modelCall: "observe",
          messages
        }
      );
      callFile = fileName;
      callTimestamp = timestamp;
    }
    const start = Date.now();
    const rawResponse = yield llmClient.createChatCompletion({
      options: {
        messages,
        response_model: {
          schema: observeSchema,
          name: "Observation"
        },
        temperature: isGPT5 ? 1 : 0.1,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      },
      logger
    });
    const end = Date.now();
    const usageTimeMs = end - start;
    const { data: observeData, usage: observeUsage } = rawResponse;
    const promptTokens = (_a4 = observeUsage == null ? void 0 : observeUsage.prompt_tokens) != null ? _a4 : 0;
    const completionTokens = (_b = observeUsage == null ? void 0 : observeUsage.completion_tokens) != null ? _b : 0;
    const reasoningTokens = (_c = observeUsage == null ? void 0 : observeUsage.reasoning_tokens) != null ? _c : 0;
    const cachedInputTokens = (_d2 = observeUsage == null ? void 0 : observeUsage.cached_input_tokens) != null ? _d2 : 0;
    let responseFile = "";
    if (logInferenceToFile) {
      const { fileName: responseFileName } = writeTimestampedTxtFile(
        `observe_summary`,
        `observe_response`,
        {
          modelResponse: "observe",
          rawResponse: observeData
        }
      );
      responseFile = responseFileName;
      appendSummary("observe", {
        [`observe_inference_type`]: "observe",
        timestamp: callTimestamp,
        LLM_input_file: callFile,
        LLM_output_file: responseFile,
        prompt_tokens: promptTokens,
        completion_tokens: completionTokens,
        reasoning_tokens: reasoningTokens,
        cached_input_tokens: cachedInputTokens,
        inference_time_ms: usageTimeMs
      });
    }
    const parsedElements = (_f = (_e = observeData.elements) == null ? void 0 : _e.map((el) => {
      const base = {
        elementId: el.elementId,
        description: String(el.description),
        method: String(el.method),
        arguments: el.arguments
      };
      return base;
    })) != null ? _f : [];
    return {
      elements: parsedElements,
      prompt_tokens: promptTokens,
      completion_tokens: completionTokens,
      reasoning_tokens: reasoningTokens,
      cached_input_tokens: cachedInputTokens,
      inference_time_ms: usageTimeMs
    };
  });
}
function act(_0) {
  return __async(this, arguments, function* ({
    instruction,
    domElements,
    llmClient,
    userProvidedInstructions,
    logger,
    logInferenceToFile = false
  }) {
    var _a4, _b, _c, _d2;
    const isGPT5 = llmClient.modelName.includes("gpt-5");
    const actSchema = import_zod3.z.object({
      elementId: import_zod3.z.string().describe(
        "the ID string associated with the element. Never include surrounding square brackets. This field must follow the format of 'number-number'."
      ),
      description: import_zod3.z.string().describe("a description of the accessible element and its purpose"),
      method: import_zod3.z.string().describe(
        "the candidate method/action to interact with the element. Select one of the available Playwright interaction methods."
      ),
      arguments: import_zod3.z.array(
        import_zod3.z.string().describe(
          "the arguments to pass to the method. For example, for a click, the arguments are empty, but for a fill, the arguments are the value to fill in."
        )
      ),
      twoStep: import_zod3.z.boolean()
    });
    const messages = [
      buildActSystemPrompt(userProvidedInstructions),
      buildObserveUserMessage(instruction, domElements)
    ];
    let callTimestamp = "";
    let callFile = "";
    if (logInferenceToFile) {
      const { fileName, timestamp } = writeTimestampedTxtFile(
        `act_summary`,
        `act_call`,
        {
          modelCall: "act",
          messages
        }
      );
      callFile = fileName;
      callTimestamp = timestamp;
    }
    const start = Date.now();
    const rawResponse = yield llmClient.createChatCompletion({
      options: {
        messages,
        response_model: {
          schema: actSchema,
          name: "act"
        },
        temperature: isGPT5 ? 1 : 0.1,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      },
      logger
    });
    const end = Date.now();
    const usageTimeMs = end - start;
    const { data: actData, usage: actUsage } = rawResponse;
    const promptTokens = (_a4 = actUsage == null ? void 0 : actUsage.prompt_tokens) != null ? _a4 : 0;
    const completionTokens = (_b = actUsage == null ? void 0 : actUsage.completion_tokens) != null ? _b : 0;
    const reasoningTokens = (_c = actUsage == null ? void 0 : actUsage.reasoning_tokens) != null ? _c : 0;
    const cachedInputTokens = (_d2 = actUsage == null ? void 0 : actUsage.cached_input_tokens) != null ? _d2 : 0;
    let responseFile = "";
    if (logInferenceToFile) {
      const { fileName: responseFileName } = writeTimestampedTxtFile(
        `act_summary`,
        `act_response`,
        {
          modelResponse: "act",
          rawResponse: actData
        }
      );
      responseFile = responseFileName;
      appendSummary("act", {
        [`act_inference_type`]: "act",
        timestamp: callTimestamp,
        LLM_input_file: callFile,
        LLM_output_file: responseFile,
        prompt_tokens: promptTokens,
        completion_tokens: completionTokens,
        reasoning_tokens: reasoningTokens,
        cached_input_tokens: cachedInputTokens,
        inference_time_ms: usageTimeMs
      });
    }
    const parsedElement = {
      elementId: actData.elementId,
      description: String(actData.description),
      method: String(actData.method),
      arguments: actData.arguments
    };
    return {
      element: parsedElement,
      prompt_tokens: promptTokens,
      completion_tokens: completionTokens,
      reasoning_tokens: reasoningTokens,
      cached_input_tokens: cachedInputTokens,
      inference_time_ms: usageTimeMs,
      twoStep: actData.twoStep
    };
  });
}

// lib/v3/handlers/actHandler.ts
init_logger();

// lib/v3/types/public/methods.ts
var import_zod4 = require("zod");
var defaultExtractSchema = import_zod4.z.object({
  extraction: import_zod4.z.string()
});
var pageTextSchema = import_zod4.z.object({
  pageText: import_zod4.z.string()
});
var V3FunctionName = /* @__PURE__ */ ((V3FunctionName2) => {
  V3FunctionName2["ACT"] = "ACT";
  V3FunctionName2["EXTRACT"] = "EXTRACT";
  V3FunctionName2["OBSERVE"] = "OBSERVE";
  V3FunctionName2["AGENT"] = "AGENT";
  return V3FunctionName2;
})(V3FunctionName || {});

// lib/v3/handlers/actHandler.ts
init_sdkErrors();
init_snapshot();

// lib/v3/types/private/handlers.ts
var SupportedPlaywrightAction = /* @__PURE__ */ ((SupportedPlaywrightAction2) => {
  SupportedPlaywrightAction2["CLICK"] = "click";
  SupportedPlaywrightAction2["FILL"] = "fill";
  SupportedPlaywrightAction2["TYPE"] = "type";
  SupportedPlaywrightAction2["PRESS"] = "press";
  SupportedPlaywrightAction2["SCROLL"] = "scrollTo";
  SupportedPlaywrightAction2["NEXT_CHUNK"] = "nextChunk";
  SupportedPlaywrightAction2["PREV_CHUNK"] = "prevChunk";
  SupportedPlaywrightAction2["SELECT_OPTION_FROM_DROPDOWN"] = "selectOptionFromDropdown";
  SupportedPlaywrightAction2["HOVER"] = "hover";
  return SupportedPlaywrightAction2;
})(SupportedPlaywrightAction || {});

// lib/v3/handlers/handlerUtils/actHandlerUtils.ts
init_deepLocator();
init_logger();
init_flowLogger();
init_sdkErrors();
var UnderstudyCommandException = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UnderstudyCommandException";
  }
};
function normalizeRootXPath(input) {
  const s2 = String(input != null ? input : "").trim();
  if (s2 === "/") return "/html";
  if (/^xpath=\/$/i.test(s2)) return "xpath=/html";
  return s2;
}
function performUnderstudyMethod(page, frame, method, rawXPath, args, domSettleTimeoutMs) {
  return __async(this, null, function* () {
    var _a4;
    const selectorRaw = normalizeRootXPath(rawXPath);
    const locator = yield resolveLocatorWithHops(
      page,
      frame,
      selectorRaw
    );
    const initialUrl = yield getFrameUrl(frame);
    v3Logger({
      category: "action",
      message: "performing understudy method",
      level: 2,
      auxiliary: {
        xpath: { value: selectorRaw, type: "string" },
        method: { value: method, type: "string" },
        url: { value: initialUrl, type: "string" }
      }
    });
    const ctx = {
      method,
      locator,
      xpath: selectorRaw,
      args: args.map((a) => a == null ? "" : String(a)),
      frame,
      page,
      initialUrl,
      domSettleTimeoutMs
    };
    SessionFileLogger.logUnderstudyActionEvent({
      actionType: `Understudy.${method}`,
      target: selectorRaw,
      args: Array.from(args)
    });
    try {
      const handler = (_a4 = METHOD_HANDLER_MAP[method]) != null ? _a4 : null;
      if (handler) {
        yield handler(ctx);
      } else {
        switch (method) {
          case "click":
            yield clickElement(ctx);
            break;
          case "fill":
            yield fillOrType(ctx);
            break;
          case "type":
            yield typeText(ctx);
            break;
          default:
            v3Logger({
              category: "action",
              message: "chosen method is invalid",
              level: 1,
              auxiliary: { method: { value: method, type: "string" } }
            });
            throw new UnderstudyCommandException(
              `Method ${method} not supported`
            );
        }
      }
      yield handlePossibleNavigation("action", selectorRaw, initialUrl, frame);
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      const stack = e2 instanceof Error ? e2.stack : void 0;
      v3Logger({
        category: "action",
        message: "error performing method",
        level: 1,
        auxiliary: {
          error: { value: msg, type: "string" },
          trace: { value: stack != null ? stack : "", type: "string" },
          method: { value: method, type: "string" },
          xpath: { value: selectorRaw, type: "string" },
          args: { value: JSON.stringify(args), type: "object" }
        }
      });
      throw new UnderstudyCommandException(msg);
    } finally {
      SessionFileLogger.logUnderstudyActionCompleted();
    }
  });
}
var METHOD_HANDLER_MAP = {
  scrollIntoView,
  scrollByPixelOffset,
  scrollTo: scrollElementToPercentage,
  scroll: scrollElementToPercentage,
  "mouse.wheel": wheelScroll,
  fill: fillOrType,
  type: typeText,
  press: pressKey,
  click: clickElement,
  doubleClick,
  dragAndDrop,
  nextChunk: scrollToNextChunk,
  prevChunk: scrollToPreviousChunk,
  selectOptionFromDropdown: selectOption,
  selectOption,
  hover
};
function selectOption(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { locator, xpath, args } = ctx;
    try {
      const text = ((_a4 = args[0]) == null ? void 0 : _a4.toString()) || "";
      yield locator.selectOption(text);
    } catch (e2) {
      v3Logger({
        category: "action",
        message: "error selecting option",
        level: 0,
        auxiliary: {
          error: { value: e2.message, type: "string" },
          trace: { value: e2.stack, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(e2.message);
    }
  });
}
function scrollIntoView(ctx) {
  return __async(this, null, function* () {
    const { locator, xpath } = ctx;
    v3Logger({
      category: "action",
      message: "scrolling element into view",
      level: 2,
      auxiliary: { xpath: { value: xpath, type: "string" } }
    });
    const { objectId } = yield locator.resolveNode();
    const ownerSession2 = locator.getFrame().session;
    yield ownerSession2.send("DOM.scrollIntoViewIfNeeded", { objectId });
    yield ownerSession2.send("Runtime.releaseObject", { objectId }).catch(() => {
    });
  });
}
function scrollElementToPercentage(ctx) {
  return __async(this, null, function* () {
    const { locator, xpath, args } = ctx;
    v3Logger({
      category: "action",
      message: "scrolling element vertically to specified percentage",
      level: 2,
      auxiliary: {
        xpath: { value: xpath, type: "string" },
        coordinate: { value: JSON.stringify(args), type: "string" }
      }
    });
    const [yArg = "0%"] = args;
    yield locator.scrollTo(yArg);
  });
}
function scrollByPixelOffset(ctx) {
  return __async(this, null, function* () {
    var _a4, _b;
    const { locator, page, args } = ctx;
    const dx = Number((_a4 = args[0]) != null ? _a4 : 0);
    const dy = Number((_b = args[1]) != null ? _b : 0);
    try {
      const { x: x2, y } = yield locator.centroid();
      yield page.scroll(x2, y, dx, dy);
    } catch (e2) {
      throw new UnderstudyCommandException(e2.message);
    }
  });
}
function wheelScroll(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { frame, args } = ctx;
    const deltaY = Number((_a4 = args[0]) != null ? _a4 : 200);
    v3Logger({
      category: "action",
      message: "dispatching mouse wheel",
      level: 2,
      auxiliary: { deltaY: { value: String(deltaY), type: "string" } }
    });
    yield frame.session.send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      x: 0,
      y: 0,
      deltaY,
      deltaX: 0
    });
  });
}
function fillOrType(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { locator, xpath, args } = ctx;
    try {
      yield locator.fill("");
      yield locator.fill((_a4 = args[0]) != null ? _a4 : "");
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error filling element",
        level: 1,
        auxiliary: {
          error: { value: msg, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(msg);
    }
  });
}
function typeText(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { locator, xpath, args } = ctx;
    try {
      yield locator.type((_a4 = args[0]) != null ? _a4 : "");
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error typing into element",
        level: 1,
        auxiliary: {
          error: { value: msg, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(msg);
    }
  });
}
function pressKey(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { args, xpath, page } = ctx;
    const key = (_a4 = args[0]) != null ? _a4 : "";
    try {
      v3Logger({
        category: "action",
        message: "pressing key",
        level: 1,
        auxiliary: {
          key: { value: key, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      yield page.keyPress(key);
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error pressing key",
        level: 1,
        auxiliary: {
          error: { value: msg, type: "string" },
          key: { value: key, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(msg);
    }
  });
}
function clickElement(ctx) {
  return __async(this, null, function* () {
    const { locator, xpath } = ctx;
    try {
      yield locator.click();
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error performing click",
        level: 0,
        auxiliary: {
          error: { value: msg, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new StagehandClickError(ctx.xpath, msg);
    }
  });
}
function doubleClick(ctx) {
  return __async(this, null, function* () {
    const { locator, xpath } = ctx;
    try {
      yield locator.click({ clickCount: 2 });
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error performing doubleClick",
        level: 0,
        auxiliary: {
          error: { value: msg, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(msg);
    }
  });
}
function dragAndDrop(ctx) {
  return __async(this, null, function* () {
    var _a4;
    const { page, frame, locator, args, xpath } = ctx;
    const toXPath = String((_a4 = args[0]) != null ? _a4 : "").trim();
    if (!toXPath)
      throw new UnderstudyCommandException(
        "dragAndDrop requires a target XPath arg"
      );
    const targetLocator = yield resolveLocatorWithHops(page, frame, toXPath);
    try {
      const { x: fromLocalX, y: fromLocalY } = yield locator.centroid();
      const { x: toLocalX, y: toLocalY } = yield targetLocator.centroid();
      const fromAbs = yield locator.getFrame().evaluate(
        ({ x: x2, y }) => {
          let X = x2;
          let Y = y;
          let w = window;
          while (w !== w.top) {
            const fe = w.frameElement;
            if (!fe) break;
            const r2 = fe.getBoundingClientRect();
            X += r2.left;
            Y += r2.top;
            w = w.parent;
          }
          return { x: Math.round(X), y: Math.round(Y) };
        },
        { x: fromLocalX, y: fromLocalY }
      );
      const toAbs = yield targetLocator.getFrame().evaluate(
        ({ x: x2, y }) => {
          let X = x2;
          let Y = y;
          let w = window;
          while (w !== w.top) {
            const fe = w.frameElement;
            if (!fe) break;
            const r2 = fe.getBoundingClientRect();
            X += r2.left;
            Y += r2.top;
            w = w.parent;
          }
          return { x: Math.round(X), y: Math.round(Y) };
        },
        { x: toLocalX, y: toLocalY }
      );
      yield page.dragAndDrop(fromAbs.x, fromAbs.y, toAbs.x, toAbs.y, {
        steps: 10,
        delay: 5
      });
    } catch (e2) {
      const msg = e2 instanceof Error ? e2.message : String(e2);
      v3Logger({
        category: "action",
        message: "error performing dragAndDrop",
        level: 0,
        auxiliary: {
          error: { value: msg, type: "string" },
          from: { value: xpath, type: "string" },
          to: { value: toXPath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(msg);
    }
  });
}
function scrollToNextChunk(ctx) {
  return __async(this, null, function* () {
    yield scrollByElementHeight(
      ctx,
      /*dir=*/
      1
    );
  });
}
function scrollToPreviousChunk(ctx) {
  return __async(this, null, function* () {
    yield scrollByElementHeight(
      ctx,
      /*dir=*/
      -1
    );
  });
}
function scrollByElementHeight(ctx, direction) {
  return __async(this, null, function* () {
    const { locator, xpath } = ctx;
    v3Logger({
      category: "action",
      message: direction > 0 ? "scrolling to next chunk" : "scrolling to previous chunk",
      level: 2,
      auxiliary: { xpath: { value: xpath, type: "string" } }
    });
    const { objectId } = yield locator.resolveNode();
    try {
      const ownerSession2 = locator.getFrame().session;
      yield ownerSession2.send(
        "Runtime.callFunctionOn",
        {
          objectId,
          functionDeclaration: `
          function(dir) {
            const waitForScrollEnd = (el) => new Promise((resolve) => {
              let last = el.scrollTop ?? 0;
              const check = () => {
                const cur = el.scrollTop ?? 0;
                if (cur === last) return resolve();
                last = cur;
                requestAnimationFrame(check);
              };
              requestAnimationFrame(check);
            });

            const tag = this.tagName?.toLowerCase();
            if (tag === "html" || tag === "body") {
              const h = window.visualViewport?.height ?? window.innerHeight;
              window.scrollBy({ top: h * dir, left: 0, behavior: "smooth" });
              const root = document.scrollingElement ?? document.documentElement;
              return waitForScrollEnd(root);
            }
            const h = this.getBoundingClientRect().height;
            this.scrollBy({ top: h * dir, left: 0, behavior: "smooth" });
            return waitForScrollEnd(this);
          }
        `,
          arguments: [{ value: direction }],
          awaitPromise: true,
          returnByValue: true
        }
      );
    } finally {
      const ownerSession2 = locator.getFrame().session;
      yield ownerSession2.send("Runtime.releaseObject", { objectId }).catch(() => {
      });
    }
  });
}
function hover(ctx) {
  return __async(this, null, function* () {
    const { locator, xpath } = ctx;
    try {
      yield locator.hover();
    } catch (e2) {
      v3Logger({
        category: "action",
        message: "error attempting to hover",
        level: 0,
        auxiliary: {
          error: { value: e2.message, type: "string" },
          trace: { value: e2.stack, type: "string" },
          xpath: { value: xpath, type: "string" }
        }
      });
      throw new UnderstudyCommandException(e2.message);
    }
  });
}
function getFrameUrl(frame) {
  return __async(this, null, function* () {
    const url = yield frame.evaluate("location.href");
    return url;
  });
}
function waitForDomNetworkQuiet(frame, timeoutMs) {
  return __async(this, null, function* () {
    const overallTimeout = typeof timeoutMs === "number" && Number.isFinite(timeoutMs) ? Math.max(0, timeoutMs) : 5e3;
    const client = frame.session;
    const settleStart = Date.now();
    let hasDoc;
    try {
      const rs = yield frame.evaluate("document.readyState");
      hasDoc = rs === "interactive" || rs === "complete";
    } catch (e2) {
      hasDoc = false;
    }
    if (!hasDoc && overallTimeout > 0) {
      yield frame.waitForLoadState("domcontentloaded", overallTimeout).catch(() => {
      });
    }
    const elapsed = Date.now() - settleStart;
    const remainingBudget = Math.max(0, overallTimeout - elapsed);
    if (remainingBudget === 0) {
      return;
    }
    yield client.send("Network.enable").catch(() => {
    });
    yield client.send("Page.enable").catch(() => {
    });
    yield client.send("Target.setAutoAttach", {
      autoAttach: true,
      waitForDebuggerOnStart: false,
      flatten: true,
      filter: [
        { type: "worker", exclude: true },
        { type: "shared_worker", exclude: true }
      ]
    }).catch(() => {
    });
    return new Promise((resolve3) => {
      const inflight = /* @__PURE__ */ new Set();
      const meta = /* @__PURE__ */ new Map();
      const docByFrame = /* @__PURE__ */ new Map();
      let quietTimer = null;
      let stalledRequestSweepTimer = null;
      const clearQuiet = () => {
        if (quietTimer) {
          clearTimeout(quietTimer);
          quietTimer = null;
        }
      };
      const maybeQuiet = () => {
        if (inflight.size === 0 && !quietTimer)
          quietTimer = setTimeout(() => resolveDone(), 500);
      };
      const finishReq = (id) => {
        if (!inflight.delete(id)) return;
        meta.delete(id);
        for (const [fid, rid] of docByFrame)
          if (rid === id) docByFrame.delete(fid);
        clearQuiet();
        maybeQuiet();
      };
      const onRequest = (p) => {
        if (p.type === "WebSocket" || p.type === "EventSource") return;
        inflight.add(p.requestId);
        meta.set(p.requestId, { url: p.request.url, start: Date.now() });
        if (p.type === "Document" && p.frameId)
          docByFrame.set(p.frameId, p.requestId);
        clearQuiet();
      };
      const onFinish = (p) => finishReq(p.requestId);
      const onCached = (p) => finishReq(p.requestId);
      const onDataUrl = (p) => {
        var _a4;
        if ((_a4 = p.response.url) == null ? void 0 : _a4.startsWith("data:")) finishReq(p.requestId);
      };
      const onFrameStop = (f3) => {
        const id = docByFrame.get(f3.frameId);
        if (id) finishReq(id);
      };
      client.on("Network.requestWillBeSent", onRequest);
      client.on("Network.loadingFinished", onFinish);
      client.on("Network.loadingFailed", onFinish);
      client.on("Network.requestServedFromCache", onCached);
      client.on("Network.responseReceived", onDataUrl);
      client.on("Page.frameStoppedLoading", onFrameStop);
      stalledRequestSweepTimer = setInterval(() => {
        var _a4;
        const now2 = Date.now();
        for (const [id, m2] of meta) {
          if (now2 - m2.start > 2e3) {
            inflight.delete(id);
            meta.delete(id);
            v3Logger({
              category: "dom",
              message: "\u23F3 forcing completion of stalled iframe document",
              level: 1,
              auxiliary: {
                url: { value: ((_a4 = m2.url) != null ? _a4 : "").slice(0, 120), type: "string" }
              }
            });
          }
        }
        maybeQuiet();
      }, 500);
      maybeQuiet();
      const guard = setTimeout(() => {
        if (inflight.size) {
          v3Logger({
            category: "dom",
            message: "\u26A0\uFE0F DOM-settle timeout reached \u2013 network requests still pending",
            level: 1,
            auxiliary: {
              count: { value: String(inflight.size), type: "integer" }
            }
          });
        }
        resolveDone();
      }, remainingBudget);
      const resolveDone = () => {
        client.off("Network.requestWillBeSent", onRequest);
        client.off("Network.loadingFinished", onFinish);
        client.off("Network.loadingFailed", onFinish);
        client.off("Network.requestServedFromCache", onCached);
        client.off("Network.responseReceived", onDataUrl);
        client.off("Page.frameStoppedLoading", onFrameStop);
        if (quietTimer) clearTimeout(quietTimer);
        if (stalledRequestSweepTimer) clearInterval(stalledRequestSweepTimer);
        clearTimeout(guard);
        resolve3();
      };
    });
  });
}
function handlePossibleNavigation(actionDescription, xpath, initialUrl, frame) {
  return __async(this, null, function* () {
    v3Logger({
      category: "action",
      message: `${actionDescription}, checking for page navigation`,
      level: 1,
      auxiliary: { xpath: { value: xpath, type: "string" } }
    });
    const afterUrl = yield getFrameUrl(frame);
    if (afterUrl !== initialUrl) {
      v3Logger({
        category: "action",
        message: "new page (frame) URL detected",
        level: 1,
        auxiliary: { url: { value: afterUrl, type: "string" } }
      });
    } else {
      v3Logger({
        category: "action",
        message: "no new (frame) URL detected",
        level: 1,
        auxiliary: { url: { value: afterUrl, type: "string" } }
      });
    }
  });
}

// lib/v3/handlers/handlerUtils/timeoutGuard.ts
init_sdkErrors();
function createTimeoutGuard(timeoutMs, errorFactory) {
  if (!timeoutMs || timeoutMs <= 0) {
    return () => {
    };
  }
  const startTime = Date.now();
  return () => {
    var _a4;
    if (Date.now() - startTime >= timeoutMs) {
      const err = (_a4 = errorFactory == null ? void 0 : errorFactory(timeoutMs)) != null ? _a4 : new TimeoutError("operation", timeoutMs);
      throw err;
    }
  };
}

// lib/v3/handlers/actHandler.ts
var ActHandler = class {
  constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, selfHeal, onMetrics, defaultDomSettleTimeoutMs) {
    this.llmClient = llmClient;
    this.defaultModelName = defaultModelName;
    this.defaultClientOptions = defaultClientOptions;
    this.resolveLlmClient = resolveLlmClient;
    this.systemPrompt = systemPrompt != null ? systemPrompt : "";
    this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
    this.selfHeal = !!selfHeal;
    this.onMetrics = onMetrics;
    this.defaultDomSettleTimeoutMs = defaultDomSettleTimeoutMs;
  }
  recordActMetrics(response) {
    var _a4, _b, _c, _d2, _e, _f;
    (_f = this.onMetrics) == null ? void 0 : _f.call(
      this,
      "ACT" /* ACT */,
      (_a4 = response.prompt_tokens) != null ? _a4 : 0,
      (_b = response.completion_tokens) != null ? _b : 0,
      (_c = response.reasoning_tokens) != null ? _c : 0,
      (_d2 = response.cached_input_tokens) != null ? _d2 : 0,
      (_e = response.inference_time_ms) != null ? _e : 0
    );
  }
  getActionFromLLM(_0) {
    return __async(this, arguments, function* ({
      instruction,
      domElements,
      xpathMap,
      llmClient,
      requireMethodAndArguments = true
    }) {
      const response = yield act({
        instruction,
        domElements,
        llmClient,
        userProvidedInstructions: this.systemPrompt,
        logger: v3Logger,
        logInferenceToFile: this.logInferenceToFile
      });
      this.recordActMetrics(response);
      const normalized = normalizeActInferenceElement(
        response.element,
        xpathMap,
        requireMethodAndArguments
      );
      if (!normalized) {
        return { response };
      }
      return {
        action: __spreadValues({}, normalized),
        response
      };
    });
  }
  act(params) {
    return __async(this, null, function* () {
      const { instruction, page, variables, timeout, model } = params;
      const llmClient = this.resolveLlmClient(model);
      const effectiveTimeoutMs = typeof timeout === "number" && timeout > 0 ? timeout : void 0;
      const ensureTimeRemaining = createTimeoutGuard(
        effectiveTimeoutMs,
        (ms) => new ActTimeoutError(ms)
      );
      ensureTimeRemaining();
      yield waitForDomNetworkQuiet(
        page.mainFrame(),
        this.defaultDomSettleTimeoutMs
      );
      ensureTimeRemaining();
      const { combinedTree, combinedXpathMap } = yield captureHybridSnapshot(
        page,
        { experimental: true }
      );
      const actInstruction = buildActPrompt(
        instruction,
        Object.values(SupportedPlaywrightAction),
        variables
      );
      ensureTimeRemaining();
      const { action: firstAction, response: actInferenceResponse } = yield this.getActionFromLLM({
        instruction: actInstruction,
        domElements: combinedTree,
        xpathMap: combinedXpathMap,
        llmClient
      });
      if (!firstAction) {
        v3Logger({
          category: "action",
          message: "no actionable element returned by LLM",
          level: 1
        });
        return {
          success: false,
          message: "Failed to perform act: No action found",
          actionDescription: instruction,
          actions: []
        };
      }
      ensureTimeRemaining();
      const firstResult = yield this.takeDeterministicAction(
        firstAction,
        page,
        this.defaultDomSettleTimeoutMs,
        llmClient,
        ensureTimeRemaining,
        variables
      );
      if ((actInferenceResponse == null ? void 0 : actInferenceResponse.twoStep) !== true) {
        return firstResult;
      }
      ensureTimeRemaining();
      const { combinedTree: combinedTree2, combinedXpathMap: combinedXpathMap2 } = yield captureHybridSnapshot(page, {
        experimental: true
      });
      let diffedTree = diffCombinedTrees(combinedTree, combinedTree2);
      if (!diffedTree.trim()) {
        diffedTree = combinedTree2;
      }
      const previousAction = `method: ${firstAction.method}, description: ${firstAction.description}, arguments: ${firstAction.arguments}`;
      const stepTwoInstructions = buildStepTwoPrompt(
        instruction,
        previousAction,
        Object.values(SupportedPlaywrightAction).filter(
          (action) => action !== "selectOptionFromDropdown" /* SELECT_OPTION_FROM_DROPDOWN */
        ),
        variables
      );
      ensureTimeRemaining();
      const { action: secondAction } = yield this.getActionFromLLM({
        instruction: stepTwoInstructions,
        domElements: diffedTree,
        xpathMap: combinedXpathMap2,
        llmClient
      });
      if (!secondAction) {
        return firstResult;
      }
      ensureTimeRemaining();
      const secondResult = yield this.takeDeterministicAction(
        secondAction,
        page,
        this.defaultDomSettleTimeoutMs,
        llmClient,
        ensureTimeRemaining,
        variables
      );
      return {
        success: firstResult.success && secondResult.success,
        message: secondResult.success ? `${firstResult.message} \u2192 ${secondResult.message}` : `${firstResult.message} \u2192 ${secondResult.message}`,
        actionDescription: firstResult.actionDescription,
        actions: [
          ...firstResult.actions || [],
          ...secondResult.actions || []
        ]
      };
    });
  }
  takeDeterministicAction(action, page, domSettleTimeoutMs, llmClientOverride, ensureTimeRemaining, variables) {
    return __async(this, null, function* () {
      var _a4, _b;
      ensureTimeRemaining == null ? void 0 : ensureTimeRemaining();
      const settleTimeout = domSettleTimeoutMs != null ? domSettleTimeoutMs : this.defaultDomSettleTimeoutMs;
      const effectiveClient = llmClientOverride != null ? llmClientOverride : this.llmClient;
      const method = (_a4 = action.method) == null ? void 0 : _a4.trim();
      if (!method || method === "not-supported") {
        v3Logger({
          category: "action",
          message: "action has no supported method",
          level: 0,
          auxiliary: {
            act: { value: JSON.stringify(action), type: "object" }
          }
        });
        return {
          success: false,
          message: `Unable to perform action: The method '${method != null ? method : ""}' is not supported in Action. Please use a supported Playwright locator method.`,
          actionDescription: action.description || `Action (${method != null ? method : "unknown"})`,
          actions: []
        };
      }
      const placeholderArgs = Array.isArray(action.arguments) ? [...action.arguments] : [];
      const resolvedArgs = (_b = substituteVariablesInArguments(action.arguments, variables)) != null ? _b : [];
      try {
        ensureTimeRemaining == null ? void 0 : ensureTimeRemaining();
        yield performUnderstudyMethod(
          page,
          page.mainFrame(),
          method,
          action.selector,
          resolvedArgs,
          settleTimeout
        );
        return {
          success: true,
          message: `Action [${method}] performed successfully on selector: ${action.selector}`,
          actionDescription: action.description || `action (${method})`,
          actions: [
            {
              selector: action.selector,
              description: action.description || `action (${method})`,
              method,
              arguments: placeholderArgs
            }
          ]
        };
      } catch (err) {
        if (err instanceof ActTimeoutError) {
          throw err;
        }
        const msg = err instanceof Error ? err.message : String(err);
        if (this.selfHeal) {
          v3Logger({
            category: "action",
            message: "Error performing action. Reprocessing the page and trying again",
            level: 1,
            auxiliary: {
              error: { value: msg, type: "string" },
              action: {
                value: JSON.stringify(action),
                type: "object"
              }
            }
          });
          try {
            const actCommand = action.description ? action.description.toLowerCase().startsWith(method.toLowerCase()) ? action.description : `${method} ${action.description}` : method;
            ensureTimeRemaining == null ? void 0 : ensureTimeRemaining();
            const { combinedTree, combinedXpathMap } = yield captureHybridSnapshot(page, {
              experimental: true
            });
            const instruction = buildActPrompt(
              actCommand,
              Object.values(SupportedPlaywrightAction),
              {}
            );
            ensureTimeRemaining == null ? void 0 : ensureTimeRemaining();
            const { action: fallbackAction, response: fallbackResponse } = yield this.getActionFromLLM({
              instruction,
              domElements: combinedTree,
              xpathMap: combinedXpathMap,
              llmClient: effectiveClient,
              requireMethodAndArguments: false
            });
            const fallbackElement = fallbackResponse.element;
            if (!fallbackElement) {
              return {
                success: false,
                message: "Failed to self-heal act: No observe results found for action",
                actionDescription: actCommand,
                actions: []
              };
            }
            let newSelector = action.selector;
            if (fallbackAction == null ? void 0 : fallbackAction.selector) {
              newSelector = fallbackAction.selector;
            }
            ensureTimeRemaining == null ? void 0 : ensureTimeRemaining();
            yield performUnderstudyMethod(
              page,
              page.mainFrame(),
              method,
              newSelector,
              resolvedArgs,
              settleTimeout
            );
            return {
              success: true,
              message: `Action [${method}] performed successfully on selector: ${newSelector}`,
              actionDescription: action.description || `action (${method})`,
              actions: [
                {
                  selector: newSelector,
                  description: action.description || `action (${method})`,
                  method,
                  arguments: placeholderArgs
                }
              ]
            };
          } catch (retryErr) {
            if (retryErr instanceof ActTimeoutError) {
              throw retryErr;
            }
            const retryMsg = retryErr instanceof Error ? retryErr.message : String(retryErr);
            return {
              success: false,
              message: `Failed to perform act after self-heal: ${retryMsg}`,
              actionDescription: action.description || `action (${method})`,
              actions: []
            };
          }
        }
        return {
          success: false,
          message: `Failed to perform act: ${msg}`,
          actionDescription: action.description || `action (${method})`,
          actions: []
        };
      }
    });
  }
};
function normalizeActInferenceElement(element, xpathMap, requireMethodAndArguments = true) {
  if (!element) {
    return void 0;
  }
  const { elementId, description, method, arguments: args } = element;
  const hasArgs = Array.isArray(args);
  if (requireMethodAndArguments && (!method || method === "not-supported" || !hasArgs)) {
    return void 0;
  }
  if (typeof elementId !== "string" || !elementId.includes("-")) {
    return void 0;
  }
  const xp = xpathMap[elementId];
  const trimmed = trimTrailingTextNode(xp);
  if (!trimmed) {
    return void 0;
  }
  return {
    description,
    method,
    arguments: hasArgs ? args : void 0,
    selector: `xpath=${trimmed}`
  };
}
function substituteVariablesInArguments(args, variables) {
  if (!variables || !Array.isArray(args)) {
    return args;
  }
  return args.map((arg) => {
    let out = arg;
    for (const [key, value] of Object.entries(variables)) {
      const token = `%${key}%`;
      out = out.split(token).join(String(value));
    }
    return out;
  });
}

// lib/v3/handlers/extractHandler.ts
init_logger();
init_snapshot();
init_sdkErrors();
function transformUrlStringsToNumericIds(schema) {
  const [finalSchema, urlPaths] = transformSchema(schema, []);
  return [finalSchema, urlPaths];
}
var ExtractHandler = class {
  constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, experimental, onMetrics) {
    this.llmClient = llmClient;
    this.defaultModelName = defaultModelName;
    this.defaultClientOptions = defaultClientOptions;
    this.resolveLlmClient = resolveLlmClient;
    this.systemPrompt = systemPrompt != null ? systemPrompt : "";
    this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
    this.experimental = experimental != null ? experimental : false;
    this.onMetrics = onMetrics;
  }
  extract(params) {
    return __async(this, null, function* () {
      var _a4, _b, _d2;
      const { instruction, schema, page, selector, timeout, model } = params;
      const llmClient = this.resolveLlmClient(model);
      const effectiveTimeoutMs = typeof timeout === "number" && timeout > 0 ? timeout : void 0;
      const ensureTimeRemaining = createTimeoutGuard(
        effectiveTimeoutMs,
        (ms) => new ExtractTimeoutError(ms)
      );
      const noArgs = !instruction && !schema;
      if (noArgs) {
        const focusSelector2 = (_a4 = selector == null ? void 0 : selector.replace(/^xpath=/i, "")) != null ? _a4 : "";
        ensureTimeRemaining();
        const snap = yield captureHybridSnapshot(page, {
          experimental: this.experimental,
          focusSelector: focusSelector2 || void 0
        });
        const result = { pageText: snap.combinedTree };
        return pageTextSchema.parse(result);
      }
      if (!instruction && schema) {
        throw new StagehandInvalidArgumentError(
          "extract() requires an instruction when a schema is provided."
        );
      }
      const focusSelector = (_b = selector == null ? void 0 : selector.replace(/^xpath=/, "")) != null ? _b : "";
      ensureTimeRemaining();
      const { combinedTree, combinedUrlMap } = yield captureHybridSnapshot(page, {
        experimental: this.experimental,
        focusSelector
      });
      v3Logger({
        category: "extraction",
        message: "Starting extraction using a11y snapshot",
        level: 1,
        auxiliary: instruction ? { instruction: { value: instruction, type: "string" } } : void 0
      });
      const baseSchema = schema != null ? schema : defaultExtractSchema;
      const isObjectSchema = getZodType(baseSchema) === "object";
      const WRAP_KEY = "value";
      const factory6 = getZFactory(baseSchema);
      const objectSchema = isObjectSchema ? baseSchema : factory6.object({
        [WRAP_KEY]: baseSchema
      });
      const [transformedSchema, urlFieldPaths] = transformUrlStringsToNumericIds(objectSchema);
      ensureTimeRemaining();
      const extractionResponse = yield extract({
        instruction,
        domElements: combinedTree,
        schema: transformedSchema,
        llmClient,
        userProvidedInstructions: this.systemPrompt,
        logger: v3Logger,
        logInferenceToFile: this.logInferenceToFile
      });
      const _c = extractionResponse, {
        metadata: { completed },
        prompt_tokens,
        completion_tokens,
        reasoning_tokens = 0,
        cached_input_tokens = 0,
        inference_time_ms
      } = _c, rest = __objRest(_c, [
        "metadata",
        "prompt_tokens",
        "completion_tokens",
        "reasoning_tokens",
        "cached_input_tokens",
        "inference_time_ms"
      ]);
      let output = rest;
      v3Logger({
        category: "extraction",
        message: completed ? "Extraction completed successfully" : "Extraction incomplete after processing all data",
        level: 1,
        auxiliary: {
          prompt_tokens: { value: String(prompt_tokens), type: "string" },
          completion_tokens: { value: String(completion_tokens), type: "string" },
          inference_time_ms: {
            value: String(inference_time_ms),
            type: "string"
          }
        }
      });
      (_d2 = this.onMetrics) == null ? void 0 : _d2.call(
        this,
        "EXTRACT" /* EXTRACT */,
        prompt_tokens,
        completion_tokens,
        reasoning_tokens,
        cached_input_tokens,
        inference_time_ms
      );
      const idToUrl = combinedUrlMap != null ? combinedUrlMap : {};
      for (const { segments } of urlFieldPaths) {
        injectUrls(
          output,
          segments,
          idToUrl
        );
      }
      if (!isObjectSchema && output && typeof output === "object") {
        output = output[WRAP_KEY];
      }
      return output;
    });
  }
};

// lib/v3/handlers/observeHandler.ts
init_logger();
init_snapshot();
init_sdkErrors();
var ObserveHandler = class {
  constructor(llmClient, defaultModelName, defaultClientOptions, resolveLlmClient, systemPrompt, logInferenceToFile, experimental, onMetrics) {
    this.llmClient = llmClient;
    this.defaultModelName = defaultModelName;
    this.defaultClientOptions = defaultClientOptions;
    this.resolveLlmClient = resolveLlmClient;
    this.systemPrompt = systemPrompt != null ? systemPrompt : "";
    this.logInferenceToFile = logInferenceToFile != null ? logInferenceToFile : false;
    this.experimental = experimental != null ? experimental : false;
    this.onMetrics = onMetrics;
  }
  observe(params) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const { instruction, page, timeout, selector, model } = params;
      const llmClient = this.resolveLlmClient(model);
      const effectiveTimeoutMs = typeof timeout === "number" && timeout > 0 ? timeout : void 0;
      const ensureTimeRemaining = createTimeoutGuard(
        effectiveTimeoutMs,
        (ms) => new ObserveTimeoutError(ms)
      );
      const effectiveInstruction = instruction != null ? instruction : "Find elements that can be used for any future actions in the page. These may be navigation links, related pages, section/subsection links, buttons, or other interactive elements. Be comprehensive: if there are multiple elements that may be relevant for future actions, return all of them.";
      v3Logger({
        category: "observation",
        message: "starting observation",
        level: 1,
        auxiliary: {
          instruction: {
            value: effectiveInstruction,
            type: "string"
          }
        }
      });
      const focusSelector = (_a4 = selector == null ? void 0 : selector.replace(/^xpath=/i, "")) != null ? _a4 : "";
      ensureTimeRemaining();
      const snapshot = yield captureHybridSnapshot(page, {
        experimental: this.experimental,
        focusSelector: focusSelector || void 0
      });
      const combinedTree = snapshot.combinedTree;
      const combinedXpathMap = (_b = snapshot.combinedXpathMap) != null ? _b : {};
      v3Logger({
        category: "observation",
        message: "Got accessibility tree data",
        level: 1
      });
      ensureTimeRemaining();
      const observationResponse = yield observe({
        instruction: effectiveInstruction,
        domElements: combinedTree,
        llmClient,
        userProvidedInstructions: this.systemPrompt,
        logger: v3Logger,
        logInferenceToFile: this.logInferenceToFile
      });
      const {
        prompt_tokens = 0,
        completion_tokens = 0,
        reasoning_tokens = 0,
        cached_input_tokens = 0,
        inference_time_ms = 0
      } = observationResponse;
      (_c = this.onMetrics) == null ? void 0 : _c.call(
        this,
        "OBSERVE" /* OBSERVE */,
        prompt_tokens,
        completion_tokens,
        reasoning_tokens,
        cached_input_tokens,
        inference_time_ms
      );
      const elementsWithSelectors = (yield Promise.all(
        observationResponse.elements.map((element) => __async(this, null, function* () {
          const _a5 = element, { elementId } = _a5, rest = __objRest(_a5, ["elementId"]);
          if (typeof elementId === "string" && elementId.includes("-")) {
            const lookUpIndex = elementId;
            const xpath = combinedXpathMap[lookUpIndex];
            const trimmedXpath = trimTrailingTextNode(xpath);
            if (!trimmedXpath) return void 0;
            return __spreadProps(__spreadValues({}, rest), {
              selector: `xpath=${trimmedXpath}`
            });
          }
          return {
            description: "an element inside a shadow DOM",
            method: "not-supported",
            arguments: [],
            selector: "not-supported"
          };
        }))
      )).filter((e2) => e2 !== void 0);
      v3Logger({
        category: "observation",
        message: "found elements",
        level: 1,
        auxiliary: {
          elements: {
            value: JSON.stringify(elementsWithSelectors),
            type: "object"
          }
        }
      });
      return elementsWithSelectors;
    });
  }
};

// lib/v3/agent/tools/goto.ts
var import_ai = require("ai");
var import_zod5 = require("zod");
var gotoTool = (v3) => (0, import_ai.tool)({
  description: "Navigate to a specific URL",
  inputSchema: import_zod5.z.object({
    url: import_zod5.z.string().describe("The URL to navigate to")
  }),
  execute: (_0) => __async(null, [_0], function* ({ url }) {
    var _a4;
    try {
      v3.logger({
        category: "agent",
        message: `Agent calling tool: goto`,
        level: 1,
        auxiliary: {
          arguments: {
            value: url,
            type: "string"
          }
        }
      });
      const page = yield v3.context.awaitActivePage();
      yield page.goto(url, { waitUntil: "load" });
      v3.recordAgentReplayStep({ type: "goto", url, waitUntil: "load" });
      return { success: true, url };
    } catch (error) {
      return { success: false, error: (_a4 = error == null ? void 0 : error.message) != null ? _a4 : String(error) };
    }
  })
});

// lib/v3/agent/tools/act.ts
var import_ai2 = require("ai");
var import_zod6 = require("zod");
var actTool = (v3, executionModel) => (0, import_ai2.tool)({
  description: "Perform an action on the page (click, type). Provide a short, specific phrase that mentions the element type.",
  inputSchema: import_zod6.z.object({
    action: import_zod6.z.string().describe(
      'Describe what to click or type, e.g. "click the Login button" or "type "John" into the first name input"'
    )
  }),
  execute: (_0) => __async(null, [_0], function* ({ action }) {
    var _a4, _b, _c, _d2;
    try {
      v3.logger({
        category: "agent",
        message: `Agent calling tool: act`,
        level: 1,
        auxiliary: {
          arguments: {
            value: action,
            type: "string"
          }
        }
      });
      const options = executionModel ? { model: executionModel } : void 0;
      const result = yield v3.act(action, options);
      const actions = (_a4 = result.actions) != null ? _a4 : [];
      v3.recordAgentReplayStep({
        type: "act",
        instruction: action,
        actions,
        actionDescription: result.actionDescription,
        message: result.message
      });
      return {
        success: (_b = result.success) != null ? _b : true,
        action: (_c = result == null ? void 0 : result.actionDescription) != null ? _c : action,
        playwrightArguments: actions.length > 0 ? actions[0] : void 0
      };
    } catch (error) {
      return { success: false, error: (_d2 = error == null ? void 0 : error.message) != null ? _d2 : String(error) };
    }
  })
});

// lib/v3/agent/tools/screenshot.ts
var import_ai3 = require("ai");
var import_zod7 = require("zod");
var screenshotTool = (v3) => (0, import_ai3.tool)({
  description: "Takes a screenshot (PNG) of the current page. Use this to quickly verify page state.",
  inputSchema: import_zod7.z.object({}),
  execute: () => __async(null, null, function* () {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: screenshot`,
      level: 1
    });
    const page = yield v3.context.awaitActivePage();
    const buffer = yield page.screenshot({ fullPage: false });
    const pageUrl = page.url();
    return {
      base64: buffer.toString("base64"),
      timestamp: Date.now(),
      pageUrl
    };
  }),
  toModelOutput: (result) => ({
    type: "content",
    value: [{ type: "media", mediaType: "image/png", data: result.base64 }]
  })
});

// lib/v3/agent/tools/wait.ts
var import_ai4 = require("ai");
var import_zod8 = require("zod");
var waitTool = (v3) => (0, import_ai4.tool)({
  description: "Wait for a specified time",
  inputSchema: import_zod8.z.object({
    timeMs: import_zod8.z.number().describe("Time in milliseconds")
  }),
  execute: (_0) => __async(null, [_0], function* ({ timeMs }) {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: wait`,
      level: 1,
      auxiliary: {
        arguments: {
          value: `Waiting for ${timeMs} milliseconds`,
          type: "string"
        }
      }
    });
    yield new Promise((resolve3) => setTimeout(resolve3, timeMs));
    if (timeMs > 0) {
      v3.recordAgentReplayStep({ type: "wait", timeMs });
    }
    return { success: true, waited: timeMs };
  })
});

// lib/v3/agent/tools/navback.ts
var import_ai5 = require("ai");
var import_zod9 = require("zod");
var navBackTool = (v3) => (0, import_ai5.tool)({
  description: "Navigate back to the previous page",
  inputSchema: import_zod9.z.object({
    reasoningText: import_zod9.z.string().describe("Why you're going back")
  }),
  execute: () => __async(null, null, function* () {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: navback`,
      level: 1
    });
    const page = yield v3.context.awaitActivePage();
    yield page.goBack({ waitUntil: "domcontentloaded" });
    v3.recordAgentReplayStep({
      type: "navback",
      waitUntil: "domcontentloaded"
    });
    return { success: true };
  })
});

// lib/v3/agent/tools/close.ts
var import_ai6 = require("ai");
var import_zod10 = require("zod");
var closeTool = () => (0, import_ai6.tool)({
  description: "Complete the task and close",
  inputSchema: import_zod10.z.object({
    reasoning: import_zod10.z.string().describe("Summary of what was accomplished"),
    taskComplete: import_zod10.z.boolean().describe("Whether the task was completed successfully")
  }),
  execute: (_0) => __async(null, [_0], function* ({ reasoning, taskComplete }) {
    return { success: true, reasoning, taskComplete };
  })
});

// lib/v3/agent/tools/ariaTree.ts
var import_ai7 = require("ai");
var import_zod11 = require("zod");
var ariaTreeTool = (v3) => (0, import_ai7.tool)({
  description: "gets the accessibility (ARIA) hybrid tree text for the current page. use this to understand structure and content.",
  inputSchema: import_zod11.z.object({}),
  execute: () => __async(null, null, function* () {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: ariaTree`,
      level: 1
    });
    const page = yield v3.context.awaitActivePage();
    const { pageText } = yield v3.extract();
    const pageUrl = page.url();
    let content = pageText;
    const MAX_TOKENS = 7e4;
    const estimatedTokens = Math.ceil(content.length / 4);
    if (estimatedTokens > MAX_TOKENS) {
      const maxChars = MAX_TOKENS * 4;
      content = content.substring(0, maxChars) + "\n\n[CONTENT TRUNCATED: Exceeded 70,000 token limit]";
    }
    return { content, pageUrl };
  }),
  toModelOutput: (result) => ({
    type: "content",
    value: [{ type: "text", text: `Accessibility Tree:
${result.content}` }]
  })
});

// lib/v3/agent/tools/fillform.ts
var import_ai8 = require("ai");
var import_zod12 = require("zod");
var fillFormTool = (v3, executionModel) => (0, import_ai8.tool)({
  description: `\u{1F4DD} FORM FILL - MULTI-FIELD INPUT TOOL
For any form with 2+ inputs/textareas. Faster than individual typing.`,
  inputSchema: import_zod12.z.object({
    fields: import_zod12.z.array(
      import_zod12.z.object({
        action: import_zod12.z.string().describe(
          'Description of typing action, e.g. "type foo into the email field"'
        ),
        value: import_zod12.z.string().describe("Text to type into the target")
      })
    ).min(1, "Provide at least one field to fill")
  }),
  execute: (_0) => __async(null, [_0], function* ({ fields }) {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: fillForm`,
      level: 1,
      auxiliary: {
        arguments: {
          value: JSON.stringify(fields),
          type: "object"
        }
      }
    });
    const instruction = `Return observation results for the following actions: ${fields.map((f3) => f3.action).join(", ")}`;
    const observeOptions = executionModel ? { model: executionModel } : void 0;
    const observeResults = yield v3.observe(instruction, observeOptions);
    const completed = [];
    const replayableActions = [];
    for (const res of observeResults) {
      const actResult = yield v3.act(res);
      completed.push(actResult);
      if (Array.isArray(actResult.actions)) {
        replayableActions.push(...actResult.actions);
      }
    }
    v3.recordAgentReplayStep({
      type: "fillForm",
      fields,
      observeResults,
      actions: replayableActions
    });
    return {
      success: true,
      actions: completed,
      playwrightArguments: replayableActions
    };
  })
});

// lib/v3/agent/tools/scroll.ts
var import_ai9 = require("ai");
var import_zod13 = require("zod");

// lib/v3/agent/utils/coordinateNormalization.ts
var DEFAULT_VIEWPORT = { width: 1288, height: 711 };
function isGoogleProvider(provider) {
  if (!provider) return false;
  return provider.toLowerCase().includes("google");
}
function normalizeGoogleCoordinates(x2, y) {
  const clampedX = Math.min(999, Math.max(0, x2));
  const clampedY = Math.min(999, Math.max(0, y));
  return {
    x: Math.floor(clampedX / 1e3 * DEFAULT_VIEWPORT.width),
    y: Math.floor(clampedY / 1e3 * DEFAULT_VIEWPORT.height)
  };
}
function processCoordinates(x2, y, provider) {
  if (isGoogleProvider(provider)) {
    return normalizeGoogleCoordinates(x2, y);
  }
  return { x: x2, y };
}

// lib/v3/agent/tools/scroll.ts
var scrollTool = (v3) => (0, import_ai9.tool)({
  description: "Scroll the page up or down by a percentage of the viewport height. Default is 80%, and what should be typically used for general page scrolling",
  inputSchema: import_zod13.z.object({
    direction: import_zod13.z.enum(["up", "down"]),
    percentage: import_zod13.z.number().min(1).max(200).optional()
  }),
  execute: (_0) => __async(null, [_0], function* ({ direction, percentage = 80 }) {
    v3.logger({
      category: "agent",
      message: `Agent calling tool: scroll`,
      level: 1,
      auxiliary: {
        arguments: {
          value: JSON.stringify({ direction, percentage }),
          type: "object"
        }
      }
    });
    const page = yield v3.context.awaitActivePage();
    const { w, h: h2 } = yield page.mainFrame().evaluate("({ w: window.innerWidth, h: window.innerHeight })");
    const scrollDistance = Math.round(h2 * percentage / 100);
    const cx = Math.floor(w / 2);
    const cy = Math.floor(h2 / 2);
    const deltaY = direction === "up" ? -scrollDistance : scrollDistance;
    yield page.scroll(cx, cy, 0, deltaY);
    v3.recordAgentReplayStep({
      type: "scroll",
      deltaX: 0,
      deltaY,
      anchor: { x: cx, y: cy }
    });
    return {
      success: true,
      message: `Scrolled ${percentage}% ${direction} (${scrollDistance}px)`,
      scrolledPixels: scrollDistance
    };
  })
});
var scrollVisionTool = (v3, provider) => (0, import_ai9.tool)({
  description: `Scroll the page up or down. For general page scrolling, no coordinates needed. Only provide coordinates when scrolling inside a nested scrollable element (e.g., a dropdown menu, modal with overflow, or scrollable sidebar). Default is 80%, and what should be typically used for general page scrolling`,
  inputSchema: import_zod13.z.object({
    direction: import_zod13.z.enum(["up", "down"]),
    coordinates: import_zod13.z.array(import_zod13.z.number()).optional().describe(
      "Only use coordinates for scrolling inside a nested scrollable element - provide (x, y) within that element"
    ),
    percentage: import_zod13.z.number().min(1).max(200).optional()
  }),
  execute: (_0) => __async(null, [_0], function* ({ direction, coordinates, percentage = 80 }) {
    const page = yield v3.context.awaitActivePage();
    const { w, h: h2 } = yield page.mainFrame().evaluate("({ w: window.innerWidth, h: window.innerHeight })");
    let cx;
    let cy;
    if (coordinates) {
      const processed = processCoordinates(
        coordinates[0],
        coordinates[1],
        provider
      );
      cx = processed.x;
      cy = processed.y;
    } else {
      cx = Math.floor(w / 2);
      cy = Math.floor(h2 / 2);
    }
    v3.logger({
      category: "agent",
      message: `Agent calling tool: scroll`,
      level: 1,
      auxiliary: {
        arguments: {
          value: JSON.stringify({
            direction,
            coordinates,
            percentage,
            processed: { cx, cy }
          }),
          type: "object"
        }
      }
    });
    const scrollDistance = Math.round(h2 * percentage / 100);
    const deltaY = direction === "up" ? -scrollDistance : scrollDistance;
    yield page.scroll(cx, cy, 0, deltaY);
    v3.recordAgentReplayStep({
      type: "scroll",
      deltaX: 0,
      deltaY,
      anchor: { x: cx, y: cy }
    });
    return {
      success: true,
      message: coordinates ? `Scrolled ${percentage}% ${direction} at (${cx}, ${cy})` : `Scrolled ${percentage}% ${direction}`,
      scrolledPixels: scrollDistance
    };
  })
});

// lib/v3/agent/tools/extract.ts
var import_ai10 = require("ai");
var import_zod14 = require("zod");
function evaluateZodSchema(schemaStr, logger) {
  var _a4;
  try {
    const fn = new Function("z", `return ${schemaStr}`);
    return fn(import_zod14.z);
  } catch (e2) {
    logger == null ? void 0 : logger({
      category: "agent",
      message: `Failed to evaluate schema: ${(_a4 = e2 == null ? void 0 : e2.message) != null ? _a4 : String(e2)}`,
      level: 0
    });
    return import_zod14.z.any();
  }
}
var extractTool = (v3, executionModel, logger) => (0, import_ai10.tool)({
  description: `Extract structured data from the current page based on a provided schema.
    
    USAGE GUIDELINES:
    - Keep schemas MINIMAL - only include fields essential for the task
    - IMPORANT: only use this if explicitly asked for structured output. In most scenarios, you should use the aria tree tool over this. 
    - If you need to extract a link, make sure the type defintion follows the format of z.string().url()
    EXAMPLES:
    1. Extract a single value:
       instruction: "extract the product price"
       schema: "z.object({ price: z.number()})"
    
    2. Extract multiple fields:
       instruction: "extract product name and price"
       schema: "z.object({ name: z.string(), price: z.number() })"
    
    3. Extract arrays:
       instruction: "extract all product names and prices"
       schema: "z.object({ products: z.array(z.object({ name: z.string(), price: z.number() })) })"`,
  inputSchema: import_zod14.z.object({
    instruction: import_zod14.z.string(),
    schema: import_zod14.z.string().optional().describe("Zod schema as code, e.g. z.object({ title: z.string() })")
  }),
  execute: (_0) => __async(null, [_0], function* ({ instruction, schema }) {
    var _a4;
    try {
      const parsedSchema = schema ? evaluateZodSchema(schema, logger) : void 0;
      const result = yield v3.extract(instruction, parsedSchema, __spreadValues({}, executionModel ? { model: executionModel } : {}));
      return { success: true, result };
    } catch (error) {
      return { success: false, error: (_a4 = error == null ? void 0 : error.message) != null ? _a4 : String(error) };
    }
  })
});

// lib/v3/agent/tools/click.ts
var import_ai11 = require("ai");
var import_zod15 = require("zod");

// lib/v3/agent/utils/xpath.ts
function ensureXPath(value) {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  return trimmed.startsWith("xpath=") ? trimmed : `xpath=${trimmed}`;
}

// lib/v3/agent/tools/click.ts
function waitForTimeout(ms) {
  return new Promise((resolve3) => setTimeout(resolve3, ms));
}
var clickTool = (v3, provider) => (0, import_ai11.tool)({
  description: "Click on an element using its coordinates (this is the most reliable way to click on an element, always use this over act, unless the element is not visible in the screenshot, but shown in ariaTree)",
  inputSchema: import_zod15.z.object({
    describe: import_zod15.z.string().describe(
      "Describe the element to click on in a short, specific phrase that mentions the element type and a good visual description"
    ),
    coordinates: import_zod15.z.array(import_zod15.z.number()).describe("The (x, y) coordinates to click on")
  }),
  execute: (_0) => __async(null, [_0], function* ({ describe, coordinates }) {
    try {
      const page = yield v3.context.awaitActivePage();
      const processed = processCoordinates(
        coordinates[0],
        coordinates[1],
        provider
      );
      v3.logger({
        category: "agent",
        message: `Agent calling tool: click`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({ describe, coordinates, processed }),
            type: "string"
          }
        }
      });
      const xpath = yield page.click(processed.x, processed.y, {
        returnXpath: true
      });
      if (isGoogleProvider(provider)) {
        yield waitForTimeout(1e3);
      }
      const normalizedXpath = ensureXPath(xpath);
      if (normalizedXpath) {
        const action = {
          selector: normalizedXpath,
          description: describe,
          method: "click",
          arguments: []
        };
        v3.recordAgentReplayStep({
          type: "act",
          instruction: describe,
          actions: [action],
          actionDescription: describe
        });
      }
      return {
        success: true,
        describe,
        coordinates: [processed.x, processed.y]
      };
    } catch (error) {
      return {
        success: false,
        error: `Error clicking: ${error.message}`
      };
    }
  })
});

// lib/v3/agent/tools/type.ts
var import_ai12 = require("ai");
var import_zod16 = require("zod");
function waitForTimeout2(ms) {
  return new Promise((resolve3) => setTimeout(resolve3, ms));
}
var typeTool = (v3, provider) => (0, import_ai12.tool)({
  description: "Type text into an element using its coordinates. This will click the element and then type the text into it (this is the most reliable way to type into an element, always use this over act, unless the element is not visible in the screenshot, but shown in ariaTree)",
  inputSchema: import_zod16.z.object({
    describe: import_zod16.z.string().describe(
      "Describe the element to type into in a short, specific phrase that mentions the element type and a good visual description"
    ),
    text: import_zod16.z.string().describe("The text to type into the element"),
    coordinates: import_zod16.z.array(import_zod16.z.number()).describe("The (x, y) coordinates to type into the element")
  }),
  execute: (_0) => __async(null, [_0], function* ({ describe, coordinates, text }) {
    try {
      const page = yield v3.context.awaitActivePage();
      const processed = processCoordinates(
        coordinates[0],
        coordinates[1],
        provider
      );
      v3.logger({
        category: "agent",
        message: `Agent calling tool: type`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({ describe, coordinates, processed, text }),
            type: "string"
          }
        }
      });
      const xpath = yield page.click(processed.x, processed.y, {
        returnXpath: true
      });
      if (isGoogleProvider(provider)) {
        yield waitForTimeout2(1e3);
      }
      yield page.type(text);
      const normalizedXpath = ensureXPath(xpath);
      if (normalizedXpath) {
        const action = {
          selector: normalizedXpath,
          description: describe,
          method: "type",
          arguments: [text]
        };
        v3.recordAgentReplayStep({
          type: "act",
          instruction: describe,
          actions: [action],
          actionDescription: describe
        });
      }
      return { success: true, describe, text };
    } catch (error) {
      return {
        success: false,
        error: `Error typing: ${error.message}`
      };
    }
  })
});

// lib/v3/agent/tools/dragAndDrop.ts
var import_ai13 = require("ai");
var import_zod17 = require("zod");
var dragAndDropTool = (v3, provider) => (0, import_ai13.tool)({
  description: "Drag and drop an element using its coordinates (this is the most reliable way to drag and drop an element, always use this over act, unless the element is not visible in the screenshot, but shown in ariaTree)",
  inputSchema: import_zod17.z.object({
    describe: import_zod17.z.string().describe("Describe the element to drag and drop"),
    startCoordinates: import_zod17.z.array(import_zod17.z.number()).describe("The (x, y) coordinates to start the drag and drop from"),
    endCoordinates: import_zod17.z.array(import_zod17.z.number()).describe("The (x, y) coordinates to end the drag and drop at")
  }),
  execute: (_0) => __async(null, [_0], function* ({ describe, startCoordinates, endCoordinates }) {
    try {
      const page = yield v3.context.awaitActivePage();
      const processedStart = processCoordinates(
        startCoordinates[0],
        startCoordinates[1],
        provider
      );
      const processedEnd = processCoordinates(
        endCoordinates[0],
        endCoordinates[1],
        provider
      );
      v3.logger({
        category: "agent",
        message: `Agent calling tool: dragAndDrop`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({
              describe,
              startCoordinates,
              endCoordinates,
              processedStart,
              processedEnd
            }),
            type: "string"
          }
        }
      });
      const [fromXpath, toXpath] = yield page.dragAndDrop(
        processedStart.x,
        processedStart.y,
        processedEnd.x,
        processedEnd.y,
        { returnXpath: true }
      );
      const normalizedFrom = ensureXPath(fromXpath);
      const normalizedTo = ensureXPath(toXpath);
      if (normalizedFrom && normalizedTo) {
        const action = {
          selector: normalizedFrom,
          description: describe,
          method: "dragAndDrop",
          arguments: [normalizedTo]
        };
        v3.recordAgentReplayStep({
          type: "act",
          instruction: describe,
          actions: [action],
          actionDescription: describe
        });
      }
      return { success: true, describe };
    } catch (error) {
      return {
        success: false,
        error: `Error dragging: ${error.message}`
      };
    }
  })
});

// lib/v3/agent/tools/clickAndHold.ts
var import_ai14 = require("ai");
var import_zod18 = require("zod");
var clickAndHoldTool = (v3, provider) => (0, import_ai14.tool)({
  description: "Click and hold on an element using its coordinates",
  inputSchema: import_zod18.z.object({
    describe: import_zod18.z.string().describe(
      "Describe the element to click on in a short, specific phrase that mentions the element type and a good visual description"
    ),
    duration: import_zod18.z.number().describe("The duration to hold the element in milliseconds"),
    coordinates: import_zod18.z.array(import_zod18.z.number()).describe("The (x, y) coordinates to click on")
  }),
  execute: (_0) => __async(null, [_0], function* ({ describe, coordinates, duration }) {
    try {
      const page = yield v3.context.awaitActivePage();
      const processed = processCoordinates(
        coordinates[0],
        coordinates[1],
        provider
      );
      v3.logger({
        category: "agent",
        message: `Agent calling tool: clickAndHold`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({
              describe,
              coordinates,
              processed,
              duration
            }),
            type: "string"
          }
        }
      });
      const [xpath] = yield page.dragAndDrop(
        processed.x,
        processed.y,
        processed.x,
        processed.y,
        { delay: duration, returnXpath: true }
      );
      const normalizedXpath = ensureXPath(xpath);
      if (normalizedXpath) {
        const action = {
          selector: normalizedXpath,
          description: describe,
          method: "clickAndHold",
          arguments: [String(duration)]
        };
        v3.recordAgentReplayStep({
          type: "act",
          instruction: describe,
          actions: [action],
          actionDescription: describe
        });
      }
      return { success: true, describe };
    } catch (error) {
      return {
        success: false,
        error: `Error clicking and holding: ${error.message}`
      };
    }
  })
});

// lib/v3/agent/tools/keys.ts
var import_ai15 = require("ai");
var import_zod19 = require("zod");
var keysTool = (v3) => (0, import_ai15.tool)({
  description: `Send keyboard input to the page without targeting a specific element. Unlike the type tool which clicks then types into coordinates, this sends keystrokes directly to wherever focus currently is.

Use method="type" to enter text into the currently focused element. Preferred when: input is already focused, text needs to flow across multiple fields (e.g., verification codes)

Use method="press" for navigation keys (Enter, Tab, Escape, Backspace, arrows) and keyboard shortcuts (Cmd+A, Ctrl+C, Shift+Tab).`,
  inputSchema: import_zod19.z.object({
    method: import_zod19.z.enum(["press", "type"]),
    value: import_zod19.z.string().describe(
      "The text to type, or the key/combo to press (Enter, Tab, Cmd+A)"
    ),
    repeat: import_zod19.z.number().optional()
  }),
  execute: (_0) => __async(null, [_0], function* ({ method, value, repeat }) {
    try {
      const page = yield v3.context.awaitActivePage();
      v3.logger({
        category: "agent",
        message: `Agent calling tool: keys`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({ method, value, repeat }),
            type: "string"
          }
        }
      });
      const times = Math.max(1, repeat != null ? repeat : 1);
      if (method === "type") {
        for (let i2 = 0; i2 < times; i2++) {
          yield page.type(value, { delay: 100 });
        }
        v3.recordAgentReplayStep({
          type: "keys",
          instruction: `type "${value}"`,
          playwrightArguments: { method, text: value, times }
        });
        return { success: true, method, value, times };
      }
      if (method === "press") {
        for (let i2 = 0; i2 < times; i2++) {
          yield page.keyPress(value, { delay: 100 });
        }
        v3.recordAgentReplayStep({
          type: "keys",
          instruction: `press ${value}`,
          playwrightArguments: { method, keys: value, times }
        });
        return { success: true, method, value, times };
      }
      return { success: false, error: `Unsupported method: ${method}` };
    } catch (error) {
      return { success: false, error: error.message };
    }
  })
});

// lib/v3/agent/tools/fillFormVision.ts
var import_ai16 = require("ai");
var import_zod20 = require("zod");
var fillFormVisionTool = (v3, provider) => (0, import_ai16.tool)({
  description: `FORM FILL - SPECIALIZED MULTI-FIELD INPUT TOOL

CRITICAL: Use this for ANY form with 2+ input fields (text inputs, textareas, etc.)
IMPORTANT: Ensure the fields are visible within the current viewport

WHY THIS TOOL EXISTS:
- Forms are the #1 use case for multi-field input
- Optimized specifically for input/textarea elements
- 4-6x faster than individual typing actions

Use fillFormVision: Pure form filling (inputs, textareas only)
MANDATORY USE CASES (always use fillFormVision for these):
- Registration forms: name, email, password fields
- Contact forms: name, email, message fields
- Checkout forms: address, payment info fields
- Profile updates: multiple user data fields
- Search filters: multiple criteria inputs`,
  inputSchema: import_zod20.z.object({
    fields: import_zod20.z.array(
      import_zod20.z.object({
        action: import_zod20.z.string().describe(
          "Description of the typing action, e.g. 'type foo into the bar field'"
        ),
        value: import_zod20.z.string().describe("Text to type into the target field"),
        coordinates: import_zod20.z.object({
          x: import_zod20.z.number(),
          y: import_zod20.z.number()
        }).describe("Coordinates of the target field")
      })
    ).min(2, "Provide at least two fields to fill")
  }),
  execute: (_0) => __async(null, [_0], function* ({ fields }) {
    try {
      const page = yield v3.context.awaitActivePage();
      const processedFields = fields.map((field) => {
        const processed = processCoordinates(
          field.coordinates.x,
          field.coordinates.y,
          provider
        );
        return __spreadProps(__spreadValues({}, field), {
          coordinates: { x: processed.x, y: processed.y }
        });
      });
      v3.logger({
        category: "agent",
        message: `Agent calling tool: fillFormVision`,
        level: 1,
        auxiliary: {
          arguments: {
            value: JSON.stringify({ fields, processedFields }),
            type: "string"
          }
        }
      });
      const actions = [];
      for (const field of processedFields) {
        const xpath = yield page.click(
          field.coordinates.x,
          field.coordinates.y,
          {
            returnXpath: true
          }
        );
        yield page.type(field.value);
        const normalizedXpath = ensureXPath(xpath);
        if (normalizedXpath) {
          actions.push({
            selector: normalizedXpath,
            description: field.action,
            method: "type",
            arguments: [field.value]
          });
        }
        yield new Promise((resolve3) => setTimeout(resolve3, 100));
      }
      if (actions.length > 0) {
        v3.recordAgentReplayStep({
          type: "act",
          instruction: `Fill ${fields.length} form fields`,
          actions,
          actionDescription: `Fill ${fields.length} form fields`
        });
      }
      return {
        success: true,
        playwrightArguments: processedFields
      };
    } catch (error) {
      return {
        success: false,
        error: `Error filling form: ${error.message}`
      };
    }
  })
});

// lib/v3/agent/tools/think.ts
var import_ai17 = require("ai");
var import_zod21 = require("zod");
var thinkTool = () => (0, import_ai17.tool)({
  description: `Use this tool to think through complex problems or plan a sequence of steps. This is for internal reasoning only and doesn't perform any actions. Use this to:

1. Plan a multi-step approach before taking action
2. Break down complex tasks
3. Reason through edge cases
4. Evaluate options when you're unsure what to do next

The output is only visible to you; use it to track your own reasoning process.`,
  inputSchema: import_zod21.z.object({
    reasoning: import_zod21.z.string().describe(
      "Your step-by-step reasoning or planning process. Be as detailed as needed."
    )
  }),
  execute: (_0) => __async(null, [_0], function* ({ reasoning }) {
    return {
      acknowledged: true,
      message: reasoning
    };
  })
});

// lib/v3/agent/tools/search.ts
var import_ai18 = require("ai");
var import_zod22 = require("zod");
function performBraveSearch(query) {
  return __async(this, null, function* () {
    var _a4;
    try {
      const encodedQuery = encodeURIComponent(query);
      const response = yield fetch(
        `https://api.search.brave.com/res/v1/web/search?q=${encodedQuery}`,
        {
          method: "GET",
          headers: {
            Accept: "application/json",
            "Accept-Encoding": "gzip",
            "X-Subscription-Token": process.env.BRAVE_API_KEY
          }
        }
      );
      if (!response.ok) {
        return {
          error: `Brave API error: ${response.status} ${response.statusText}`,
          data: { results: [] }
        };
      }
      const data = yield response.json();
      const results = [];
      if (((_a4 = data == null ? void 0 : data.web) == null ? void 0 : _a4.results) && Array.isArray(data.web.results)) {
        for (const item of data.web.results.slice(0, 5)) {
          if (item.title && item.url) {
            results.push({
              title: item.title,
              url: item.url,
              description: item.description
            });
          }
        }
      }
      return { data: { results } };
    } catch (error) {
      console.error("Search error", error);
      return {
        error: `Error performing search: ${error.message}`,
        data: { results: [] }
      };
    }
  });
}
var searchTool = (v3) => (0, import_ai18.tool)({
  description: "Perform a web search and returns results. Use this tool when you need information from the web or when you are unsure of the exact URL you want to navigate to. This can be used to find the ideal entry point, resulting in a task that is easier to complete due to starting further in the process.",
  inputSchema: import_zod22.z.object({
    query: import_zod22.z.string().describe("The search query to look for on the web")
  }),
  execute: (_0) => __async(null, [_0], function* ({ query }) {
    var _a4, _b, _c;
    v3.logger({
      category: "agent",
      message: `Agent calling tool: search`,
      level: 1,
      auxiliary: {
        arguments: {
          value: JSON.stringify({ query }),
          type: "string"
        }
      }
    });
    const result = yield performBraveSearch(query);
    v3.recordAgentReplayStep({
      type: "search",
      instruction: query,
      playwrightArguments: { query },
      message: (_c = result.error) != null ? _c : `Found ${(_b = (_a4 = result.data) == null ? void 0 : _a4.results.length) != null ? _b : 0} results`
    });
    return __spreadProps(__spreadValues({}, result), {
      timestamp: Date.now()
    });
  })
});

// lib/v3/agent/tools/index.ts
function filterTools(tools, mode, excludeTools) {
  const filtered = __spreadValues({}, tools);
  if (mode === "hybrid") {
    delete filtered.fillForm;
  } else {
    delete filtered.click;
    delete filtered.type;
    delete filtered.dragAndDrop;
    delete filtered.clickAndHold;
    delete filtered.fillFormVision;
  }
  if (excludeTools) {
    for (const toolName of excludeTools) {
      delete filtered[toolName];
    }
  }
  return filtered;
}
function createAgentTools(v3, options) {
  var _a4;
  const executionModel = options == null ? void 0 : options.executionModel;
  const mode = (_a4 = options == null ? void 0 : options.mode) != null ? _a4 : "dom";
  const provider = options == null ? void 0 : options.provider;
  const excludeTools = options == null ? void 0 : options.excludeTools;
  const allTools = {
    act: actTool(v3, executionModel),
    ariaTree: ariaTreeTool(v3),
    click: clickTool(v3, provider),
    clickAndHold: clickAndHoldTool(v3, provider),
    close: closeTool(),
    dragAndDrop: dragAndDropTool(v3, provider),
    extract: extractTool(v3, executionModel, options == null ? void 0 : options.logger),
    fillForm: fillFormTool(v3, executionModel),
    fillFormVision: fillFormVisionTool(v3, provider),
    goto: gotoTool(v3),
    keys: keysTool(v3),
    navback: navBackTool(v3),
    screenshot: screenshotTool(v3),
    scroll: mode === "hybrid" ? scrollVisionTool(v3, provider) : scrollTool(v3),
    think: thinkTool(),
    type: typeTool(v3, provider),
    wait: waitTool(v3)
  };
  if (process.env.BRAVE_API_KEY) {
    allTools.search = searchTool(v3);
  }
  return filterTools(allTools, mode, excludeTools);
}

// lib/v3/agent/prompts/agentSystemPrompt.ts
function buildToolsSection(isHybridMode, hasSearch, excludeTools) {
  const excludeSet = new Set(excludeTools != null ? excludeTools : []);
  const hybridTools = [
    {
      name: "screenshot",
      description: "Take a compressed JPEG screenshot for quick visual context"
    },
    {
      name: "ariaTree",
      description: "Get an accessibility (ARIA) hybrid tree for full page context"
    },
    {
      name: "click",
      description: "Click on an element (PREFERRED - more reliable when element is visible in viewport)"
    },
    {
      name: "type",
      description: "Type text into an element (PREFERRED - more reliable when element is visible in viewport)"
    },
    {
      name: "act",
      description: "Perform a specific atomic action (click, type, etc.) - ONLY use when element is in ariaTree but NOT visible in screenshot. Less reliable but can interact with out-of-viewport elements."
    },
    { name: "dragAndDrop", description: "Drag and drop an element" },
    { name: "clickAndHold", description: "Click and hold on an element" },
    { name: "keys", description: "Press a keyboard key" },
    {
      name: "fillFormVision",
      description: "Fill out a form using coordinates"
    },
    { name: "think", description: "Think about the task" },
    { name: "extract", description: "Extract structured data" },
    { name: "goto", description: "Navigate to a URL" },
    { name: "wait", description: "Wait for a specified time" },
    { name: "navback", description: "Navigate back in browser history" },
    { name: "scroll", description: "Scroll the page x pixels up or down" },
    { name: "close", description: "Mark the task as complete or failed" }
  ];
  const domTools = [
    {
      name: "screenshot",
      description: "Take a compressed JPEG screenshot for quick visual context"
    },
    {
      name: "ariaTree",
      description: "Get an accessibility (ARIA) hybrid tree for full page context"
    },
    {
      name: "act",
      description: "Perform a specific atomic action (click, type)"
    },
    { name: "keys", description: "Press a keyboard key" },
    { name: "fillForm", description: "Fill out a form" },
    { name: "think", description: "Think about the task" },
    { name: "extract", description: "Extract structured data" },
    { name: "goto", description: "Navigate to a URL" },
    { name: "wait", description: "Wait for a specified time" },
    { name: "navback", description: "Navigate back in browser history" },
    { name: "scroll", description: "Scroll the page x pixels up or down" },
    { name: "close", description: "Mark the task as complete or failed" }
  ];
  const baseTools = isHybridMode ? hybridTools : domTools;
  if (hasSearch) {
    baseTools.push({
      name: "search",
      description: "Perform a web search and return results. Prefer this over navigating to Google and searching within the page for reliability and efficiency."
    });
  }
  const filteredTools = baseTools.filter((tool21) => !excludeSet.has(tool21.name));
  const toolLines = filteredTools.map((tool21) => `    <tool name="${tool21.name}">${tool21.description}</tool>`).join("\n");
  return `<tools>
${toolLines}
  </tools>`;
}
function buildAgentSystemPrompt(options) {
  const {
    url,
    executionInstruction,
    mode,
    systemInstructions,
    isBrowserbase = false,
    excludeTools
  } = options;
  const localeDate = (/* @__PURE__ */ new Date()).toLocaleDateString();
  const isoDate = (/* @__PURE__ */ new Date()).toISOString();
  const cdata = (text) => `<![CDATA[${text}]]>`;
  const isHybridMode = mode === "hybrid";
  const hasSearch = Boolean(process.env.BRAVE_API_KEY);
  const toolsSection = buildToolsSection(isHybridMode, hasSearch, excludeTools);
  const strategyItems = isHybridMode ? [
    `<item>Tool selection priority: Use specific tools (click, type) when elements are visible in viewport for maximum reliability.</item>`,
    `<item>Always use screenshot to get proper grounding of the coordinates you want to type/click into.</item>`,
    `<item>When interacting with an input, always use the type tool to type into the input, over clicking and then typing into it.</item>`,
    `<item>Use ariaTree as a secondary tool when elements aren't visible in screenshot or to get full page context.</item>`,
    `<item>Only use act when element is in ariaTree but NOT visible in screenshot.</item>`
  ] : [
    `<item>Tool selection priority: Use act tool for all clicking and typing on a page.</item>`,
    `<item>Always check ariaTree first to understand full page content without scrolling - it shows all elements including those below the fold.</item>`,
    `<item>When interacting with an input, always use the act tool to type into the input, over clicking and then typing.</item>`,
    `<item>If an element is present in the ariaTree, use act to interact with it directly - this eliminates the need to scroll.</item>`,
    `<item>Use screenshot for visual confirmation when needed, but rely primarily on ariaTree for element detection.</item>`
  ];
  const strategySection = strategyItems.join("\n    ");
  const commonStrategyItems = `
    <item>CRITICAL: Use extract ONLY when the task explicitly requires structured data output (e.g., "get job listings", "extract product details"). For reading page content or understanding elements, always use ${isHybridMode ? "screenshot or ariaTree" : "ariaTree"} instead - it's faster and more reliable.</item>
    <item>Keep actions atomic and verify outcomes before proceeding.</item>
    <item>For each action, provide clear reasoning about why you're taking that step.</item>
    <item>When you need to input text that could be entered character-by-character or through multiple separate inputs, prefer using the keys tool to type the entire sequence at once. This is more efficient for scenarios like verification codes split across multiple fields, or when virtual keyboards are present but direct typing would be faster.</item>
    `;
  const pageUnderstandingProtocol = isHybridMode ? `<page_understanding_protocol>
    <step_1>
      <title>UNDERSTAND THE PAGE</title>
      <primary_tool>
        <name>screenshot</name>
        <usage>Visual confirmation when needed. Ideally after navigating to a new page.</usage>
        </primary_tool>
      <secondary_tool>
        <name>ariaTree</name>
        <usage>Get complete page context before taking actions</usage>
        <benefit>Eliminates the need to scroll and provides full accessible content</benefit>
      </secondary_tool>
    </step_1>
  </page_understanding_protocol>` : `<page_understanding_protocol>
    <step_1>
      <title>UNDERSTAND THE PAGE</title>
      <primary_tool>
        <name>ariaTree</name>
        <usage>Get complete page context before taking actions</usage>
        <benefit>Eliminates the need to scroll and provides full accessible content</benefit>
        </primary_tool>
      <secondary_tool>
        <name>screenshot</name>
        <usage>Visual confirmation when needed. Ideally after navigating to a new page.</usage>
      </secondary_tool>
    </step_1>
  </page_understanding_protocol>`;
  const roadblocksSection = isBrowserbase ? `<roadblocks>
    <note>captchas, popups, etc.</note>
    <captcha>If you see a captcha, use the wait tool. It will automatically be solved by our internal solver.</captcha>
  </roadblocks>` : "";
  const customInstructionsBlock = systemInstructions ? `<customInstructions>${cdata(systemInstructions)}</customInstructions>
  ` : "";
  return `<system>
  <identity>You are a web automation assistant using browser automation tools to accomplish the user's goal.</identity>
  ${customInstructionsBlock}<task>
    <goal>${cdata(executionInstruction)}</goal>
    <date display="local" iso="${isoDate}">${localeDate}</date>
    <note>You may think the date is different due to knowledge cutoff, but this is the actual date.</note>
  </task>
  <page>
    <startingUrl>you are starting your task on this url: ${url}</startingUrl>
  </page>
  <mindset>
    <note>Be very intentional about your action. The initial instruction is very important, and slight variations of the actual goal can lead to failures.</note>
    <importantNote>If something fails to meet a single condition of the task, move on from it rather than seeing if it meets other criteria. We only care that it meets all of it</importantNote>
    <note>When the task is complete, do not seek more information; you have completed the task.</note>
  </mindset>
  <guidelines>
    <item>Always start by understanding the current page state</item>
    <item>Use the screenshot tool to verify page state when needed</item>
    <item>Use appropriate tools for each action</item>
    <item>When the task is complete, use the "close" tool with taskComplete: true</item>
    <item>If the task cannot be completed, use "close" with taskComplete: false</item>
  </guidelines>
  ${pageUnderstandingProtocol}
  <navigation>
    <rule>If you are confident in the URL, navigate directly to it.</rule>
    ${hasSearch ? `<rule>If you are not confident in the URL, use the search tool to find it.</rule>` : ``}
  </navigation>
  ${toolsSection}
  <strategy>
    ${strategySection}
    ${commonStrategyItems}
  </strategy>
  ${roadblocksSection}
  <completion>
    <note>When you complete the task, explain any information that was found that was relevant to the original task.</note>
    <examples>
      <example>If you were asked for specific flights, list the flights you found.</example>
      <example>If you were asked for information about a product, list the product information you were asked for.</example>
    </examples>
  </completion>
</system>`;
}

// lib/v3/handlers/v3AgentHandler.ts
var import_ai19 = require("ai");

// lib/v3/agent/utils/messageProcessing.ts
function isToolMessage(message) {
  return !!message && typeof message === "object" && message.role === "tool" && Array.isArray(message.content);
}
function isScreenshotPart(part) {
  return !!part && typeof part === "object" && part.toolName === "screenshot";
}
function isAriaTreePart(part) {
  return !!part && typeof part === "object" && part.toolName === "ariaTree";
}
function processMessages(params) {
  const originalContentSize = JSON.stringify(params.prompt).length;
  const screenshotIndices = findToolIndices(params.prompt, "screenshot");
  const ariaTreeIndices = findToolIndices(params.prompt, "ariaTree");
  const processedPrompt = params.prompt.map(
    (message, index) => {
      if (isToolMessage(message)) {
        if (message.content.some((part) => isScreenshotPart(part))) {
          const shouldCompress = shouldCompressScreenshot(
            index,
            screenshotIndices
          );
          if (shouldCompress) {
            return compressScreenshotMessage(message);
          }
        }
        if (message.content.some((part) => isAriaTreePart(part))) {
          const shouldCompress = shouldCompressAriaTree(index, ariaTreeIndices);
          if (shouldCompress) {
            return compressAriaTreeMessage(message);
          }
        }
      }
      return message;
    }
  );
  const compressedContentSize = JSON.stringify(processedPrompt).length;
  const stats = calculateCompressionStats(
    originalContentSize,
    compressedContentSize,
    screenshotIndices.length,
    ariaTreeIndices.length
  );
  return {
    processedPrompt,
    stats
  };
}
function findToolIndices(prompt, toolName) {
  const screenshotIndices = [];
  prompt.forEach((message, index) => {
    if (isToolMessage(message)) {
      const hasMatch = message.content.some(
        (part) => toolName === "screenshot" ? isScreenshotPart(part) : isAriaTreePart(part)
      );
      if (hasMatch) {
        screenshotIndices.push(index);
      }
    }
  });
  return screenshotIndices;
}
function shouldCompressScreenshot(index, screenshotIndices) {
  const isNewestScreenshot = index === Math.max(...screenshotIndices);
  const isSecondNewestScreenshot = screenshotIndices.length > 1 && index === screenshotIndices.sort((a, b) => b - a)[1];
  return !isNewestScreenshot && !isSecondNewestScreenshot;
}
function shouldCompressAriaTree(index, ariaTreeIndices) {
  const isNewestAriaTree = index === Math.max(...ariaTreeIndices);
  return !isNewestAriaTree;
}
function compressScreenshotMessage(message) {
  const updatedContent = message.content.map((part) => {
    if (isScreenshotPart(part)) {
      return __spreadProps(__spreadValues({}, part), {
        result: [
          {
            type: "text",
            text: "screenshot taken"
          }
        ]
      });
    }
    return part;
  });
  return __spreadProps(__spreadValues({}, message), {
    content: updatedContent
  });
}
function compressAriaTreeMessage(message) {
  const updatedContent = message.content.map((part) => {
    if (isAriaTreePart(part)) {
      return __spreadProps(__spreadValues({}, part), {
        result: [
          {
            type: "text",
            text: "ARIA tree extracted for context of page elements"
          }
        ]
      });
    }
    return part;
  });
  return __spreadProps(__spreadValues({}, message), {
    content: updatedContent
  });
}
function calculateCompressionStats(originalSize, compressedSize, screenshotCount, ariaTreeCount) {
  const savedChars = originalSize - compressedSize;
  const compressionRatio = originalSize > 0 ? (originalSize - compressedSize) / originalSize * 100 : 0;
  return {
    originalSize,
    compressedSize,
    savedChars,
    compressionRatio,
    screenshotCount,
    ariaTreeCount
  };
}

// lib/v3/handlers/v3AgentHandler.ts
init_flowLogger();

// lib/v3/agent/utils/actionMapping.ts
function mapToolResultToActions({
  toolCallName,
  toolResult,
  args,
  reasoning
}) {
  switch (toolCallName) {
    case "act":
      return mapActToolResult(toolResult, args, reasoning);
    case "fillForm":
      return mapFillFormToolResult(toolResult, args, reasoning);
    default:
      return [createStandardAction(toolCallName, toolResult, args, reasoning)];
  }
}
function mapActToolResult(toolResult, args, reasoning) {
  if (!toolResult || typeof toolResult !== "object") {
    return [createStandardAction("act", toolResult, args, reasoning)];
  }
  const result = toolResult;
  const output = result.output || result;
  const action = __spreadValues({
    type: "act",
    reasoning,
    taskCompleted: false
  }, args);
  if (output.playwrightArguments) {
    action.playwrightArguments = output.playwrightArguments;
  }
  return [action];
}
function mapFillFormToolResult(toolResult, args, reasoning) {
  if (!toolResult || typeof toolResult !== "object") {
    return [createStandardAction("fillForm", toolResult, args, reasoning)];
  }
  const result = toolResult;
  const output = result.output || result;
  const observeResults = Array.isArray(output == null ? void 0 : output.playwrightArguments) ? output.playwrightArguments : [];
  const actions = [];
  actions.push(__spreadValues({
    type: "fillForm",
    reasoning,
    taskCompleted: false
  }, args));
  for (const observeResult of observeResults) {
    actions.push({
      type: "act",
      reasoning: "acting from fillform tool",
      taskCompleted: false,
      playwrightArguments: observeResult
    });
  }
  return actions;
}
function createStandardAction(toolCallName, toolResult, args, reasoning) {
  const action = __spreadValues({
    type: toolCallName,
    reasoning,
    taskCompleted: toolCallName === "close" ? args == null ? void 0 : args.taskComplete : false
  }, args);
  if (toolCallName === "screenshot") {
    action.result = "screenshotTaken";
    return action;
  }
  if (toolCallName !== "ariaTree" && toolResult) {
    const { output } = toolResult;
    Object.assign(action, output);
  }
  return action;
}

// lib/v3/handlers/v3AgentHandler.ts
init_sdkErrors();
function getErrorMessage(error) {
  return error instanceof Error ? error.message : String(error);
}
var V3AgentHandler = class {
  constructor(v3, logger, llmClient, executionModel, systemInstructions, mcpTools, mode) {
    this.v3 = v3;
    this.logger = logger;
    this.llmClient = llmClient;
    this.executionModel = executionModel;
    this.systemInstructions = systemInstructions;
    this.mcpTools = mcpTools;
    this.mode = mode != null ? mode : "dom";
  }
  prepareAgent(instructionOrOptions) {
    return __async(this, null, function* () {
      var _a4, _b;
      try {
        const options = typeof instructionOrOptions === "string" ? { instruction: instructionOrOptions } : instructionOrOptions;
        const maxSteps = options.maxSteps || 20;
        const initialPageUrl = (yield this.v3.context.awaitActivePage()).url();
        const systemPrompt = buildAgentSystemPrompt({
          url: initialPageUrl,
          executionInstruction: options.instruction,
          mode: this.mode,
          systemInstructions: this.systemInstructions,
          isBrowserbase: this.v3.isBrowserbase,
          excludeTools: options.excludeTools
        });
        const tools = this.createTools(options.excludeTools);
        const allTools = __spreadValues(__spreadValues({}, tools), this.mcpTools);
        const messages = ((_a4 = options.messages) == null ? void 0 : _a4.length) ? [...options.messages, { role: "user", content: options.instruction }] : [{ role: "user", content: options.instruction }];
        if (!((_b = this.llmClient) == null ? void 0 : _b.getLanguageModel)) {
          throw new MissingLLMConfigurationError();
        }
        const baseModel = this.llmClient.getLanguageModel();
        const wrappedModel = (0, import_ai19.wrapLanguageModel)({
          model: baseModel,
          middleware: __spreadValues({
            transformParams: (_0) => __async(this, [_0], function* ({ params }) {
              const { processedPrompt } = processMessages(params);
              return __spreadProps(__spreadValues({}, params), { prompt: processedPrompt });
            })
          }, SessionFileLogger.createLlmLoggingMiddleware(baseModel.modelId))
        });
        return {
          options,
          maxSteps,
          systemPrompt,
          allTools,
          messages,
          wrappedModel,
          initialPageUrl
        };
      } catch (error) {
        this.logger({
          category: "agent",
          message: `failed to prepare agent: ${error}`,
          level: 0
        });
        throw error;
      }
    });
  }
  createStepHandler(state, userCallback) {
    return (event) => __async(this, null, function* () {
      var _a4;
      this.logger({
        category: "agent",
        message: `Step finished: ${event.finishReason}`,
        level: 2
      });
      if (event.toolCalls && event.toolCalls.length > 0) {
        for (let i2 = 0; i2 < event.toolCalls.length; i2++) {
          const toolCall = event.toolCalls[i2];
          const args = toolCall.input;
          const toolResult = (_a4 = event.toolResults) == null ? void 0 : _a4[i2];
          if (event.text && event.text.length > 0) {
            state.collectedReasoning.push(event.text);
            this.logger({
              category: "agent",
              message: `reasoning: ${event.text}`,
              level: 1
            });
          }
          if (toolCall.toolName === "close") {
            state.completed = true;
            if (args == null ? void 0 : args.taskComplete) {
              const closeReasoning = args.reasoning;
              const allReasoning = state.collectedReasoning.join(" ");
              state.finalMessage = closeReasoning ? `${allReasoning} ${closeReasoning}`.trim() : allReasoning || "Task completed successfully";
            }
          }
          const mappedActions = mapToolResultToActions({
            toolCallName: toolCall.toolName,
            toolResult,
            args,
            reasoning: event.text || void 0
          });
          for (const action of mappedActions) {
            action.pageUrl = state.currentPageUrl;
            action.timestamp = Date.now();
            state.actions.push(action);
          }
        }
        state.currentPageUrl = (yield this.v3.context.awaitActivePage()).url();
        if (process.env.EVALS === "true") {
          try {
            yield this.captureAndEmitScreenshot();
          } catch (e2) {
            this.logger({
              category: "agent",
              message: `Warning: Failed to capture screenshot: ${getErrorMessage(e2)}`,
              level: 1
            });
          }
        }
      }
      if (userCallback) {
        yield userCallback(event);
      }
    });
  }
  execute(instructionOrOptions) {
    return __async(this, null, function* () {
      var _a4;
      const startTime = Date.now();
      const options = typeof instructionOrOptions === "object" ? instructionOrOptions : null;
      const signal = options == null ? void 0 : options.signal;
      const shouldHighlightCursor = (_a4 = options == null ? void 0 : options.highlightCursor) != null ? _a4 : this.mode === "hybrid";
      const state = {
        collectedReasoning: [],
        actions: [],
        finalMessage: "",
        completed: false,
        currentPageUrl: ""
      };
      let messages = [];
      try {
        const {
          options: preparedOptions,
          maxSteps,
          systemPrompt,
          allTools,
          messages: preparedMessages,
          wrappedModel,
          initialPageUrl
        } = yield this.prepareAgent(instructionOrOptions);
        if (shouldHighlightCursor && this.mode === "hybrid") {
          const page = yield this.v3.context.awaitActivePage();
          yield page.enableCursorOverlay().catch(() => {
          });
        }
        messages = preparedMessages;
        state.currentPageUrl = initialPageUrl;
        const callbacks = instructionOrOptions.callbacks;
        if (callbacks) {
          const streamingOnlyCallbacks = [
            "onChunk",
            "onFinish",
            "onError",
            "onAbort"
          ];
          const invalidCallbacks = streamingOnlyCallbacks.filter(
            (name) => callbacks[name] != null
          );
          if (invalidCallbacks.length > 0) {
            throw new StreamingCallbacksInNonStreamingModeError(invalidCallbacks);
          }
        }
        const result = yield this.llmClient.generateText({
          model: wrappedModel,
          system: systemPrompt,
          messages,
          tools: allTools,
          stopWhen: (result2) => this.handleStop(result2, maxSteps),
          temperature: 1,
          toolChoice: "auto",
          prepareStep: callbacks == null ? void 0 : callbacks.prepareStep,
          onStepFinish: this.createStepHandler(state, callbacks == null ? void 0 : callbacks.onStepFinish),
          abortSignal: preparedOptions.signal,
          providerOptions: wrappedModel.modelId.includes("gemini-3") ? {
            google: {
              mediaResolution: "MEDIA_RESOLUTION_HIGH"
            }
          } : void 0
        });
        return this.consolidateMetricsAndResult(
          startTime,
          state,
          messages,
          result
        );
      } catch (error) {
        if (error instanceof StreamingCallbacksInNonStreamingModeError) {
          throw error;
        }
        if (signal == null ? void 0 : signal.aborted) {
          const reason = signal.reason ? String(signal.reason) : "aborted";
          throw new AgentAbortError(reason);
        }
        const errorMessage = getErrorMessage(error);
        this.logger({
          category: "agent",
          message: `Error executing agent task: ${errorMessage}`,
          level: 0
        });
        return {
          success: false,
          actions: state.actions,
          message: `Failed to execute task: ${errorMessage}`,
          completed: false,
          messages
        };
      }
    });
  }
  stream(instructionOrOptions) {
    return __async(this, null, function* () {
      var _a4;
      const streamOptions = typeof instructionOrOptions === "object" ? instructionOrOptions : null;
      const shouldHighlightCursor = (_a4 = streamOptions == null ? void 0 : streamOptions.highlightCursor) != null ? _a4 : this.mode === "hybrid";
      const {
        options,
        maxSteps,
        systemPrompt,
        allTools,
        messages,
        wrappedModel,
        initialPageUrl
      } = yield this.prepareAgent(instructionOrOptions);
      if (shouldHighlightCursor && this.mode === "hybrid") {
        const page = yield this.v3.context.awaitActivePage();
        yield page.enableCursorOverlay().catch(() => {
        });
      }
      const callbacks = instructionOrOptions.callbacks;
      const state = {
        collectedReasoning: [],
        actions: [],
        finalMessage: "",
        completed: false,
        currentPageUrl: initialPageUrl
      };
      const startTime = Date.now();
      let resolveResult;
      let rejectResult;
      const resultPromise = new Promise((resolve3, reject) => {
        resolveResult = resolve3;
        rejectResult = reject;
      });
      const handleError = (error) => {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger({
          category: "agent",
          message: `Error during streaming: ${errorMessage}`,
          level: 0
        });
        rejectResult(error);
      };
      const streamResult = this.llmClient.streamText({
        model: wrappedModel,
        system: systemPrompt,
        messages,
        tools: allTools,
        stopWhen: (result) => this.handleStop(result, maxSteps),
        temperature: 1,
        toolChoice: "auto",
        prepareStep: callbacks == null ? void 0 : callbacks.prepareStep,
        onStepFinish: this.createStepHandler(state, callbacks == null ? void 0 : callbacks.onStepFinish),
        onError: (event) => {
          if (callbacks == null ? void 0 : callbacks.onError) {
            callbacks.onError(event);
          }
          handleError(event.error);
        },
        onChunk: callbacks == null ? void 0 : callbacks.onChunk,
        onFinish: (event) => {
          if (callbacks == null ? void 0 : callbacks.onFinish) {
            callbacks.onFinish(event);
          }
          const result = this.consolidateMetricsAndResult(
            startTime,
            state,
            messages,
            event
          );
          resolveResult(result);
        },
        onAbort: (event) => {
          var _a5;
          if (callbacks == null ? void 0 : callbacks.onAbort) {
            callbacks.onAbort(event);
          }
          const reason = ((_a5 = options.signal) == null ? void 0 : _a5.reason) ? String(options.signal.reason) : "Stream was aborted";
          rejectResult(new AgentAbortError(reason));
        },
        abortSignal: options.signal,
        providerOptions: wrappedModel.modelId.includes("gemini-3") ? {
          google: {
            mediaResolution: "MEDIA_RESOLUTION_HIGH"
          }
        } : void 0
      });
      const agentStreamResult = streamResult;
      agentStreamResult.result = resultPromise;
      return agentStreamResult;
    });
  }
  consolidateMetricsAndResult(startTime, state, inputMessages, result) {
    var _a4;
    if (!state.finalMessage) {
      const allReasoning = state.collectedReasoning.join(" ").trim();
      state.finalMessage = allReasoning || result.text || "";
    }
    const endTime = Date.now();
    const inferenceTimeMs = endTime - startTime;
    if (result.usage) {
      this.v3.updateMetrics(
        "AGENT" /* AGENT */,
        result.usage.inputTokens || 0,
        result.usage.outputTokens || 0,
        result.usage.reasoningTokens || 0,
        result.usage.cachedInputTokens || 0,
        inferenceTimeMs
      );
    }
    const responseMessages = ((_a4 = result.response) == null ? void 0 : _a4.messages) || [];
    const fullMessages = [
      ...inputMessages,
      ...responseMessages
    ];
    return {
      success: state.completed,
      message: state.finalMessage || "Task execution completed",
      actions: state.actions,
      completed: state.completed,
      usage: result.usage ? {
        input_tokens: result.usage.inputTokens || 0,
        output_tokens: result.usage.outputTokens || 0,
        reasoning_tokens: result.usage.reasoningTokens || 0,
        cached_input_tokens: result.usage.cachedInputTokens || 0,
        inference_time_ms: inferenceTimeMs
      } : void 0,
      messages: fullMessages
    };
  }
  createTools(excludeTools) {
    var _a4, _b, _c;
    const provider = (_c = (_b = (_a4 = this.llmClient) == null ? void 0 : _a4.getLanguageModel) == null ? void 0 : _b.call(_a4)) == null ? void 0 : _c.provider;
    return createAgentTools(this.v3, {
      executionModel: this.executionModel,
      logger: this.logger,
      mode: this.mode,
      provider,
      excludeTools
    });
  }
  handleStop(result, maxSteps) {
    var _a4;
    const lastStep = result.steps[result.steps.length - 1];
    if ((_a4 = lastStep == null ? void 0 : lastStep.toolCalls) == null ? void 0 : _a4.some((tc) => tc.toolName === "close")) {
      return true;
    }
    return (0, import_ai19.stepCountIs)(maxSteps)(result);
  }
  /**
   * Capture a screenshot and emit it via the event bus
   */
  captureAndEmitScreenshot() {
    return __async(this, null, function* () {
      try {
        const page = yield this.v3.context.awaitActivePage();
        const screenshot = yield page.screenshot({ fullPage: false });
        this.v3.bus.emit("agent_screensot_taken_event", screenshot);
      } catch (error) {
        this.logger({
          category: "agent",
          message: `Error capturing screenshot: ${getErrorMessage(error)}`,
          level: 0
        });
      }
    });
  }
};

// lib/v3/handlers/v3CuaAgentHandler.ts
init_snapshot();

// lib/v3/agent/AgentProvider.ts
init_sdkErrors();

// lib/v3/agent/AnthropicCUAClient.ts
init_sdkErrors();
var import_sdk = __toESM(require("@anthropic-ai/sdk"));

// lib/v3/agent/AgentClient.ts
var AgentClient = class {
  constructor(type, modelName, userProvidedInstructions) {
    this.type = type;
    this.modelName = modelName;
    this.userProvidedInstructions = userProvidedInstructions;
    this.clientOptions = {};
  }
};

// lib/v3/agent/utils/imageCompression.ts
function findItemsWithImages(items) {
  const itemsWithImages = [];
  items.forEach((item, index) => {
    let hasImage = false;
    if (Array.isArray(item.content)) {
      hasImage = item.content.some(
        (contentItem) => contentItem.type === "tool_result" && "content" in contentItem && Array.isArray(contentItem.content) && contentItem.content.some(
          (nestedItem) => nestedItem.type === "image"
        )
      );
    }
    if (hasImage) {
      itemsWithImages.push(index);
    }
  });
  return itemsWithImages;
}
function compressConversationImages(items, keepMostRecentCount = 2) {
  const itemsWithImages = findItemsWithImages(items);
  items.forEach((item, index) => {
    const imageIndex = itemsWithImages.indexOf(index);
    const shouldCompress = imageIndex >= 0 && imageIndex < itemsWithImages.length - keepMostRecentCount;
    if (shouldCompress) {
      if (Array.isArray(item.content)) {
        item.content = item.content.map(
          (contentItem) => {
            if (contentItem.type === "tool_result" && "content" in contentItem && Array.isArray(contentItem.content) && contentItem.content.some(
              (nestedItem) => nestedItem.type === "image"
            )) {
              return __spreadProps(__spreadValues({}, contentItem), {
                content: "screenshot taken"
              });
            }
            return contentItem;
          }
        );
      }
    }
  });
  return {
    items
  };
}
function findGoogleItemsWithImages(items) {
  const itemsWithImages = [];
  items.forEach((item, index) => {
    let hasImage = false;
    if (item.parts && Array.isArray(item.parts)) {
      hasImage = item.parts.some((part) => {
        var _a4, _b, _c, _d2, _e;
        if ((_b = (_a4 = part.functionResponse) == null ? void 0 : _a4.response) == null ? void 0 : _b.data) {
          const data = part.functionResponse.response.data;
          return data.some(
            (dataItem) => {
              var _a5, _b2;
              return (_b2 = (_a5 = dataItem.inlineData) == null ? void 0 : _a5.mimeType) == null ? void 0 : _b2.startsWith("image/");
            }
          );
        }
        if ((_c = part.functionResponse) == null ? void 0 : _c.parts) {
          return part.functionResponse.parts.some(
            (responsePart) => {
              var _a5, _b2;
              return (_b2 = (_a5 = responsePart.inlineData) == null ? void 0 : _a5.mimeType) == null ? void 0 : _b2.startsWith("image/");
            }
          );
        }
        return (_e = (_d2 = part.inlineData) == null ? void 0 : _d2.mimeType) == null ? void 0 : _e.startsWith("image/");
      });
    }
    if (hasImage) {
      itemsWithImages.push(index);
    }
  });
  return itemsWithImages;
}
function compressGoogleConversationImages(items, keepMostRecentCount = 2) {
  const itemsWithImages = findGoogleItemsWithImages(items);
  items.forEach((item, index) => {
    const imageIndex = itemsWithImages.indexOf(index);
    const shouldCompress = imageIndex >= 0 && imageIndex < itemsWithImages.length - keepMostRecentCount;
    if (shouldCompress && item.parts && Array.isArray(item.parts)) {
      item.parts = item.parts.map((part) => {
        var _a4, _b, _c, _d2, _e;
        if ((_b = (_a4 = part.functionResponse) == null ? void 0 : _a4.response) == null ? void 0 : _b.data) {
          const data = part.functionResponse.response.data;
          const hasImage = data.some(
            (dataItem) => {
              var _a5, _b2;
              return (_b2 = (_a5 = dataItem.inlineData) == null ? void 0 : _a5.mimeType) == null ? void 0 : _b2.startsWith("image/");
            }
          );
          if (hasImage) {
            return __spreadProps(__spreadValues({}, part), {
              functionResponse: __spreadProps(__spreadValues({}, part.functionResponse), {
                data: [],
                response: __spreadProps(__spreadValues({}, part.functionResponse.response), {
                  compressed: "screenshot taken"
                })
              })
            });
          }
        }
        if ((_c = part.functionResponse) == null ? void 0 : _c.parts) {
          const hasImageInParts = part.functionResponse.parts.some(
            (responsePart) => {
              var _a5, _b2;
              return (_b2 = (_a5 = responsePart.inlineData) == null ? void 0 : _a5.mimeType) == null ? void 0 : _b2.startsWith("image/");
            }
          );
          if (hasImageInParts) {
            return __spreadProps(__spreadValues({}, part), {
              functionResponse: __spreadProps(__spreadValues({}, part.functionResponse), {
                parts: part.functionResponse.parts.filter(
                  (responsePart) => {
                    var _a5, _b2;
                    return !((_b2 = (_a5 = responsePart.inlineData) == null ? void 0 : _a5.mimeType) == null ? void 0 : _b2.startsWith("image/"));
                  }
                ),
                response: __spreadProps(__spreadValues({}, part.functionResponse.response), {
                  compressed: "screenshot taken"
                })
              })
            });
          }
        }
        if ((_e = (_d2 = part.inlineData) == null ? void 0 : _d2.mimeType) == null ? void 0 : _e.startsWith("image/")) {
          return {
            text: "screenshot taken"
          };
        }
        return part;
      });
    }
  });
  return {
    items
  };
}

// lib/v3/agent/AnthropicCUAClient.ts
init_flowLogger();
var import_uuid2 = require("uuid");
var AnthropicCUAClient = class extends AgentClient {
  constructor(type, modelName, userProvidedInstructions, clientOptions, tools) {
    super(type, modelName, userProvidedInstructions);
    this.currentViewport = { width: 1288, height: 711 };
    this.thinkingBudget = null;
    this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.ANTHROPIC_API_KEY || "";
    this.baseURL = (clientOptions == null ? void 0 : clientOptions.baseURL) || void 0;
    if ((clientOptions == null ? void 0 : clientOptions.thinkingBudget) && typeof clientOptions.thinkingBudget === "number") {
      this.thinkingBudget = clientOptions.thinkingBudget;
    }
    this.clientOptions = {
      apiKey: this.apiKey
    };
    if (this.baseURL) {
      this.clientOptions.baseURL = this.baseURL;
    }
    this.client = new import_sdk.default(this.clientOptions);
    this.tools = tools;
  }
  setViewport(width, height) {
    this.currentViewport = { width, height };
  }
  setCurrentUrl(url) {
    this.currentUrl = url;
  }
  setScreenshotProvider(provider) {
    this.screenshotProvider = provider;
  }
  setActionHandler(handler) {
    this.actionHandler = handler;
  }
  setTools(tools) {
    this.tools = tools;
  }
  /**
   * Execute a task with the Anthropic CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */
  execute(executionOptions) {
    return __async(this, null, function* () {
      const { options, logger } = executionOptions;
      const { instruction } = options;
      const maxSteps = options.maxSteps || 10;
      let currentStep = 0;
      let completed = false;
      const actions = [];
      const messageList = [];
      let finalMessage = "";
      let inputItems = this.createInitialInputItems(instruction);
      logger({
        category: "agent",
        message: `Starting Anthropic agent execution with instruction: ${instruction}`,
        level: 1
      });
      let totalInputTokens = 0;
      let totalOutputTokens = 0;
      let totalInferenceTime = 0;
      try {
        while (!completed && currentStep < maxSteps) {
          logger({
            category: "agent",
            message: `Executing step ${currentStep + 1}/${maxSteps}`,
            level: 1
          });
          const result = yield this.executeStep(inputItems, logger);
          totalInputTokens += result.usage.input_tokens;
          totalOutputTokens += result.usage.output_tokens;
          totalInferenceTime += result.usage.inference_time_ms;
          if (result.actions.length > 0) {
            logger({
              category: "agent",
              message: `Step ${currentStep + 1} performed ${result.actions.length} actions`,
              level: 2
            });
            actions.push(...result.actions);
          }
          completed = result.completed;
          if (!completed) {
            inputItems = result.nextInputItems;
          }
          if (result.message) {
            messageList.push(result.message);
            finalMessage = result.message;
          }
          currentStep++;
        }
        logger({
          category: "agent",
          message: `Anthropic agent execution completed: ${completed}, with ${actions.length} total actions performed`,
          level: 1
        });
        return {
          success: completed,
          actions,
          message: finalMessage,
          completed,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing agent task: ${errorMessage}`,
          level: 0
        });
        return {
          success: false,
          actions,
          message: `Failed to execute task: ${errorMessage}`,
          completed: false,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      }
    });
  }
  executeStep(inputItems, logger) {
    return __async(this, null, function* () {
      try {
        const result = yield this.getAction(inputItems);
        const content = result.content;
        const usage = {
          input_tokens: result.usage.input_tokens,
          output_tokens: result.usage.output_tokens,
          inference_time_ms: result.usage.inference_time_ms
        };
        logger({
          category: "agent",
          message: `Received response with ${content.length} content blocks`,
          level: 2
        });
        const stepActions = [];
        const toolUseItems = [];
        let message = "";
        for (const block of content) {
          logger({
            category: "agent",
            message: `Processing block type: ${block.type}, id: ${block.id || "unknown"}`,
            level: 2
          });
          if (block.type === "tool_use") {
            logger({
              category: "agent",
              message: `Found tool_use block: ${JSON.stringify(block)}`,
              level: 2
            });
            const toolUseItem = block;
            toolUseItems.push(toolUseItem);
            logger({
              category: "agent",
              message: `Added tool_use item: ${toolUseItem.name}, action: ${JSON.stringify(toolUseItem.input)}`,
              level: 2
            });
            const action = this.convertToolUseToAction(toolUseItem);
            if (action) {
              logger({
                category: "agent",
                message: `Created action from tool_use: ${toolUseItem.name}, action: ${action.type}`,
                level: 2
              });
              stepActions.push(action);
            } else if (this.tools && toolUseItem.name in this.tools) {
              stepActions.push({
                type: "custom_tool",
                tool: toolUseItem.name,
                input: toolUseItem.input
              });
            }
          } else if (block.type === "text") {
            const textBlock = block;
            message += textBlock.text + "\n";
            logger({
              category: "agent",
              message: `Found text block: ${textBlock.text}`,
              level: 2
            });
          } else {
            logger({
              category: "agent",
              message: `Found unknown block type: ${block.type}`,
              level: 2
            });
          }
        }
        if (this.actionHandler && stepActions.length > 0) {
          for (const action of stepActions) {
            try {
              logger({
                category: "agent",
                message: `Executing action: ${action.type}`,
                level: 1
              });
              yield this.actionHandler(action);
            } catch (error) {
              if (error instanceof StagehandClosedError) {
                throw error;
              }
              const errorMessage = error instanceof Error ? error.message : String(error);
              logger({
                category: "agent",
                message: `Error executing action ${action.type}: ${errorMessage}`,
                level: 0
              });
            }
          }
        }
        const assistantMessage = {
          role: "assistant",
          content
        };
        const nextInputItems = [...inputItems];
        compressConversationImages(nextInputItems);
        nextInputItems.push(assistantMessage);
        if (toolUseItems.length > 0) {
          const toolResults = yield this.takeAction(toolUseItems, logger);
          if (toolResults.length > 0) {
            const userToolResultsMessage = {
              role: "user",
              content: toolResults
            };
            nextInputItems.push(userToolResultsMessage);
          }
        }
        const completed = toolUseItems.length === 0;
        logger({
          category: "agent",
          message: `Step processed ${toolUseItems.length} tool use items, completed: ${completed}`,
          level: 2
        });
        return {
          actions: stepActions,
          message: message.trim(),
          completed,
          nextInputItems,
          usage
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing step: ${errorMessage}`,
          level: 0
        });
        throw error;
      }
    });
  }
  createInitialInputItems(instruction) {
    return [
      {
        role: "system",
        content: this.userProvidedInstructions
      },
      {
        role: "user",
        content: instruction
      }
    ];
  }
  getAction(inputItems) {
    return __async(this, null, function* () {
      try {
        const messages = [];
        for (const item of inputItems) {
          if ("role" in item) {
            if (item.role !== "system") {
              messages.push(item);
            }
          }
        }
        const thinking = this.thinkingBudget ? { type: "enabled", budget_tokens: this.thinkingBudget } : void 0;
        const requestParams = {
          model: this.modelName,
          max_tokens: 4096,
          messages,
          tools: [
            {
              type: "computer_20250124",
              // Use the latest version for Claude 3.7 Sonnet
              name: "computer",
              display_width_px: this.currentViewport.width,
              display_height_px: this.currentViewport.height,
              display_number: 1
            }
          ],
          betas: ["computer-use-2025-01-24"]
        };
        if (this.tools && Object.keys(this.tools).length > 0) {
          const customTools = Object.entries(this.tools).map(([name, tool21]) => {
            const schema = tool21.inputSchema;
            const jsonSchema3 = toJsonSchema(schema);
            const inputSchema = {
              type: "object",
              properties: jsonSchema3.properties || {},
              required: jsonSchema3.required || []
            };
            return {
              name,
              description: tool21.description,
              input_schema: inputSchema
            };
          });
          requestParams.tools = [
            ...requestParams.tools,
            ...customTools
          ];
        }
        if (this.userProvidedInstructions) {
          requestParams.system = this.userProvidedInstructions;
        }
        if (thinking) {
          requestParams.thinking = thinking;
        }
        const llmRequestId = (0, import_uuid2.v7)();
        SessionFileLogger.logLlmRequest({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.getAction",
          prompt: formatCuaPromptPreview(messages)
        });
        const startTime = Date.now();
        const response = yield this.client.beta.messages.create(requestParams);
        const endTime = Date.now();
        const elapsedMs = endTime - startTime;
        const usage = {
          input_tokens: response.usage.input_tokens,
          output_tokens: response.usage.output_tokens,
          inference_time_ms: elapsedMs
        };
        SessionFileLogger.logLlmResponse({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.getAction",
          output: formatCuaResponsePreview(response.content),
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens
        });
        this.lastMessageId = response.id;
        return {
          // Cast the response content to our internal type
          content: response.content,
          id: response.id,
          usage
        };
      } catch (error) {
        console.error("Error getting action from Anthropic:", error);
        throw error;
      }
    });
  }
  takeAction(toolUseItems, logger) {
    return __async(this, null, function* () {
      const toolResults = [];
      logger({
        category: "agent",
        message: `Taking action on ${toolUseItems.length} tool use items`,
        level: 2
      });
      for (const item of toolUseItems) {
        try {
          logger({
            category: "agent",
            message: `Processing tool use: ${item.name}, id: ${item.id}, action: ${JSON.stringify(item.input)}`,
            level: 2
          });
          if (item.name === "computer") {
            const action = item.input.action;
            logger({
              category: "agent",
              message: `Computer action type: ${action}`,
              level: 2
            });
            const screenshot = yield this.captureScreenshot();
            logger({
              category: "agent",
              message: `Screenshot captured, length: ${screenshot.length}`,
              level: 2
            });
            const imageContent = [
              {
                type: "image",
                source: {
                  type: "base64",
                  media_type: "image/png",
                  data: screenshot.replace(/^data:image\/png;base64,/, "")
                }
              }
            ];
            if (this.currentUrl) {
              toolResults.push({
                type: "tool_result",
                tool_use_id: item.id,
                content: [
                  ...imageContent,
                  {
                    type: "text",
                    text: `Current URL: ${this.currentUrl}`
                  }
                ]
              });
            } else {
              toolResults.push({
                type: "tool_result",
                tool_use_id: item.id,
                content: imageContent
              });
            }
            logger({
              category: "agent",
              message: `Added computer tool result for tool_use_id: ${item.id}`,
              level: 2
            });
          } else {
            let toolResult = "Tool executed successfully";
            if (this.tools && item.name in this.tools) {
              try {
                const tool21 = this.tools[item.name];
                logger({
                  category: "agent",
                  message: `Executing tool call: ${item.name} with args: ${JSON.stringify(item.input)}`,
                  level: 1
                });
                const result = yield tool21.execute(item.input, {
                  toolCallId: item.id,
                  messages: []
                });
                toolResult = JSON.stringify(result);
                logger({
                  category: "agent",
                  message: `Tool ${item.name} completed successfully. Result: ${toolResult}`,
                  level: 1
                });
              } catch (toolError) {
                const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
                toolResult = `Error executing tool: ${errorMessage}`;
                logger({
                  category: "agent",
                  message: `Error executing tool ${item.name}: ${errorMessage}`,
                  level: 0
                });
              }
            }
            toolResults.push({
              type: "tool_result",
              tool_use_id: item.id,
              content: [
                {
                  type: "text",
                  text: toolResult
                }
              ]
            });
            logger({
              category: "agent",
              message: `Added custom tool result for tool ${item.name}, tool_use_id: ${item.id}`,
              level: 2
            });
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger({
            category: "agent",
            message: `Error executing tool use: ${errorMessage}`,
            level: 0
          });
          try {
            if (item.name === "computer") {
              const screenshot = yield this.captureScreenshot();
              toolResults.push({
                type: "tool_result",
                tool_use_id: item.id,
                content: [
                  {
                    type: "image",
                    source: {
                      type: "base64",
                      media_type: "image/png",
                      data: screenshot.replace(/^data:image\/png;base64,/, "")
                    }
                  },
                  {
                    type: "text",
                    text: `Error: ${errorMessage}`
                  }
                ]
              });
              logger({
                category: "agent",
                message: `Added error tool result with screenshot for tool_use_id: ${item.id}`,
                level: 1
              });
            } else {
              toolResults.push({
                type: "tool_result",
                tool_use_id: item.id,
                content: [
                  {
                    type: "text",
                    text: `Error: ${errorMessage}`
                  }
                ]
              });
              logger({
                category: "agent",
                message: `Added error tool result for tool_use_id: ${item.id}`,
                level: 1
              });
            }
          } catch (screenshotError) {
            logger({
              category: "agent",
              message: `Error capturing screenshot: ${String(screenshotError)}`,
              level: 0
            });
            toolResults.push({
              type: "tool_result",
              tool_use_id: item.id,
              content: [
                {
                  type: "text",
                  text: `Error: ${errorMessage}`
                }
              ]
            });
            logger({
              category: "agent",
              message: `Added text error tool result for tool_use_id: ${item.id}`,
              level: 1
            });
          }
        }
      }
      logger({
        category: "agent",
        message: `Prepared ${toolResults.length} tool results for next request`,
        level: 2
      });
      return toolResults;
    });
  }
  convertToolUseToAction(item) {
    try {
      const { name, input } = item;
      if (name === "computer") {
        const action = input.action;
        if (!action) {
          console.warn("Missing action in tool use item:", item);
          return null;
        }
        if (action === "screenshot") {
          return __spreadValues({
            type: "screenshot"
          }, input);
        } else if (action === "click") {
          return __spreadValues({
            type: "click",
            x: input.x,
            y: input.y,
            button: input.button || "left"
          }, input);
        } else if (action === "type") {
          return __spreadValues({
            type: "type",
            text: input.text
          }, input);
        } else if (action === "keypress" || action === "key") {
          return __spreadValues({
            type: "keypress",
            keys: [input.text]
          }, input);
        } else if (action === "double_click" || action === "doubleClick") {
          return __spreadValues({
            type: "doubleClick",
            x: input.x || (input.coordinate ? input.coordinate[0] : 0),
            y: input.y || (input.coordinate ? input.coordinate[1] : 0)
          }, input);
        } else if (action === "scroll") {
          const x2 = input.x || (input.coordinate ? input.coordinate[0] : 0);
          const y = input.y || (input.coordinate ? input.coordinate[1] : 0);
          let scroll_x = 0;
          let scroll_y = 0;
          const scrollAmount = input.scroll_amount || 5;
          const scrollMultiplier = 100;
          if (input.scroll_direction) {
            const direction = input.scroll_direction;
            if (direction === "down") {
              scroll_y = scrollAmount * scrollMultiplier;
            } else if (direction === "up") {
              scroll_y = -scrollAmount * scrollMultiplier;
            } else if (direction === "right") {
              scroll_x = scrollAmount * scrollMultiplier;
            } else if (direction === "left") {
              scroll_x = -scrollAmount * scrollMultiplier;
            }
          } else {
            scroll_x = input.scroll_x || 0;
            scroll_y = input.scroll_y || 0;
          }
          return __spreadValues({
            type: "scroll",
            x: x2,
            y,
            scroll_x,
            scroll_y
          }, input);
        } else if (action === "move") {
          const coordinates = input.coordinate;
          const x2 = coordinates ? coordinates[0] : input.x || 0;
          const y = coordinates ? coordinates[1] : input.y || 0;
          return __spreadValues({
            type: "move",
            x: x2,
            y
          }, input);
        } else if (action === "drag" || action === "left_click_drag") {
          const path8 = input.path || (input.coordinate ? [
            {
              x: input.start_coordinate[0],
              y: input.start_coordinate[1]
            },
            {
              x: input.coordinate[0],
              y: input.coordinate[1]
            }
          ] : []);
          return __spreadValues({
            type: "drag",
            path: path8
          }, input);
        } else if (action === "wait") {
          return __spreadValues({
            type: "wait"
          }, input);
        } else if (action === "left_click") {
          const coordinates = input.coordinate;
          const x2 = coordinates ? coordinates[0] : input.x || 0;
          const y = coordinates ? coordinates[1] : input.y || 0;
          return __spreadValues({
            type: "click",
            x: x2,
            y,
            button: "left"
          }, input);
        } else {
          return __spreadValues({
            type: action
          }, input);
        }
      } else if (name === "str_replace_editor" || name === "bash") {
        return {
          type: name,
          params: input
        };
      } else if (this.tools && name in this.tools) {
        return null;
      }
      console.warn(`Unknown tool name: ${name}`);
      return null;
    } catch (error) {
      console.error("Error converting tool use to action:", error);
      return null;
    }
  }
  captureScreenshot(options) {
    return __async(this, null, function* () {
      if (options == null ? void 0 : options.base64Image) {
        return `data:image/png;base64,${options.base64Image}`;
      }
      if (this.screenshotProvider) {
        try {
          const base64Image = yield this.screenshotProvider();
          return `data:image/png;base64,${base64Image}`;
        } catch (error) {
          console.error("Error capturing screenshot:", error);
          throw error;
        }
      }
      throw new AgentScreenshotProviderError(
        "`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image"
      );
    });
  }
};

// lib/v3/agent/OpenAICUAClient.ts
var import_openai = __toESM(require("openai"));
init_sdkErrors();
init_flowLogger();
var import_uuid3 = require("uuid");
var OpenAICUAClient = class extends AgentClient {
  constructor(type, modelName, userProvidedInstructions, clientOptions, tools) {
    super(type, modelName, userProvidedInstructions);
    this.currentViewport = { width: 1288, height: 711 };
    this.actualScreenshotSize = { width: 1288, height: 711 };
    this.reasoningItems = /* @__PURE__ */ new Map();
    this.environment = "browser";
    this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.OPENAI_API_KEY || "";
    this.baseURL = (clientOptions == null ? void 0 : clientOptions.baseURL) || void 0;
    this.organization = (clientOptions == null ? void 0 : clientOptions.organization) || process.env.OPENAI_ORG;
    if ((clientOptions == null ? void 0 : clientOptions.environment) && typeof clientOptions.environment === "string") {
      this.environment = clientOptions.environment;
    }
    this.clientOptions = {
      apiKey: this.apiKey
    };
    if (this.baseURL) {
      this.clientOptions.baseURL = this.baseURL;
    }
    this.client = new import_openai.default(this.clientOptions);
    this.tools = tools;
  }
  setViewport(width, height) {
    this.currentViewport = { width, height };
  }
  setScreenshotSize(width, height) {
    this.actualScreenshotSize = { width, height };
  }
  setCurrentUrl(url) {
    this.currentUrl = url;
  }
  setScreenshotProvider(provider) {
    this.screenshotProvider = provider;
  }
  setActionHandler(handler) {
    this.actionHandler = handler;
  }
  setTools(tools) {
    this.tools = tools;
  }
  setSafetyConfirmationHandler(handler) {
    this.safetyConfirmationHandler = handler;
  }
  /**
   * Execute a task with the OpenAI CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */
  execute(executionOptions) {
    return __async(this, null, function* () {
      const { options, logger } = executionOptions;
      const { instruction } = options;
      const maxSteps = options.maxSteps || 10;
      let currentStep = 0;
      let completed = false;
      const actions = [];
      const messageList = [];
      let finalMessage = "";
      this.reasoningItems.clear();
      let inputItems = this.createInitialInputItems(instruction);
      let previousResponseId = void 0;
      let totalInputTokens = 0;
      let totalOutputTokens = 0;
      let totalInferenceTime = 0;
      try {
        while (!completed && currentStep < maxSteps) {
          logger({
            category: "agent",
            message: `Executing step ${currentStep + 1}/${maxSteps}`,
            level: 1
          });
          const result = yield this.executeStep(
            inputItems,
            previousResponseId,
            logger
          );
          totalInputTokens += result.usage.input_tokens;
          totalOutputTokens += result.usage.output_tokens;
          totalInferenceTime += result.usage.inference_time_ms;
          actions.push(...result.actions);
          completed = result.completed;
          previousResponseId = result.responseId;
          if (!completed) {
            inputItems = result.nextInputItems;
          }
          if (result.message) {
            messageList.push(result.message);
            finalMessage = result.message;
          }
          currentStep++;
        }
        return {
          success: completed,
          actions,
          message: finalMessage,
          completed,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing agent task: ${errorMessage}`,
          level: 0
        });
        return {
          success: false,
          actions,
          message: `Failed to execute task: ${errorMessage}`,
          completed: false,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      }
    });
  }
  /**
   * Execute a single step of the agent
   * This coordinates the flow: Request  Get Action  Execute Action
   */
  executeStep(inputItems, previousResponseId, logger) {
    return __async(this, null, function* () {
      try {
        const result = yield this.getAction(inputItems, previousResponseId);
        const output = result.output;
        const responseId = result.responseId;
        const usage = {
          input_tokens: result.usage.input_tokens,
          output_tokens: result.usage.output_tokens,
          inference_time_ms: result.usage.inference_time_ms
        };
        for (const item of output) {
          if (item.type === "reasoning") {
            this.reasoningItems.set(item.id, item);
            logger({
              category: "agent",
              message: `Reasoning: ${String(item.content || "")}`,
              level: 1
            });
          }
        }
        const stepActions = [];
        for (const item of output) {
          if (item.type === "computer_call" && this.isComputerCallItem(item)) {
            logger({
              category: "agent",
              message: `Found computer_call: ${item.action.type}, call_id: ${item.call_id}`,
              level: 2
            });
            const action = this.convertComputerCallToAction(item);
            if (action) {
              stepActions.push(action);
              logger({
                category: "agent",
                message: `Converted computer_call to action: ${action.type}`,
                level: 2
              });
            }
          } else if (item.type === "function_call" && this.isFunctionCallItem(item)) {
            logger({
              category: "agent",
              message: `Found function_call: ${item.name}, call_id: ${item.call_id}`,
              level: 2
            });
            const action = this.convertFunctionCallToAction(item);
            if (action) {
              stepActions.push(action);
              logger({
                category: "agent",
                message: `Converted function_call to action: ${action.type}`,
                level: 2
              });
            }
          }
        }
        let message = "";
        for (const item of output) {
          if (item.type === "message") {
            logger({
              category: "agent",
              message: `Found message block`,
              level: 2
            });
            if (item.content && Array.isArray(item.content)) {
              for (const content of item.content) {
                if (content.type === "output_text" && content.text) {
                  message += content.text + "\n";
                  logger({
                    category: "agent",
                    message: `Message text: ${String(content.text || "")}`,
                    level: 1
                  });
                }
              }
            }
          }
        }
        const nextInputItems = yield this.takeAction(output, logger);
        const completed = output.length === 0 || output.every(
          (item) => item.type === "message" || item.type === "reasoning"
        );
        return {
          actions: stepActions,
          message: message.trim(),
          completed,
          nextInputItems,
          responseId,
          usage
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing step: ${errorMessage}`,
          level: 0
        });
        throw error;
      }
    });
  }
  isComputerCallItem(item) {
    return item.type === "computer_call" && "call_id" in item && "action" in item && typeof item.action === "object";
  }
  handleSafetyConfirmation(pendingSafetyChecks, logger) {
    return __async(this, null, function* () {
      if (this.safetyConfirmationHandler) {
        logger({
          category: "agent",
          message: `Requesting safety confirmation for ${pendingSafetyChecks.length} check(s): ${pendingSafetyChecks.map((c) => c.code).join(", ")}`,
          level: 1
        });
        const response = yield this.safetyConfirmationHandler(pendingSafetyChecks);
        if (response.acknowledged) {
          logger({
            category: "agent",
            message: `Safety checks acknowledged by user`,
            level: 1
          });
          return pendingSafetyChecks;
        } else {
          logger({
            category: "agent",
            message: `Safety checks rejected by user`,
            level: 1
          });
          return void 0;
        }
      }
      logger({
        category: "agent",
        message: `Auto-acknowledging ${pendingSafetyChecks.length} safety check(s)`,
        level: 2
      });
      return pendingSafetyChecks;
    });
  }
  isFunctionCallItem(item) {
    return item.type === "function_call" && "call_id" in item && "name" in item && "arguments" in item;
  }
  createInitialInputItems(instruction) {
    return [
      {
        role: "system",
        content: this.userProvidedInstructions
      },
      {
        role: "user",
        content: instruction
      }
    ];
  }
  getAction(inputItems, previousResponseId) {
    return __async(this, null, function* () {
      try {
        const requestParams = {
          model: this.modelName,
          tools: [
            {
              type: "computer_use_preview",
              display_width: this.currentViewport.width,
              display_height: this.currentViewport.height,
              environment: this.environment
            }
          ],
          input: inputItems,
          truncation: "auto"
        };
        if (this.tools && Object.keys(this.tools).length > 0) {
          const customTools = Object.entries(this.tools).map(([name, tool21]) => ({
            type: "function",
            name,
            function: {
              name,
              description: tool21.description,
              parameters: tool21.inputSchema
            }
          }));
          requestParams.tools = [
            ...requestParams.tools,
            ...customTools
          ];
        }
        if (previousResponseId) {
          requestParams.previous_response_id = previousResponseId;
        }
        const llmRequestId = (0, import_uuid3.v7)();
        SessionFileLogger.logLlmRequest({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.getAction",
          prompt: formatCuaPromptPreview(inputItems)
        });
        const startTime = Date.now();
        const response = yield this.client.responses.create(requestParams);
        const endTime = Date.now();
        const elapsedMs = endTime - startTime;
        const usage = {
          input_tokens: response.usage.input_tokens,
          output_tokens: response.usage.output_tokens,
          inference_time_ms: elapsedMs
        };
        SessionFileLogger.logLlmResponse({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.getAction",
          output: formatCuaResponsePreview(response.output),
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens
        });
        this.lastResponseId = response.id;
        return {
          output: response.output,
          responseId: response.id,
          usage
        };
      } catch (error) {
        console.error("Error getting action from OpenAI:", error);
        throw error;
      }
    });
  }
  takeAction(output, logger) {
    return __async(this, null, function* () {
      const nextInputItems = [];
      for (const item of output) {
        if (item.type === "computer_call" && this.isComputerCallItem(item)) {
          try {
            const action = this.convertComputerCallToAction(item);
            if (action && this.actionHandler) {
              logger({
                category: "agent",
                message: `Executing computer action: ${action.type}`,
                level: 1
              });
              yield this.actionHandler(action);
            }
            const screenshot = yield this.captureScreenshot();
            const outputItem = {
              type: "computer_call_output",
              call_id: item.call_id,
              output: {
                type: "input_image",
                image_url: screenshot
              }
            };
            logger({
              category: "agent",
              message: `Added computer_call_output for call_id: ${item.call_id}`,
              level: 2
            });
            if (this.currentUrl) {
              const computerCallOutput = outputItem;
              computerCallOutput.output.current_url = this.currentUrl;
            }
            if (item.pending_safety_checks && item.pending_safety_checks.length > 0) {
              const acknowledgedChecks = yield this.handleSafetyConfirmation(
                item.pending_safety_checks,
                logger
              );
              if (acknowledgedChecks) {
                const computerCallOutput = outputItem;
                computerCallOutput.acknowledged_safety_checks = acknowledgedChecks;
              }
            }
            nextInputItems.push(outputItem);
          } catch (error) {
            if (error instanceof StagehandClosedError) {
              throw error;
            }
            const errorMessage = error instanceof Error ? error.message : String(error);
            logger({
              category: "agent",
              message: `Error executing computer call: ${errorMessage}`,
              level: 0
            });
            try {
              const screenshot = yield this.captureScreenshot();
              const errorOutputItem = {
                type: "computer_call_output",
                call_id: item.call_id,
                output: {
                  type: "input_image",
                  image_url: screenshot,
                  error: errorMessage
                }
              };
              if (this.currentUrl) {
                const computerCallOutput = errorOutputItem;
                computerCallOutput.output.current_url = this.currentUrl;
              }
              if (item.pending_safety_checks && item.pending_safety_checks.length > 0) {
                const acknowledgedChecks = yield this.handleSafetyConfirmation(
                  item.pending_safety_checks,
                  logger
                );
                if (acknowledgedChecks) {
                  const computerCallOutput = errorOutputItem;
                  computerCallOutput.acknowledged_safety_checks = acknowledgedChecks;
                }
              }
              nextInputItems.push(errorOutputItem);
            } catch (screenshotError) {
              if (screenshotError instanceof StagehandClosedError) {
                throw screenshotError;
              }
              logger({
                category: "agent",
                message: `Error capturing screenshot: ${String(screenshotError)}`,
                level: 0
              });
              nextInputItems.push({
                type: "computer_call_output",
                call_id: item.call_id,
                output: `Error: ${errorMessage}`
              });
            }
          }
        } else if (item.type === "function_call" && this.isFunctionCallItem(item)) {
          try {
            const action = this.convertFunctionCallToAction(item);
            if (action && this.actionHandler) {
              yield this.actionHandler(action);
            }
            let toolResult = "Tool executed successfully";
            if (this.tools && item.name in this.tools) {
              try {
                const tool21 = this.tools[item.name];
                const args = JSON.parse(item.arguments);
                logger({
                  category: "agent",
                  message: `Executing tool call: ${item.name} with args: ${item.arguments}`,
                  level: 1
                });
                const result = yield tool21.execute(args, {
                  toolCallId: item.call_id,
                  messages: []
                });
                toolResult = JSON.stringify(result);
                logger({
                  category: "agent",
                  message: `Tool ${item.name} completed successfully. Result: ${toolResult}`,
                  level: 1
                });
              } catch (toolError) {
                const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
                toolResult = `Error executing tool: ${errorMessage}`;
                logger({
                  category: "agent",
                  message: `Error executing tool ${item.name}: ${errorMessage}`,
                  level: 0
                });
              }
            }
            const outputItem = {
              type: "function_call_output",
              call_id: item.call_id,
              output: toolResult
            };
            nextInputItems.push(outputItem);
          } catch (error) {
            if (error instanceof StagehandClosedError) {
              throw error;
            }
            const errorMessage = error instanceof Error ? error.message : String(error);
            logger({
              category: "agent",
              message: `Error executing function call: ${errorMessage}`,
              level: 0
            });
            const errorOutputItem = {
              type: "function_call_output",
              call_id: item.call_id,
              output: `Error: ${errorMessage}`
            };
            nextInputItems.push(errorOutputItem);
          }
        }
      }
      return nextInputItems;
    });
  }
  convertComputerCallToAction(call) {
    const { action } = call;
    const scaledAction = __spreadValues({}, action);
    if (action.x !== void 0 && action.y !== void 0) {
      const scaleX = this.currentViewport.width / this.actualScreenshotSize.width;
      const scaleY = this.currentViewport.height / this.actualScreenshotSize.height;
      scaledAction.x = Math.floor(action.x * scaleX);
      scaledAction.y = Math.floor(action.y * scaleY);
    }
    return __spreadValues({
      type: action.type
    }, scaledAction);
  }
  convertFunctionCallToAction(call) {
    try {
      const args = JSON.parse(call.arguments);
      return {
        type: call.name,
        params: args
      };
    } catch (error) {
      console.error("Error parsing function call arguments:", error);
      return null;
    }
  }
  captureScreenshot(options) {
    return __async(this, null, function* () {
      if (options == null ? void 0 : options.base64Image) {
        return `data:image/png;base64,${options.base64Image}`;
      }
      if (this.screenshotProvider) {
        try {
          const base64Image = yield this.screenshotProvider();
          return `data:image/png;base64,${base64Image}`;
        } catch (error) {
          console.error("Error capturing screenshot:", error);
          throw error;
        }
      }
      throw new AgentScreenshotProviderError(
        "`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image"
      );
    });
  }
};

// lib/v3/agent/GoogleCUAClient.ts
var import_genai3 = require("@google/genai");
init_sdkErrors();

// lib/v3/agent/utils/cuaKeyMapping.ts
var KEY_MAP = {
  ENTER: "Enter",
  RETURN: "Enter",
  ESCAPE: "Escape",
  ESC: "Escape",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  SPACE: " ",
  DELETE: "Delete",
  DEL: "Delete",
  ARROWUP: "ArrowUp",
  ARROWDOWN: "ArrowDown",
  ARROWLEFT: "ArrowLeft",
  ARROWRIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  SHIFT: "Shift",
  CONTROL: "Control",
  CTRL: "Control",
  ALT: "Alt",
  OPTION: "Alt",
  // macOS alternative name
  META: "Meta",
  COMMAND: "Meta",
  // macOS
  CMD: "Meta",
  // macOS shorthand
  SUPER: "Meta",
  // Linux
  WINDOWS: "Meta",
  // Windows
  WIN: "Meta",
  // Windows shorthand
  HOME: "Home",
  END: "End",
  PAGEUP: "PageUp",
  PAGEDOWN: "PageDown",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PGUP: "PageUp",
  PGDN: "PageDown"
};
function mapKeyToPlaywright(key) {
  if (!key) return key;
  const upperKey = key.toUpperCase();
  return KEY_MAP[upperKey] || key;
}

// lib/v3/agent/utils/googleCustomToolHandler.ts
var import_genai2 = require("@google/genai");
function executeGoogleCustomTool(toolName, toolArgs, tools, functionCall, logger) {
  return __async(this, null, function* () {
    try {
      logger({
        category: "agent",
        message: `Executing custom tool: ${toolName} with args: ${JSON.stringify(toolArgs)}`,
        level: 1
      });
      const tool21 = tools[toolName];
      const toolResult = yield tool21.execute(toolArgs, {
        toolCallId: `tool_${Date.now()}`,
        messages: []
      });
      logger({
        category: "agent",
        message: `Tool ${toolName} completed successfully. Result: ${JSON.stringify(toolResult)}`,
        level: 1
      });
      const functionResponsePart = {
        functionResponse: {
          name: toolName,
          response: {
            result: JSON.stringify(toolResult)
          }
        }
      };
      return {
        functionResponse: functionResponsePart,
        success: true
      };
    } catch (toolError) {
      const errorMessage = toolError instanceof Error ? toolError.message : String(toolError);
      logger({
        category: "agent",
        message: `Error executing custom tool ${toolName}: ${errorMessage}`,
        level: 0
      });
      const functionResponsePart = {
        functionResponse: {
          name: toolName,
          response: {
            error: errorMessage
          }
        }
      };
      return {
        functionResponse: functionResponsePart,
        success: false
      };
    }
  });
}
function isCustomTool(functionCall, tools) {
  return !!(tools && functionCall.name && functionCall.name in tools);
}
function convertToolSetToFunctionDeclarations(tools) {
  const functionDeclarations = [];
  for (const [name, tool21] of Object.entries(tools)) {
    const functionDeclaration = convertToolToFunctionDeclaration(name, tool21);
    if (functionDeclaration) {
      functionDeclarations.push(functionDeclaration);
    }
  }
  return functionDeclarations;
}
function convertToolToFunctionDeclaration(name, tool21) {
  try {
    const schema = tool21.inputSchema;
    const jsonSchema3 = toJsonSchema(schema);
    const parameters = convertJsonSchemaToGoogleParameters(jsonSchema3);
    return {
      name,
      description: tool21.description || `Execute ${name}`,
      parameters
    };
  } catch (error) {
    console.error(
      `Error converting tool ${name} to function declaration:`,
      error
    );
    return null;
  }
}
function convertJsonSchemaToGoogleParameters(schema) {
  const properties = {};
  if (schema.properties) {
    for (const [key, value] of Object.entries(schema.properties)) {
      const propSchema = value;
      properties[key] = __spreadValues({
        type: mapJsonTypeToGoogleType(propSchema.type || "string")
      }, propSchema.description ? { description: propSchema.description } : {});
    }
  }
  return __spreadValues({
    type: import_genai2.Type.OBJECT,
    properties
  }, schema.required && schema.required.length > 0 ? { required: schema.required } : {});
}
function mapJsonTypeToGoogleType(jsonType) {
  switch (jsonType.toLowerCase()) {
    case "string":
      return import_genai2.Type.STRING;
    case "number":
    case "integer":
      return import_genai2.Type.NUMBER;
    case "boolean":
      return import_genai2.Type.BOOLEAN;
    case "array":
      return import_genai2.Type.ARRAY;
    case "object":
      return import_genai2.Type.OBJECT;
    default:
      return import_genai2.Type.STRING;
  }
}

// lib/v3/agent/GoogleCUAClient.ts
init_flowLogger();
var import_uuid4 = require("uuid");
var GoogleCUAClient = class extends AgentClient {
  constructor(type, modelName, userProvidedInstructions, clientOptions, tools) {
    super(type, modelName, userProvidedInstructions);
    this.currentViewport = { width: 1288, height: 711 };
    this.actualScreenshotSize = { width: 1288, height: 711 };
    this.history = [];
    this.environment = "ENVIRONMENT_BROWSER";
    this.tools = tools;
    this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.GEMINI_API_KEY || process.env.GOOGLE_GENERATIVE_AI_API_KEY || process.env.GOOGLE_API_KEY || "";
    this.baseURL = clientOptions == null ? void 0 : clientOptions.baseURL;
    const genAIOptions = __spreadValues({
      apiKey: this.apiKey
    }, this.baseURL ? { httpOptions: { baseUrl: this.baseURL } } : {});
    this.client = new import_genai3.GoogleGenAI(genAIOptions);
    if ((clientOptions == null ? void 0 : clientOptions.environment) && typeof clientOptions.environment === "string") {
      this.environment = clientOptions.environment;
    }
    this.generateContentConfig = {
      temperature: 1,
      topP: 0.95,
      topK: 40,
      maxOutputTokens: 8192,
      // systemInstruction: this.userProvidedInstructions
      //   ? { parts: [{ text: this.userProvidedInstructions }] }
      //   : { parts: [{ text: buildGoogleCUASystemPrompt() }] },
      tools: [
        {
          computerUse: {
            environment: this.environment
          }
        }
      ]
    };
    this.clientOptions = __spreadValues({
      apiKey: this.apiKey
    }, this.baseURL ? { baseURL: this.baseURL } : {});
    if (this.tools && Object.keys(this.tools).length > 0) {
      this.updateGenerateContentConfig();
    }
  }
  setViewport(width, height) {
    this.currentViewport = { width, height };
  }
  setScreenshotSize(width, height) {
    this.actualScreenshotSize = { width, height };
  }
  setCurrentUrl(url) {
    this.currentUrl = url;
  }
  setScreenshotProvider(provider) {
    this.screenshotProvider = provider;
  }
  setActionHandler(handler) {
    this.actionHandler = handler;
  }
  setTools(tools) {
    this.tools = tools;
    this.updateGenerateContentConfig();
  }
  setSafetyConfirmationHandler(handler) {
    this.safetyConfirmationHandler = handler;
  }
  handleSafetyConfirmation(safetyDecision, logger) {
    return __async(this, null, function* () {
      const safetyMessage = typeof safetyDecision === "object" ? JSON.stringify(safetyDecision, null, 2) : String(safetyDecision);
      const safetyChecks = [
        {
          id: "google-safety-decision",
          code: "safety_decision",
          message: safetyMessage
        }
      ];
      if (this.safetyConfirmationHandler) {
        logger({
          category: "agent",
          message: `Requesting safety confirmation for Google safety decision: ${safetyMessage}`,
          level: 1
        });
        const response = yield this.safetyConfirmationHandler(safetyChecks);
        if (response.acknowledged) {
          logger({
            category: "agent",
            message: `Safety decision acknowledged by user`,
            level: 1
          });
          return "true";
        } else {
          logger({
            category: "agent",
            message: `Safety decision rejected by user`,
            level: 1
          });
          return void 0;
        }
      }
      logger({
        category: "agent",
        message: `Auto-acknowledging Google safety decision`,
        level: 2
      });
      return "true";
    });
  }
  /**
   * Update the generateContentConfig with current tools
   */
  updateGenerateContentConfig() {
    const functionDeclarations = this.tools && Object.keys(this.tools).length > 0 ? convertToolSetToFunctionDeclarations(this.tools) : [];
    this.generateContentConfig = __spreadProps(__spreadValues({}, this.generateContentConfig), {
      tools: [
        __spreadValues({
          computerUse: {
            environment: this.environment
          }
        }, functionDeclarations.length > 0 ? { functionDeclarations } : {})
      ]
    });
  }
  /**
   * Execute a task with the Google CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */
  execute(executionOptions) {
    return __async(this, null, function* () {
      const { options, logger } = executionOptions;
      const { instruction } = options;
      const maxSteps = options.maxSteps || 10;
      let currentStep = 0;
      let completed = false;
      const actions = [];
      const messageList = [];
      let finalMessage = "";
      this.history = [];
      yield this.initializeHistory(instruction);
      let totalInputTokens = 0;
      let totalOutputTokens = 0;
      let totalInferenceTime = 0;
      try {
        while (!completed && currentStep < maxSteps) {
          logger({
            category: "agent",
            message: `Executing step ${currentStep + 1}/${maxSteps}`,
            level: 1
          });
          const result = yield this.executeStep(logger);
          totalInputTokens += result.usage.input_tokens;
          totalOutputTokens += result.usage.output_tokens;
          totalInferenceTime += result.usage.inference_time_ms;
          actions.push(...result.actions);
          completed = result.completed;
          if (result.message) {
            messageList.push(result.message);
            finalMessage = result.message;
          }
          currentStep++;
        }
        return {
          success: completed,
          actions,
          message: finalMessage,
          completed,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing agent task: ${errorMessage}`,
          level: 0
        });
        return {
          success: false,
          actions,
          message: `Failed to execute task: ${errorMessage}`,
          completed: false,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      }
    });
  }
  /**
   * Initialize conversation history with the initial instruction
   */
  initializeHistory(instruction) {
    return __async(this, null, function* () {
      const parts = [{ text: instruction }];
      const systemPromptContent = this.userProvidedInstructions ? this.userProvidedInstructions : buildGoogleCUASystemPrompt().content;
      this.history = [
        {
          role: "user",
          parts: [
            {
              text: "System prompt: " + systemPromptContent
            }
          ]
        },
        {
          role: "user",
          parts
        }
      ];
    });
  }
  /**
   * Execute a single step of the agent
   */
  executeStep(logger) {
    return __async(this, null, function* () {
      var _a4, _b;
      try {
        const startTime = Date.now();
        const compressedResult = compressGoogleConversationImages(
          this.history,
          2
        );
        const compressedHistory = compressedResult.items;
        const maxRetries = 5;
        const baseDelayS = 1;
        let lastError = null;
        let response = null;
        const llmRequestId = (0, import_uuid4.v7)();
        SessionFileLogger.logLlmRequest({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.generateContent",
          prompt: formatCuaPromptPreview(compressedHistory)
        });
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            if (attempt > 0) {
              const delay2 = baseDelayS * Math.pow(2, attempt) * 1e3;
              logger({
                category: "agent",
                message: `Generating content failed on attempt ${attempt + 1}. Retrying in ${delay2 / 1e3} seconds...`,
                level: 2
              });
              yield new Promise((resolve3) => setTimeout(resolve3, delay2));
            }
            response = yield this.client.models.generateContent({
              model: this.modelName,
              contents: compressedHistory,
              config: this.generateContentConfig
            });
            if (!response.candidates || response.candidates.length === 0) {
              throw new LLMResponseError("agent", "Response has no candidates!");
            }
            const candidate = response.candidates[0];
            if (!candidate.content || !candidate.content.parts) {
              const reason = candidate.finishReason || "unknown";
              throw new LLMResponseError(
                "agent",
                `Response has no content (finish reason: ${reason})`
              );
            }
            break;
          } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            logger({
              category: "agent",
              message: `API call error: ${lastError.message}`,
              level: 2
            });
            if (attempt === maxRetries - 1) {
              logger({
                category: "agent",
                message: `Generating content failed after ${maxRetries} attempts.`,
                level: 0
              });
              throw lastError;
            }
          }
        }
        if (!response) {
          throw lastError || new Error("Failed to get response after all retries");
        }
        const endTime = Date.now();
        const elapsedMs = endTime - startTime;
        const { usageMetadata } = response;
        SessionFileLogger.logLlmResponse({
          requestId: llmRequestId,
          model: this.modelName,
          operation: "CUA.generateContent",
          output: formatCuaResponsePreview(response),
          inputTokens: usageMetadata == null ? void 0 : usageMetadata.promptTokenCount,
          outputTokens: usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount
        });
        const result = yield this.processResponse(response, logger);
        if (response.candidates && response.candidates[0]) {
          const sanitizedContent = JSON.parse(
            JSON.stringify(response.candidates[0].content)
          );
          if (sanitizedContent.parts) {
            for (const part of sanitizedContent.parts) {
              if ((_a4 = part.functionCall) == null ? void 0 : _a4.args) {
                if (typeof part.functionCall.args.x === "number" && part.functionCall.args.x > 999) {
                  part.functionCall.args.x = 999;
                }
                if (typeof part.functionCall.args.y === "number" && part.functionCall.args.y > 999) {
                  part.functionCall.args.y = 999;
                }
              }
            }
          }
          this.history.push(sanitizedContent);
        }
        const functionResponses = [];
        if (result.actions.length > 0) {
          let hasError = false;
          for (let i2 = 0; i2 < result.actions.length; i2++) {
            const action = result.actions[i2];
            logger({
              category: "agent",
              message: `Executing action ${i2 + 1}/${result.actions.length}: ${action.type}`,
              level: 2
            });
            if (action.type === "open_web_browser") {
              action.pageUrl = this.currentUrl;
              logger({
                category: "agent",
                message: "Skipping open_web_browser action",
                level: 2
              });
            } else if (action.type === "custom_tool") {
              const toolName = action.name;
              const toolArgs = action.arguments;
              if (this.tools && toolName in this.tools) {
                const correspondingFunctionCall = result.functionCalls.find(
                  (fc) => fc.name === toolName
                );
                if (correspondingFunctionCall) {
                  const executionResult = yield executeGoogleCustomTool(
                    toolName,
                    toolArgs,
                    this.tools,
                    correspondingFunctionCall,
                    logger
                  );
                  functionResponses.push(executionResult.functionResponse);
                  if (!executionResult.success) {
                    hasError = true;
                  }
                }
              }
            } else if (this.actionHandler) {
              try {
                yield this.actionHandler(action);
                if (i2 < result.actions.length - 1) {
                  const nextAction = result.actions[i2 + 1];
                  const isTypingAction = action.type === "type" || nextAction.type === "type";
                  const delay2 = isTypingAction ? 500 : 200;
                  yield new Promise((resolve3) => setTimeout(resolve3, delay2));
                }
              } catch (actionError) {
                if (actionError instanceof StagehandClosedError) {
                  throw actionError;
                }
                logger({
                  category: "agent",
                  message: `Error executing action ${action.type}: ${actionError}`,
                  level: 0
                });
                hasError = true;
              }
            }
          }
          if (result.functionCalls.length > 0 || hasError) {
            const computerUseFunctionCalls = result.functionCalls.filter(
              (fc) => !isCustomTool(fc, this.tools)
            );
            if (computerUseFunctionCalls.length > 0) {
              try {
                logger({
                  category: "agent",
                  message: `Taking screenshot after executing ${result.actions.length} actions${hasError ? " (with errors)" : ""}`,
                  level: 2
                });
                const screenshot = yield this.captureScreenshot();
                const base64Data = screenshot.replace(
                  /^data:image\/png;base64,/,
                  ""
                );
                for (const functionCall of computerUseFunctionCalls) {
                  let safetyAcknowledgement;
                  if ((_b = functionCall.args) == null ? void 0 : _b.safety_decision) {
                    safetyAcknowledgement = yield this.handleSafetyConfirmation(
                      functionCall.args.safety_decision,
                      logger
                    );
                  }
                  const functionResponsePart = {
                    functionResponse: {
                      name: functionCall.name,
                      response: __spreadValues({
                        url: this.currentUrl || ""
                      }, safetyAcknowledgement !== void 0 ? {
                        safety_acknowledgement: safetyAcknowledgement
                      } : {}),
                      parts: [
                        {
                          inlineData: {
                            mimeType: "image/png",
                            data: base64Data
                          }
                        }
                      ]
                    }
                  };
                  functionResponses.push(functionResponsePart);
                }
              } catch (error) {
                logger({
                  category: "agent",
                  message: `Error capturing screenshot: ${error}`,
                  level: 0
                });
              }
            }
          }
          if (functionResponses.length > 0) {
            logger({
              category: "agent",
              message: `Adding ${functionResponses.length} function responses to history`,
              level: 2
            });
            this.history.push({
              role: "user",
              parts: functionResponses
            });
          }
        }
        return {
          actions: result.actions,
          message: result.message,
          completed: result.completed,
          usage: {
            input_tokens: (usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) || 0,
            output_tokens: (usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) || 0,
            inference_time_ms: elapsedMs
          }
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger({
          category: "agent",
          message: `Error executing step: ${errorMessage}`,
          level: 0
        });
        throw error;
      }
    });
  }
  /**
   * Process the response from Google's API
   */
  processResponse(response, logger) {
    return __async(this, null, function* () {
      const actions = [];
      let message = "";
      const functionCalls = [];
      if (!response.candidates || response.candidates.length === 0) {
        return {
          actions: [],
          message: "No candidates in response",
          completed: true,
          functionCalls: []
        };
      }
      const candidate = response.candidates[0];
      logger({
        category: "agent",
        message: `Raw response from Google: ${JSON.stringify(candidate.content, null, 2)}`,
        level: 2
      });
      for (const part of candidate.content.parts) {
        if (part.text) {
          message += part.text + "\n";
          logger({
            category: "agent",
            message: `Reasoning: ${part.text}`,
            level: 1
          });
        }
        if (part.functionCall) {
          functionCalls.push(part.functionCall);
          logger({
            category: "agent",
            message: `Found function call: ${part.functionCall.name} with args: ${JSON.stringify(part.functionCall.args)}`,
            level: 2
          });
          const action = this.convertFunctionCallToAction(part.functionCall);
          if (action) {
            if (part.functionCall.name === "type_text_at" && action.type === "type") {
              logger({
                category: "agent",
                message: `Adding action: ${JSON.stringify(action)}`,
                level: 2
              });
              actions.push({
                type: "click",
                x: action.x,
                y: action.y,
                button: "left"
              });
              if (action.clearBeforeTyping) {
                actions.push({
                  type: "keypress",
                  keys: ["ControlOrMeta+A"]
                });
                actions.push({
                  type: "keypress",
                  keys: ["Backspace"]
                });
              }
              actions.push(action);
              if (action.pressEnter) {
                actions.push({
                  type: "keypress",
                  keys: ["Enter"]
                });
              }
            } else {
              actions.push(action);
            }
          } else {
            logger({
              category: "agent",
              message: `Warning: Could not convert function call ${part.functionCall.name} to action`,
              level: 1
            });
          }
        }
      }
      logger({
        category: "agent",
        message: `Found ${functionCalls.length} function calls, converted to ${actions.length} actions`,
        level: 2
      });
      const completed = functionCalls.length === 0 || candidate.finishReason && candidate.finishReason !== "STOP";
      return {
        actions,
        message: message.trim(),
        completed,
        functionCalls
      };
    });
  }
  /**
   * Convert Google function call to Stagehand action
   */
  convertFunctionCallToAction(functionCall) {
    var _a4, _b;
    const { name, args } = functionCall;
    if (!name || !args) {
      return null;
    }
    switch (name) {
      case "open_web_browser":
        return {
          type: "open_web_browser",
          timestamp: Date.now()
        };
      case "click_at": {
        const { x: x2, y } = this.normalizeCoordinates(
          args.x,
          args.y
        );
        return {
          type: "click",
          x: x2,
          y,
          button: args.button || "left"
        };
      }
      case "type_text_at": {
        const { x: x2, y } = this.normalizeCoordinates(
          args.x,
          args.y
        );
        const pressEnter = (_a4 = args.press_enter) != null ? _a4 : false;
        const clearBeforeTyping = (_b = args.clear_before_typing) != null ? _b : true;
        return {
          type: "type",
          text: args.text,
          x: x2,
          y,
          pressEnter,
          clearBeforeTyping
        };
      }
      case "key_combination": {
        const keys = args.keys.split("+").map((key) => key.trim()).map((key) => mapKeyToPlaywright(key));
        return {
          type: "keypress",
          keys
        };
      }
      case "scroll_document": {
        const direction = args.direction.toLowerCase();
        return {
          type: "keypress",
          keys: [direction === "up" ? "PageUp" : "PageDown"]
        };
      }
      case "scroll_at": {
        const { x: x2, y } = this.normalizeCoordinates(
          args.x,
          args.y
        );
        const direction = (args.direction || "down").toLowerCase();
        const magnitude = typeof args.magnitude === "number" ? args.magnitude : 800;
        let scroll_x = 0;
        let scroll_y = 0;
        if (direction === "up") {
          scroll_y = -magnitude;
        } else if (direction === "down") {
          scroll_y = magnitude;
        } else if (direction === "left") {
          scroll_x = -magnitude;
        } else if (direction === "right") {
          scroll_x = magnitude;
        } else {
          scroll_y = magnitude;
        }
        return {
          type: "scroll",
          x: x2,
          y,
          scroll_x,
          scroll_y
        };
      }
      case "navigate":
        return {
          type: "goto",
          url: args.url
        };
      case "go_back":
        return {
          type: "back"
        };
      case "go_forward":
        return {
          type: "forward"
        };
      case "wait_5_seconds":
        return {
          type: "wait",
          timeMs: 5e3
          // Google CUA waits for 5 seconds
        };
      case "hover_at": {
        const { x: x2, y } = this.normalizeCoordinates(
          args.x,
          args.y
        );
        return {
          type: "move",
          x: x2,
          y
        };
      }
      case "search":
        return {
          type: "goto",
          url: "https://www.google.com"
        };
      case "drag_and_drop": {
        const startPoint = this.normalizeCoordinates(
          args.x,
          args.y
        );
        const endPoint = this.normalizeCoordinates(
          args.destination_x,
          args.destination_y
        );
        return {
          type: "drag",
          path: [
            { x: startPoint.x, y: startPoint.y },
            { x: endPoint.x, y: endPoint.y }
          ]
        };
      }
      default:
        if (isCustomTool(functionCall, this.tools)) {
          return {
            type: "custom_tool",
            name,
            arguments: args,
            timestamp: Date.now(),
            pageUrl: this.currentUrl
          };
        }
        console.warn(`Unsupported Google CUA function: ${name}`);
        return null;
    }
  }
  /**
   * Normalize coordinates from Google's 0-1000 range to actual viewport dimensions
   */
  normalizeCoordinates(x2, y) {
    x2 = Math.min(999, Math.max(0, x2));
    y = Math.min(999, Math.max(0, y));
    const screenshotX = x2 / 1e3 * this.actualScreenshotSize.width;
    const screenshotY = y / 1e3 * this.actualScreenshotSize.height;
    const scaleX = this.currentViewport.width / this.actualScreenshotSize.width;
    const scaleY = this.currentViewport.height / this.actualScreenshotSize.height;
    return {
      x: Math.floor(screenshotX * scaleX),
      y: Math.floor(screenshotY * scaleY)
    };
  }
  captureScreenshot(options) {
    return __async(this, null, function* () {
      if (options == null ? void 0 : options.currentUrl) {
        this.currentUrl = options.currentUrl;
      }
      if (options == null ? void 0 : options.base64Image) {
        return `data:image/png;base64,${options.base64Image}`;
      }
      if (this.screenshotProvider) {
        try {
          const base64Image = yield this.screenshotProvider();
          return `data:image/png;base64,${base64Image}`;
        } catch (error) {
          console.error("Error capturing screenshot:", error);
          throw error;
        }
      }
      throw new AgentScreenshotProviderError(
        "`screenshotProvider` has not been set. Please call `setScreenshotProvider()` with a valid function that returns a base64-encoded image"
      );
    });
  }
};

// lib/v3/agent/MicrosoftCUAClient.ts
var import_openai2 = __toESM(require("openai"));
init_sdkErrors();
var MicrosoftCUAClient = class extends AgentClient {
  constructor(type, modelName, userProvidedInstructions, clientOptions) {
    super(type, modelName || "fara-7b", userProvidedInstructions);
    this.currentViewport = { width: 1288, height: 711 };
    // Dual history system
    this.conversationHistory = [];
    // Conceptual flow
    this.actionHistory = [];
    // Raw model responses
    this.maxImages = 3;
    this.temperature = 0;
    this.facts = [];
    // FARA-specific MLM processor config
    this.MLM_PROCESSOR_IM_CFG = {
      min_pixels: 3136,
      max_pixels: 12845056,
      patch_size: 14,
      merge_size: 2
    };
    // Resized dimensions for model input
    this.resizedViewport = { width: 1288, height: 711 };
    // Actual screenshot dimensions (tracked separately from viewport)
    this.actualScreenshotSize = { width: 1288, height: 711 };
    this.apiKey = (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.AZURE_API_KEY || process.env.FIREWORKS_API_KEY || "";
    this.baseURL = (clientOptions == null ? void 0 : clientOptions.baseURL) || process.env.AZURE_ENDPOINT || process.env.FIREWORKS_ENDPOINT || "";
    this.clientOptions = {
      apiKey: this.apiKey,
      baseURL: this.baseURL
    };
    if (!this.apiKey || this.apiKey === "") {
      throw new Error(
        "API key is required. Please provide it via clientOptions.apiKey or AZURE_API_KEY or FIREWORKS_API_KEY environment variables."
      );
    }
    this.client = new import_openai2.default({
      apiKey: this.apiKey,
      baseURL: this.baseURL
    });
    if ((clientOptions == null ? void 0 : clientOptions.maxImages) !== void 0) {
      this.maxImages = clientOptions.maxImages;
    }
    if ((clientOptions == null ? void 0 : clientOptions.temperature) !== void 0) {
      this.temperature = clientOptions.temperature;
    }
  }
  setViewport(width, height) {
    this.currentViewport = { width, height };
    this.resizedViewport = this.smartResize(width, height);
  }
  setScreenshotSize(width, height) {
    this.actualScreenshotSize = { width, height };
  }
  setCurrentUrl(url) {
    this.currentUrl = url;
  }
  setScreenshotProvider(provider) {
    this.screenshotProvider = provider;
  }
  setActionHandler(handler) {
    this.actionHandler = handler;
  }
  /**
   * Smart resize algorithm from FARA
   * Ensures dimensions are divisible by factor and within pixel limits
   */
  smartResize(width, height) {
    const { patch_size, merge_size, min_pixels, max_pixels } = this.MLM_PROCESSOR_IM_CFG;
    const factor = patch_size * merge_size;
    const roundByFactor = (num, f3) => Math.round(num / f3) * f3;
    const ceilByFactor = (num, f3) => Math.ceil(num / f3) * f3;
    const floorByFactor = (num, f3) => Math.floor(num / f3) * f3;
    let h_bar = Math.max(factor, roundByFactor(height, factor));
    let w_bar = Math.max(factor, roundByFactor(width, factor));
    if (h_bar * w_bar > max_pixels) {
      const beta = Math.sqrt(height * width / max_pixels);
      h_bar = floorByFactor(height / beta, factor);
      w_bar = floorByFactor(width / beta, factor);
    } else if (h_bar * w_bar < min_pixels) {
      const beta = Math.sqrt(min_pixels / (height * width));
      h_bar = ceilByFactor(height * beta, factor);
      w_bar = ceilByFactor(width * beta, factor);
    }
    return { width: w_bar, height: h_bar };
  }
  /**
   * Generate system prompt with tool description
   * Simplified to match Python's minimal approach
   */
  generateSystemPrompt() {
    const { width, height } = this.actualScreenshotSize;
    let basePrompt = "You are a helpful assistant.";
    if (this.userProvidedInstructions) {
      basePrompt = `${basePrompt}

${this.userProvidedInstructions}`;
    }
    const toolDescription = `Use a mouse and keyboard to interact with a computer, and take screenshots.
* This is an interface to a desktop GUI. You do not have access to a terminal or applications menu. You must click on desktop icons to start applications.
* Some applications may take time to start or process actions, so you may need to wait and take successive screenshots to see the results of your actions. E.g. if you click on Firefox and a window doesn't open, try wait and taking another screenshot.
* The screen's resolution is ${width}x${height}.
* Whenever you intend to move the cursor to click on an element like an icon, you should consult a screenshot to determine the coordinates of the element before moving the cursor.
* If you tried clicking on a program or link but it failed to load, even after waiting, try adjusting your cursor position so that the tip of the cursor visually falls on the element that you want to click.
* Make sure to click any buttons, links, icons, etc with the cursor tip in the center of the element. Don't click boxes on their edges unless asked.
* When a separate scrollable container prominently overlays the webpage, if you want to scroll within it, you typically need to mouse_move() over it first and then scroll().
* If a popup window appears that you want to close, if left_click() on the 'X' or close button doesn't work, try key(keys=['Escape']) to close it.
* On some search bars, when you type(), you may need to press_enter=False and instead separately call left_click() on the search button to submit the search query. This is especially true of search bars that have auto-suggest popups for e.g. locations
* For calendar widgets, you usually need to left_click() on arrows to move between months and left_click() on dates to select them; type() is not typically used to input dates there.`;
    const actionsDescription = `The action to perform. The available actions are:
* \`key\`: Performs key down presses on the arguments passed in order, then performs key releases in reverse order. Includes "Enter", "Alt", "Shift", "Tab", "Control", "Backspace", "Delete", "Escape", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageDown", "PageUp", "Shift", etc.
* \`type\`: Type a string of text on the keyboard.
* \`mouse_move\`: Move the cursor to a specified (x, y) pixel coordinate on the screen.
* \`left_click\`: Click the left mouse button.
* \`scroll\`: Performs a scroll of the mouse scroll wheel.
* \`history_back\`: Go back to the previous page in the browser history.
* \`pause_and_memorize_fact\`: Pause and memorize a fact for future reference.
* \`visit_url\`: Visit a specified URL.
* \`web_search\`: Perform a web search with a specified query.
* \`wait\`: Wait specified seconds for the change to happen.
* \`terminate\`: Terminate the current task and report its completion status.`;
    const toolSchema = {
      name: "computer_use",
      description: toolDescription,
      parameters: {
        type: "object",
        required: ["action"],
        properties: {
          action: {
            type: "string",
            description: actionsDescription,
            enum: [
              "key",
              "type",
              "mouse_move",
              "left_click",
              "scroll",
              "visit_url",
              "web_search",
              "history_back",
              "pause_and_memorize_fact",
              "wait",
              "terminate"
            ]
          },
          keys: {
            type: "array",
            description: "Required only by `action=key`."
          },
          text: {
            type: "string",
            description: "Required only by `action=type`."
          },
          press_enter: {
            type: "boolean",
            description: "Whether to press the Enter key after typing. Required only by `action=type`."
          },
          delete_existing_text: {
            type: "boolean",
            description: "Whether to delete existing text before typing. Required only by `action=type`."
          },
          coordinate: {
            type: "array",
            description: "(x, y): The x (pixels from the left edge) and y (pixels from the top edge) coordinates to move the mouse to. Required only by `action=left_click`, `action=mouse_move`, and `action=type`."
          },
          pixels: {
            type: "number",
            description: "The amount of scrolling to perform. Positive values scroll up, negative values scroll down. Required only by `action=scroll`."
          },
          fact: {
            type: "string",
            description: "The fact to remember for the future. Required only by `action=pause_and_memorize_fact`."
          },
          time: {
            type: "number",
            description: "The seconds to wait. Required only by `action=wait`."
          },
          status: {
            type: "string",
            description: "The status of the task. Required only by `action=terminate`.",
            enum: ["success", "failure"]
          }
        }
      }
    };
    const toolDescs = JSON.stringify(toolSchema, null, 2);
    const functionCallTemplate = `
You are provided with function signatures within <tools></tools> XML tags:
<tools>
${toolDescs}
</tools>

For each function call, return a json object with function name and arguments within <tool_call></tool_call> XML tags:
<tool_call>
{{"name": <function-name>, "arguments": <args-json-object>}}
</tool_call>`;
    return `${basePrompt}

${functionCallTemplate}`;
  }
  /**
   * Parse thoughts and action from model response
   * FARA uses XML-based tool calling: <tool_call>\n{...}\n</tool_call>
   */
  parseThoughtsAndAction(response) {
    try {
      const parts = response.split("<tool_call>\n");
      const thoughts = parts[0].trim();
      const actionText = parts[1].split("\n</tool_call>")[0].trim();
      let parsedAction;
      try {
        parsedAction = JSON.parse(actionText);
      } catch (jsonError) {
        if (actionText.startsWith("{{") && actionText.endsWith("}")) {
          const fixedText = actionText.slice(1);
          try {
            parsedAction = JSON.parse(fixedText);
          } catch (retryError) {
            throw new Error(
              `Failed to parse action text even after fixing double brackets. Original: ${actionText}. Fixed: ${fixedText}. Error: ${retryError}`
            );
          }
        } else {
          throw new Error(
            `Failed to parse action text as JSON: ${actionText}. Error: ${jsonError}`
          );
        }
      }
      return {
        thoughts,
        functionCall: {
          name: parsedAction.name || "computer_use",
          arguments: __spreadProps(__spreadValues({}, parsedAction.arguments), {
            thoughts
          })
        }
      };
    } catch (error) {
      throw new Error(
        `Failed to parse FARA tool call from response: ${response}. Error: ${error}`
      );
    }
  }
  /**
   * Convert FARA function call to Stagehand AgentAction
   */
  convertFunctionCallToAction(functionCall) {
    const args = functionCall.arguments;
    const action = args.action;
    const transformCoordinate = (coord) => {
      if (!coord || coord.length !== 2) return coord;
      const [x2, y] = coord;
      const scaleX = this.currentViewport.width / this.actualScreenshotSize.width;
      const scaleY = this.currentViewport.height / this.actualScreenshotSize.height;
      return [Math.round(x2 * scaleX), Math.round(y * scaleY)];
    };
    const baseAction = {
      type: action,
      reasoning: args.thoughts
    };
    switch (action) {
      case "left_click": {
        const clickCoord = transformCoordinate(args.coordinate);
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "click",
          x: clickCoord[0],
          y: clickCoord[1],
          button: "left"
        });
      }
      case "mouse_move": {
        const moveCoord = transformCoordinate(args.coordinate);
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "move",
          coordinate: moveCoord
        });
      }
      case "type": {
        const typeCoord = args.coordinate ? transformCoordinate(args.coordinate) : void 0;
        return __spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({}, baseAction), {
          text: args.text
        }), typeCoord && { x: typeCoord[0], y: typeCoord[1] }), {
          press_enter: args.press_enter !== void 0 ? args.press_enter : true
        }), args.delete_existing_text !== void 0 && {
          delete_existing_text: args.delete_existing_text
        });
      }
      case "key":
      case "keypress": {
        const keys = args.keys || [];
        const normalizedKeys = keys.map((k) => mapKeyToPlaywright(k));
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "keypress",
          keys: normalizedKeys
        });
      }
      case "scroll": {
        const pixels = args.pixels || 0;
        return __spreadProps(__spreadValues({}, baseAction), {
          scroll_x: 0,
          scroll_y: -pixels
          // Invert: negative pixels = scroll down
        });
      }
      case "visit_url": {
        let url = args.url;
        if (!url.startsWith("https://") && !url.startsWith("http://") && !url.startsWith("file://") && !url.startsWith("about:")) {
          if (url.includes(" ")) {
            url = `https://www.bing.com/search?q=${encodeURIComponent(url)}&FORM=QBLH`;
          } else {
            url = "https://" + url;
          }
        }
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "goto",
          url
        });
      }
      case "web_search": {
        const query = args.query;
        const searchUrl = `https://www.bing.com/search?q=${encodeURIComponent(query)}&FORM=QBLH`;
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "goto",
          url: searchUrl
        });
      }
      case "history_back":
        return __spreadProps(__spreadValues({}, baseAction), {
          type: "back"
        });
      case "wait": {
        const durationSeconds = args.time || args.duration || 3;
        return __spreadProps(__spreadValues({}, baseAction), {
          timeMs: durationSeconds * 1e3
          // Convert seconds to ms
        });
      }
      case "pause_and_memorize_fact": {
        const fact = args.fact;
        this.facts.push(fact);
        return __spreadProps(__spreadValues({}, baseAction), {
          fact
        });
      }
      case "terminate":
        return __spreadProps(__spreadValues({}, baseAction), {
          status: args.status
        });
      default:
        return __spreadValues(__spreadValues({}, baseAction), args);
    }
  }
  /**
   * Capture a screenshot and return as base64 data URL
   */
  captureScreenshot() {
    return __async(this, null, function* () {
      if (!this.screenshotProvider) {
        throw new AgentScreenshotProviderError("Screenshot provider not set");
      }
      const base64Screenshot = yield this.screenshotProvider();
      return `data:image/png;base64,${base64Screenshot}`;
    });
  }
  /**
   * Remove old screenshots from history
   * Matches Python's maybe_remove_old_screenshots
   */
  maybeRemoveOldScreenshots(history, includesCurrent = false) {
    if (this.maxImages <= 0) {
      return history;
    }
    const maxImages = includesCurrent ? this.maxImages : this.maxImages - 1;
    const newHistory = [];
    let nImages = 0;
    for (let i2 = history.length - 1; i2 >= 0; i2--) {
      const msg = history[i2];
      let hasImage = false;
      if (Array.isArray(msg.content)) {
        hasImage = msg.content.some((c) => c.type === "image_url");
      }
      if (i2 === 0 && nImages >= maxImages) {
        if (Array.isArray(msg.content)) {
          const newContent = msg.content.filter((c) => c.type !== "image_url");
          if (newContent.length === 0) {
            continue;
          }
          newHistory.push(__spreadProps(__spreadValues({}, msg), { content: newContent }));
        } else {
          newHistory.push(msg);
        }
        continue;
      }
      if (hasImage) {
        if (nImages < maxImages) {
          newHistory.push(msg);
          nImages++;
        } else {
          if (Array.isArray(msg.content)) {
            const newContent = msg.content.filter(
              (c) => c.type !== "image_url"
            );
            if (newContent.length > 0) {
              newHistory.push(__spreadProps(__spreadValues({}, msg), { content: newContent }));
            }
          } else {
            newHistory.push(msg);
          }
        }
      } else {
        newHistory.push(msg);
      }
    }
    return newHistory.reverse();
  }
  /**
   * Reconstruct history for API call
   * Merges conceptual chat history with raw action history
   */
  reconstructHistory() {
    const history = [];
    let actionTurn = 0;
    for (let i2 = 0; i2 < this.conversationHistory.length; i2++) {
      const m2 = this.conversationHistory[i2];
      if (m2.role === "assistant") {
        if (actionTurn >= this.actionHistory.length) {
          console.warn("OUT OF SYNC: Action history shorter than chat history");
          history.push(m2);
        } else {
          history.push(this.actionHistory[actionTurn]);
          actionTurn++;
        }
      } else {
        history.push(m2);
      }
    }
    return this.maybeRemoveOldScreenshots(history);
  }
  /**
   * Execute a single step
   */
  executeStep(logger, isFirstRound = false) {
    return __async(this, null, function* () {
      var _a4, _b;
      const screenshotDataUrl = yield this.captureScreenshot();
      if (isFirstRound) {
        const lastMessage = this.conversationHistory[this.conversationHistory.length - 1];
        if (lastMessage && lastMessage.role === "user") {
          const originalContent = typeof lastMessage.content === "string" ? lastMessage.content : (_b = (_a4 = lastMessage.content.find((c) => c.type === "text")) == null ? void 0 : _a4.text) != null ? _b : "Start task";
          lastMessage.content = [
            {
              type: "image_url",
              image_url: { url: screenshotDataUrl }
            },
            {
              type: "text",
              text: originalContent
            }
          ];
        }
      } else {
        const userContent = [
          {
            type: "image_url",
            image_url: { url: screenshotDataUrl }
          }
        ];
        let textPrompt = "Here is the next screenshot. Think about what to do next.";
        if (this.currentUrl) {
          const trimmedUrl = this.currentUrl.length > 100 ? this.currentUrl.slice(0, 100) + "..." : this.currentUrl;
          textPrompt = `Current URL: ${trimmedUrl}
${textPrompt}`;
        }
        userContent.push({
          type: "text",
          text: textPrompt
        });
        this.conversationHistory.push({
          role: "user",
          content: userContent
        });
      }
      let history = this.reconstructHistory();
      const systemMessage = {
        role: "system",
        content: this.generateSystemPrompt()
      };
      history = [systemMessage, ...history];
      logger({
        category: "agent",
        message: `Making API call to FARA model with ${history.length} messages`,
        level: 2
      });
      const startTime = Date.now();
      let response;
      try {
        response = yield this.client.chat.completions.create({
          model: this.modelName,
          messages: history,
          temperature: this.temperature
        });
      } catch (apiError) {
        logger({
          category: "agent",
          message: `API call failed: ${apiError instanceof Error ? apiError.message : String(apiError)}`,
          level: 0
        });
        throw apiError;
      }
      const inferenceTime = Date.now() - startTime;
      logger({
        category: "agent",
        message: `API call completed in ${inferenceTime}ms`,
        level: 2
      });
      const content = response.choices[0].message.content || "";
      const usage = response.usage || {
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
      };
      const assistantMsg = {
        role: "assistant",
        content
      };
      this.conversationHistory.push(assistantMsg);
      this.actionHistory.push(assistantMsg);
      logger({
        category: "agent",
        message: `Model response: ${content}`,
        level: 2
      });
      const { thoughts, functionCall } = this.parseThoughtsAndAction(content);
      logger({
        category: "agent",
        message: `Thoughts: ${thoughts}`,
        level: 2
      });
      logger({
        category: "agent",
        message: `Action: ${JSON.stringify(functionCall.arguments)}`,
        level: 2
      });
      const agentAction = this.convertFunctionCallToAction(functionCall);
      const actions = [];
      if (agentAction.type === "type" && typeof agentAction.x === "number" && typeof agentAction.y === "number") {
        actions.push({
          type: "click",
          x: agentAction.x,
          y: agentAction.y,
          button: "left"
        });
        if (agentAction.delete_existing_text) {
          actions.push({
            type: "keypress",
            keys: ["Command+A"]
          });
          actions.push({
            type: "keypress",
            keys: ["Backspace"]
          });
        }
        actions.push({
          type: "type",
          text: agentAction.text
        });
        if (agentAction.press_enter !== false) {
          actions.push({
            type: "keypress",
            keys: ["Enter"]
          });
        }
      } else {
        actions.push(agentAction);
      }
      if (this.actionHandler && agentAction.type !== "terminate") {
        for (const action of actions) {
          yield this.actionHandler(action);
        }
      }
      const completed = functionCall.arguments.action === "terminate";
      return {
        actions,
        completed,
        usage: {
          input_tokens: usage.prompt_tokens,
          output_tokens: usage.completion_tokens,
          inference_time_ms: inferenceTime
        }
      };
    });
  }
  /**
   * Execute a task with the FARA CUA
   * This is the main entry point for the agent
   * @implements AgentClient.execute
   */
  execute(executionOptions) {
    return __async(this, null, function* () {
      const { options, logger } = executionOptions;
      const { instruction } = options;
      const maxSteps = options.maxSteps || 10;
      let currentStep = 0;
      let completed = false;
      const actions = [];
      const messageList = [];
      let finalMessage = "";
      let totalInputTokens = 0;
      let totalOutputTokens = 0;
      let totalInferenceTime = 0;
      this.conversationHistory = [
        {
          role: "user",
          content: instruction
        }
      ];
      this.actionHistory = [];
      try {
        while (!completed && currentStep < maxSteps) {
          logger({
            category: "agent",
            message: `Executing step ${currentStep + 1}/${maxSteps}`,
            level: 1
          });
          const isFirstRound = currentStep === 0;
          const result = yield this.executeStep(logger, isFirstRound);
          totalInputTokens += result.usage.input_tokens;
          totalOutputTokens += result.usage.output_tokens;
          totalInferenceTime += result.usage.inference_time_ms;
          actions.push(...result.actions);
          completed = result.completed;
          currentStep++;
          const lastAction = result.actions[result.actions.length - 1];
          if (lastAction == null ? void 0 : lastAction.reasoning) {
            messageList.push(lastAction.reasoning);
          }
        }
        if (completed) {
          const lastAction = actions[actions.length - 1];
          finalMessage = (lastAction == null ? void 0 : lastAction.status) === "success" ? "Task completed successfully." : "Task completed with failures.";
        } else {
          finalMessage = `Reached maximum steps (${maxSteps}) without completion.`;
        }
        if (messageList.length > 0) {
          finalMessage = `${messageList.join("\n\n")}

${finalMessage}`;
        }
        return {
          success: completed,
          completed,
          message: finalMessage,
          actions,
          usage: {
            input_tokens: totalInputTokens,
            output_tokens: totalOutputTokens,
            inference_time_ms: totalInferenceTime
          }
        };
      } catch (error) {
        logger({
          category: "agent",
          message: `Error during execution: ${error}`,
          level: 0
        });
        throw error;
      }
    });
  }
};

// lib/v3/agent/AgentProvider.ts
var modelToAgentProviderMap = {
  "computer-use-preview": "openai",
  "computer-use-preview-2025-03-11": "openai",
  "claude-3-7-sonnet-latest": "anthropic",
  "claude-sonnet-4-20250514": "anthropic",
  "claude-sonnet-4-5-20250929": "anthropic",
  "claude-opus-4-5-20251101": "anthropic",
  "claude-haiku-4-5-20251001": "anthropic",
  "gemini-2.5-computer-use-preview-10-2025": "google",
  "fara-7b": "microsoft"
};
var AgentProvider = class _AgentProvider {
  /**
   * Create a new agent provider
   */
  constructor(logger) {
    this.logger = logger;
  }
  getClient(modelName, clientOptions, userProvidedInstructions, tools) {
    const explicitProvider = clientOptions == null ? void 0 : clientOptions.provider;
    const type = explicitProvider || _AgentProvider.getAgentProvider(modelName);
    this.logger({
      category: "agent",
      message: `Getting agent client for type: ${type}, model: ${modelName}${explicitProvider ? " (explicit provider)" : ""}`,
      level: 2
    });
    try {
      switch (type) {
        case "openai":
          return new OpenAICUAClient(
            type,
            modelName,
            userProvidedInstructions,
            clientOptions,
            tools
          );
        case "anthropic":
          return new AnthropicCUAClient(
            type,
            modelName,
            userProvidedInstructions,
            clientOptions,
            tools
          );
        case "google":
          return new GoogleCUAClient(
            type,
            modelName,
            userProvidedInstructions,
            clientOptions,
            tools
          );
        case "microsoft":
          return new MicrosoftCUAClient(
            type,
            modelName,
            userProvidedInstructions,
            clientOptions
          );
        default:
          throw new UnsupportedModelProviderError(
            ["openai", "anthropic", "google", "microsoft"],
            "Computer Use Agent"
          );
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger({
        category: "agent",
        message: `Error creating agent client: ${errorMessage}`,
        level: 0
      });
      throw error;
    }
  }
  static getAgentProvider(modelName) {
    const normalized = modelName.includes("/") ? modelName.split("/")[1] : modelName;
    if (normalized in modelToAgentProviderMap) {
      return modelToAgentProviderMap[normalized];
    }
    throw new UnsupportedModelError(
      Object.keys(modelToAgentProviderMap),
      "Computer Use Agent"
    );
  }
};

// lib/v3/handlers/v3CuaAgentHandler.ts
init_flowLogger();
init_sdkErrors();
function getPNGDimensions(buffer) {
  if (buffer.length < 24 || buffer[0] !== 137 || buffer[1] !== 80 || buffer[2] !== 78 || buffer[3] !== 71) {
    throw new Error("Invalid PNG file");
  }
  const width = buffer.readUInt32BE(16);
  const height = buffer.readUInt32BE(20);
  return { width, height };
}
var V3CuaAgentHandler = class {
  constructor(v3, logger, options, tools) {
    this.v3 = v3;
    this.logger = logger;
    this.options = options;
    this.provider = new AgentProvider(logger);
    const client = this.provider.getClient(
      options.modelName,
      options.clientOptions || {},
      options.userProvidedInstructions,
      tools
    );
    this.agentClient = client;
    this.setupAgentClient();
    this.agent = client;
  }
  /**
   * Ensures the V3 context is still available (not closed).
   * Throws StagehandClosedError if stagehand.close() was called.
   */
  ensureNotClosed() {
    if (!this.v3.context) {
      throw new StagehandClosedError();
    }
  }
  setupAgentClient() {
    this.agentClient.setScreenshotProvider(() => __async(this, null, function* () {
      this.ensureNotClosed();
      const page = yield this.v3.context.awaitActivePage();
      const screenshotBuffer = yield page.screenshot({ fullPage: false });
      if (this.agentClient instanceof GoogleCUAClient || this.agentClient instanceof OpenAICUAClient || this.agentClient instanceof MicrosoftCUAClient) {
        try {
          const dimensions = getPNGDimensions(screenshotBuffer);
          this.agentClient.setScreenshotSize(
            dimensions.width,
            dimensions.height
          );
        } catch (e2) {
          this.logger({
            category: "agent",
            message: `Could not read screenshot dimensions: ${e2}`,
            level: 1
          });
        }
      }
      return screenshotBuffer.toString("base64");
    }));
    this.agentClient.setActionHandler((action) => __async(this, null, function* () {
      var _a4, _b, _c;
      this.ensureNotClosed();
      action.pageUrl = (yield this.v3.context.awaitActivePage()).url();
      const defaultDelay = 500;
      const waitBetween = ((_a4 = this.options.clientOptions) == null ? void 0 : _a4.waitBetweenActions) || defaultDelay;
      try {
        if (this.highlightCursor) {
          try {
            yield this.injectCursor();
          } catch (e2) {
          }
        }
        yield new Promise((r2) => setTimeout(r2, 300));
        const shouldLog = action.type !== "screenshot";
        if (shouldLog) {
          SessionFileLogger.logUnderstudyActionEvent({
            actionType: `v3CUA.${action.type}`,
            target: this.computePointerTarget(action),
            args: [action]
          });
        }
        try {
          yield this.executeAction(action);
        } finally {
          if (shouldLog) SessionFileLogger.logUnderstudyActionCompleted();
        }
        action.timestamp = Date.now();
        yield new Promise((r2) => setTimeout(r2, waitBetween));
        try {
          yield this.captureAndSendScreenshot();
        } catch (e2) {
          this.logger({
            category: "agent",
            message: `Warning: Failed to take screenshot after action: ${String(
              (_b = e2 == null ? void 0 : e2.message) != null ? _b : e2
            )}`,
            level: 1
          });
        }
      } catch (error) {
        const msg = (_c = error == null ? void 0 : error.message) != null ? _c : String(error);
        this.logger({
          category: "agent",
          message: `Error executing action ${action.type}: ${msg}`,
          level: 0
        });
        throw error;
      }
    }));
    void this.updateClientViewport();
    void this.updateClientUrl();
  }
  setSafetyConfirmationHandler(handler) {
    if (this.agentClient instanceof GoogleCUAClient || this.agentClient instanceof OpenAICUAClient) {
      this.agentClient.setSafetyConfirmationHandler(handler);
    }
  }
  execute(optionsOrInstruction) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const options = typeof optionsOrInstruction === "string" ? { instruction: optionsOrInstruction } : optionsOrInstruction;
      this.setSafetyConfirmationHandler((_a4 = options.callbacks) == null ? void 0 : _a4.onSafetyConfirmation);
      this.highlightCursor = options.highlightCursor !== false;
      const page = yield this.v3.context.awaitActivePage();
      const currentUrl = page.url();
      if (!currentUrl || currentUrl === "about:blank") {
        this.logger({
          category: "agent",
          message: `Page URL is empty. Navigating to https://www.google.com ...`,
          level: 1
        });
        yield page.goto("https://www.google.com", { waitUntil: "load" });
      }
      if (this.highlightCursor) {
        try {
          yield this.injectCursor();
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.logger({
            category: "agent",
            message: `Warning: Failed to inject cursor: ${errorMessage}. Continuing with execution.`,
            level: 1
          });
        }
      }
      const start = Date.now();
      const result = yield this.agent.execute({ options, logger: this.logger });
      const inferenceTimeMs = Date.now() - start;
      if (result.usage) {
        this.v3.updateMetrics(
          "AGENT" /* AGENT */,
          result.usage.input_tokens,
          result.usage.output_tokens,
          (_b = result.usage.reasoning_tokens) != null ? _b : 0,
          (_c = result.usage.cached_input_tokens) != null ? _c : 0,
          inferenceTimeMs
        );
      }
      return result;
    });
  }
  executeAction(action) {
    return __async(this, null, function* () {
      var _a4;
      const page = yield this.v3.context.awaitActivePage();
      const recording = this.v3.isAgentReplayActive();
      switch (action.type) {
        case "click": {
          const { x: x2, y, button = "left", clickCount } = action;
          if (recording) {
            const xpath = yield page.click(x2, y, {
              button: button != null ? button : "left",
              clickCount: clickCount != null ? clickCount : 1,
              returnXpath: true
            });
            const normalized = ensureXPath(xpath);
            if (normalized) {
              const stagehandAction = {
                selector: normalized,
                description: this.describePointerAction("click", x2, y),
                method: "click",
                arguments: []
              };
              this.recordCuaActStep(
                action,
                [stagehandAction],
                stagehandAction.description
              );
            }
          } else {
            yield page.click(x2, y, {
              button: button != null ? button : "left",
              clickCount: clickCount != null ? clickCount : 1
            });
          }
          return { success: true };
        }
        case "double_click":
        case "doubleClick": {
          const { x: x2, y } = action;
          if (recording) {
            const xpath = yield page.click(x2, y, {
              button: "left",
              clickCount: 2,
              returnXpath: true
            });
            const normalized = ensureXPath(xpath);
            if (normalized) {
              const stagehandAction = {
                selector: normalized,
                description: this.describePointerAction("double click", x2, y),
                method: "doubleClick",
                arguments: []
              };
              this.recordCuaActStep(
                action,
                [stagehandAction],
                stagehandAction.description
              );
            }
          } else {
            yield page.click(x2, y, {
              button: "left",
              clickCount: 2
            });
          }
          return { success: true };
        }
        case "tripleClick": {
          const { x: x2, y } = action;
          if (recording) {
            const xpath = yield page.click(x2, y, {
              button: "left",
              clickCount: 3,
              returnXpath: true
            });
            const normalized = ensureXPath(xpath);
            if (normalized) {
              const stagehandAction = {
                selector: normalized,
                description: this.describePointerAction("triple click", x2, y),
                method: "tripleClick",
                arguments: []
              };
              this.recordCuaActStep(
                action,
                [stagehandAction],
                stagehandAction.description
              );
            }
          } else {
            yield page.click(x2, y, {
              clickCount: 3
            });
          }
          return { success: true };
        }
        case "type": {
          const { text } = action;
          yield page.type(String(text != null ? text : ""));
          if (recording) {
            const xpath = yield computeActiveElementXpath(page);
            const normalized = ensureXPath(xpath);
            if (normalized) {
              const stagehandAction = {
                selector: normalized,
                description: this.describeTypeAction(String(text != null ? text : "")),
                method: "type",
                arguments: [String(text != null ? text : "")]
              };
              this.recordCuaActStep(
                action,
                [stagehandAction],
                stagehandAction.description
              );
            }
          }
          return { success: true };
        }
        case "keypress": {
          const { keys } = action;
          const keyList = Array.isArray(keys) ? keys : [keys];
          const stagehandActions = [];
          for (const rawKey of keyList) {
            const mapped = mapKeyToPlaywright(String(rawKey != null ? rawKey : ""));
            yield page.keyPress(mapped);
            if (recording) {
              stagehandActions.push({
                selector: "xpath=/html",
                description: `press ${mapped}`,
                method: "press",
                arguments: [mapped]
              });
            }
          }
          if (recording && stagehandActions.length > 0) {
            this.recordCuaActStep(
              action,
              stagehandActions,
              stagehandActions.map((a) => a.description).filter(Boolean).join(", ") || "keypress"
            );
          }
          return { success: true };
        }
        case "scroll": {
          const { x: x2, y, scroll_x = 0, scroll_y = 0 } = action;
          yield page.scroll(
            x2 != null ? x2 : 0,
            y != null ? y : 0,
            scroll_x != null ? scroll_x : 0,
            scroll_y != null ? scroll_y : 0
          );
          this.v3.recordAgentReplayStep({
            type: "scroll",
            deltaX: Number(scroll_x != null ? scroll_x : 0),
            deltaY: Number(scroll_y != null ? scroll_y : 0),
            anchor: typeof x2 === "number" && typeof y === "number" ? { x: Math.round(x2), y: Math.round(y) } : void 0
          });
          return { success: true };
        }
        case "drag": {
          const { path: path8 } = action;
          if (Array.isArray(path8) && path8.length >= 2) {
            const start = path8[0];
            const end = path8[path8.length - 1];
            if (recording) {
              const xps = yield page.dragAndDrop(start.x, start.y, end.x, end.y, {
                steps: Math.min(20, Math.max(5, path8.length)),
                delay: 10,
                returnXpath: true
              });
              const [fromXpath, toXpath] = xps || ["", ""];
              const from = ensureXPath(fromXpath);
              const to = ensureXPath(toXpath);
              if (from && to) {
                const stagehandAction = {
                  selector: from,
                  description: this.describeDragAction(),
                  method: "dragAndDrop",
                  arguments: [to]
                };
                this.recordCuaActStep(
                  action,
                  [stagehandAction],
                  stagehandAction.description
                );
              }
            } else {
              yield page.dragAndDrop(start.x, start.y, end.x, end.y, {
                steps: Math.min(20, Math.max(5, path8.length)),
                delay: 10
              });
            }
          }
          return { success: true };
        }
        case "move": {
          const { x: x2, y } = action;
          if (typeof x2 === "number" && typeof y === "number") {
            if (recording) {
              const xpath = yield page.hover(x2, y, { returnXpath: true });
              const normalized = ensureXPath(xpath);
              if (normalized) {
                const stagehandAction = {
                  selector: normalized,
                  description: this.describePointerAction("hover", x2, y),
                  method: "hover",
                  arguments: []
                };
                this.recordCuaActStep(
                  action,
                  [stagehandAction],
                  stagehandAction.description
                );
              }
            } else {
              yield page.hover(x2, y);
            }
          }
          return { success: true };
        }
        case "wait": {
          const time = (_a4 = action == null ? void 0 : action.timeMs) != null ? _a4 : 1e3;
          yield new Promise((r2) => setTimeout(r2, time));
          if (time > 0 && recording) {
            this.v3.recordAgentReplayStep({ type: "wait", timeMs: Number(time) });
          }
          return { success: true };
        }
        case "screenshot": {
          return { success: true };
        }
        case "goto": {
          const { url } = action;
          yield page.goto(String(url != null ? url : ""), { waitUntil: "load" });
          if (recording) {
            this.v3.recordAgentReplayStep({
              type: "goto",
              url: String(url != null ? url : "")
            });
          }
          return { success: true };
        }
        case "back": {
          yield page.goBack();
          if (recording) {
            this.v3.recordAgentReplayStep({
              type: "back"
            });
          }
          return { success: true };
        }
        case "forward": {
          yield page.goForward();
          if (recording) {
            this.v3.recordAgentReplayStep({
              type: "forward"
            });
          }
          return { success: true };
        }
        case "open_web_browser": {
          return { success: true };
        }
        case "custom_tool": {
          return { success: true };
        }
        default:
          this.logger({
            category: "agent",
            message: `Unknown action type: ${String(action.type)}`,
            level: 1
          });
          return {
            success: false,
            error: `Unknown action ${String(action.type)}`
          };
      }
    });
  }
  // helper to make pointer target human-readable for logging
  computePointerTarget(action) {
    return typeof action.x === "number" && typeof action.y === "number" ? `(${action.x}, ${action.y})` : typeof action.selector === "string" ? action.selector : typeof action.input === "string" ? action.input : typeof action.description === "string" ? action.description : void 0;
  }
  describePointerAction(kind, x2, y) {
    const nx = Number(x2);
    const ny = Number(y);
    if (Number.isFinite(nx) && Number.isFinite(ny)) {
      return `${kind} at (${Math.round(nx)}, ${Math.round(ny)})`;
    }
    return kind;
  }
  describeTypeAction(text) {
    const snippet = text.length > 30 ? `${text.slice(0, 27)}...` : text;
    return `type "${snippet}"`;
  }
  describeDragAction() {
    return "drag and drop";
  }
  buildInstructionFallback(agentAction, fallback) {
    const raw = typeof agentAction.action === "string" && agentAction.action.trim() || typeof agentAction.reasoning === "string" && agentAction.reasoning.trim();
    return raw && raw.length > 0 ? raw : fallback;
  }
  recordCuaActStep(agentAction, stagehandActions, fallback) {
    var _a4;
    if (!stagehandActions.length) return;
    const instruction = this.buildInstructionFallback(agentAction, fallback);
    const description = ((_a4 = stagehandActions[0]) == null ? void 0 : _a4.description) || instruction;
    const actions = stagehandActions.map((act2) => __spreadProps(__spreadValues({}, act2), {
      description: act2.description || description
    }));
    this.v3.recordAgentReplayStep({
      type: "act",
      instruction,
      actions,
      actionDescription: description,
      message: typeof agentAction.reasoning === "string" && agentAction.reasoning.trim().length > 0 ? agentAction.reasoning.trim() : void 0
    });
  }
  updateClientViewport() {
    return __async(this, null, function* () {
      try {
        const page = yield this.v3.context.awaitActivePage();
        const { w, h: h2 } = yield page.mainFrame().evaluate("({ w: window.innerWidth, h: window.innerHeight })");
        if (w && h2) this.agentClient.setViewport(w, h2);
      } catch (e2) {
      }
    });
  }
  updateClientUrl() {
    return __async(this, null, function* () {
      try {
        const page = yield this.v3.context.awaitActivePage();
        const url = page.url();
        this.agentClient.setCurrentUrl(url);
      } catch (e2) {
      }
    });
  }
  captureAndSendScreenshot() {
    return __async(this, null, function* () {
      var _a4;
      this.logger({
        category: "agent",
        message: "Capturing screenshot",
        level: 1
      });
      try {
        const page = yield this.v3.context.awaitActivePage();
        const screenshotBuffer = yield page.screenshot({ fullPage: false });
        if (this.agentClient instanceof GoogleCUAClient || this.agentClient instanceof OpenAICUAClient || this.agentClient instanceof MicrosoftCUAClient) {
          try {
            const dimensions = getPNGDimensions(screenshotBuffer);
            this.agentClient.setScreenshotSize(
              dimensions.width,
              dimensions.height
            );
          } catch (e2) {
            this.logger({
              category: "agent",
              message: `Could not read screenshot dimensions: ${e2}`,
              level: 1
            });
          }
        }
        this.v3.bus.emit("agent_screenshot_taken_event", screenshotBuffer);
        const currentUrl = page.url();
        return yield this.agentClient.captureScreenshot({
          base64Image: screenshotBuffer.toString("base64"),
          currentUrl
        });
      } catch (e2) {
        this.logger({
          category: "agent",
          message: `Error capturing screenshot: ${String((_a4 = e2 == null ? void 0 : e2.message) != null ? _a4 : e2)}`,
          level: 0
        });
        return null;
      }
    });
  }
  injectCursor() {
    return __async(this, null, function* () {
      try {
        const page = yield this.v3.context.awaitActivePage();
        yield page.enableCursorOverlay();
      } catch (e2) {
      }
    });
  }
};

// lib/v3/launch/browserbase.ts
var import_sdk2 = __toESM(require("@browserbasehq/sdk"));
init_sdkErrors();
function createBrowserbaseSession(apiKey, projectId, params, resumeSessionId) {
  return __async(this, null, function* () {
    var _b;
    const bb = new import_sdk2.default({ apiKey });
    if (resumeSessionId) {
      const existing = yield bb.sessions.retrieve(
        resumeSessionId
      );
      if (!(existing == null ? void 0 : existing.id)) {
        throw new BrowserbaseSessionNotFoundError();
      }
      const ws = existing.connectUrl;
      if (!ws) {
        throw new StagehandInitError(
          `Browserbase session resume missing connectUrl for ${resumeSessionId}`
        );
      }
      return { ws, sessionId: resumeSessionId, bb };
    }
    const _a4 = params != null ? params : {}, {
      projectId: overrideProjectId,
      browserSettings,
      userMetadata
    } = _a4, rest = __objRest(_a4, [
      "projectId",
      "browserSettings",
      "userMetadata"
    ]);
    const createPayload = __spreadProps(__spreadValues({
      projectId: overrideProjectId != null ? overrideProjectId : projectId
    }, rest), {
      browserSettings: __spreadProps(__spreadValues({}, browserSettings != null ? browserSettings : {}), {
        viewport: (_b = browserSettings == null ? void 0 : browserSettings.viewport) != null ? _b : { width: 1288, height: 711 }
      }),
      userMetadata: __spreadProps(__spreadValues({}, userMetadata != null ? userMetadata : {}), {
        stagehand: "true"
      })
    });
    const created = yield bb.sessions.create(createPayload);
    if (!(created == null ? void 0 : created.connectUrl) || !(created == null ? void 0 : created.id)) {
      throw new StagehandInitError(
        "Browserbase session creation returned an unexpected shape."
      );
    }
    return { ws: created.connectUrl, sessionId: created.id, bb };
  });
}

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-launcher.js
var fs7 = __toESM(require("fs"), 1);
var net = __toESM(require("net"), 1);

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-finder.js
var chrome_finder_exports = {};
__export(chrome_finder_exports, {
  darwin: () => darwin,
  darwinFast: () => darwinFast,
  linux: () => linux,
  win32: () => win32,
  wsl: () => wsl
});
var import_fs5 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
var import_os = require("os");
var import_child_process2 = require("child_process");
var import_escape_string_regexp = __toESM(require_escape_string_regexp(), 1);

// ../../node_modules/.pnpm/lighthouse-logger@2.0.2/node_modules/lighthouse-logger/index.js
var import_process = __toESM(require("process"), 1);
var import_events = require("events");
var import_debug = __toESM(require_src(), 1);

// ../../node_modules/.pnpm/marky@1.3.0/node_modules/marky/lib/marky.es.js
var perf = typeof performance !== "undefined" && performance;
var nowPolyfillForNode;
{
  hrtime = process.hrtime;
  getNanoSeconds = function() {
    var hr = hrtime();
    return hr[0] * 1e9 + hr[1];
  };
  loadTime = getNanoSeconds();
  nowPolyfillForNode = function() {
    return (getNanoSeconds() - loadTime) / 1e6;
  };
}
var hrtime;
var getNanoSeconds;
var loadTime;
var now = perf && perf.now ? function() {
  return perf.now();
} : nowPolyfillForNode;
function throwIfEmpty(name) {
  if (!name) {
    throw new Error("name must be non-empty");
  }
}
function insertSorted(arr, item) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = low + high >>> 1;
    if (arr[mid].startTime < item.startTime) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  arr.splice(low, 0, item);
}
var mark;
var stop;
var getEntries;
var clear;
if (perf && perf.mark && perf.measure && perf.getEntriesByName && perf.getEntriesByType && perf.clearMarks && perf.clearMeasures && // In Node, we want to detect that this perf/correctness fix [1] is available, which
// landed in Node 16.15.0, 17.6.0, and 18.0.0. However, it's not observable, and
// we don't want to rely on fragile version checks.
// So we can rely on this observable change [2] to add clearResourceTimings, which
// landed a bit later (18.2.0), but is close enough for our purposes.
// [1]: https://github.com/nodejs/node/pull/42032
// [2]: https://github.com/nodejs/node/pull/42725
perf.clearResourceTimings) {
  mark = function(name) {
    throwIfEmpty(name);
    perf.mark("start " + name);
  };
  stop = function(name) {
    throwIfEmpty(name);
    perf.mark("end " + name);
    var measure = perf.measure(name, "start " + name, "end " + name);
    if (measure) {
      return measure;
    }
    var entries = perf.getEntriesByName(name);
    return entries[entries.length - 1];
  };
  getEntries = function() {
    return perf.getEntriesByType("measure");
  };
  clear = function() {
    perf.clearMarks();
    perf.clearMeasures();
  };
} else {
  marks = {};
  entries = [];
  mark = function(name) {
    throwIfEmpty(name);
    var startTime = now();
    marks["$" + name] = startTime;
  };
  stop = function(name) {
    throwIfEmpty(name);
    var endTime = now();
    var startTime = marks["$" + name];
    if (!startTime) {
      throw new Error("no known mark: " + name);
    }
    var entry = {
      startTime,
      name,
      duration: endTime - startTime,
      entryType: "measure"
    };
    insertSorted(entries, entry);
    return entry;
  };
  getEntries = function() {
    return entries;
  };
  clear = function() {
    marks = {};
    entries = [];
  };
}
var marks;
var entries;

// ../../node_modules/.pnpm/lighthouse-logger@2.0.2/node_modules/lighthouse-logger/index.js
var isWindows = import_process.default.platform === "win32";
var isBrowser = import_process.default.browser;
var colors = {
  red: isBrowser ? "crimson" : 1,
  yellow: isBrowser ? "gold" : 3,
  cyan: isBrowser ? "darkturquoise" : 6,
  green: isBrowser ? "forestgreen" : 2,
  blue: isBrowser ? "steelblue" : 4,
  magenta: isBrowser ? "palevioletred" : 5
};
import_debug.default.colors = [colors.cyan, colors.green, colors.blue, colors.magenta];
var Emitter = class extends import_events.EventEmitter {
  // yarn build-types fails without this!
  // https://github.com/microsoft/TypeScript/issues/41672#issuecomment-2303803072
  constructor(options) {
    super(options);
  }
  /**
   * Fires off all status updates. Listen with
   * `require('lib/log').events.addListener('status', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */
  issueStatus(title, argsArray) {
    if (title === "status" || title === "statusEnd") {
      this.emit(title, [title, ...argsArray]);
    }
  }
  /**
   * Fires off all warnings. Listen with
   * `require('lib/log').events.addListener('warning', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */
  issueWarning(title, argsArray) {
    this.emit("warning", [title, ...argsArray]);
  }
};
var loggersByTitle = {};
var loggingBufferColumns = 25;
var level_;
var Log = class _Log {
  static _logToStdErr(title, argsArray) {
    const log = _Log.loggerfn(title);
    log(...argsArray);
  }
  /**
   * @param {string} title
   */
  static loggerfn(title) {
    title = `LH:${title}`;
    let log = loggersByTitle[title];
    if (!log) {
      log = (0, import_debug.default)(title);
      loggersByTitle[title] = log;
      if (title.endsWith("error")) {
        log.color = colors.red;
      } else if (title.endsWith("warn")) {
        log.color = colors.yellow;
      }
    }
    return log;
  }
  /**
   * @param {string} level
   */
  static setLevel(level) {
    level_ = level;
    switch (level) {
      case "silent":
        import_debug.default.enable("-LH:*");
        break;
      case "verbose":
        import_debug.default.enable("LH:*");
        break;
      case "warn":
        import_debug.default.enable("-LH:*, LH:*:warn, LH:*:error");
        break;
      case "error":
        import_debug.default.enable("-LH:*, LH:*:error");
        break;
      default:
        import_debug.default.enable("LH:*, -LH:*:verbose");
    }
  }
  /**
   * A simple formatting utility for event logging.
   * @param {string} prefix
   * @param {!Object} data A JSON-serializable object of event data to log.
   * @param {string=} level Optional logging level. Defaults to 'log'.
   */
  static formatProtocol(prefix, data, level) {
    const columns = !import_process.default || import_process.default.browser ? Infinity : import_process.default.stdout.columns;
    const method = data.method || "?????";
    const maxLength = columns - method.length - prefix.length - loggingBufferColumns;
    const snippet = data.params && method !== "IO.read" ? JSON.stringify(data.params).substr(0, maxLength) : "";
    _Log._logToStdErr(`${prefix}:${level || ""}`, [method, snippet]);
  }
  /**
   * @return {boolean}
   */
  static isVerbose() {
    return level_ === "verbose";
  }
  /**
   * @param {{msg: string, id: string, args?: any[]}} status
   * @param {string} level
   */
  static time({ msg, id, args = [] }, level = "log") {
    mark(id);
    _Log[level]("status", msg, ...args);
  }
  /**
   * @param {{msg: string, id: string, args?: any[]}} status
   * @param {string} level
   */
  static timeEnd({ msg, id, args = [] }, level = "verbose") {
    _Log[level]("statusEnd", msg, ...args);
    stop(id);
  }
  /**
   * @param {string} title
   * @param {...any} args
   */
  static log(title, ...args) {
    _Log.events.issueStatus(title, args);
    return _Log._logToStdErr(title, args);
  }
  /**
   * @param {string} title
   * @param {...any} args
   */
  static warn(title, ...args) {
    _Log.events.issueWarning(title, args);
    return _Log._logToStdErr(`${title}:warn`, args);
  }
  /**
   * @param {string} title
   * @param {...any} args
   */
  static error(title, ...args) {
    return _Log._logToStdErr(`${title}:error`, args);
  }
  /**
   * @param {string} title
   * @param {...any} args
   */
  static verbose(title, ...args) {
    _Log.events.issueStatus(title, args);
    return _Log._logToStdErr(`${title}:verbose`, args);
  }
  /**
   * Add surrounding escape sequences to turn a string green when logged.
   * @param {string} str
   * @return {string}
   */
  static greenify(str) {
    return `${_Log.green}${str}${_Log.reset}`;
  }
  /**
   * Add surrounding escape sequences to turn a string red when logged.
   * @param {string} str
   * @return {string}
   */
  static redify(str) {
    return `${_Log.red}${str}${_Log.reset}`;
  }
  static get green() {
    return "\x1B[32m";
  }
  static get red() {
    return "\x1B[31m";
  }
  static get yellow() {
    return "\x1B[33m";
  }
  static get purple() {
    return "\x1B[95m";
  }
  static get reset() {
    return "\x1B[0m";
  }
  static get bold() {
    return "\x1B[1m";
  }
  static get dim() {
    return "\x1B[2m";
  }
  static get tick() {
    return isWindows ? "\u221A" : "\u2713";
  }
  static get cross() {
    return isWindows ? "\xD7" : "\u2718";
  }
  static get whiteSmallSquare() {
    return isWindows ? "\u0387" : "\u25AB";
  }
  static get heavyHorizontal() {
    return isWindows ? "\u2500" : "\u2501";
  }
  static get heavyVertical() {
    return isWindows ? "\u2502 " : "\u2503 ";
  }
  static get heavyUpAndRight() {
    return isWindows ? "\u2514" : "\u2517";
  }
  static get heavyVerticalAndRight() {
    return isWindows ? "\u251C" : "\u2523";
  }
  static get heavyDownAndHorizontal() {
    return isWindows ? "\u252C" : "\u2533";
  }
  static get doubleLightHorizontal() {
    return "\u2500\u2500";
  }
};
Log.events = new Emitter();
Log.takeTimeEntries = () => {
  const entries = getEntries();
  clear();
  return entries;
};
Log.getTimeEntries = () => getEntries();
var lighthouse_logger_default = Log;

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/utils.js
var import_path4 = require("path");
var import_child_process = __toESM(require("child_process"), 1);
var import_fs4 = require("fs");
var import_is_wsl = __toESM(require_is_wsl(), 1);
function defaults(val, def) {
  return typeof val === "undefined" ? def : val;
}
function delay(time) {
  return __async(this, null, function* () {
    return new Promise((resolve3) => setTimeout(resolve3, time));
  });
}
var LauncherError = class extends Error {
  constructor(message = "Unexpected error", code) {
    super();
    this.message = message;
    this.code = code;
    this.stack = new Error().stack;
    return this;
  }
};
var ChromePathNotSetError = class extends LauncherError {
  constructor() {
    super(...arguments);
    this.message = "The CHROME_PATH environment variable must be set to a Chrome/Chromium executable no older than Chrome stable.";
    this.code = "ERR_LAUNCHER_PATH_NOT_SET";
  }
};
var InvalidUserDataDirectoryError = class extends LauncherError {
  constructor() {
    super(...arguments);
    this.message = "userDataDir must be false or a path.";
    this.code = "ERR_LAUNCHER_INVALID_USER_DATA_DIRECTORY";
  }
};
var UnsupportedPlatformError = class extends LauncherError {
  constructor() {
    super(...arguments);
    this.message = `Platform ${getPlatform()} is not supported.`;
    this.code = "ERR_LAUNCHER_UNSUPPORTED_PLATFORM";
  }
};
var ChromeNotInstalledError = class extends LauncherError {
  constructor() {
    super(...arguments);
    this.message = "No Chrome installations found.";
    this.code = "ERR_LAUNCHER_NOT_INSTALLED";
  }
};
function getPlatform() {
  return import_is_wsl.default ? "wsl" : process.platform;
}
function makeTmpDir() {
  switch (getPlatform()) {
    case "darwin":
    case "linux":
      return makeUnixTmpDir();
    case "wsl":
      process.env.TEMP = getWSLLocalAppDataPath(`${process.env.PATH}`);
    case "win32":
      return makeWin32TmpDir();
    default:
      throw new UnsupportedPlatformError();
  }
}
function toWinDirFormat(dir = "") {
  const results = /\/mnt\/([a-z])\//.exec(dir);
  if (!results) {
    return dir;
  }
  const driveLetter = results[1];
  return dir.replace(`/mnt/${driveLetter}/`, `${driveLetter.toUpperCase()}:\\`).replace(/\//g, "\\");
}
function toWin32Path(dir = "") {
  if (/[a-z]:\\/iu.test(dir)) {
    return dir;
  }
  try {
    return import_child_process.default.execFileSync("wslpath", ["-w", dir]).toString().trim();
  } catch (e2) {
    return toWinDirFormat(dir);
  }
}
function toWSLPath(dir, fallback) {
  try {
    return import_child_process.default.execFileSync("wslpath", ["-u", dir]).toString().trim();
  } catch (e2) {
    return fallback;
  }
}
function getLocalAppDataPath(path8) {
  const userRegExp = /\/mnt\/([a-z])\/Users\/([^\/:]+)\/AppData\//;
  const results = userRegExp.exec(path8) || [];
  return `/mnt/${results[1]}/Users/${results[2]}/AppData/Local`;
}
function getWSLLocalAppDataPath(path8) {
  const userRegExp = /\/([a-z])\/Users\/([^\/:]+)\/AppData\//;
  const results = userRegExp.exec(path8) || [];
  return toWSLPath(`${results[1]}:\\Users\\${results[2]}\\AppData\\Local`, getLocalAppDataPath(path8));
}
function makeUnixTmpDir() {
  return import_child_process.default.execSync("mktemp -d -t lighthouse.XXXXXXX").toString().trim();
}
function makeWin32TmpDir() {
  const winTmpPath = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp";
  const randomNumber = Math.floor(Math.random() * 9e7 + 1e7);
  const tmpdir2 = (0, import_path4.join)(winTmpPath, "lighthouse." + randomNumber);
  (0, import_fs4.mkdirSync)(tmpdir2, { recursive: true });
  return tmpdir2;
}

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-finder.js
var newLineRegex = /\r?\n/;
function darwinFast() {
  const priorityOptions = [
    process.env.CHROME_PATH,
    process.env.LIGHTHOUSE_CHROMIUM_PATH,
    "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
  ];
  for (const chromePath of priorityOptions) {
    if (chromePath && canAccess(chromePath))
      return chromePath;
  }
  return darwin()[0];
}
function darwin() {
  const suffixes = ["/Contents/MacOS/Google Chrome Canary", "/Contents/MacOS/Google Chrome"];
  const LSREGISTER = "/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister";
  const installations = [];
  const customChromePath = resolveChromePath();
  if (customChromePath) {
    installations.push(customChromePath);
  }
  (0, import_child_process2.execSync)(`${LSREGISTER} -dump | grep -i 'google chrome\\( canary\\)\\?\\.app' | awk '{$1=""; print $0}'`).toString().split(newLineRegex).forEach((inst) => {
    suffixes.forEach((suffix) => {
      const execPath = import_path5.default.join(inst.substring(0, inst.indexOf(".app") + 4).trim(), suffix);
      if (canAccess(execPath) && installations.indexOf(execPath) === -1) {
        installations.push(execPath);
      }
    });
  });
  const home = (0, import_escape_string_regexp.default)(process.env.HOME || (0, import_os.homedir)());
  const priorities = [
    { regex: new RegExp(`^${home}/Applications/.*Chrome\\.app`), weight: 50 },
    { regex: new RegExp(`^${home}/Applications/.*Chrome Canary\\.app`), weight: 51 },
    { regex: /^\/Applications\/.*Chrome.app/, weight: 100 },
    { regex: /^\/Applications\/.*Chrome Canary.app/, weight: 101 },
    { regex: /^\/Volumes\/.*Chrome.app/, weight: -2 },
    { regex: /^\/Volumes\/.*Chrome Canary.app/, weight: -1 }
  ];
  if (process.env.LIGHTHOUSE_CHROMIUM_PATH) {
    priorities.unshift({ regex: new RegExp((0, import_escape_string_regexp.default)(process.env.LIGHTHOUSE_CHROMIUM_PATH)), weight: 150 });
  }
  if (process.env.CHROME_PATH) {
    priorities.unshift({ regex: new RegExp((0, import_escape_string_regexp.default)(process.env.CHROME_PATH)), weight: 151 });
  }
  return sort(installations, priorities);
}
function resolveChromePath() {
  if (canAccess(process.env.CHROME_PATH)) {
    return process.env.CHROME_PATH;
  }
  if (canAccess(process.env.LIGHTHOUSE_CHROMIUM_PATH)) {
    lighthouse_logger_default.warn("ChromeLauncher", "LIGHTHOUSE_CHROMIUM_PATH is deprecated, use CHROME_PATH env variable instead.");
    return process.env.LIGHTHOUSE_CHROMIUM_PATH;
  }
  return void 0;
}
function linux() {
  let installations = [];
  const customChromePath = resolveChromePath();
  if (customChromePath) {
    installations.push(customChromePath);
  }
  const desktopInstallationFolders = [
    import_path5.default.join((0, import_os.homedir)(), ".local/share/applications/"),
    "/usr/share/applications/"
  ];
  desktopInstallationFolders.forEach((folder) => {
    installations = installations.concat(findChromeExecutables(folder));
  });
  const executables = [
    "google-chrome-stable",
    "google-chrome",
    "chromium-browser",
    "chromium"
  ];
  executables.forEach((executable) => {
    try {
      const chromePath = (0, import_child_process2.execFileSync)("which", [executable], { stdio: "pipe" }).toString().split(newLineRegex)[0];
      if (canAccess(chromePath)) {
        installations.push(chromePath);
      }
    } catch (e2) {
    }
  });
  if (!installations.length) {
    throw new ChromePathNotSetError();
  }
  const priorities = [
    { regex: /chrome-wrapper$/, weight: 51 },
    { regex: /google-chrome-stable$/, weight: 50 },
    { regex: /google-chrome$/, weight: 49 },
    { regex: /chromium-browser$/, weight: 48 },
    { regex: /chromium$/, weight: 47 }
  ];
  if (process.env.LIGHTHOUSE_CHROMIUM_PATH) {
    priorities.unshift({ regex: new RegExp((0, import_escape_string_regexp.default)(process.env.LIGHTHOUSE_CHROMIUM_PATH)), weight: 100 });
  }
  if (process.env.CHROME_PATH) {
    priorities.unshift({ regex: new RegExp((0, import_escape_string_regexp.default)(process.env.CHROME_PATH)), weight: 101 });
  }
  return sort(uniq(installations.filter(Boolean)), priorities);
}
function wsl() {
  process.env.LOCALAPPDATA = getWSLLocalAppDataPath(`${process.env.PATH}`);
  process.env.PROGRAMFILES = toWSLPath("C:/Program Files", "/mnt/c/Program Files");
  process.env["PROGRAMFILES(X86)"] = toWSLPath("C:/Program Files (x86)", "/mnt/c/Program Files (x86)");
  return win32();
}
function win32() {
  const installations = [];
  const suffixes = [
    `${import_path5.default.sep}Google${import_path5.default.sep}Chrome SxS${import_path5.default.sep}Application${import_path5.default.sep}chrome.exe`,
    `${import_path5.default.sep}Google${import_path5.default.sep}Chrome${import_path5.default.sep}Application${import_path5.default.sep}chrome.exe`
  ];
  const prefixes = [
    process.env.LOCALAPPDATA,
    process.env.PROGRAMFILES,
    process.env["PROGRAMFILES(X86)"]
  ].filter(Boolean);
  const customChromePath = resolveChromePath();
  if (customChromePath) {
    installations.push(customChromePath);
  }
  prefixes.forEach((prefix) => suffixes.forEach((suffix) => {
    const chromePath = import_path5.default.join(prefix, suffix);
    if (canAccess(chromePath)) {
      installations.push(chromePath);
    }
  }));
  return installations;
}
function sort(installations, priorities) {
  const defaultPriority = 10;
  return installations.map((inst) => {
    for (const pair of priorities) {
      if (pair.regex.test(inst)) {
        return { path: inst, weight: pair.weight };
      }
    }
    return { path: inst, weight: defaultPriority };
  }).sort((a, b) => b.weight - a.weight).map((pair) => pair.path);
}
function canAccess(file) {
  if (!file) {
    return false;
  }
  try {
    import_fs5.default.accessSync(file);
    return true;
  } catch (e2) {
    return false;
  }
}
function uniq(arr) {
  return Array.from(new Set(arr));
}
function findChromeExecutables(folder) {
  const argumentsRegex = /(^[^ ]+).*/;
  const chromeExecRegex = "^Exec=/.*/(google-chrome|chrome|chromium)-.*";
  let installations = [];
  if (canAccess(folder)) {
    let execPaths;
    try {
      execPaths = (0, import_child_process2.execSync)(`grep -ER "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`, { stdio: "pipe" });
    } catch (e2) {
      execPaths = (0, import_child_process2.execSync)(`grep -Er "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`, { stdio: "pipe" });
    }
    execPaths = execPaths.toString().split(newLineRegex).map((execPath) => execPath.replace(argumentsRegex, "$1"));
    execPaths.forEach((execPath) => canAccess(execPath) && installations.push(execPath));
  }
  return installations;
}

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/random-port.js
var import_http = require("http");
function getRandomPort() {
  return new Promise((resolve3, reject) => {
    const server = (0, import_http.createServer)();
    server.listen(0);
    server.once("listening", () => {
      const { port } = server.address();
      server.close(() => resolve3(port));
    });
    server.once("error", reject);
  });
}

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/flags.js
var DEFAULT_FLAGS = [
  "--disable-features=" + [
    // Disable built-in Google Translate service
    "Translate",
    // Disable the Chrome Optimization Guide background networking
    "OptimizationHints",
    //  Disable the Chrome Media Router (cast target discovery) background networking
    "MediaRouter",
    /// Avoid the startup dialog for _Do you want the application Chromium.app to accept incoming network connections?_. This is a sub-component of the MediaRouter.
    "DialMediaRouteProvider",
    // Disable the feature of: Calculate window occlusion on Windows will be used in the future to throttle and potentially unload foreground tabs in occluded windows.
    "CalculateNativeWinOcclusion",
    // Disables the Discover feed on NTP
    "InterestFeedContentSuggestions",
    // Don't update the CT lists
    "CertificateTransparencyComponentUpdater",
    // Disables autofill server communication. This feature isn't disabled via other 'parent' flags.
    "AutofillServerCommunication",
    // Disables "Enhanced ad privacy in Chrome" dialog (though as of 2024-03-20 it shouldn't show up if the profile has no stored country).
    "PrivacySandboxSettings4"
  ].join(","),
  // Disable all chrome extensions
  "--disable-extensions",
  // Disable some extensions that aren't affected by --disable-extensions
  "--disable-component-extensions-with-background-pages",
  // Disable various background network services, including extension updating,
  //   safe browsing service, upgrade detector, translate, UMA
  "--disable-background-networking",
  // Don't update the browser 'components' listed at chrome://components/
  "--disable-component-update",
  // Disables client-side phishing detection.
  "--disable-client-side-phishing-detection",
  // Disable syncing to a Google account
  "--disable-sync",
  // Disable reporting to UMA, but allows for collection
  "--metrics-recording-only",
  // Disable installation of default apps on first run
  "--disable-default-apps",
  // Mute any audio
  "--mute-audio",
  // Disable the default browser check, do not prompt to set it as such
  "--no-default-browser-check",
  // Skip first run wizards
  "--no-first-run",
  // Disable backgrounding renders for occluded windows
  "--disable-backgrounding-occluded-windows",
  // Disable renderer process backgrounding
  "--disable-renderer-backgrounding",
  // Disable task throttling of timer tasks from background pages.
  "--disable-background-timer-throttling",
  // Disable the default throttling of IPC between renderer & browser processes.
  "--disable-ipc-flooding-protection",
  // Avoid potential instability of using Gnome Keyring or KDE wallet. crbug.com/571003 crbug.com/991424
  "--password-store=basic",
  // Use mock keychain on Mac to prevent blocking permissions dialogs
  "--use-mock-keychain",
  // Disable background tracing (aka slow reports & deep reports) to avoid 'Tracing already started'
  "--force-fieldtrials=*BackgroundTracing/default/",
  // Suppresses hang monitor dialogs in renderer processes. This flag may allow slow unload handlers on a page to prevent the tab from closing.
  "--disable-hang-monitor",
  // Reloading a page that came from a POST normally prompts the user.
  "--disable-prompt-on-repost",
  // Disables Domain Reliability Monitoring, which tracks whether the browser has difficulty contacting Google-owned sites and uploads reports to Google.
  "--disable-domain-reliability",
  // Disable the in-product Help (IPH) system.
  "--propagate-iph-for-testing"
];

// ../../node_modules/.pnpm/chrome-launcher@1.2.0/node_modules/chrome-launcher/dist/chrome-launcher.js
var import_child_process3 = require("child_process");
var isWsl2 = getPlatform() === "wsl";
var isWindows2 = getPlatform() === "win32";
var _SIGINT = "SIGINT";
var _SIGINT_EXIT_CODE = 130;
var _SUPPORTED_PLATFORMS = /* @__PURE__ */ new Set(["darwin", "linux", "win32", "wsl"]);
var instances = /* @__PURE__ */ new Set();
var sigintListener = () => {
  killAll();
  process.exit(_SIGINT_EXIT_CODE);
};
function launch() {
  return __async(this, arguments, function* (opts = {}) {
    opts.handleSIGINT = defaults(opts.handleSIGINT, true);
    const instance = new Launcher(opts);
    if (opts.handleSIGINT && instances.size === 0) {
      process.on(_SIGINT, sigintListener);
    }
    instances.add(instance);
    yield instance.launch();
    const kill = () => {
      instances.delete(instance);
      if (instances.size === 0) {
        process.removeListener(_SIGINT, sigintListener);
      }
      instance.kill();
    };
    return {
      pid: instance.pid,
      port: instance.port,
      process: instance.chromeProcess,
      remoteDebuggingPipes: instance.remoteDebuggingPipes,
      kill
    };
  });
}
function killAll() {
  let errors = [];
  for (const instance of instances) {
    try {
      instance.kill();
      instances.delete(instance);
    } catch (err) {
      errors.push(err);
    }
  }
  return errors;
}
var Launcher = class _Launcher {
  constructor(opts = {}, moduleOverrides = {}) {
    this.opts = opts;
    this.tmpDirandPidFileReady = false;
    this.remoteDebuggingPipes = null;
    this.fs = moduleOverrides.fs || fs7;
    this.spawn = moduleOverrides.spawn || import_child_process3.spawn;
    lighthouse_logger_default.setLevel(defaults(this.opts.logLevel, "silent"));
    this.startingUrl = defaults(this.opts.startingUrl, "about:blank");
    this.chromeFlags = defaults(this.opts.chromeFlags, []);
    this.prefs = defaults(this.opts.prefs, {});
    this.requestedPort = defaults(this.opts.port, 0);
    this.portStrictMode = opts.portStrictMode;
    this.chromePath = this.opts.chromePath;
    this.ignoreDefaultFlags = defaults(this.opts.ignoreDefaultFlags, false);
    this.connectionPollInterval = defaults(this.opts.connectionPollInterval, 500);
    this.maxConnectionRetries = defaults(this.opts.maxConnectionRetries, 50);
    this.envVars = defaults(opts.envVars, Object.assign({}, process.env));
    if (typeof this.opts.userDataDir === "boolean") {
      if (!this.opts.userDataDir) {
        this.useDefaultProfile = true;
        this.userDataDir = void 0;
      } else {
        throw new InvalidUserDataDirectoryError();
      }
    } else {
      this.useDefaultProfile = false;
      this.userDataDir = this.opts.userDataDir;
    }
    this.useRemoteDebuggingPipe = this.chromeFlags.some((f3) => f3.startsWith("--remote-debugging-pipe"));
  }
  get flags() {
    const flags = this.ignoreDefaultFlags ? [] : DEFAULT_FLAGS.slice();
    if (this.port) {
      flags.push(`--remote-debugging-port=${this.port}`);
    }
    if (!this.ignoreDefaultFlags && getPlatform() === "linux") {
      flags.push("--disable-setuid-sandbox");
    }
    if (!this.useDefaultProfile) {
      flags.push(`--user-data-dir=${isWsl2 ? toWin32Path(this.userDataDir) : this.userDataDir}`);
    }
    if (process.env.HEADLESS)
      flags.push("--headless");
    flags.push(...this.chromeFlags);
    flags.push(this.startingUrl);
    return flags;
  }
  static defaultFlags() {
    return DEFAULT_FLAGS.slice();
  }
  /** Returns the highest priority chrome installation. */
  static getFirstInstallation() {
    if (getPlatform() === "darwin")
      return darwinFast();
    return chrome_finder_exports[getPlatform()]()[0];
  }
  /** Returns all available chrome installations in decreasing priority order. */
  static getInstallations() {
    return chrome_finder_exports[getPlatform()]();
  }
  // Wrapper function to enable easy testing.
  makeTmpDir() {
    return makeTmpDir();
  }
  prepare() {
    const platform = getPlatform();
    if (!_SUPPORTED_PLATFORMS.has(platform)) {
      throw new UnsupportedPlatformError();
    }
    this.userDataDir = this.userDataDir || this.makeTmpDir();
    this.outFile = this.fs.openSync(`${this.userDataDir}/chrome-out.log`, "a");
    this.errFile = this.fs.openSync(`${this.userDataDir}/chrome-err.log`, "a");
    this.setBrowserPrefs();
    this.pidFile = `${this.userDataDir}/chrome.pid`;
    lighthouse_logger_default.verbose("ChromeLauncher", `created ${this.userDataDir}`);
    this.tmpDirandPidFileReady = true;
  }
  setBrowserPrefs() {
    if (Object.keys(this.prefs).length === 0) {
      return;
    }
    const profileDir = `${this.userDataDir}/Default`;
    if (!this.fs.existsSync(profileDir)) {
      this.fs.mkdirSync(profileDir, { recursive: true });
    }
    const preferenceFile = `${profileDir}/Preferences`;
    try {
      if (this.fs.existsSync(preferenceFile)) {
        const file = this.fs.readFileSync(preferenceFile, "utf-8");
        const content = JSON.parse(file);
        this.fs.writeFileSync(preferenceFile, JSON.stringify(__spreadValues(__spreadValues({}, content), this.prefs)), "utf-8");
      } else {
        this.fs.writeFileSync(preferenceFile, JSON.stringify(__spreadValues({}, this.prefs)), "utf-8");
      }
    } catch (err) {
      lighthouse_logger_default.log("ChromeLauncher", `Failed to set browser prefs: ${err.message}`);
    }
  }
  launch() {
    return __async(this, null, function* () {
      if (this.requestedPort !== 0) {
        this.port = this.requestedPort;
        try {
          yield this.isDebuggerReady();
          lighthouse_logger_default.log("ChromeLauncher", `Found existing Chrome already running using port ${this.port}, using that.`);
          return;
        } catch (err) {
          if (this.portStrictMode) {
            throw new Error(`found no Chrome at port ${this.requestedPort}`);
          }
          lighthouse_logger_default.log("ChromeLauncher", `No debugging port found on port ${this.port}, launching a new Chrome.`);
        }
      }
      if (this.chromePath === void 0) {
        const installation = _Launcher.getFirstInstallation();
        if (!installation) {
          throw new ChromeNotInstalledError();
        }
        this.chromePath = installation;
      }
      if (!this.tmpDirandPidFileReady) {
        this.prepare();
      }
      this.pid = yield this.spawnProcess(this.chromePath);
      return Promise.resolve();
    });
  }
  spawnProcess(execPath) {
    return __async(this, null, function* () {
      const spawnPromise = (() => __async(this, null, function* () {
        if (this.chromeProcess) {
          lighthouse_logger_default.log("ChromeLauncher", `Chrome already running with pid ${this.chromeProcess.pid}.`);
          return this.chromeProcess.pid;
        }
        if (this.requestedPort === 0) {
          if (this.useRemoteDebuggingPipe) {
            this.port = 0;
          } else {
            this.port = yield getRandomPort();
          }
        }
        lighthouse_logger_default.verbose("ChromeLauncher", `Launching with command:
"${execPath}" ${this.flags.join(" ")}`);
        this.chromeProcess = this.spawn(execPath, this.flags, {
          // On non-windows platforms, `detached: true` makes child process a leader of a new
          // process group, making it possible to kill child process tree with `.kill(-pid)` command.
          // @see https://nodejs.org/api/child_process.html#child_process_options_detached
          detached: process.platform !== "win32",
          stdio: this.useRemoteDebuggingPipe ? ["ignore", this.outFile, this.errFile, "pipe", "pipe"] : ["ignore", this.outFile, this.errFile],
          env: this.envVars
        });
        if (this.chromeProcess.pid) {
          this.fs.writeFileSync(this.pidFile, this.chromeProcess.pid.toString());
        }
        if (this.useRemoteDebuggingPipe) {
          this.remoteDebuggingPipes = {
            incoming: this.chromeProcess.stdio[4],
            outgoing: this.chromeProcess.stdio[3]
          };
        }
        lighthouse_logger_default.verbose("ChromeLauncher", `Chrome running with pid ${this.chromeProcess.pid} on port ${this.port}.`);
        return this.chromeProcess.pid;
      }))();
      const pid = yield spawnPromise;
      if (this.port !== 0) {
        yield this.waitUntilReady();
      }
      return pid;
    });
  }
  cleanup(client) {
    if (client) {
      client.removeAllListeners();
      client.end();
      client.destroy();
      client.unref();
    }
  }
  // resolves if ready, rejects otherwise
  isDebuggerReady() {
    return new Promise((resolve3, reject) => {
      const client = net.createConnection(this.port, "127.0.0.1");
      client.once("error", (err) => {
        this.cleanup(client);
        reject(err);
      });
      client.once("connect", () => {
        this.cleanup(client);
        resolve3();
      });
    });
  }
  // resolves when debugger is ready, rejects after 10 polls
  waitUntilReady() {
    const launcher = this;
    return new Promise((resolve3, reject) => {
      let retries = 0;
      let waitStatus = "Waiting for browser.";
      const poll = () => {
        if (retries === 0) {
          lighthouse_logger_default.log("ChromeLauncher", waitStatus);
        }
        retries++;
        waitStatus += "..";
        lighthouse_logger_default.log("ChromeLauncher", waitStatus);
        launcher.isDebuggerReady().then(() => {
          lighthouse_logger_default.log("ChromeLauncher", waitStatus + `${lighthouse_logger_default.greenify(lighthouse_logger_default.tick)}`);
          resolve3();
        }).catch((err) => {
          if (retries > launcher.maxConnectionRetries) {
            lighthouse_logger_default.error("ChromeLauncher", err.message);
            const stderr = this.fs.readFileSync(`${this.userDataDir}/chrome-err.log`, { encoding: "utf-8" });
            lighthouse_logger_default.error("ChromeLauncher", `Logging contents of ${this.userDataDir}/chrome-err.log`);
            lighthouse_logger_default.error("ChromeLauncher", stderr);
            return reject(err);
          }
          delay(launcher.connectionPollInterval).then(poll);
        });
      };
      poll();
    });
  }
  kill() {
    if (!this.chromeProcess) {
      return;
    }
    this.chromeProcess.on("close", () => {
      delete this.chromeProcess;
      this.destroyTmp();
    });
    lighthouse_logger_default.log("ChromeLauncher", `Killing Chrome instance ${this.chromeProcess.pid}`);
    try {
      if (isWindows2) {
        const taskkillProc = (0, import_child_process3.spawnSync)(`taskkill /pid ${this.chromeProcess.pid} /T /F`, { shell: true, encoding: "utf-8" });
        const { stderr } = taskkillProc;
        if (stderr)
          lighthouse_logger_default.error("ChromeLauncher", `taskkill stderr`, stderr);
      } else {
        if (this.chromeProcess.pid) {
          process.kill(-this.chromeProcess.pid, "SIGKILL");
        }
      }
    } catch (err) {
      const message = `Chrome could not be killed ${err.message}`;
      lighthouse_logger_default.warn("ChromeLauncher", message);
    }
    this.destroyTmp();
  }
  destroyTmp() {
    if (this.outFile) {
      this.fs.closeSync(this.outFile);
      delete this.outFile;
    }
    if (this.userDataDir === void 0 || this.opts.userDataDir !== void 0) {
      return;
    }
    if (this.errFile) {
      this.fs.closeSync(this.errFile);
      delete this.errFile;
    }
    const rmSync = this.fs.rmSync || this.fs.rmdirSync;
    rmSync(this.userDataDir, { recursive: true, force: true, maxRetries: 10 });
  }
};

// lib/v3/launch/local.ts
init_sdkErrors();
function launchLocalChrome(opts) {
  return __async(this, null, function* () {
    var _a4, _b, _c;
    const headless = (_a4 = opts.headless) != null ? _a4 : false;
    const chromeFlags = [
      headless ? "--headless=new" : void 0,
      "--remote-allow-origins=*",
      "--no-first-run",
      "--no-default-browser-check",
      "--disable-dev-shm-usage",
      "--site-per-process",
      ...(_b = opts.chromeFlags) != null ? _b : []
    ].filter((f3) => typeof f3 === "string");
    const chrome = yield launch({
      chromePath: opts.chromePath,
      chromeFlags,
      userDataDir: opts.userDataDir
    });
    const ws = yield waitForWebSocketDebuggerUrl(
      chrome.port,
      (_c = opts.connectTimeoutMs) != null ? _c : 15e3
    );
    return { ws, chrome };
  });
}
function waitForWebSocketDebuggerUrl(port, timeoutMs) {
  return __async(this, null, function* () {
    const deadline = Date.now() + timeoutMs;
    let lastErrMsg = "";
    while (Date.now() < deadline) {
      try {
        const resp = yield fetch(`http://127.0.0.1:${port}/json/version`);
        if (resp.ok) {
          const json = yield resp.json();
          const url = json.webSocketDebuggerUrl;
          if (typeof url === "string") return url;
        } else {
          lastErrMsg = `${resp.status} ${resp.statusText}`;
        }
      } catch (err) {
        lastErrMsg = err instanceof Error ? err.message : String(err);
      }
      yield new Promise((r2) => setTimeout(r2, 250));
    }
    throw new ConnectionTimeoutError(
      `Timed out waiting for /json/version on port ${port}${lastErrMsg ? ` (last error: ${lastErrMsg})` : ""}`
    );
  });
}

// lib/v3/llm/LLMProvider.ts
init_sdkErrors();

// lib/v3/llm/aisdk.ts
var import_ai21 = require("ai");
var import_uuid5 = require("uuid");

// lib/v3/llm/LLMClient.ts
var import_ai20 = require("ai");
var AnnotatedScreenshotText = "This is a screenshot of the current page state with the elements annotated on it. Each element id is annotated with a number to the top left of it. Duplicate annotations at the same location are under each other vertically.";
var LLMClient = class {
  constructor(modelName, userProvidedInstructions) {
    this.generateObject = import_ai20.generateObject;
    this.generateText = import_ai20.generateText;
    this.streamText = import_ai20.streamText;
    this.streamObject = import_ai20.streamObject;
    this.generateImage = import_ai20.experimental_generateImage;
    this.embed = import_ai20.embed;
    this.embedMany = import_ai20.embedMany;
    this.transcribe = import_ai20.experimental_transcribe;
    this.generateSpeech = import_ai20.experimental_generateSpeech;
    this.modelName = modelName;
    this.userProvidedInstructions = userProvidedInstructions;
  }
};

// lib/v3/llm/aisdk.ts
init_flowLogger();
var AISdkClient = class extends LLMClient {
  constructor({
    model,
    logger
  }) {
    super(model.modelId);
    this.type = "aisdk";
    this.model = model;
    this.logger = logger;
  }
  getLanguageModel() {
    return this.model;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
      (_a4 = this.logger) == null ? void 0 : _a4.call(this, {
        category: "aisdk",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          options: {
            value: JSON.stringify(__spreadProps(__spreadValues({}, options), {
              image: void 0,
              messages: options.messages.map((msg) => __spreadProps(__spreadValues({}, msg), {
                content: Array.isArray(msg.content) ? msg.content.map(
                  (c) => "image_url" in c ? __spreadProps(__spreadValues({}, c), { image_url: { url: "[IMAGE_REDACTED]" } }) : c
                ) : msg.content
              }))
            })),
            type: "object"
          },
          modelName: {
            value: this.model.modelId,
            type: "string"
          }
        }
      });
      const formattedMessages = options.messages.map(
        (message) => {
          if (Array.isArray(message.content)) {
            if (message.role === "system") {
              const systemMessage = {
                role: "system",
                content: message.content.map((c) => "text" in c ? c.text : "").join("\n")
              };
              return systemMessage;
            }
            const contentParts = message.content.map((content) => {
              if ("image_url" in content) {
                const imageContent = {
                  type: "image",
                  image: content.image_url.url
                };
                return imageContent;
              } else {
                const textContent = {
                  type: "text",
                  text: content.text
                };
                return textContent;
              }
            });
            if (message.role === "user") {
              const userMessage = {
                role: "user",
                content: contentParts
              };
              return userMessage;
            } else {
              const textOnlyParts = contentParts.map((part) => ({
                type: "text",
                text: part.type === "image" ? "[Image]" : part.text
              }));
              const assistantMessage = {
                role: "assistant",
                content: textOnlyParts
              };
              return assistantMessage;
            }
          }
          return {
            role: message.role,
            content: message.content
          };
        }
      );
      let objectResponse;
      const isGPT5 = this.model.modelId.includes("gpt-5");
      const usesLowReasoningEffort = this.model.modelId.includes("gpt-5.1") || this.model.modelId.includes("gpt-5.2");
      if (options.response_model) {
        const llmRequestId2 = (0, import_uuid5.v7)();
        const promptPreview2 = formatLlmPromptPreview(options.messages, {
          hasSchema: true
        });
        SessionFileLogger.logLlmRequest({
          requestId: llmRequestId2,
          model: this.model.modelId,
          operation: "generateObject",
          prompt: promptPreview2
        });
        const isDeepSeek = this.model.modelId.includes("deepseek");
        if (isDeepSeek) {
          const parsedSchema = JSON.stringify(
            toJsonSchema(options.response_model.schema)
          );
          formattedMessages.push({
            role: "user",
            content: `Respond in this zod schema format:
${parsedSchema}

You must respond in JSON format. respond WITH JSON. Do not include any other text, formatting or markdown in your output. Do not include \`\`\` or \`\`\`json in your response. Only the JSON object itself.`
          });
        }
        try {
          objectResponse = yield (0, import_ai21.generateObject)({
            model: this.model,
            messages: formattedMessages,
            schema: options.response_model.schema,
            temperature: options.temperature,
            providerOptions: isGPT5 ? {
              openai: {
                textVerbosity: "low",
                // Making these the default for gpt-5 for now
                reasoningEffort: usesLowReasoningEffort ? "low" : "minimal"
              }
            } : void 0
          });
        } catch (err) {
          SessionFileLogger.logLlmResponse({
            requestId: llmRequestId2,
            model: this.model.modelId,
            operation: "generateObject",
            output: `[error: ${err instanceof Error ? err.message : "unknown"}]`
          });
          if (import_ai21.NoObjectGeneratedError.isInstance(err)) {
            (_g = this.logger) == null ? void 0 : _g.call(this, {
              category: "AISDK error",
              message: err.message,
              level: 0,
              auxiliary: {
                cause: {
                  value: JSON.stringify((_b = err.cause) != null ? _b : {}),
                  type: "object"
                },
                text: {
                  value: (_c = err.text) != null ? _c : "",
                  type: "string"
                },
                response: {
                  value: JSON.stringify((_d2 = err.response) != null ? _d2 : {}),
                  type: "object"
                },
                usage: {
                  value: JSON.stringify((_e = err.usage) != null ? _e : {}),
                  type: "object"
                },
                finishReason: {
                  value: (_f = err.finishReason) != null ? _f : "unknown",
                  type: "string"
                },
                requestId: {
                  value: options.requestId,
                  type: "string"
                }
              }
            });
            throw err;
          }
          throw err;
        }
        const result2 = {
          data: objectResponse.object,
          usage: {
            prompt_tokens: (_h = objectResponse.usage.inputTokens) != null ? _h : 0,
            completion_tokens: (_i = objectResponse.usage.outputTokens) != null ? _i : 0,
            reasoning_tokens: (_j = objectResponse.usage.reasoningTokens) != null ? _j : 0,
            cached_input_tokens: (_k = objectResponse.usage.cachedInputTokens) != null ? _k : 0,
            total_tokens: (_l = objectResponse.usage.totalTokens) != null ? _l : 0
          }
        };
        SessionFileLogger.logLlmResponse({
          requestId: llmRequestId2,
          model: this.model.modelId,
          operation: "generateObject",
          output: JSON.stringify(objectResponse.object),
          inputTokens: objectResponse.usage.inputTokens,
          outputTokens: objectResponse.usage.outputTokens
        });
        (_m = this.logger) == null ? void 0 : _m.call(this, {
          category: "aisdk",
          message: "response",
          level: 1,
          auxiliary: {
            response: {
              value: JSON.stringify({
                object: objectResponse.object,
                usage: objectResponse.usage,
                finishReason: objectResponse.finishReason
                // Omit request and response properties that might contain images
              }),
              type: "object"
            },
            requestId: {
              value: options.requestId,
              type: "string"
            }
          }
        });
        return result2;
      }
      const tools = {};
      if (options.tools && options.tools.length > 0) {
        for (const tool21 of options.tools) {
          tools[tool21.name] = {
            description: tool21.description,
            inputSchema: tool21.parameters
          };
        }
      }
      const llmRequestId = (0, import_uuid5.v7)();
      const toolCount = Object.keys(tools).length;
      const promptPreview = formatLlmPromptPreview(options.messages, {
        toolCount
      });
      SessionFileLogger.logLlmRequest({
        requestId: llmRequestId,
        model: this.model.modelId,
        operation: "generateText",
        prompt: promptPreview
      });
      let textResponse;
      try {
        textResponse = yield (0, import_ai21.generateText)({
          model: this.model,
          messages: formattedMessages,
          tools: Object.keys(tools).length > 0 ? tools : void 0,
          toolChoice: Object.keys(tools).length > 0 ? options.tool_choice === "required" ? "required" : options.tool_choice === "none" ? "none" : "auto" : void 0,
          temperature: options.temperature
        });
      } catch (err) {
        SessionFileLogger.logLlmResponse({
          requestId: llmRequestId,
          model: this.model.modelId,
          operation: "generateText",
          output: `[error: ${err instanceof Error ? err.message : "unknown"}]`
        });
        throw err;
      }
      const transformedToolCalls = (textResponse.toolCalls || []).map(
        (toolCall) => ({
          id: toolCall.toolCallId || `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          type: "function",
          function: {
            name: toolCall.toolName,
            arguments: JSON.stringify(toolCall.input)
          }
        })
      );
      const result = {
        id: `chatcmpl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        object: "chat.completion",
        created: Math.floor(Date.now() / 1e3),
        model: this.model.modelId,
        choices: [
          {
            index: 0,
            message: {
              role: "assistant",
              content: textResponse.text || null,
              tool_calls: transformedToolCalls
            },
            finish_reason: textResponse.finishReason || "stop"
          }
        ],
        usage: {
          prompt_tokens: (_n = textResponse.usage.inputTokens) != null ? _n : 0,
          completion_tokens: (_o = textResponse.usage.outputTokens) != null ? _o : 0,
          reasoning_tokens: (_p = textResponse.usage.reasoningTokens) != null ? _p : 0,
          cached_input_tokens: (_q = textResponse.usage.cachedInputTokens) != null ? _q : 0,
          total_tokens: (_r = textResponse.usage.totalTokens) != null ? _r : 0
        }
      };
      SessionFileLogger.logLlmResponse({
        requestId: llmRequestId,
        model: this.model.modelId,
        operation: "generateText",
        output: textResponse.text || (transformedToolCalls.length > 0 ? `[${transformedToolCalls.length} tool calls]` : ""),
        inputTokens: textResponse.usage.inputTokens,
        outputTokens: textResponse.usage.outputTokens
      });
      (_s = this.logger) == null ? void 0 : _s.call(this, {
        category: "aisdk",
        message: "response",
        level: 2,
        auxiliary: {
          response: {
            value: JSON.stringify({
              text: textResponse.text,
              usage: textResponse.usage,
              finishReason: textResponse.finishReason
              // Omit request and response properties that might contain images
            }),
            type: "object"
          },
          requestId: {
            value: options.requestId,
            type: "string"
          }
        }
      });
      return result;
    });
  }
};

// lib/v3/llm/AnthropicClient.ts
var import_sdk3 = __toESM(require("@anthropic-ai/sdk"));
init_sdkErrors();
var AnthropicClient = class extends LLMClient {
  constructor({
    modelName,
    clientOptions,
    userProvidedInstructions
  }) {
    super(modelName);
    this.type = "anthropic";
    this.client = new import_sdk3.default(clientOptions);
    this.modelName = modelName;
    this.clientOptions = clientOptions;
    this.userProvidedInstructions = userProvidedInstructions;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options,
      retries,
      logger
    }) {
      var _a4, _b;
      const optionsWithoutImage = __spreadValues({}, options);
      delete optionsWithoutImage.image;
      logger({
        category: "anthropic",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          options: {
            value: JSON.stringify(optionsWithoutImage),
            type: "object"
          }
        }
      });
      const systemMessage = options.messages.find((msg) => {
        if (msg.role === "system") {
          if (typeof msg.content === "string") {
            return true;
          } else if (Array.isArray(msg.content)) {
            return msg.content.every((content) => content.type !== "image_url");
          }
        }
        return false;
      });
      const userMessages = options.messages.filter(
        (msg) => msg.role !== "system"
      );
      const formattedMessages = userMessages.map((msg) => {
        if (typeof msg.content === "string") {
          return {
            role: msg.role,
            // ensure its not checking for system types
            content: msg.content
          };
        } else {
          return {
            role: msg.role,
            content: msg.content.map((content) => {
              if ("image_url" in content) {
                const formattedContent = {
                  type: "image",
                  source: {
                    type: "base64",
                    media_type: "image/jpeg",
                    data: content.image_url.url
                  }
                };
                return formattedContent;
              } else {
                return { type: "text", text: content.text };
              }
            })
          };
        }
      });
      if (options.image) {
        const screenshotMessage = {
          role: "user",
          content: [
            {
              type: "image",
              source: {
                type: "base64",
                media_type: "image/jpeg",
                data: options.image.buffer.toString("base64")
              }
            }
          ]
        };
        if (options.image.description && Array.isArray(screenshotMessage.content)) {
          screenshotMessage.content.push({
            type: "text",
            text: options.image.description
          });
        }
        formattedMessages.push(screenshotMessage);
      }
      let anthropicTools2 = (_a4 = options.tools) == null ? void 0 : _a4.map((tool21) => {
        return {
          name: tool21.name,
          description: tool21.description,
          input_schema: {
            type: "object",
            properties: tool21.parameters.properties,
            required: tool21.parameters.required
          }
        };
      });
      let toolDefinition;
      if (options.response_model) {
        const jsonSchema3 = toJsonSchema(options.response_model.schema);
        const { properties: schemaProperties, required: schemaRequired } = extractSchemaProperties(jsonSchema3);
        toolDefinition = {
          name: "print_extracted_data",
          description: "Prints the extracted data based on the provided schema.",
          input_schema: {
            type: "object",
            properties: schemaProperties,
            required: schemaRequired
          }
        };
      }
      if (toolDefinition) {
        anthropicTools2 = anthropicTools2 != null ? anthropicTools2 : [];
        anthropicTools2.push(toolDefinition);
      }
      const response = yield this.client.messages.create({
        model: this.modelName,
        max_tokens: options.maxOutputTokens || 8192,
        messages: formattedMessages,
        tools: anthropicTools2,
        system: systemMessage ? systemMessage.content : void 0,
        temperature: options.temperature
      });
      logger({
        category: "anthropic",
        message: "response",
        level: 2,
        auxiliary: {
          response: {
            value: JSON.stringify(response),
            type: "object"
          },
          requestId: {
            value: options.requestId,
            type: "string"
          }
        }
      });
      const usageData = {
        prompt_tokens: response.usage.input_tokens,
        completion_tokens: response.usage.output_tokens,
        total_tokens: response.usage.input_tokens + response.usage.output_tokens
      };
      const transformedResponse = {
        id: response.id,
        object: "chat.completion",
        created: Date.now(),
        model: response.model,
        choices: [
          {
            index: 0,
            message: {
              role: "assistant",
              content: ((_b = response.content.find((c) => c.type === "text")) == null ? void 0 : _b.text) || null,
              tool_calls: response.content.filter((c) => c.type === "tool_use").map((toolUse) => ({
                id: toolUse.id,
                type: "function",
                function: {
                  name: toolUse.name,
                  arguments: JSON.stringify(toolUse.input)
                }
              }))
            },
            finish_reason: response.stop_reason
          }
        ],
        usage: usageData
      };
      logger({
        category: "anthropic",
        message: "transformed response",
        level: 2,
        auxiliary: {
          transformedResponse: {
            value: JSON.stringify(transformedResponse),
            type: "object"
          },
          requestId: {
            value: options.requestId,
            type: "string"
          }
        }
      });
      if (options.response_model) {
        const toolUse = response.content.find((c) => c.type === "tool_use");
        if (toolUse && "input" in toolUse) {
          const result = toolUse.input;
          const finalParsedResponse = {
            data: result,
            usage: usageData
          };
          return finalParsedResponse;
        } else {
          if (!retries || retries < 5) {
            return this.createChatCompletion({
              options,
              logger,
              retries: (retries != null ? retries : 0) + 1
            });
          }
          logger({
            category: "anthropic",
            message: "error creating chat completion",
            level: 0,
            auxiliary: {
              requestId: {
                value: options.requestId,
                type: "string"
              }
            }
          });
          throw new CreateChatCompletionResponseError(
            "No tool use with input in response"
          );
        }
      }
      return transformedResponse;
    });
  }
};
var extractSchemaProperties = (jsonSchema3) => {
  var _a4;
  const schemaRoot = ((_a4 = jsonSchema3.definitions) == null ? void 0 : _a4.MySchema) || jsonSchema3;
  return {
    properties: schemaRoot.properties,
    required: schemaRoot.required
  };
};

// lib/v3/llm/CerebrasClient.ts
var import_openai3 = __toESM(require("openai"));
init_sdkErrors();
var CerebrasClient = class extends LLMClient {
  constructor({
    modelName,
    clientOptions,
    userProvidedInstructions
  }) {
    super(modelName, userProvidedInstructions);
    this.type = "cerebras";
    this.hasVision = false;
    this.client = new import_openai3.default(__spreadValues({
      baseURL: "https://api.cerebras.ai/v1",
      apiKey: (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.CEREBRAS_API_KEY
    }, clientOptions));
    this.modelName = modelName;
    this.clientOptions = clientOptions;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options,
      retries,
      logger
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      const optionsWithoutImage = __spreadValues({}, options);
      delete optionsWithoutImage.image;
      logger({
        category: "cerebras",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          options: {
            value: JSON.stringify(optionsWithoutImage),
            type: "object"
          }
        }
      });
      const formattedMessages = options.messages.map((msg) => {
        const baseMessage = {
          content: typeof msg.content === "string" ? msg.content : Array.isArray(msg.content) && msg.content.length > 0 && "text" in msg.content[0] ? msg.content[0].text : ""
        };
        if (msg.role === "system") {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "system" });
        } else if (msg.role === "assistant") {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "assistant" });
        } else {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "user" });
        }
      });
      let tools = (_a4 = options.tools) == null ? void 0 : _a4.map((tool21) => ({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: {
            type: "object",
            properties: tool21.parameters.properties,
            required: tool21.parameters.required
          }
        }
      }));
      if (options.response_model) {
        const jsonSchema3 = toJsonSchema(options.response_model.schema);
        const schemaProperties = jsonSchema3.properties || {};
        const schemaRequired = jsonSchema3.required || [];
        const responseTool = {
          type: "function",
          function: {
            name: "print_extracted_data",
            description: "Prints the extracted data based on the provided schema.",
            parameters: {
              type: "object",
              properties: schemaProperties,
              required: schemaRequired
            }
          }
        };
        tools = tools ? [...tools, responseTool] : [responseTool];
      }
      try {
        const apiResponse = yield this.client.chat.completions.create({
          model: this.modelName.split("cerebras-")[1],
          messages: [
            ...formattedMessages,
            // Add explicit instruction to return JSON if we have a response model
            ...options.response_model ? [
              {
                role: "system",
                content: `IMPORTANT: Your response must be valid JSON that matches this schema: ${JSON.stringify(
                  options.response_model.schema
                )}`
              }
            ] : []
          ],
          temperature: options.temperature || 0.7,
          max_tokens: options.maxOutputTokens,
          tools,
          tool_choice: options.tool_choice || "auto"
        });
        const response = {
          id: apiResponse.id,
          object: "chat.completion",
          created: Date.now(),
          model: this.modelName.split("cerebras-")[1],
          choices: [
            {
              index: 0,
              message: {
                role: "assistant",
                content: ((_c = (_b = apiResponse.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || null,
                tool_calls: ((_e = (_d2 = apiResponse.choices[0]) == null ? void 0 : _d2.message) == null ? void 0 : _e.tool_calls) || []
              },
              finish_reason: ((_f = apiResponse.choices[0]) == null ? void 0 : _f.finish_reason) || "stop"
            }
          ],
          usage: {
            prompt_tokens: ((_g = apiResponse.usage) == null ? void 0 : _g.prompt_tokens) || 0,
            completion_tokens: ((_h = apiResponse.usage) == null ? void 0 : _h.completion_tokens) || 0,
            total_tokens: ((_i = apiResponse.usage) == null ? void 0 : _i.total_tokens) || 0
          }
        };
        logger({
          category: "cerebras",
          message: "response",
          level: 2,
          auxiliary: {
            response: {
              value: JSON.stringify(response),
              type: "object"
            },
            requestId: {
              value: options.requestId,
              type: "string"
            }
          }
        });
        if (!options.response_model) {
          return response;
        }
        const toolCall = (_l = (_k = (_j = response.choices[0]) == null ? void 0 : _j.message) == null ? void 0 : _k.tool_calls) == null ? void 0 : _l[0];
        if ((_m = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _m.arguments) {
          try {
            const result = JSON.parse(toolCall.function.arguments);
            const finalResponse = {
              data: result,
              usage: response.usage
            };
            return finalResponse;
          } catch (e2) {
            logger({
              category: "cerebras",
              message: "failed to parse tool call arguments as JSON, retrying",
              level: 0,
              auxiliary: {
                error: {
                  value: e2.message,
                  type: "string"
                }
              }
            });
          }
        }
        const content = (_o = (_n = response.choices[0]) == null ? void 0 : _n.message) == null ? void 0 : _o.content;
        if (content) {
          try {
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              const result = JSON.parse(jsonMatch[0]);
              const finalResponse = {
                data: result,
                usage: response.usage
              };
              return finalResponse;
            }
          } catch (e2) {
            logger({
              category: "cerebras",
              message: "failed to parse content as JSON",
              level: 0,
              auxiliary: {
                error: {
                  value: e2.message,
                  type: "string"
                }
              }
            });
          }
        }
        if (!retries || retries < 5) {
          return this.createChatCompletion({
            options,
            logger,
            retries: (retries != null ? retries : 0) + 1
          });
        }
        throw new CreateChatCompletionResponseError("Invalid response schema");
      } catch (error) {
        logger({
          category: "cerebras",
          message: "error creating chat completion",
          level: 0,
          auxiliary: {
            error: {
              value: error.message,
              type: "string"
            },
            requestId: {
              value: options.requestId,
              type: "string"
            }
          }
        });
        throw error;
      }
    });
  }
};

// lib/v3/llm/GoogleClient.ts
var import_genai4 = require("@google/genai");
init_sdkErrors();
var roleMap = {
  user: "user",
  assistant: "model",
  system: "user"
  // Gemini API prefers system instructions either via system_instruction or at the start of 'user' content
};
var safetySettings = [
  {
    category: import_genai4.HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
  },
  {
    category: import_genai4.HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
  },
  {
    category: import_genai4.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
  },
  {
    category: import_genai4.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: import_genai4.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE
  }
];
var GoogleClient = class extends LLMClient {
  constructor({
    logger,
    // Added logger based on other clients
    modelName,
    clientOptions
  }) {
    super(modelName);
    this.type = "google";
    if (!(clientOptions == null ? void 0 : clientOptions.apiKey)) {
      clientOptions.apiKey = loadApiKeyFromEnv("google_legacy", logger);
    }
    this.clientOptions = clientOptions;
    this.client = new import_genai4.GoogleGenAI({ apiKey: clientOptions.apiKey });
    this.modelName = modelName;
    this.logger = logger;
    this.hasVision = modelName.includes("vision") || modelName.includes("gemini-1.5");
  }
  // Helper to convert project's ChatMessage[] to Gemini's Content[]
  formatMessages(messages, image) {
    const contents = [];
    let systemInstruction = null;
    messages.forEach((msg, index) => {
      const role = roleMap[msg.role];
      if (!role) {
        this.logger({
          category: "google",
          message: `WARNING: Unsupported role: ${msg.role}`,
          level: 1
        });
        return;
      }
      if (msg.role === "system") {
        if (typeof msg.content === "string") {
          systemInstruction = (systemInstruction ? systemInstruction + "\n\n" : "") + msg.content;
        }
        return;
      }
      const parts = [];
      if (Array.isArray(msg.content)) {
        msg.content.forEach((partContent) => {
          var _a4;
          if (partContent.type === "text") {
            parts.push({ text: partContent.text });
          } else if (partContent.type === "image_url") {
            if ("image_url" in partContent && ((_a4 = partContent.image_url) == null ? void 0 : _a4.url)) {
              const base64Data = partContent.image_url.url.split(",")[1];
              const mimeTypeMatch = partContent.image_url.url.match(
                /^data:(image\/\w+);base64,/
              );
              if (base64Data && mimeTypeMatch) {
                parts.push({
                  inlineData: { mimeType: mimeTypeMatch[1], data: base64Data }
                });
              } else {
                this.logger({
                  category: "google",
                  message: "WARNING: Could not parse image data URI format",
                  level: 1
                });
              }
            }
          }
        });
      } else if (typeof msg.content === "string") {
        parts.push({ text: msg.content });
      }
      if (image && index === messages.length - 1 && msg.role === "user") {
        const imageDesc = image.description || AnnotatedScreenshotText;
        parts.push({ text: imageDesc });
        parts.push({
          inlineData: {
            mimeType: "image/jpeg",
            // Assuming JPEG, adjust if needed
            data: image.buffer.toString("base64")
          }
        });
      }
      if (systemInstruction && contents.length === 0 && role === "user") {
        const firstPartText = parts.find((p) => "text" in p);
        if (firstPartText && "text" in firstPartText) {
          firstPartText.text = `${systemInstruction}

${firstPartText.text}`;
        } else {
          parts.unshift({ text: systemInstruction });
        }
        systemInstruction = null;
      }
      if (parts.length > 0) {
        contents.push({ role, parts });
      }
    });
    if (systemInstruction) {
      contents.unshift({ role: "user", parts: [{ text: systemInstruction }] });
    }
    return contents;
  }
  // Helper to convert LLMTool[] to Gemini's Tool[]
  formatTools(tools) {
    if (!tools || tools.length === 0) {
      return void 0;
    }
    return [
      {
        functionDeclarations: tools.map((tool21) => {
          let parameters = void 0;
          if (tool21.parameters) {
            parameters = {
              type: import_genai4.Type.OBJECT,
              properties: tool21.parameters.properties,
              required: tool21.parameters.required
            };
          }
          return {
            name: tool21.name,
            description: tool21.description,
            parameters
          };
        })
      }
    ];
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      // Ensure LLMResponse is compatible
      options,
      logger,
      retries = 3
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i;
      const {
        image,
        requestId,
        response_model,
        tools,
        temperature,
        top_p,
        maxOutputTokens
      } = options;
      const formattedMessages = this.formatMessages(options.messages, image);
      const formattedTools = this.formatTools(tools);
      const generationConfig = {
        maxOutputTokens,
        temperature,
        topP: top_p,
        responseMimeType: response_model ? "application/json" : void 0,
        responseSchema: response_model ? toGeminiSchema(response_model.schema) : void 0
      };
      logger({
        category: "google",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          modelName: { value: this.modelName, type: "string" },
          requestId: { value: requestId, type: "string" },
          requestPayloadSummary: {
            value: `Model: ${this.modelName}, Messages: ${formattedMessages.length}, Config Keys: ${Object.keys(generationConfig).join(", ")}, Tools: ${formattedTools ? formattedTools.length : 0}, Safety Categories: ${safetySettings.map((s2) => s2.category).join(", ")}`,
            type: "string"
          }
        }
      });
      const requestPayload = {
        model: this.modelName,
        contents: formattedMessages,
        config: __spreadProps(__spreadValues({}, generationConfig), {
          safetySettings,
          tools: formattedTools
        })
      };
      try {
        logger({
          category: "google",
          message: "Full request payload",
          level: 2,
          auxiliary: {
            requestId: { value: requestId, type: "string" },
            fullPayload: {
              value: JSON.stringify(requestPayload),
              type: "object"
            }
          }
        });
      } catch (e2) {
        logger({
          category: "google",
          message: "Failed to stringify full request payload for logging",
          level: 0,
          auxiliary: {
            requestId: { value: requestId, type: "string" },
            error: { value: e2.message, type: "string" }
          }
        });
      }
      try {
        const result = yield this.client.models.generateContent(requestPayload);
        logger({
          category: "google",
          message: "received response",
          level: 2,
          auxiliary: {
            requestId: { value: requestId, type: "string" },
            response: {
              value: JSON.stringify(result),
              type: "object"
            }
          }
        });
        const finishReason = ((_b = (_a4 = result.candidates) == null ? void 0 : _a4[0]) == null ? void 0 : _b.finishReason) || "unknown";
        const toolCalls = (_c = result.functionCalls) == null ? void 0 : _c.map(
          (fc, index) => ({
            id: `tool_call_${requestId}_${index}`,
            type: "function",
            function: {
              name: fc.name,
              arguments: JSON.stringify(fc.args)
            }
          })
        );
        let content = null;
        try {
          content = result.text;
        } catch (e2) {
          logger({
            category: "google",
            message: `Could not extract text content: ${e2.message}`,
            level: 1,
            auxiliary: { requestId: { value: requestId, type: "string" } }
          });
          content = null;
        }
        const llmResponse = {
          id: ((_f = (_e = (_d2 = result.candidates) == null ? void 0 : _d2[0]) == null ? void 0 : _e.index) == null ? void 0 : _f.toString()) || requestId,
          object: "chat.completion",
          created: Math.floor(Date.now() / 1e3),
          model: this.modelName,
          choices: [
            {
              index: 0,
              message: {
                role: "assistant",
                content,
                tool_calls: toolCalls
              },
              finish_reason: finishReason
            }
          ],
          usage: {
            prompt_tokens: ((_g = result.usageMetadata) == null ? void 0 : _g.promptTokenCount) || 0,
            completion_tokens: ((_h = result.usageMetadata) == null ? void 0 : _h.candidatesTokenCount) || 0,
            total_tokens: ((_i = result.usageMetadata) == null ? void 0 : _i.totalTokenCount) || 0
          }
        };
        if (response_model) {
          let parsedData;
          try {
            const potentialJson = (content == null ? void 0 : content.trim().replace(/^```json\n?|\n?```$/g, "")) || "{}";
            parsedData = JSON.parse(potentialJson);
          } catch (e2) {
            logger({
              category: "google",
              message: `Failed to parse JSON response: ${e2.message}`,
              level: 0,
              auxiliary: {
                content: { value: content || "null", type: "string" }
              }
            });
            if (retries > 0) {
              return this.createChatCompletion({
                options,
                logger,
                retries: retries - 1
              });
            }
            throw new CreateChatCompletionResponseError(
              `Failed to parse JSON response: ${e2.message}`
            );
          }
          try {
            validateZodSchema(response_model.schema, parsedData);
          } catch (err) {
            logger({
              category: "google",
              message: "Response failed Zod schema validation",
              level: 0
            });
            if (retries > 0) {
              return this.createChatCompletion({
                options,
                logger,
                retries: retries - 1
              });
            }
            throw err;
          }
          const extractionResult = {
            data: parsedData,
            usage: llmResponse.usage
          };
          return extractionResult;
        }
        return llmResponse;
      } catch (error) {
        logger({
          category: "google",
          message: `Error during Google AI chat completion: ${error.message}`,
          level: 0,
          auxiliary: {
            errorDetails: {
              value: `Message: ${error.message}${error.stack ? "\nStack: " + error.stack : ""}`,
              type: "string"
            },
            requestId: { value: requestId, type: "string" }
          }
        });
        if (retries > 0) {
          logger({
            category: "google",
            message: `Retrying... (${retries} attempts left)`,
            level: 1
          });
          yield new Promise(
            (resolve3) => setTimeout(resolve3, 1e3 * (4 - retries))
          );
          return this.createChatCompletion({
            options,
            logger,
            retries: retries - 1
          });
        }
        if (error instanceof StagehandError) {
          throw error;
        }
        throw new StagehandError(
          `Google AI API request failed: ${error.message}`
        );
      }
    });
  }
};

// lib/v3/llm/GroqClient.ts
var import_openai4 = __toESM(require("openai"));
init_sdkErrors();
var GroqClient = class extends LLMClient {
  constructor({
    modelName,
    clientOptions,
    userProvidedInstructions
  }) {
    super(modelName, userProvidedInstructions);
    this.type = "groq";
    this.hasVision = false;
    this.client = new import_openai4.default(__spreadValues({
      baseURL: "https://api.groq.com/openai/v1",
      apiKey: (clientOptions == null ? void 0 : clientOptions.apiKey) || process.env.GROQ_API_KEY
    }, clientOptions));
    this.modelName = modelName;
    this.clientOptions = clientOptions;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options,
      retries,
      logger
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      const optionsWithoutImage = __spreadValues({}, options);
      delete optionsWithoutImage.image;
      logger({
        category: "groq",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          options: {
            value: JSON.stringify(optionsWithoutImage),
            type: "object"
          }
        }
      });
      const formattedMessages = options.messages.map((msg) => {
        const baseMessage = {
          content: typeof msg.content === "string" ? msg.content : Array.isArray(msg.content) && msg.content.length > 0 && "text" in msg.content[0] ? msg.content[0].text : ""
        };
        if (msg.role === "system") {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "system" });
        } else if (msg.role === "assistant") {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "assistant" });
        } else {
          return __spreadProps(__spreadValues({}, baseMessage), { role: "user" });
        }
      });
      let tools = (_a4 = options.tools) == null ? void 0 : _a4.map((tool21) => ({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: {
            type: "object",
            properties: tool21.parameters.properties,
            required: tool21.parameters.required
          }
        }
      }));
      if (options.response_model) {
        const jsonSchema3 = toJsonSchema(options.response_model.schema);
        const schemaProperties = jsonSchema3.properties || {};
        const schemaRequired = jsonSchema3.required || [];
        const responseTool = {
          type: "function",
          function: {
            name: "print_extracted_data",
            description: "Prints the extracted data based on the provided schema.",
            parameters: {
              type: "object",
              properties: schemaProperties,
              required: schemaRequired
            }
          }
        };
        tools = tools ? [...tools, responseTool] : [responseTool];
      }
      try {
        const apiResponse = yield this.client.chat.completions.create({
          model: this.modelName.split("groq-")[1],
          messages: [
            ...formattedMessages,
            // Add explicit instruction to return JSON if we have a response model
            ...options.response_model ? [
              {
                role: "system",
                content: `IMPORTANT: Your response must be valid JSON that matches this schema: ${JSON.stringify(
                  options.response_model.schema
                )}`
              }
            ] : []
          ],
          temperature: options.temperature || 0.7,
          max_tokens: options.maxOutputTokens,
          tools,
          tool_choice: options.tool_choice || "auto"
        });
        const response = {
          id: apiResponse.id,
          object: "chat.completion",
          created: Date.now(),
          model: this.modelName.split("groq-")[1],
          choices: [
            {
              index: 0,
              message: {
                role: "assistant",
                content: ((_c = (_b = apiResponse.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || null,
                tool_calls: ((_e = (_d2 = apiResponse.choices[0]) == null ? void 0 : _d2.message) == null ? void 0 : _e.tool_calls) || []
              },
              finish_reason: ((_f = apiResponse.choices[0]) == null ? void 0 : _f.finish_reason) || "stop"
            }
          ],
          usage: {
            prompt_tokens: ((_g = apiResponse.usage) == null ? void 0 : _g.prompt_tokens) || 0,
            completion_tokens: ((_h = apiResponse.usage) == null ? void 0 : _h.completion_tokens) || 0,
            total_tokens: ((_i = apiResponse.usage) == null ? void 0 : _i.total_tokens) || 0
          }
        };
        logger({
          category: "groq",
          message: "response",
          level: 2,
          auxiliary: {
            response: {
              value: JSON.stringify(response),
              type: "object"
            },
            requestId: {
              value: options.requestId,
              type: "string"
            }
          }
        });
        if (!options.response_model) {
          return response;
        }
        const toolCall = (_l = (_k = (_j = response.choices[0]) == null ? void 0 : _j.message) == null ? void 0 : _k.tool_calls) == null ? void 0 : _l[0];
        if ((_m = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _m.arguments) {
          try {
            const result = JSON.parse(toolCall.function.arguments);
            const finalResponse = {
              data: result,
              usage: response.usage
            };
            return finalResponse;
          } catch (e2) {
            logger({
              category: "groq",
              message: "failed to parse tool call arguments as JSON, retrying",
              level: 0,
              auxiliary: {
                error: {
                  value: e2.message,
                  type: "string"
                }
              }
            });
          }
        }
        const content = (_o = (_n = response.choices[0]) == null ? void 0 : _n.message) == null ? void 0 : _o.content;
        if (content) {
          try {
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              const result = JSON.parse(jsonMatch[0]);
              const finalResponse = {
                data: result,
                usage: response.usage
              };
              return finalResponse;
            }
          } catch (e2) {
            logger({
              category: "groq",
              message: "failed to parse content as JSON",
              level: 0,
              auxiliary: {
                error: {
                  value: e2.message,
                  type: "string"
                }
              }
            });
          }
        }
        if (!retries || retries < 5) {
          return this.createChatCompletion({
            options,
            logger,
            retries: (retries != null ? retries : 0) + 1
          });
        }
        throw new CreateChatCompletionResponseError("Invalid response schema");
      } catch (error) {
        logger({
          category: "groq",
          message: "error creating chat completion",
          level: 0,
          auxiliary: {
            error: {
              value: error.message,
              type: "string"
            },
            requestId: {
              value: options.requestId,
              type: "string"
            }
          }
        });
        throw error;
      }
    });
  }
};

// lib/v3/llm/OpenAIClient.ts
var import_openai5 = __toESM(require("openai"));
init_sdkErrors();
var OpenAIClient = class extends LLMClient {
  constructor({
    modelName,
    clientOptions
  }) {
    super(modelName);
    this.type = "openai";
    this.clientOptions = clientOptions;
    this.client = new import_openai5.default(clientOptions);
    this.modelName = modelName;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options: optionsInitial,
      logger,
      retries = 3
    }) {
      var _a4, _b, _e;
      let options = optionsInitial;
      let isToolsOverridedForO1 = false;
      if (this.modelName.startsWith("o1") || this.modelName.startsWith("o3")) {
        let {
          tool_choice,
          top_p,
          frequency_penalty,
          presence_penalty,
          temperature
        } = options;
        _a4 = options, {
          tool_choice,
          top_p,
          frequency_penalty,
          presence_penalty,
          temperature
        } = _a4, options = __objRest(_a4, [
          "tool_choice",
          "top_p",
          "frequency_penalty",
          "presence_penalty",
          "temperature"
        ]);
        options.messages = options.messages.map((message) => __spreadProps(__spreadValues({}, message), {
          role: "user"
        }));
        if (options.tools && options.response_model) {
          throw new StagehandError(
            "Cannot use both tool and response_model for o1 models"
          );
        }
        if (options.tools) {
          let { tools } = options;
          _b = options, { tools } = _b, options = __objRest(_b, ["tools"]);
          isToolsOverridedForO1 = true;
          options.messages.push({
            role: "user",
            content: `You have the following tools available to you:
${JSON.stringify(
              tools
            )}

          Respond with the following zod schema format to use a method: {
            "name": "<tool_name>",
            "arguments": <tool_args>
          }
          
          Do not include any other text or formattings like \`\`\` in your response. Just the JSON object.`
          });
        }
      }
      if (options.temperature && (this.modelName.startsWith("o1") || this.modelName.startsWith("o3"))) {
        throw new StagehandError("Temperature is not supported for o1 models");
      }
      const _c = options, { requestId } = _c, optionsWithoutImageAndRequestId = __objRest(_c, ["requestId"]);
      logger({
        category: "openai",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          options: {
            value: JSON.stringify(__spreadProps(__spreadValues({}, optionsWithoutImageAndRequestId), {
              requestId
            })),
            type: "object"
          },
          modelName: {
            value: this.modelName,
            type: "string"
          }
        }
      });
      if (options.image) {
        const screenshotMessage = {
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: {
                url: `data:image/jpeg;base64,${options.image.buffer.toString("base64")}`
              }
            },
            ...options.image.description ? [{ type: "text", text: options.image.description }] : []
          ]
        };
        options.messages.push(screenshotMessage);
      }
      let responseFormat;
      if (options.response_model) {
        if (this.modelName.startsWith("o1") || this.modelName.startsWith("o3")) {
          try {
            const parsedSchema = JSON.stringify(
              toJsonSchema(options.response_model.schema)
            );
            options.messages.push({
              role: "user",
              content: `Respond in this zod schema format:
${parsedSchema}


          Do not include any other text, formatting or markdown in your output. Do not include \`\`\` or \`\`\`json in your response. Only the JSON object itself.`
            });
          } catch (error) {
            logger({
              category: "openai",
              message: "Failed to parse response model schema",
              level: 0
            });
            if (retries > 0) {
              return this.createChatCompletion({
                options,
                logger,
                retries: retries - 1
              });
            }
            throw error;
          }
        } else {
          responseFormat = {
            type: "json_schema",
            json_schema: {
              name: options.response_model.name,
              schema: toJsonSchema(options.response_model.schema)
            }
          };
        }
      }
      const _d2 = __spreadProps(__spreadValues({}, optionsWithoutImageAndRequestId), {
        model: this.modelName
      }), { response_model } = _d2, openAiOptions = __objRest(_d2, ["response_model"]);
      logger({
        category: "openai",
        message: "creating chat completion",
        level: 2,
        auxiliary: {
          openAiOptions: {
            value: JSON.stringify(openAiOptions),
            type: "object"
          }
        }
      });
      const formattedMessages = options.messages.map((message) => {
        if (Array.isArray(message.content)) {
          const contentParts = message.content.map((content) => {
            if ("image_url" in content) {
              const imageContent = {
                image_url: {
                  url: content.image_url.url
                },
                type: "image_url"
              };
              return imageContent;
            } else {
              const textContent = {
                text: content.text,
                type: "text"
              };
              return textContent;
            }
          });
          if (message.role === "system") {
            const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
              role: "system",
              content: contentParts.filter(
                (content) => content.type === "text"
              )
            });
            return formattedMessage2;
          } else if (message.role === "user") {
            const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
              role: "user",
              content: contentParts
            });
            return formattedMessage2;
          } else {
            const formattedMessage2 = __spreadProps(__spreadValues({}, message), {
              role: "assistant",
              content: contentParts.filter(
                (content) => content.type === "text"
              )
            });
            return formattedMessage2;
          }
        }
        const formattedMessage = {
          role: "user",
          content: message.content
        };
        return formattedMessage;
      });
      const body = __spreadProps(__spreadValues({}, openAiOptions), {
        model: this.modelName,
        messages: formattedMessages,
        response_format: responseFormat,
        stream: false,
        tools: (_e = options.tools) == null ? void 0 : _e.map((tool21) => ({
          function: {
            name: tool21.name,
            description: tool21.description,
            parameters: tool21.parameters
          },
          type: "function"
        }))
      });
      const response = yield this.client.chat.completions.create(body);
      if (isToolsOverridedForO1) {
        try {
          const parsedContent = JSON.parse(response.choices[0].message.content);
          response.choices[0].message.tool_calls = [
            {
              function: {
                name: parsedContent["name"],
                arguments: JSON.stringify(parsedContent["arguments"])
              },
              type: "function",
              id: "-1"
            }
          ];
          response.choices[0].message.content = null;
        } catch (error) {
          logger({
            category: "openai",
            message: "Failed to parse tool call response",
            level: 0,
            auxiliary: {
              error: {
                value: error.message,
                type: "string"
              },
              content: {
                value: response.choices[0].message.content,
                type: "string"
              }
            }
          });
          if (retries > 0) {
            return this.createChatCompletion({
              options,
              logger,
              retries: retries - 1
            });
          }
          throw error;
        }
      }
      logger({
        category: "openai",
        message: "response",
        level: 2,
        auxiliary: {
          response: {
            value: JSON.stringify(response),
            type: "object"
          },
          requestId: {
            value: requestId,
            type: "string"
          }
        }
      });
      if (options.response_model) {
        const extractedData = response.choices[0].message.content;
        const parsedData = JSON.parse(extractedData);
        try {
          validateZodSchema(options.response_model.schema, parsedData);
        } catch (e2) {
          logger({
            category: "openai",
            message: "Response failed Zod schema validation",
            level: 0
          });
          if (retries > 0) {
            return this.createChatCompletion({
              options,
              logger,
              retries: retries - 1
            });
          }
          if (e2 instanceof ZodSchemaValidationError) {
            logger({
              category: "openai",
              message: `Error during OpenAI chat completion: ${e2.message}`,
              level: 0,
              auxiliary: {
                errorDetails: {
                  value: `Message: ${e2.message}${e2.stack ? "\nStack: " + e2.stack : ""}`,
                  type: "string"
                },
                requestId: { value: requestId, type: "string" }
              }
            });
            throw new CreateChatCompletionResponseError(e2.message);
          }
          throw e2;
        }
        return {
          data: parsedData,
          usage: response.usage
        };
      }
      return response;
    });
  }
};

// ../../node_modules/.pnpm/@ai-sdk+provider-utils@3.0.12_zod@4.2.1/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_provider = require("@ai-sdk/provider");
var import_provider2 = require("@ai-sdk/provider");
var import_provider3 = require("@ai-sdk/provider");
var import_provider4 = require("@ai-sdk/provider");
var import_provider5 = require("@ai-sdk/provider");
var import_provider6 = require("@ai-sdk/provider");
var import_provider7 = require("@ai-sdk/provider");
var import_provider8 = require("@ai-sdk/provider");

// ../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// ../../node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// ../../node_modules/.pnpm/@ai-sdk+provider-utils@3.0.12_zod@4.2.1/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_provider9 = require("@ai-sdk/provider");
var import_provider10 = require("@ai-sdk/provider");
var import_provider11 = require("@ai-sdk/provider");
var z42 = __toESM(require("zod/v4"), 1);
var import_v32 = require("zod/v3");
var import_v33 = require("zod/v3");
var import_v34 = require("zod/v3");
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i2 = 0; i2 < size; i2++) {
      chars[i2] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new import_provider.InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function isAbortError(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new import_provider3.APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a4, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a4 = globalThisAny.navigator) == null ? void 0 : _a4.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([_key, value]) => value != null)
  );
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}
var VERSION = true ? "3.0.12" : "0.0.0-test";
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}
function injectJsonInstructionIntoMessages({
  messages,
  schema,
  schemaPrefix,
  schemaSuffix
}) {
  var _a4, _b;
  const systemMessage = ((_a4 = messages[0]) == null ? void 0 : _a4.role) === "system" ? __spreadValues({}, messages[0]) : { role: "system", content: "" };
  systemMessage.content = injectJsonInstruction({
    prompt: systemMessage.content,
    schema,
    schemaPrefix,
    schemaSuffix
  });
  return [
    systemMessage,
    ...((_b = messages[0]) == null ? void 0 : _b.role) === "system" ? messages.slice(1) : messages
  ];
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new import_provider4.LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new import_provider4.LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new import_provider4.LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new import_provider4.LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
function loadSetting({
  settingValue,
  environmentVariableName,
  settingName,
  description
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null) {
    throw new import_provider5.LoadSettingError({
      message: `${description} setting must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new import_provider5.LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null) {
    throw new import_provider5.LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof settingValue !== "string") {
    throw new import_provider5.LoadSettingError({
      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return settingValue;
}
function mediaTypeToExtension(mediaType) {
  var _a4;
  const [_type2, subtype = ""] = mediaType.toLowerCase().split("/");
  return (_a4 = {
    mpeg: "mp3",
    "x-wav": "wav",
    opus: "ogg",
    mp4: "m4a",
    "x-m4a": "m4a"
  }[subtype]) != null ? _a4 : subtype;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function lazyValidator(createValidator) {
  let validator22;
  return () => {
    if (validator22 == null) {
      validator22 = createValidator();
    }
    return validator22;
  };
}
function asValidator(value) {
  return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
  return validator((value) => __async(null, null, function* () {
    const result = yield standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new import_provider8.TypeValidationError({
        value,
        cause: result.issues
      })
    };
  }));
}
function validateTypes(_0) {
  return __async(this, arguments, function* ({
    value,
    schema
  }) {
    const result = yield safeValidateTypes({ value, schema });
    if (!result.success) {
      throw import_provider7.TypeValidationError.wrap({ value, cause: result.error });
    }
    return result.value;
  });
}
function safeValidateTypes(_0) {
  return __async(this, arguments, function* ({
    value,
    schema
  }) {
    const validator22 = asValidator(schema);
    try {
      if (validator22.validate == null) {
        return { success: true, value, rawValue: value };
      }
      const result = yield validator22.validate(value);
      if (result.success) {
        return { success: true, value: result.value, rawValue: value };
      }
      return {
        success: false,
        error: import_provider7.TypeValidationError.wrap({ value, cause: result.error }),
        rawValue: value
      };
    } catch (error) {
      return {
        success: false,
        error: import_provider7.TypeValidationError.wrap({ value, cause: error }),
        rawValue: value
      };
    }
  });
}
function parseJSON(_0) {
  return __async(this, arguments, function* ({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse(text);
      if (schema == null) {
        return value;
      }
      return validateTypes({ value, schema });
    } catch (error) {
      if (import_provider6.JSONParseError.isInstance(error) || import_provider6.TypeValidationError.isInstance(error)) {
        throw error;
      }
      throw new import_provider6.JSONParseError({ text, cause: error });
    }
  });
}
function safeParseJSON(_0) {
  return __async(this, arguments, function* ({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse(text);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      return yield safeValidateTypes({ value, schema });
    } catch (error) {
      return {
        success: false,
        error: import_provider6.JSONParseError.isInstance(error) ? error : new import_provider6.JSONParseError({ text, cause: error }),
        rawValue: void 0
      };
    }
  });
}
function isParsableJson(input) {
  try {
    secureJsonParse(input);
    return true;
  } catch (e2) {
    return false;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      transform(_0, _1) {
        return __async(this, arguments, function* ({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(yield safeParseJSON({ text: data, schema }));
        });
      }
    })
  );
}
function parseProviderOptions(_0) {
  return __async(this, arguments, function* ({
    provider,
    providerOptions,
    schema
  }) {
    if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
      return void 0;
    }
    const parsedProviderOptions = yield safeValidateTypes({
      value: providerOptions[provider],
      schema
    });
    if (!parsedProviderOptions.success) {
      throw new import_provider9.InvalidArgumentError({
        argument: "providerOptions",
        message: `invalid ${provider} provider options`,
        cause: parsedProviderOptions.error
      });
    }
    return parsedProviderOptions.value;
  });
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = (_0) => __async(null, [_0], function* ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch3
}) {
  return postToApi({
    url,
    headers: __spreadValues({
      "Content-Type": "application/json"
    }, headers),
    body: {
      content: JSON.stringify(body),
      values: body
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch3
  });
});
var postFormDataToApi = (_0) => __async(null, [_0], function* ({
  url,
  headers,
  formData,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch3
}) {
  return postToApi({
    url,
    headers,
    body: {
      content: formData,
      values: Object.fromEntries(formData.entries())
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch3
  });
});
var postToApi = (_0) => __async(null, [_0], function* ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch3 = getOriginalFetch2()
}) {
  try {
    const response = yield fetch3(url, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = yield failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError(error) || import_provider10.APICallError.isInstance(error)) {
          throw error;
        }
        throw new import_provider10.APICallError({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return yield successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError(error) || import_provider10.APICallError.isInstance(error)) {
          throw error;
        }
      }
      throw new import_provider10.APICallError({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: body.values });
  }
});
function tool19(tool22) {
  return tool22;
}
function createProviderDefinedToolFactory({
  id,
  name,
  inputSchema
}) {
  return (_a4) => {
    var _b = _a4, {
      execute,
      outputSchema,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    } = _b, args = __objRest(_b, [
      "execute",
      "outputSchema",
      "toModelOutput",
      "onInputStart",
      "onInputDelta",
      "onInputAvailable"
    ]);
    return tool19({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  };
}
function createProviderDefinedToolFactoryWithOutputSchema({
  id,
  name,
  inputSchema,
  outputSchema
}) {
  return (_a4) => {
    var _b = _a4, {
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    } = _b, args = __objRest(_b, [
      "execute",
      "toModelOutput",
      "onInputStart",
      "onInputDelta",
      "onInputAvailable"
    ]);
    return tool19({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  };
}
function resolve(value) {
  return __async(this, null, function* () {
    if (typeof value === "function") {
      value = value();
    }
    return Promise.resolve(value);
  });
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage: errorToMessage2,
  isRetryable
}) => (_0) => __async(null, [_0], function* ({ response, url, requestBodyValues }) {
  const responseBody = yield response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new import_provider11.APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = yield parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new import_provider11.APICallError({
        message: errorToMessage2(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new import_provider11.APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
});
var createEventSourceResponseHandler = (chunkSchema3) => (_0) => __async(null, [_0], function* ({ response }) {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new import_provider11.EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema3
    })
  };
});
var createJsonStreamResponseHandler = (chunkSchema3) => (_0) => __async(null, [_0], function* ({ response }) {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new import_provider11.EmptyResponseBodyError({});
  }
  let buffer = "";
  return {
    responseHeaders,
    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(
      new TransformStream({
        transform(chunkText, controller) {
          return __async(this, null, function* () {
            if (chunkText.endsWith("\n")) {
              controller.enqueue(
                yield safeParseJSON({
                  text: buffer + chunkText,
                  schema: chunkSchema3
                })
              );
              buffer = "";
            } else {
              buffer += chunkText;
            }
          });
        }
      })
    )
  };
});
var createJsonResponseHandler = (responseSchema3) => (_0) => __async(null, [_0], function* ({ response, url, requestBodyValues }) {
  const responseBody = yield response.text();
  const parsedResult = yield safeParseJSON({
    text: responseBody,
    schema: responseSchema3
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new import_provider11.APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
});
var createBinaryResponseHandler = () => (_0) => __async(null, [_0], function* ({ response, url, requestBodyValues }) {
  const responseHeaders = extractResponseHeaders(response);
  if (!response.body) {
    throw new import_provider11.APICallError({
      message: "Response body is empty",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0
    });
  }
  try {
    const buffer = yield response.arrayBuffer();
    return {
      responseHeaders,
      value: new Uint8Array(buffer)
    };
  } catch (error) {
    throw new import_provider11.APICallError({
      message: "Failed to read response as array buffer",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0,
      cause: error
    });
  }
});
var getRelativePath = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2]) break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options);
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a4, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a4 = def.type) == null ? void 0 : _a4._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== import_v33.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x2) => !!x2);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a4 = schema, { additionalProperties } = _a4, rest = __objRest(_a4, ["additionalProperties"]);
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a4;
  if (schema.format || ((_a4 = schema.anyOf) == null ? void 0 : _a4.some((x2) => x2.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message && refs.errorMessages && { errorMessage: { format: message } }));
  } else {
    schema.format = value;
  }
}
function addPattern(schema, regex, message, refs) {
  var _a4;
  if (schema.pattern || ((_a4 = schema.allOf) == null ? void 0 : _a4.some((x2) => x2.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push(__spreadValues({
      pattern: stringifyRegExpWithFlags(regex, refs)
    }, message && refs.errorMessages && { errorMessage: { pattern: message } }));
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a4;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && ((_a4 = source[i2 + 2]) == null ? void 0 : _a4.match(/[a-z]/))) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e2) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef(def, refs) {
  var _a4, _b, _c, _d2, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a4 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a4 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === import_v34.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const _a5 = parseStringDef(def.keyType._def, refs), { type } = _a5, keyType = __objRest(_a5, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === import_v34.ZodFirstPartyTypeKind.ZodEnum) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === import_v34.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === import_v34.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const _b2 = parseBrandedDef(
      def.keyType._def,
      refs
    ), { type } = _b2, keyType = __objRest(_b2, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || parseAnyDef();
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return { not: parseAnyDef() };
}
function parseNullDef() {
  return {
    type: "null"
  };
}
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length)
  )) {
    const types3 = options.reduce((types22, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types22.includes(type) ? [...types22, type] : types22;
    }, []);
    return {
      type: types3.length > 1 ? types3 : types3[0]
    };
  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types3 = options.reduce(
      (acc, x2) => {
        const type = typeof x2._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x2._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types3.length === options.length) {
      const uniqueTypes = types3.filter((x2, i2, a) => a.indexOf(x2) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x2) => {
            return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x2) => [
          ...acc,
          ...x2._def.values.filter((x22) => !acc.includes(x22))
        ],
        []
      )
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x2, i2) => parseDef(x2._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    }))
  ).filter(
    (x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    }));
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }));
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef = (def, refs) => {
  var _a4;
  if (refs.currentPath.toString() === ((_a4 = refs.propertyPath) == null ? void 0 : _a4.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
};
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x2) => x2 !== void 0)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x2, i2) => parseDef(x2._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i2}`]
        }))
      ).reduce(
        (acc, x2) => x2 === void 0 ? acc : [...acc, x2],
        []
      ),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x2, i2) => parseDef(x2._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i2}`]
        }))
      ).reduce(
        (acc, x2) => x2 === void 0 ? acc : [...acc, x2],
        []
      )
    };
  }
}
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
function parseUnknownDef() {
  return parseAnyDef();
}
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case import_v32.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def);
    case import_v32.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def);
    case import_v32.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case import_v32.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case import_v32.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef();
    case import_v32.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodUnion:
    case import_v32.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def);
    case import_v32.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case import_v32.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case import_v32.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case import_v32.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodNaN:
    case import_v32.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case import_v32.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case import_v32.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case import_v32.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case import_v32.ZodFirstPartyTypeKind.ZodFunction:
    case import_v32.ZodFirstPartyTypeKind.ZodVoid:
    case import_v32.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};
function parseDef(def, refs, forceResolution = false) {
  var _a4;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a4 = refs.override) == null ? void 0 : _a4.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema22) => {
  if (def.description) {
    jsonSchema22.description = def.description;
  }
  return jsonSchema22;
};
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
};
var zodToJsonSchema2 = (schema, options) => {
  var _a4;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a22;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a22 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a22 : parseAnyDef()
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a4 = parseDef(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a4 : parseAnyDef();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default = zodToJsonSchema2;
function zod3Schema(zodSchema22, options) {
  var _a4;
  const useReferences = (_a4 = options == null ? void 0 : options.useReferences) != null ? _a4 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: (value) => __async(null, null, function* () {
        const result = yield zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      })
    }
  );
}
function zod4Schema(zodSchema22, options) {
  var _a4;
  const useReferences = (_a4 = options == null ? void 0 : options.useReferences) != null ? _a4 : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z42.toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: (value) => __async(null, null, function* () {
        const result = yield z42.safeParseAsync(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      })
    }
  );
}
function isZod4Schema2(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema(zodSchema22, options) {
  if (isZod4Schema2(zodSchema22)) {
    return zod4Schema(zodSchema22, options);
  } else {
    return zod3Schema(zodSchema22, options);
  }
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
var { btoa, atob } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    latin1string += String.fromCodePoint(array[i2]);
  }
  return btoa(latin1string);
}
function convertToBase64(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;
}
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}

// ../../node_modules/.pnpm/@ai-sdk+openai@2.0.53_zod@4.2.1/node_modules/@ai-sdk/openai/dist/index.mjs
var import_provider12 = require("@ai-sdk/provider");
var import_v4 = require("zod/v4");
var import_provider13 = require("@ai-sdk/provider");
var import_v42 = require("zod/v4");
var import_v43 = require("zod/v4");
var import_provider14 = require("@ai-sdk/provider");
var import_provider15 = require("@ai-sdk/provider");
var import_v44 = require("zod/v4");
var import_v45 = require("zod/v4");
var import_provider16 = require("@ai-sdk/provider");
var import_v46 = require("zod/v4");
var import_v47 = require("zod/v4");
var import_v48 = require("zod/v4");
var import_v49 = require("zod/v4");
var import_v410 = require("zod/v4");
var import_v411 = require("zod/v4");
var import_v412 = require("zod/v4");
var import_v413 = require("zod/v4");
var import_v414 = require("zod/v4");
var import_provider17 = require("@ai-sdk/provider");
var import_provider18 = require("@ai-sdk/provider");
var import_v415 = require("zod/v4");
var import_v416 = require("zod/v4");
var import_v417 = require("zod/v4");
var import_provider19 = require("@ai-sdk/provider");
var import_v418 = require("zod/v4");
var import_v419 = require("zod/v4");
var import_v420 = require("zod/v4");
var openaiErrorDataSchema = import_v4.z.object({
  error: import_v4.z.object({
    message: import_v4.z.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: import_v4.z.string().nullish(),
    param: import_v4.z.any().nullish(),
    code: import_v4.z.union([import_v4.z.string(), import_v4.z.number()]).nullish()
  })
});
var openaiFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: openaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function convertToOpenAIChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a4, _b, _c;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                      // OpenAI specific extension: image detail
                      detail: (_b = (_a4 = part.providerOptions) == null ? void 0 : _a4.openai) == null ? void 0 : _b.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new import_provider13.UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  switch (part.mediaType) {
                    case "audio/wav": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "wav"
                        }
                      };
                    }
                    case "audio/mp3":
                    case "audio/mpeg": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "mp3"
                        }
                      };
                    }
                    default: {
                      throw new import_provider13.UnsupportedFunctionalityError({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                    }
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new import_provider13.UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new import_provider13.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiChatResponseSchema = lazyValidator(
  () => zodSchema(
    import_v42.z.object({
      id: import_v42.z.string().nullish(),
      created: import_v42.z.number().nullish(),
      model: import_v42.z.string().nullish(),
      choices: import_v42.z.array(
        import_v42.z.object({
          message: import_v42.z.object({
            role: import_v42.z.literal("assistant").nullish(),
            content: import_v42.z.string().nullish(),
            tool_calls: import_v42.z.array(
              import_v42.z.object({
                id: import_v42.z.string().nullish(),
                type: import_v42.z.literal("function"),
                function: import_v42.z.object({
                  name: import_v42.z.string(),
                  arguments: import_v42.z.string()
                })
              })
            ).nullish(),
            annotations: import_v42.z.array(
              import_v42.z.object({
                type: import_v42.z.literal("url_citation"),
                start_index: import_v42.z.number(),
                end_index: import_v42.z.number(),
                url: import_v42.z.string(),
                title: import_v42.z.string()
              })
            ).nullish()
          }),
          index: import_v42.z.number(),
          logprobs: import_v42.z.object({
            content: import_v42.z.array(
              import_v42.z.object({
                token: import_v42.z.string(),
                logprob: import_v42.z.number(),
                top_logprobs: import_v42.z.array(
                  import_v42.z.object({
                    token: import_v42.z.string(),
                    logprob: import_v42.z.number()
                  })
                )
              })
            ).nullish()
          }).nullish(),
          finish_reason: import_v42.z.string().nullish()
        })
      ),
      usage: import_v42.z.object({
        prompt_tokens: import_v42.z.number().nullish(),
        completion_tokens: import_v42.z.number().nullish(),
        total_tokens: import_v42.z.number().nullish(),
        prompt_tokens_details: import_v42.z.object({
          cached_tokens: import_v42.z.number().nullish()
        }).nullish(),
        completion_tokens_details: import_v42.z.object({
          reasoning_tokens: import_v42.z.number().nullish(),
          accepted_prediction_tokens: import_v42.z.number().nullish(),
          rejected_prediction_tokens: import_v42.z.number().nullish()
        }).nullish()
      }).nullish()
    })
  )
);
var openaiChatChunkSchema = lazyValidator(
  () => zodSchema(
    import_v42.z.union([
      import_v42.z.object({
        id: import_v42.z.string().nullish(),
        created: import_v42.z.number().nullish(),
        model: import_v42.z.string().nullish(),
        choices: import_v42.z.array(
          import_v42.z.object({
            delta: import_v42.z.object({
              role: import_v42.z.enum(["assistant"]).nullish(),
              content: import_v42.z.string().nullish(),
              tool_calls: import_v42.z.array(
                import_v42.z.object({
                  index: import_v42.z.number(),
                  id: import_v42.z.string().nullish(),
                  type: import_v42.z.literal("function").nullish(),
                  function: import_v42.z.object({
                    name: import_v42.z.string().nullish(),
                    arguments: import_v42.z.string().nullish()
                  })
                })
              ).nullish(),
              annotations: import_v42.z.array(
                import_v42.z.object({
                  type: import_v42.z.literal("url_citation"),
                  start_index: import_v42.z.number(),
                  end_index: import_v42.z.number(),
                  url: import_v42.z.string(),
                  title: import_v42.z.string()
                })
              ).nullish()
            }).nullish(),
            logprobs: import_v42.z.object({
              content: import_v42.z.array(
                import_v42.z.object({
                  token: import_v42.z.string(),
                  logprob: import_v42.z.number(),
                  top_logprobs: import_v42.z.array(
                    import_v42.z.object({
                      token: import_v42.z.string(),
                      logprob: import_v42.z.number()
                    })
                  )
                })
              ).nullish()
            }).nullish(),
            finish_reason: import_v42.z.string().nullish(),
            index: import_v42.z.number()
          })
        ),
        usage: import_v42.z.object({
          prompt_tokens: import_v42.z.number().nullish(),
          completion_tokens: import_v42.z.number().nullish(),
          total_tokens: import_v42.z.number().nullish(),
          prompt_tokens_details: import_v42.z.object({
            cached_tokens: import_v42.z.number().nullish()
          }).nullish(),
          completion_tokens_details: import_v42.z.object({
            reasoning_tokens: import_v42.z.number().nullish(),
            accepted_prediction_tokens: import_v42.z.number().nullish(),
            rejected_prediction_tokens: import_v42.z.number().nullish()
          }).nullish()
        }).nullish()
      }),
      openaiErrorDataSchema
    ])
  )
);
var openaiChatLanguageModelOptions = lazyValidator(
  () => zodSchema(
    import_v43.z.object({
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: import_v43.z.record(import_v43.z.coerce.number(), import_v43.z.number()).optional(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       */
      logprobs: import_v43.z.union([import_v43.z.boolean(), import_v43.z.number()]).optional(),
      /**
       * Whether to enable parallel function calling during tool use. Default to true.
       */
      parallelToolCalls: import_v43.z.boolean().optional(),
      /**
       * A unique identifier representing your end-user, which can help OpenAI to
       * monitor and detect abuse.
       */
      user: import_v43.z.string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: import_v43.z.enum(["minimal", "low", "medium", "high"]).optional(),
      /**
       * Maximum number of completion tokens to generate. Useful for reasoning models.
       */
      maxCompletionTokens: import_v43.z.number().optional(),
      /**
       * Whether to enable persistence in responses API.
       */
      store: import_v43.z.boolean().optional(),
      /**
       * Metadata to associate with the request.
       */
      metadata: import_v43.z.record(import_v43.z.string().max(64), import_v43.z.string().max(512)).optional(),
      /**
       * Parameters for prediction mode.
       */
      prediction: import_v43.z.record(import_v43.z.string(), import_v43.z.any()).optional(),
      /**
       * Whether to use structured outputs.
       *
       * @default true
       */
      structuredOutputs: import_v43.z.boolean().optional(),
      /**
       * Service tier for the request.
       * - 'auto': Default service tier. The request will be processed with the service tier configured in the
       *           Project settings. Unless otherwise configured, the Project will use 'default'.
       * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
       * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
       * - 'default': The request will be processed with the standard pricing and performance for the selected model.
       *
       * @default 'auto'
       */
      serviceTier: import_v43.z.enum(["auto", "flex", "priority", "default"]).optional(),
      /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */
      strictJsonSchema: import_v43.z.boolean().optional(),
      /**
       * Controls the verbosity of the model's responses.
       * Lower values will result in more concise responses, while higher values will result in more verbose responses.
       */
      textVerbosity: import_v43.z.enum(["low", "medium", "high"]).optional(),
      /**
       * A cache key for prompt caching. Allows manual control over prompt caching behavior.
       * Useful for improving cache hit rates and working around automatic caching issues.
       */
      promptCacheKey: import_v43.z.string().optional(),
      /**
       * A stable identifier used to help detect users of your application
       * that may be violating OpenAI's usage policies. The IDs should be a
       * string that uniquely identifies each user. We recommend hashing their
       * username or email address, in order to avoid sending us any identifying
       * information.
       */
      safetyIdentifier: import_v43.z.string().optional()
    })
  )
);
function prepareChatTools({
  tools,
  toolChoice,
  structuredOutputs,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool21 of tools) {
    switch (tool21.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool21.name,
            description: tool21.description,
            parameters: tool21.inputSchema,
            strict: structuredOutputs ? strictJsonSchema : void 0
          }
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider14.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var OpenAIChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const openaiOptions = (_a4 = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiChatLanguageModelOptions
      })) != null ? _a4 : {};
      const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is only supported with structuredOutputs"
        });
      }
      const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
        {
          prompt,
          systemMessageMode: getSystemMessageMode(this.modelId)
        }
      );
      warnings.push(...messageWarnings);
      const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
      const baseArgs = {
        // model id:
        model: this.modelId,
        // model specific settings:
        logit_bias: openaiOptions.logitBias,
        logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
        top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
        user: openaiOptions.user,
        parallel_tool_calls: openaiOptions.parallelToolCalls,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d2 = responseFormat.name) != null ? _d2 : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        stop: stopSequences,
        seed,
        verbosity: openaiOptions.textVerbosity,
        // openai specific settings:
        // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
        max_completion_tokens: openaiOptions.maxCompletionTokens,
        store: openaiOptions.store,
        metadata: openaiOptions.metadata,
        prediction: openaiOptions.prediction,
        reasoning_effort: openaiOptions.reasoningEffort,
        service_tier: openaiOptions.serviceTier,
        prompt_cache_key: openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions.safetyIdentifier,
        // messages:
        messages
      };
      if (isReasoningModel(this.modelId)) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
        if (baseArgs.frequency_penalty != null) {
          baseArgs.frequency_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty",
            details: "frequencyPenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.presence_penalty != null) {
          baseArgs.presence_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty",
            details: "presencePenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.logit_bias != null) {
          baseArgs.logit_bias = void 0;
          warnings.push({
            type: "other",
            message: "logitBias is not supported for reasoning models"
          });
        }
        if (baseArgs.logprobs != null) {
          baseArgs.logprobs = void 0;
          warnings.push({
            type: "other",
            message: "logprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.top_logprobs != null) {
          baseArgs.top_logprobs = void 0;
          warnings.push({
            type: "other",
            message: "topLogprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.max_tokens != null) {
          if (baseArgs.max_completion_tokens == null) {
            baseArgs.max_completion_tokens = baseArgs.max_tokens;
          }
          baseArgs.max_tokens = void 0;
        }
      } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for the search preview models and has been removed."
          });
        }
      }
      if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        baseArgs.service_tier = void 0;
      }
      if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        baseArgs.service_tier = void 0;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = prepareChatTools({
        tools,
        toolChoice,
        structuredOutputs,
        strictJsonSchema
      });
      return {
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        }),
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const { args: body, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
      for (const toolCall of (_a4 = choice.message.tool_calls) != null ? _a4 : []) {
        content.push({
          type: "tool-call",
          toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
      for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
        content.push({
          type: "source",
          sourceType: "url",
          id: generateId(),
          url: annotation.url,
          title: annotation.title
        });
      }
      const completionTokenDetails = (_d2 = response.usage) == null ? void 0 : _d2.completion_tokens_details;
      const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
      const providerMetadata = { openai: {} };
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
        providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
      }
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
        providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
      }
      if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
        providerMetadata.openai.logprobs = choice.logprobs.content;
      }
      return {
        content,
        finishReason: mapOpenAIFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
          outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
          totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
          reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
          cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
        },
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings,
        providerMetadata
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: {
          include_usage: true
        }
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiChatChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const toolCalls = [];
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      let isActiveText = false;
      const providerMetadata = { openai: {} };
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata(value)));
              }
              if (value.usage != null) {
                usage.inputTokens = (_a4 = value.usage.prompt_tokens) != null ? _a4 : void 0;
                usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                usage.reasoningTokens = (_e = (_d2 = value.usage.completion_tokens_details) == null ? void 0 : _d2.reasoning_tokens) != null ? _e : void 0;
                usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                  providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                }
                if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                  providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                }
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason(choice.finish_reason);
              }
              if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                providerMetadata.openai.logprobs = choice.logprobs.content;
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              if (delta.content != null) {
                if (!isActiveText) {
                  controller.enqueue({ type: "text-start", id: "0" });
                  isActiveText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: delta.content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCallDelta of delta.tool_calls) {
                  const index = toolCallDelta.index;
                  if (toolCalls[index] == null) {
                    if (toolCallDelta.type !== "function") {
                      throw new import_provider12.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function' type.`
                      });
                    }
                    if (toolCallDelta.id == null) {
                      throw new import_provider12.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'id' to be a string.`
                      });
                    }
                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                      throw new import_provider12.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function.name' to be a string.`
                      });
                    }
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallDelta.id,
                      toolName: toolCallDelta.function.name
                    });
                    toolCalls[index] = {
                      id: toolCallDelta.id,
                      type: "function",
                      function: {
                        name: toolCallDelta.function.name,
                        arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                      },
                      hasFinished: false
                    };
                    const toolCall2 = toolCalls[index];
                    if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                      if (toolCall2.function.arguments.length > 0) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                      }
                      if (isParsableJson(toolCall2.function.arguments)) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: (_q = toolCall2.id) != null ? _q : generateId(),
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.hasFinished = true;
                      }
                    }
                    continue;
                  }
                  const toolCall = toolCalls[index];
                  if (toolCall.hasFinished) {
                    continue;
                  }
                  if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                    toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                  }
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.id,
                    delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                  });
                  if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_x = toolCall.id) != null ? _x : generateId(),
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                    toolCall.hasFinished = true;
                  }
                }
              }
              if (delta.annotations != null) {
                for (const annotation of delta.annotations) {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: generateId(),
                    url: annotation.url,
                    title: annotation.title
                  });
                }
              }
            },
            flush(controller) {
              if (isActiveText) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue(__spreadValues({
                type: "finish",
                finishReason,
                usage
              }, providerMetadata != null ? { providerMetadata } : {}));
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function isReasoningModel(modelId) {
  return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing(modelId) {
  return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing(modelId) {
  return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode(modelId) {
  var _a4, _b;
  if (!isReasoningModel(modelId)) {
    return "system";
  }
  return (_b = (_a4 = reasoningModels[modelId]) == null ? void 0 : _a4.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels = {
  "o1-mini": {
    systemMessageMode: "remove"
  },
  "o1-mini-2024-09-12": {
    systemMessageMode: "remove"
  },
  "o1-preview": {
    systemMessageMode: "remove"
  },
  "o1-preview-2024-09-12": {
    systemMessageMode: "remove"
  },
  o3: {
    systemMessageMode: "developer"
  },
  "o3-2025-04-16": {
    systemMessageMode: "developer"
  },
  "o3-mini": {
    systemMessageMode: "developer"
  },
  "o3-mini-2025-01-31": {
    systemMessageMode: "developer"
  },
  "o4-mini": {
    systemMessageMode: "developer"
  },
  "o4-mini-2025-04-16": {
    systemMessageMode: "developer"
  }
};
function convertToOpenAICompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new import_provider15.InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new import_provider15.UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new import_provider15.UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompletionResponseSchema = lazyValidator(
  () => zodSchema(
    import_v44.z.object({
      id: import_v44.z.string().nullish(),
      created: import_v44.z.number().nullish(),
      model: import_v44.z.string().nullish(),
      choices: import_v44.z.array(
        import_v44.z.object({
          text: import_v44.z.string(),
          finish_reason: import_v44.z.string(),
          logprobs: import_v44.z.object({
            tokens: import_v44.z.array(import_v44.z.string()),
            token_logprobs: import_v44.z.array(import_v44.z.number()),
            top_logprobs: import_v44.z.array(import_v44.z.record(import_v44.z.string(), import_v44.z.number())).nullish()
          }).nullish()
        })
      ),
      usage: import_v44.z.object({
        prompt_tokens: import_v44.z.number(),
        completion_tokens: import_v44.z.number(),
        total_tokens: import_v44.z.number()
      }).nullish()
    })
  )
);
var openaiCompletionChunkSchema = lazyValidator(
  () => zodSchema(
    import_v44.z.union([
      import_v44.z.object({
        id: import_v44.z.string().nullish(),
        created: import_v44.z.number().nullish(),
        model: import_v44.z.string().nullish(),
        choices: import_v44.z.array(
          import_v44.z.object({
            text: import_v44.z.string(),
            finish_reason: import_v44.z.string().nullish(),
            index: import_v44.z.number(),
            logprobs: import_v44.z.object({
              tokens: import_v44.z.array(import_v44.z.string()),
              token_logprobs: import_v44.z.array(import_v44.z.number()),
              top_logprobs: import_v44.z.array(import_v44.z.record(import_v44.z.string(), import_v44.z.number())).nullish()
            }).nullish()
          })
        ),
        usage: import_v44.z.object({
          prompt_tokens: import_v44.z.number(),
          completion_tokens: import_v44.z.number(),
          total_tokens: import_v44.z.number()
        }).nullish()
      }),
      openaiErrorDataSchema
    ])
  )
);
var openaiCompletionProviderOptions = lazyValidator(
  () => zodSchema(
    import_v45.z.object({
      /**
      Echo back the prompt in addition to the completion.
         */
      echo: import_v45.z.boolean().optional(),
      /**
      Modify the likelihood of specified tokens appearing in the completion.
      
      Accepts a JSON object that maps tokens (specified by their token ID in
      the GPT tokenizer) to an associated bias value from -100 to 100. You
      can use this tokenizer tool to convert text to token IDs. Mathematically,
      the bias is added to the logits generated by the model prior to sampling.
      The exact effect will vary per model, but values between -1 and 1 should
      decrease or increase likelihood of selection; values like -100 or 100
      should result in a ban or exclusive selection of the relevant token.
      
      As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
      token from being generated.
       */
      logitBias: import_v45.z.record(import_v45.z.string(), import_v45.z.number()).optional(),
      /**
      The suffix that comes after a completion of inserted text.
       */
      suffix: import_v45.z.string().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
       */
      user: import_v45.z.string().optional(),
      /**
      Return the log probabilities of the tokens. Including logprobs will increase
      the response size and can slow down response times. However, it can
      be useful to better understand how the model is behaving.
      Setting to true will return the log probabilities of the tokens that
      were generated.
      Setting to a number will return the log probabilities of the top n
      tokens that were generated.
         */
      logprobs: import_v45.z.union([import_v45.z.boolean(), import_v45.z.number()]).optional()
    })
  )
);
var OpenAICompletionLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      // No URLs are supported for completion models.
    };
    this.modelId = modelId;
    this.config = config;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences: userStopSequences,
      responseFormat,
      tools,
      toolChoice,
      seed,
      providerOptions
    }) {
      const warnings = [];
      const openaiOptions = __spreadValues(__spreadValues({}, yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiCompletionProviderOptions
      })), yield parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompletionProviderOptions
      }));
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (tools == null ? void 0 : tools.length) {
        warnings.push({ type: "unsupported-setting", setting: "tools" });
      }
      if (toolChoice != null) {
        warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
      }
      if (responseFormat != null && responseFormat.type !== "text") {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format is not supported."
        });
      }
      const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
      const stop2 = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
      return {
        args: {
          // model id:
          model: this.modelId,
          // model specific settings:
          echo: openaiOptions.echo,
          logit_bias: openaiOptions.logitBias,
          logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
          suffix: openaiOptions.suffix,
          user: openaiOptions.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          // prompt:
          prompt: completionPrompt,
          // stop sequences:
          stop: stop2.length > 0 ? stop2 : void 0
        },
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const { args, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiCompletionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const providerMetadata = { openai: {} };
      if (choice.logprobs != null) {
        providerMetadata.openai.logprobs = choice.logprobs;
      }
      return {
        content: [{ type: "text", text: choice.text }],
        usage: {
          inputTokens: (_a4 = response.usage) == null ? void 0 : _a4.prompt_tokens,
          outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
          totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
        },
        finishReason: mapOpenAIFinishReason2(choice.finish_reason),
        request: { body: args },
        response: __spreadProps(__spreadValues({}, getResponseMetadata2(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        providerMetadata,
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: {
          include_usage: true
        }
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiCompletionChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const providerMetadata = { openai: {} };
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata2(value)));
                controller.enqueue({ type: "text-start", id: "0" });
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason2(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.logprobs) != null) {
                providerMetadata.openai.logprobs = choice.logprobs;
              }
              if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: choice.text
                });
              }
            },
            flush(controller) {
              if (!isFirstChunk) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                providerMetadata,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var openaiEmbeddingProviderOptions = lazyValidator(
  () => zodSchema(
    import_v46.z.object({
      /**
      The number of dimensions the resulting output embeddings should have.
      Only supported in text-embedding-3 and later models.
         */
      dimensions: import_v46.z.number().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
      */
      user: import_v46.z.string().optional()
    })
  )
);
var openaiTextEmbeddingResponseSchema = lazyValidator(
  () => zodSchema(
    import_v47.z.object({
      data: import_v47.z.array(import_v47.z.object({ embedding: import_v47.z.array(import_v47.z.number()) })),
      usage: import_v47.z.object({ prompt_tokens: import_v47.z.number() }).nullish()
    })
  )
);
var OpenAIEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a4;
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider16.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const openaiOptions = (_a4 = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiEmbeddingProviderOptions
      })) != null ? _a4 : {};
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/embeddings",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float",
          dimensions: openaiOptions.dimensions,
          user: openaiOptions.user
        },
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var openaiImageResponseSchema = lazyValidator(
  () => zodSchema(
    import_v48.z.object({
      data: import_v48.z.array(
        import_v48.z.object({
          b64_json: import_v48.z.string(),
          revised_prompt: import_v48.z.string().optional()
        })
      )
    })
  )
);
var modelMaxImagesPerCall = {
  "dall-e-3": 1,
  "dall-e-2": 10,
  "gpt-image-1": 10,
  "gpt-image-1-mini": 10
};
var hasDefaultResponseFormat = /* @__PURE__ */ new Set([
  "gpt-image-1",
  "gpt-image-1-mini"
]);
var OpenAIImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get maxImagesPerCall() {
    var _a4;
    return (_a4 = modelMaxImagesPerCall[this.modelId]) != null ? _a4 : 1;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(_0) {
    return __async(this, arguments, function* ({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      if (aspectRatio != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support aspect ratio. Use `size` instead."
        });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = yield postJsonToApi({
        url: this.config.url({
          path: "/images/generations",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: __spreadValues(__spreadValues({
          model: this.modelId,
          prompt,
          n,
          size
        }, (_d2 = providerOptions.openai) != null ? _d2 : {}), !hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}),
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        },
        providerMetadata: {
          openai: {
            images: response.data.map(
              (item) => item.revised_prompt ? {
                revisedPrompt: item.revised_prompt
              } : null
            )
          }
        }
      };
    });
  }
};
var codeInterpreterInputSchema = lazySchema(
  () => zodSchema(
    import_v49.z.object({
      code: import_v49.z.string().nullish(),
      containerId: import_v49.z.string()
    })
  )
);
var codeInterpreterOutputSchema = lazySchema(
  () => zodSchema(
    import_v49.z.object({
      outputs: import_v49.z.array(
        import_v49.z.discriminatedUnion("type", [
          import_v49.z.object({ type: import_v49.z.literal("logs"), logs: import_v49.z.string() }),
          import_v49.z.object({ type: import_v49.z.literal("image"), url: import_v49.z.string() })
        ])
      ).nullish()
    })
  )
);
var codeInterpreterArgsSchema = lazySchema(
  () => zodSchema(
    import_v49.z.object({
      container: import_v49.z.union([
        import_v49.z.string(),
        import_v49.z.object({
          fileIds: import_v49.z.array(import_v49.z.string()).optional()
        })
      ]).optional()
    })
  )
);
var codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.code_interpreter",
  name: "code_interpreter",
  inputSchema: codeInterpreterInputSchema,
  outputSchema: codeInterpreterOutputSchema
});
var codeInterpreter = (args = {}) => {
  return codeInterpreterToolFactory(args);
};
var comparisonFilterSchema = import_v410.z.object({
  key: import_v410.z.string(),
  type: import_v410.z.enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
  value: import_v410.z.union([import_v410.z.string(), import_v410.z.number(), import_v410.z.boolean()])
});
var compoundFilterSchema = import_v410.z.object({
  type: import_v410.z.enum(["and", "or"]),
  filters: import_v410.z.array(
    import_v410.z.union([comparisonFilterSchema, import_v410.z.lazy(() => compoundFilterSchema)])
  )
});
var fileSearchArgsSchema = lazySchema(
  () => zodSchema(
    import_v410.z.object({
      vectorStoreIds: import_v410.z.array(import_v410.z.string()),
      maxNumResults: import_v410.z.number().optional(),
      ranking: import_v410.z.object({
        ranker: import_v410.z.string().optional(),
        scoreThreshold: import_v410.z.number().optional()
      }).optional(),
      filters: import_v410.z.union([comparisonFilterSchema, compoundFilterSchema]).optional()
    })
  )
);
var fileSearchOutputSchema = lazySchema(
  () => zodSchema(
    import_v410.z.object({
      queries: import_v410.z.array(import_v410.z.string()),
      results: import_v410.z.array(
        import_v410.z.object({
          attributes: import_v410.z.record(import_v410.z.string(), import_v410.z.unknown()),
          fileId: import_v410.z.string(),
          filename: import_v410.z.string(),
          score: import_v410.z.number(),
          text: import_v410.z.string()
        })
      ).nullable()
    })
  )
);
var fileSearch = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.file_search",
  name: "file_search",
  inputSchema: import_v410.z.object({}),
  outputSchema: fileSearchOutputSchema
});
var imageGenerationArgsSchema = lazySchema(
  () => zodSchema(
    import_v411.z.object({
      background: import_v411.z.enum(["auto", "opaque", "transparent"]).optional(),
      inputFidelity: import_v411.z.enum(["low", "high"]).optional(),
      inputImageMask: import_v411.z.object({
        fileId: import_v411.z.string().optional(),
        imageUrl: import_v411.z.string().optional()
      }).optional(),
      model: import_v411.z.string().optional(),
      moderation: import_v411.z.enum(["auto"]).optional(),
      outputCompression: import_v411.z.number().int().min(0).max(100).optional(),
      outputFormat: import_v411.z.enum(["png", "jpeg", "webp"]).optional(),
      partialImages: import_v411.z.number().int().min(0).max(3).optional(),
      quality: import_v411.z.enum(["auto", "low", "medium", "high"]).optional(),
      size: import_v411.z.enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
    }).strict()
  )
);
var imageGenerationInputSchema = lazySchema(() => zodSchema(import_v411.z.object({})));
var imageGenerationOutputSchema = lazySchema(
  () => zodSchema(import_v411.z.object({ result: import_v411.z.string() }))
);
var imageGenerationToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.image_generation",
  name: "image_generation",
  inputSchema: imageGenerationInputSchema,
  outputSchema: imageGenerationOutputSchema
});
var imageGeneration = (args = {}) => {
  return imageGenerationToolFactory(args);
};
var localShellInputSchema = lazySchema(
  () => zodSchema(
    import_v412.z.object({
      action: import_v412.z.object({
        type: import_v412.z.literal("exec"),
        command: import_v412.z.array(import_v412.z.string()),
        timeoutMs: import_v412.z.number().optional(),
        user: import_v412.z.string().optional(),
        workingDirectory: import_v412.z.string().optional(),
        env: import_v412.z.record(import_v412.z.string(), import_v412.z.string()).optional()
      })
    })
  )
);
var localShellOutputSchema = lazySchema(
  () => zodSchema(import_v412.z.object({ output: import_v412.z.string() }))
);
var localShell = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.local_shell",
  name: "local_shell",
  inputSchema: localShellInputSchema,
  outputSchema: localShellOutputSchema
});
var webSearchArgsSchema = lazySchema(
  () => zodSchema(
    import_v413.z.object({
      filters: import_v413.z.object({ allowedDomains: import_v413.z.array(import_v413.z.string()).optional() }).optional(),
      searchContextSize: import_v413.z.enum(["low", "medium", "high"]).optional(),
      userLocation: import_v413.z.object({
        type: import_v413.z.literal("approximate"),
        country: import_v413.z.string().optional(),
        city: import_v413.z.string().optional(),
        region: import_v413.z.string().optional(),
        timezone: import_v413.z.string().optional()
      }).optional()
    })
  )
);
var webSearchInputSchema = lazySchema(() => zodSchema(import_v413.z.object({})));
var webSearchOutputSchema = lazySchema(
  () => zodSchema(
    import_v413.z.object({
      action: import_v413.z.discriminatedUnion("type", [
        import_v413.z.object({
          type: import_v413.z.literal("search"),
          query: import_v413.z.string().optional()
        }),
        import_v413.z.object({
          type: import_v413.z.literal("openPage"),
          url: import_v413.z.string()
        }),
        import_v413.z.object({
          type: import_v413.z.literal("find"),
          url: import_v413.z.string(),
          pattern: import_v413.z.string()
        })
      ])
    })
  )
);
var webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search",
  name: "web_search",
  inputSchema: webSearchInputSchema,
  outputSchema: webSearchOutputSchema
});
var webSearch = (args = {}) => webSearchToolFactory(args);
var webSearchPreviewArgsSchema = lazySchema(
  () => zodSchema(
    import_v414.z.object({
      searchContextSize: import_v414.z.enum(["low", "medium", "high"]).optional(),
      userLocation: import_v414.z.object({
        type: import_v414.z.literal("approximate"),
        country: import_v414.z.string().optional(),
        city: import_v414.z.string().optional(),
        region: import_v414.z.string().optional(),
        timezone: import_v414.z.string().optional()
      }).optional()
    })
  )
);
var webSearchPreviewInputSchema = lazySchema(
  () => zodSchema(import_v414.z.object({}))
);
var webSearchPreviewOutputSchema = lazySchema(
  () => zodSchema(
    import_v414.z.object({
      action: import_v414.z.discriminatedUnion("type", [
        import_v414.z.object({
          type: import_v414.z.literal("search"),
          query: import_v414.z.string().optional()
        }),
        import_v414.z.object({
          type: import_v414.z.literal("openPage"),
          url: import_v414.z.string()
        }),
        import_v414.z.object({
          type: import_v414.z.literal("find"),
          url: import_v414.z.string(),
          pattern: import_v414.z.string()
        })
      ])
    })
  )
);
var webSearchPreview = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search_preview",
  name: "web_search_preview",
  inputSchema: webSearchPreviewInputSchema,
  outputSchema: webSearchPreviewOutputSchema
});
var openaiTools = {
  /**
   * The Code Interpreter tool allows models to write and run Python code in a
   * sandboxed environment to solve complex problems in domains like data analysis,
   * coding, and math.
   *
   * @param container - The container to use for the code interpreter.
   *
   * Must have name `code_interpreter`.
   */
  codeInterpreter,
  /**
   * File search is a tool available in the Responses API. It enables models to
   * retrieve information in a knowledge base of previously uploaded files through
   * semantic and keyword search.
   *
   * Must have name `file_search`.
   *
   * @param vectorStoreIds - The vector store IDs to use for the file search.
   * @param maxNumResults - The maximum number of results to return.
   * @param ranking - The ranking options to use for the file search.
   * @param filters - The filters to use for the file search.
   */
  fileSearch,
  /**
   * The image generation tool allows you to generate images using a text prompt,
   * and optionally image inputs. It leverages the GPT Image model,
   * and automatically optimizes text inputs for improved performance.
   *
   * Must have name `image_generation`.
   *
   * @param size - Image dimensions (e.g., 1024x1024, 1024x1536)
   * @param quality - Rendering quality (e.g. low, medium, high)
   * @param format - File output format
   * @param compression - Compression level (0-100%) for JPEG and WebP formats
   * @param background - Transparent or opaque
   */
  imageGeneration,
  /**
   * Local shell is a tool that allows agents to run shell commands locally
   * on a machine you or the user provides.
   *
   * Supported models: `gpt-5-codex` and `codex-mini-latest`
   *
   * Must have name `local_shell`.
   */
  localShell,
  /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search_preview`.
   *
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   *
   * @deprecated Use `webSearch` instead.
   */
  webSearchPreview,
  /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search`.
   *
   * @param filters - The filters to use for the web search.
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   */
  webSearch
};
function isFileId(data, prefixes) {
  if (!prefixes) return false;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
function convertToOpenAIResponsesInput(_0) {
  return __async(this, arguments, function* ({
    prompt,
    systemMessageMode,
    fileIdPrefixes,
    store,
    hasLocalShellTool = false
  }) {
    var _a4, _b, _c, _d2;
    const input = [];
    const warnings = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          switch (systemMessageMode) {
            case "system": {
              input.push({ role: "system", content });
              break;
            }
            case "developer": {
              input.push({ role: "developer", content });
              break;
            }
            case "remove": {
              warnings.push({
                type: "other",
                message: "system messages are removed for this model"
              });
              break;
            }
            default: {
              const _exhaustiveCheck = systemMessageMode;
              throw new Error(
                `Unsupported system message mode: ${_exhaustiveCheck}`
              );
            }
          }
          break;
        }
        case "user": {
          input.push({
            role: "user",
            content: content.map((part, index) => {
              var _a22, _b2, _c2;
              switch (part.type) {
                case "text": {
                  return { type: "input_text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return __spreadProps(__spreadValues({
                      type: "input_image"
                    }, part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }), {
                      detail: (_b2 = (_a22 = part.providerOptions) == null ? void 0 : _a22.openai) == null ? void 0 : _b2.imageDetail
                    });
                  } else if (part.mediaType === "application/pdf") {
                    if (part.data instanceof URL) {
                      return {
                        type: "input_file",
                        file_url: part.data.toString()
                      };
                    }
                    return __spreadValues({
                      type: "input_file"
                    }, typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    });
                  } else {
                    throw new import_provider18.UnsupportedFunctionalityError({
                      functionality: `file part media type ${part.mediaType}`
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          const reasoningMessages = {};
          const toolCallParts = {};
          for (const part of content) {
            switch (part.type) {
              case "text": {
                const id = (_b = (_a4 = part.providerOptions) == null ? void 0 : _a4.openai) == null ? void 0 : _b.itemId;
                if (store && id != null) {
                  input.push({ type: "item_reference", id });
                  break;
                }
                input.push({
                  role: "assistant",
                  content: [{ type: "output_text", text: part.text }],
                  id
                });
                break;
              }
              case "tool-call": {
                toolCallParts[part.toolCallId] = part;
                if (part.providerExecuted) {
                  break;
                }
                const id = (_d2 = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d2.itemId;
                if (store && id != null) {
                  input.push({ type: "item_reference", id });
                  break;
                }
                if (hasLocalShellTool && part.toolName === "local_shell") {
                  const parsedInput = yield validateTypes({
                    value: part.input,
                    schema: localShellInputSchema
                  });
                  input.push({
                    type: "local_shell_call",
                    call_id: part.toolCallId,
                    id,
                    action: {
                      type: "exec",
                      command: parsedInput.action.command,
                      timeout_ms: parsedInput.action.timeoutMs,
                      user: parsedInput.action.user,
                      working_directory: parsedInput.action.workingDirectory,
                      env: parsedInput.action.env
                    }
                  });
                  break;
                }
                input.push({
                  type: "function_call",
                  call_id: part.toolCallId,
                  name: part.toolName,
                  arguments: JSON.stringify(part.input),
                  id
                });
                break;
              }
              // assistant tool result parts are from provider-executed tools:
              case "tool-result": {
                if (store) {
                  input.push({ type: "item_reference", id: part.toolCallId });
                } else {
                  warnings.push({
                    type: "other",
                    message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                  });
                }
                break;
              }
              case "reasoning": {
                const providerOptions = yield parseProviderOptions({
                  provider: "openai",
                  providerOptions: part.providerOptions,
                  schema: openaiResponsesReasoningProviderOptionsSchema
                });
                const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                if (reasoningId != null) {
                  const reasoningMessage = reasoningMessages[reasoningId];
                  if (store) {
                    if (reasoningMessage === void 0) {
                      input.push({ type: "item_reference", id: reasoningId });
                      reasoningMessages[reasoningId] = {
                        type: "reasoning",
                        id: reasoningId,
                        summary: []
                      };
                    }
                  } else {
                    const summaryParts = [];
                    if (part.text.length > 0) {
                      summaryParts.push({
                        type: "summary_text",
                        text: part.text
                      });
                    } else if (reasoningMessage !== void 0) {
                      warnings.push({
                        type: "other",
                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                      });
                    }
                    if (reasoningMessage === void 0) {
                      reasoningMessages[reasoningId] = {
                        type: "reasoning",
                        id: reasoningId,
                        encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                        summary: summaryParts
                      };
                      input.push(reasoningMessages[reasoningId]);
                    } else {
                      reasoningMessage.summary.push(...summaryParts);
                      if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                        reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                      }
                    }
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                  });
                }
                break;
              }
            }
          }
          break;
        }
        case "tool": {
          for (const part of content) {
            const output = part.output;
            if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
              const parsedOutput = yield validateTypes({
                value: output.value,
                schema: localShellOutputSchema
              });
              input.push({
                type: "local_shell_call_output",
                call_id: part.toolCallId,
                output: parsedOutput.output
              });
              break;
            }
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
              case "content":
                contentValue = output.value.map((item) => {
                  switch (item.type) {
                    case "text": {
                      return { type: "input_text", text: item.text };
                    }
                    case "media": {
                      return item.mediaType.startsWith("image/") ? {
                        type: "input_image",
                        image_url: `data:${item.mediaType};base64,${item.data}`
                      } : {
                        type: "input_file",
                        filename: "data",
                        file_data: `data:${item.mediaType};base64,${item.data}`
                      };
                    }
                  }
                });
                break;
            }
            input.push({
              type: "function_call_output",
              call_id: part.toolCallId,
              output: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return { input, warnings };
  });
}
var openaiResponsesReasoningProviderOptionsSchema = import_v415.z.object({
  itemId: import_v415.z.string().nullish(),
  reasoningEncryptedContent: import_v415.z.string().nullish()
});
function mapOpenAIResponseFinishReason({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "unknown";
  }
}
var openaiResponsesChunkSchema = lazyValidator(
  () => zodSchema(
    import_v416.z.union([
      import_v416.z.object({
        type: import_v416.z.literal("response.output_text.delta"),
        item_id: import_v416.z.string(),
        delta: import_v416.z.string(),
        logprobs: import_v416.z.array(
          import_v416.z.object({
            token: import_v416.z.string(),
            logprob: import_v416.z.number(),
            top_logprobs: import_v416.z.array(
              import_v416.z.object({
                token: import_v416.z.string(),
                logprob: import_v416.z.number()
              })
            )
          })
        ).nullish()
      }),
      import_v416.z.object({
        type: import_v416.z.enum(["response.completed", "response.incomplete"]),
        response: import_v416.z.object({
          incomplete_details: import_v416.z.object({ reason: import_v416.z.string() }).nullish(),
          usage: import_v416.z.object({
            input_tokens: import_v416.z.number(),
            input_tokens_details: import_v416.z.object({ cached_tokens: import_v416.z.number().nullish() }).nullish(),
            output_tokens: import_v416.z.number(),
            output_tokens_details: import_v416.z.object({ reasoning_tokens: import_v416.z.number().nullish() }).nullish()
          }),
          service_tier: import_v416.z.string().nullish()
        })
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.created"),
        response: import_v416.z.object({
          id: import_v416.z.string(),
          created_at: import_v416.z.number(),
          model: import_v416.z.string(),
          service_tier: import_v416.z.string().nullish()
        })
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.output_item.added"),
        output_index: import_v416.z.number(),
        item: import_v416.z.discriminatedUnion("type", [
          import_v416.z.object({
            type: import_v416.z.literal("message"),
            id: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("reasoning"),
            id: import_v416.z.string(),
            encrypted_content: import_v416.z.string().nullish()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("function_call"),
            id: import_v416.z.string(),
            call_id: import_v416.z.string(),
            name: import_v416.z.string(),
            arguments: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("web_search_call"),
            id: import_v416.z.string(),
            status: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("computer_call"),
            id: import_v416.z.string(),
            status: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("file_search_call"),
            id: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("image_generation_call"),
            id: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("code_interpreter_call"),
            id: import_v416.z.string(),
            container_id: import_v416.z.string(),
            code: import_v416.z.string().nullable(),
            outputs: import_v416.z.array(
              import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({ type: import_v416.z.literal("logs"), logs: import_v416.z.string() }),
                import_v416.z.object({ type: import_v416.z.literal("image"), url: import_v416.z.string() })
              ])
            ).nullable(),
            status: import_v416.z.string()
          })
        ])
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.output_item.done"),
        output_index: import_v416.z.number(),
        item: import_v416.z.discriminatedUnion("type", [
          import_v416.z.object({
            type: import_v416.z.literal("message"),
            id: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("reasoning"),
            id: import_v416.z.string(),
            encrypted_content: import_v416.z.string().nullish()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("function_call"),
            id: import_v416.z.string(),
            call_id: import_v416.z.string(),
            name: import_v416.z.string(),
            arguments: import_v416.z.string(),
            status: import_v416.z.literal("completed")
          }),
          import_v416.z.object({
            type: import_v416.z.literal("code_interpreter_call"),
            id: import_v416.z.string(),
            code: import_v416.z.string().nullable(),
            container_id: import_v416.z.string(),
            outputs: import_v416.z.array(
              import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({ type: import_v416.z.literal("logs"), logs: import_v416.z.string() }),
                import_v416.z.object({ type: import_v416.z.literal("image"), url: import_v416.z.string() })
              ])
            ).nullable()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("image_generation_call"),
            id: import_v416.z.string(),
            result: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("web_search_call"),
            id: import_v416.z.string(),
            status: import_v416.z.string(),
            action: import_v416.z.discriminatedUnion("type", [
              import_v416.z.object({
                type: import_v416.z.literal("search"),
                query: import_v416.z.string().nullish()
              }),
              import_v416.z.object({
                type: import_v416.z.literal("open_page"),
                url: import_v416.z.string()
              }),
              import_v416.z.object({
                type: import_v416.z.literal("find"),
                url: import_v416.z.string(),
                pattern: import_v416.z.string()
              })
            ])
          }),
          import_v416.z.object({
            type: import_v416.z.literal("file_search_call"),
            id: import_v416.z.string(),
            queries: import_v416.z.array(import_v416.z.string()),
            results: import_v416.z.array(
              import_v416.z.object({
                attributes: import_v416.z.record(import_v416.z.string(), import_v416.z.unknown()),
                file_id: import_v416.z.string(),
                filename: import_v416.z.string(),
                score: import_v416.z.number(),
                text: import_v416.z.string()
              })
            ).nullish()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("local_shell_call"),
            id: import_v416.z.string(),
            call_id: import_v416.z.string(),
            action: import_v416.z.object({
              type: import_v416.z.literal("exec"),
              command: import_v416.z.array(import_v416.z.string()),
              timeout_ms: import_v416.z.number().optional(),
              user: import_v416.z.string().optional(),
              working_directory: import_v416.z.string().optional(),
              env: import_v416.z.record(import_v416.z.string(), import_v416.z.string()).optional()
            })
          }),
          import_v416.z.object({
            type: import_v416.z.literal("computer_call"),
            id: import_v416.z.string(),
            status: import_v416.z.literal("completed")
          })
        ])
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.function_call_arguments.delta"),
        item_id: import_v416.z.string(),
        output_index: import_v416.z.number(),
        delta: import_v416.z.string()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.image_generation_call.partial_image"),
        item_id: import_v416.z.string(),
        output_index: import_v416.z.number(),
        partial_image_b64: import_v416.z.string()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.code_interpreter_call_code.delta"),
        item_id: import_v416.z.string(),
        output_index: import_v416.z.number(),
        delta: import_v416.z.string()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.code_interpreter_call_code.done"),
        item_id: import_v416.z.string(),
        output_index: import_v416.z.number(),
        code: import_v416.z.string()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.output_text.annotation.added"),
        annotation: import_v416.z.discriminatedUnion("type", [
          import_v416.z.object({
            type: import_v416.z.literal("url_citation"),
            url: import_v416.z.string(),
            title: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("file_citation"),
            file_id: import_v416.z.string(),
            filename: import_v416.z.string().nullish(),
            index: import_v416.z.number().nullish(),
            start_index: import_v416.z.number().nullish(),
            end_index: import_v416.z.number().nullish(),
            quote: import_v416.z.string().nullish()
          })
        ])
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.reasoning_summary_part.added"),
        item_id: import_v416.z.string(),
        summary_index: import_v416.z.number()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.reasoning_summary_text.delta"),
        item_id: import_v416.z.string(),
        summary_index: import_v416.z.number(),
        delta: import_v416.z.string()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("response.reasoning_summary_part.done"),
        item_id: import_v416.z.string(),
        summary_index: import_v416.z.number()
      }),
      import_v416.z.object({
        type: import_v416.z.literal("error"),
        code: import_v416.z.string(),
        message: import_v416.z.string(),
        param: import_v416.z.string().nullish(),
        sequence_number: import_v416.z.number()
      }),
      import_v416.z.object({ type: import_v416.z.string() }).loose().transform((value) => ({
        type: "unknown_chunk",
        message: value.type
      }))
      // fallback for unknown chunks
    ])
  )
);
var openaiResponsesResponseSchema = lazyValidator(
  () => zodSchema(
    import_v416.z.object({
      id: import_v416.z.string(),
      created_at: import_v416.z.number(),
      error: import_v416.z.object({
        code: import_v416.z.string(),
        message: import_v416.z.string()
      }).nullish(),
      model: import_v416.z.string(),
      output: import_v416.z.array(
        import_v416.z.discriminatedUnion("type", [
          import_v416.z.object({
            type: import_v416.z.literal("message"),
            role: import_v416.z.literal("assistant"),
            id: import_v416.z.string(),
            content: import_v416.z.array(
              import_v416.z.object({
                type: import_v416.z.literal("output_text"),
                text: import_v416.z.string(),
                logprobs: import_v416.z.array(
                  import_v416.z.object({
                    token: import_v416.z.string(),
                    logprob: import_v416.z.number(),
                    top_logprobs: import_v416.z.array(
                      import_v416.z.object({
                        token: import_v416.z.string(),
                        logprob: import_v416.z.number()
                      })
                    )
                  })
                ).nullish(),
                annotations: import_v416.z.array(
                  import_v416.z.discriminatedUnion("type", [
                    import_v416.z.object({
                      type: import_v416.z.literal("url_citation"),
                      start_index: import_v416.z.number(),
                      end_index: import_v416.z.number(),
                      url: import_v416.z.string(),
                      title: import_v416.z.string()
                    }),
                    import_v416.z.object({
                      type: import_v416.z.literal("file_citation"),
                      file_id: import_v416.z.string(),
                      filename: import_v416.z.string().nullish(),
                      index: import_v416.z.number().nullish(),
                      start_index: import_v416.z.number().nullish(),
                      end_index: import_v416.z.number().nullish(),
                      quote: import_v416.z.string().nullish()
                    }),
                    import_v416.z.object({
                      type: import_v416.z.literal("container_file_citation")
                    })
                  ])
                )
              })
            )
          }),
          import_v416.z.object({
            type: import_v416.z.literal("web_search_call"),
            id: import_v416.z.string(),
            status: import_v416.z.string(),
            action: import_v416.z.discriminatedUnion("type", [
              import_v416.z.object({
                type: import_v416.z.literal("search"),
                query: import_v416.z.string().nullish()
              }),
              import_v416.z.object({
                type: import_v416.z.literal("open_page"),
                url: import_v416.z.string()
              }),
              import_v416.z.object({
                type: import_v416.z.literal("find"),
                url: import_v416.z.string(),
                pattern: import_v416.z.string()
              })
            ])
          }),
          import_v416.z.object({
            type: import_v416.z.literal("file_search_call"),
            id: import_v416.z.string(),
            queries: import_v416.z.array(import_v416.z.string()),
            results: import_v416.z.array(
              import_v416.z.object({
                attributes: import_v416.z.record(import_v416.z.string(), import_v416.z.unknown()),
                file_id: import_v416.z.string(),
                filename: import_v416.z.string(),
                score: import_v416.z.number(),
                text: import_v416.z.string()
              })
            ).nullish()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("code_interpreter_call"),
            id: import_v416.z.string(),
            code: import_v416.z.string().nullable(),
            container_id: import_v416.z.string(),
            outputs: import_v416.z.array(
              import_v416.z.discriminatedUnion("type", [
                import_v416.z.object({ type: import_v416.z.literal("logs"), logs: import_v416.z.string() }),
                import_v416.z.object({ type: import_v416.z.literal("image"), url: import_v416.z.string() })
              ])
            ).nullable()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("image_generation_call"),
            id: import_v416.z.string(),
            result: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("local_shell_call"),
            id: import_v416.z.string(),
            call_id: import_v416.z.string(),
            action: import_v416.z.object({
              type: import_v416.z.literal("exec"),
              command: import_v416.z.array(import_v416.z.string()),
              timeout_ms: import_v416.z.number().optional(),
              user: import_v416.z.string().optional(),
              working_directory: import_v416.z.string().optional(),
              env: import_v416.z.record(import_v416.z.string(), import_v416.z.string()).optional()
            })
          }),
          import_v416.z.object({
            type: import_v416.z.literal("function_call"),
            call_id: import_v416.z.string(),
            name: import_v416.z.string(),
            arguments: import_v416.z.string(),
            id: import_v416.z.string()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("computer_call"),
            id: import_v416.z.string(),
            status: import_v416.z.string().optional()
          }),
          import_v416.z.object({
            type: import_v416.z.literal("reasoning"),
            id: import_v416.z.string(),
            encrypted_content: import_v416.z.string().nullish(),
            summary: import_v416.z.array(
              import_v416.z.object({
                type: import_v416.z.literal("summary_text"),
                text: import_v416.z.string()
              })
            )
          })
        ])
      ),
      service_tier: import_v416.z.string().nullish(),
      incomplete_details: import_v416.z.object({ reason: import_v416.z.string() }).nullish(),
      usage: import_v416.z.object({
        input_tokens: import_v416.z.number(),
        input_tokens_details: import_v416.z.object({ cached_tokens: import_v416.z.number().nullish() }).nullish(),
        output_tokens: import_v416.z.number(),
        output_tokens_details: import_v416.z.object({ reasoning_tokens: import_v416.z.number().nullish() }).nullish()
      })
    })
  )
);
var TOP_LOGPROBS_MAX = 20;
var openaiResponsesReasoningModelIds = [
  "o1",
  "o1-2024-12-17",
  "o3-mini",
  "o3-mini-2025-01-31",
  "o3",
  "o3-2025-04-16",
  "o4-mini",
  "o4-mini-2025-04-16",
  "codex-mini-latest",
  "computer-use-preview",
  "gpt-5",
  "gpt-5-2025-08-07",
  "gpt-5-codex",
  "gpt-5-mini",
  "gpt-5-mini-2025-08-07",
  "gpt-5-nano",
  "gpt-5-nano-2025-08-07",
  "gpt-5-pro",
  "gpt-5-pro-2025-10-06"
];
var openaiResponsesModelIds = [
  "gpt-4.1",
  "gpt-4.1-2025-04-14",
  "gpt-4.1-mini",
  "gpt-4.1-mini-2025-04-14",
  "gpt-4.1-nano",
  "gpt-4.1-nano-2025-04-14",
  "gpt-4o",
  "gpt-4o-2024-05-13",
  "gpt-4o-2024-08-06",
  "gpt-4o-2024-11-20",
  "gpt-4o-audio-preview",
  "gpt-4o-audio-preview-2024-10-01",
  "gpt-4o-audio-preview-2024-12-17",
  "gpt-4o-search-preview",
  "gpt-4o-search-preview-2025-03-11",
  "gpt-4o-mini-search-preview",
  "gpt-4o-mini-search-preview-2025-03-11",
  "gpt-4o-mini",
  "gpt-4o-mini-2024-07-18",
  "gpt-4-turbo",
  "gpt-4-turbo-2024-04-09",
  "gpt-4-turbo-preview",
  "gpt-4-0125-preview",
  "gpt-4-1106-preview",
  "gpt-4",
  "gpt-4-0613",
  "gpt-4.5-preview",
  "gpt-4.5-preview-2025-02-27",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-1106",
  "chatgpt-4o-latest",
  "gpt-5-chat-latest",
  ...openaiResponsesReasoningModelIds
];
var openaiResponsesProviderOptionsSchema = lazyValidator(
  () => zodSchema(
    import_v417.z.object({
      include: import_v417.z.array(
        import_v417.z.enum([
          "reasoning.encrypted_content",
          // handled internally by default, only needed for unknown reasoning models
          "file_search_call.results",
          "message.output_text.logprobs"
        ])
      ).nullish(),
      instructions: import_v417.z.string().nullish(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       *
       * @see https://platform.openai.com/docs/api-reference/responses/create
       * @see https://cookbook.openai.com/examples/using_logprobs
       */
      logprobs: import_v417.z.union([import_v417.z.boolean(), import_v417.z.number().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
      /**
       * The maximum number of total calls to built-in tools that can be processed in a response.
       * This maximum number applies across all built-in tool calls, not per individual tool.
       * Any further attempts to call a tool by the model will be ignored.
       */
      maxToolCalls: import_v417.z.number().nullish(),
      metadata: import_v417.z.any().nullish(),
      parallelToolCalls: import_v417.z.boolean().nullish(),
      previousResponseId: import_v417.z.string().nullish(),
      promptCacheKey: import_v417.z.string().nullish(),
      reasoningEffort: import_v417.z.string().nullish(),
      reasoningSummary: import_v417.z.string().nullish(),
      safetyIdentifier: import_v417.z.string().nullish(),
      serviceTier: import_v417.z.enum(["auto", "flex", "priority", "default"]).nullish(),
      store: import_v417.z.boolean().nullish(),
      strictJsonSchema: import_v417.z.boolean().nullish(),
      textVerbosity: import_v417.z.enum(["low", "medium", "high"]).nullish(),
      truncation: import_v417.z.enum(["auto", "disabled"]).nullish(),
      user: import_v417.z.string().nullish()
    })
  )
);
function prepareResponsesTools(_0) {
  return __async(this, arguments, function* ({
    tools,
    toolChoice,
    strictJsonSchema
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const openaiTools2 = [];
    for (const tool21 of tools) {
      switch (tool21.type) {
        case "function":
          openaiTools2.push({
            type: "function",
            name: tool21.name,
            description: tool21.description,
            parameters: tool21.inputSchema,
            strict: strictJsonSchema
          });
          break;
        case "provider-defined": {
          switch (tool21.id) {
            case "openai.file_search": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: fileSearchArgsSchema
              });
              openaiTools2.push({
                type: "file_search",
                vector_store_ids: args.vectorStoreIds,
                max_num_results: args.maxNumResults,
                ranking_options: args.ranking ? {
                  ranker: args.ranking.ranker,
                  score_threshold: args.ranking.scoreThreshold
                } : void 0,
                filters: args.filters
              });
              break;
            }
            case "openai.local_shell": {
              openaiTools2.push({
                type: "local_shell"
              });
              break;
            }
            case "openai.web_search_preview": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: webSearchPreviewArgsSchema
              });
              openaiTools2.push({
                type: "web_search_preview",
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            case "openai.web_search": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: webSearchArgsSchema
              });
              openaiTools2.push({
                type: "web_search",
                filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            case "openai.code_interpreter": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: codeInterpreterArgsSchema
              });
              openaiTools2.push({
                type: "code_interpreter",
                container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
              });
              break;
            }
            case "openai.image_generation": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: imageGenerationArgsSchema
              });
              openaiTools2.push({
                type: "image_generation",
                background: args.background,
                input_fidelity: args.inputFidelity,
                input_image_mask: args.inputImageMask ? {
                  file_id: args.inputImageMask.fileId,
                  image_url: args.inputImageMask.imageUrl
                } : void 0,
                model: args.model,
                size: args.size,
                quality: args.quality,
                moderation: args.moderation,
                output_format: args.outputFormat,
                output_compression: args.outputCompression
              });
              break;
            }
          }
          break;
        }
        default:
          toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
          break;
      }
    }
    if (toolChoice == null) {
      return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
      case "required":
        return { tools: openaiTools2, toolChoice: type, toolWarnings };
      case "tool":
        return {
          tools: openaiTools2,
          toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new import_provider19.UnsupportedFunctionalityError({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  });
}
var OpenAIResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/],
      "application/pdf": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      maxOutputTokens,
      temperature,
      stopSequences,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      seed,
      prompt,
      providerOptions,
      tools,
      toolChoice,
      responseFormat
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const modelConfig = getResponsesModelConfig(this.modelId);
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
      }
      const openaiOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiResponsesProviderOptionsSchema
      });
      const { input, warnings: inputWarnings } = yield convertToOpenAIResponsesInput({
        prompt,
        systemMessageMode: modelConfig.systemMessageMode,
        fileIdPrefixes: this.config.fileIdPrefixes,
        store: (_a4 = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a4 : true,
        hasLocalShellTool: hasOpenAITool("openai.local_shell")
      });
      warnings.push(...inputWarnings);
      const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
      let include = openaiOptions == null ? void 0 : openaiOptions.include;
      function addInclude(key) {
        if (include == null) {
          include = [key];
        } else if (!include.includes(key)) {
          include = [...include, key];
        }
      }
      function hasOpenAITool(id) {
        return (tools == null ? void 0 : tools.find(
          (tool21) => tool21.type === "provider-defined" && tool21.id === id
        )) != null;
      }
      const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
      if (topLogprobs) {
        addInclude("message.output_text.logprobs");
      }
      const webSearchToolName = (_c = tools == null ? void 0 : tools.find(
        (tool21) => tool21.type === "provider-defined" && (tool21.id === "openai.web_search" || tool21.id === "openai.web_search_preview")
      )) == null ? void 0 : _c.name;
      if (webSearchToolName) {
        addInclude("web_search_call.action.sources");
      }
      if (hasOpenAITool("openai.code_interpreter")) {
        addInclude("code_interpreter_call.outputs");
      }
      const store = openaiOptions == null ? void 0 : openaiOptions.store;
      if (store === false && modelConfig.isReasoningModel) {
        addInclude("reasoning.encrypted_content");
      }
      const baseArgs = __spreadValues(__spreadProps(__spreadValues({
        model: this.modelId,
        input,
        temperature,
        top_p: topP,
        max_output_tokens: maxOutputTokens
      }, ((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
        text: __spreadValues(__spreadValues({}, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
          format: responseFormat.schema != null ? {
            type: "json_schema",
            strict: strictJsonSchema,
            name: (_d2 = responseFormat.name) != null ? _d2 : "response",
            description: responseFormat.description,
            schema: responseFormat.schema
          } : { type: "json_object" }
        }), (openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
          verbosity: openaiOptions.textVerbosity
        })
      }), {
        // provider options:
        max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
        metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
        parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
        previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
        store,
        user: openaiOptions == null ? void 0 : openaiOptions.user,
        instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
        service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
        include,
        prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
        top_logprobs: topLogprobs,
        truncation: openaiOptions == null ? void 0 : openaiOptions.truncation
      }), modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
        reasoning: __spreadValues(__spreadValues({}, (openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
          effort: openaiOptions.reasoningEffort
        }), (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
          summary: openaiOptions.reasoningSummary
        })
      });
      if (modelConfig.isReasoningModel) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
      } else {
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningEffort",
            details: "reasoningEffort is not supported for non-reasoning models"
          });
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningSummary",
            details: "reasoningSummary is not supported for non-reasoning models"
          });
        }
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        delete baseArgs.service_tier;
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        delete baseArgs.service_tier;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = yield prepareResponsesTools({
        tools,
        toolChoice,
        strictJsonSchema
      });
      return {
        webSearchToolName,
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        }),
        warnings: [...warnings, ...toolWarnings],
        store
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
      const {
        args: body,
        warnings,
        webSearchToolName
      } = yield this.getArgs(options);
      const url = this.config.url({
        path: "/responses",
        modelId: this.modelId
      });
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiResponsesResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      if (response.error) {
        throw new import_provider17.APICallError({
          message: response.error.message,
          url,
          requestBodyValues: body,
          statusCode: 400,
          responseHeaders,
          responseBody: rawResponse,
          isRetryable: false
        });
      }
      const content = [];
      const logprobs = [];
      let hasFunctionCall = false;
      for (const part of response.output) {
        switch (part.type) {
          case "reasoning": {
            if (part.summary.length === 0) {
              part.summary.push({ type: "summary_text", text: "" });
            }
            for (const summary of part.summary) {
              content.push({
                type: "reasoning",
                text: summary.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id,
                    reasoningEncryptedContent: (_a4 = part.encrypted_content) != null ? _a4 : null
                  }
                }
              });
            }
            break;
          }
          case "image_generation_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "image_generation",
              input: "{}",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "image_generation",
              result: {
                result: part.result
              },
              providerExecuted: true
            });
            break;
          }
          case "local_shell_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.call_id,
              toolName: "local_shell",
              input: JSON.stringify({
                action: part.action
              }),
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            break;
          }
          case "message": {
            for (const contentPart of part.content) {
              if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                logprobs.push(contentPart.logprobs);
              }
              content.push({
                type: "text",
                text: contentPart.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id
                  }
                }
              });
              for (const annotation of contentPart.annotations) {
                if (annotation.type === "url_citation") {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: (_f = (_e = (_d2 = this.config).generateId) == null ? void 0 : _e.call(_d2)) != null ? _f : generateId(),
                    url: annotation.url,
                    title: annotation.title
                  });
                } else if (annotation.type === "file_citation") {
                  content.push({
                    type: "source",
                    sourceType: "document",
                    id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                    mediaType: "text/plain",
                    title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                    filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                  });
                }
              }
            }
            break;
          }
          case "function_call": {
            hasFunctionCall = true;
            content.push({
              type: "tool-call",
              toolCallId: part.call_id,
              toolName: part.name,
              input: part.arguments,
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            break;
          }
          case "web_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: webSearchToolName != null ? webSearchToolName : "web_search",
              input: JSON.stringify({}),
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: webSearchToolName != null ? webSearchToolName : "web_search",
              result: mapWebSearchOutput(part.action),
              providerExecuted: true
            });
            break;
          }
          case "computer_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "computer_use",
              input: "",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "computer_use",
              result: {
                type: "computer_use_tool_result",
                status: part.status || "completed"
              },
              providerExecuted: true
            });
            break;
          }
          case "file_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "file_search",
              input: "{}",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "file_search",
              result: {
                queries: part.queries,
                results: (_n = (_m = part.results) == null ? void 0 : _m.map((result) => ({
                  attributes: result.attributes,
                  fileId: result.file_id,
                  filename: result.filename,
                  score: result.score,
                  text: result.text
                }))) != null ? _n : null
              },
              providerExecuted: true
            });
            break;
          }
          case "code_interpreter_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "code_interpreter",
              input: JSON.stringify({
                code: part.code,
                containerId: part.container_id
              }),
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "code_interpreter",
              result: {
                outputs: part.outputs
              },
              providerExecuted: true
            });
            break;
          }
        }
      }
      const providerMetadata = {
        openai: { responseId: response.id }
      };
      if (logprobs.length > 0) {
        providerMetadata.openai.logprobs = logprobs;
      }
      if (typeof response.service_tier === "string") {
        providerMetadata.openai.serviceTier = response.service_tier;
      }
      return {
        content,
        finishReason: mapOpenAIResponseFinishReason({
          finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
          hasFunctionCall
        }),
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
          reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
          cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
        },
        request: { body },
        response: {
          id: response.id,
          timestamp: new Date(response.created_at * 1e3),
          modelId: response.model,
          headers: responseHeaders,
          body: rawResponse
        },
        providerMetadata,
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const {
        args: body,
        warnings,
        webSearchToolName,
        store
      } = yield this.getArgs(options);
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/responses",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, body), {
          stream: true
        }),
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiResponsesChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const self2 = this;
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const logprobs = [];
      let responseId = null;
      const ongoingToolCalls = {};
      let hasFunctionCall = false;
      const activeReasoning = {};
      let serviceTier;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isResponseOutputItemAddedChunk(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: value.item.name,
                    toolCallId: value.item.call_id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.call_id,
                    toolName: value.item.name
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "web_search",
                    input: JSON.stringify({}),
                    providerExecuted: true
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "computer_use",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "computer_use",
                    providerExecuted: true
                  });
                } else if (value.item.type === "code_interpreter_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "code_interpreter",
                    toolCallId: value.item.id,
                    codeInterpreter: {
                      containerId: value.item.container_id
                    }
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "code_interpreter",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: value.item.id,
                    delta: `{"containerId":"${value.item.container_id}","code":"`
                  });
                } else if (value.item.type === "file_search_call") {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    input: "{}",
                    providerExecuted: true
                  });
                } else if (value.item.type === "image_generation_call") {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "image_generation",
                    input: "{}",
                    providerExecuted: true
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-start",
                    id: value.item.id,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning") {
                  activeReasoning[value.item.id] = {
                    encryptedContent: value.item.encrypted_content,
                    summaryParts: { 0: "active" }
                  };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item.id}:0`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id,
                        reasoningEncryptedContent: (_a4 = value.item.encrypted_content) != null ? _a4 : null
                      }
                    }
                  });
                }
              } else if (isResponseOutputItemDoneChunk(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasFunctionCall = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.call_id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.call_id,
                    toolName: value.item.name,
                    input: value.item.arguments,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "web_search",
                    result: mapWebSearchOutput(value.item.action),
                    providerExecuted: true
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    input: "",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    result: {
                      type: "computer_use_tool_result",
                      status: value.item.status || "completed"
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "file_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    result: {
                      queries: value.item.queries,
                      results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result) => ({
                        attributes: result.attributes,
                        fileId: result.file_id,
                        filename: result.filename,
                        score: result.score,
                        text: result.text
                      }))) != null ? _c : null
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "code_interpreter_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "code_interpreter",
                    result: {
                      outputs: value.item.outputs
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "image_generation_call") {
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "image_generation",
                    result: {
                      result: value.item.result
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "local_shell_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.call_id,
                    toolName: "local_shell",
                    input: JSON.stringify({
                      action: {
                        type: "exec",
                        command: value.item.action.command,
                        timeoutMs: value.item.action.timeout_ms,
                        user: value.item.action.user,
                        workingDirectory: value.item.action.working_directory,
                        env: value.item.action.env
                      }
                    }),
                    providerMetadata: {
                      openai: { itemId: value.item.id }
                    }
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-end",
                    id: value.item.id
                  });
                } else if (value.item.type === "reasoning") {
                  const activeReasoningPart = activeReasoning[value.item.id];
                  const summaryPartIndices = Object.entries(
                    activeReasoningPart.summaryParts
                  ).filter(
                    ([_, status]) => status === "active" || status === "can-conclude"
                  ).map(([summaryIndex]) => summaryIndex);
                  for (const summaryIndex of summaryPartIndices) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value.item.id}:${summaryIndex}`,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id,
                          reasoningEncryptedContent: (_d2 = value.item.encrypted_content) != null ? _d2 : null
                        }
                      }
                    });
                  }
                  delete activeReasoning[value.item.id];
                }
              } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: value.delta
                  });
                }
              } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    // The delta is code, which is embedding in a JSON string.
                    // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                    delta: JSON.stringify(value.delta).slice(1, -1)
                  });
                }
              } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: '"}'
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: toolCall.toolCallId,
                    toolName: "code_interpreter",
                    input: JSON.stringify({
                      code: value.code,
                      containerId: toolCall.codeInterpreter.containerId
                    }),
                    providerExecuted: true
                  });
                }
              } else if (isResponseCreatedChunk(value)) {
                responseId = value.response.id;
                controller.enqueue({
                  type: "response-metadata",
                  id: value.response.id,
                  timestamp: new Date(value.response.created_at * 1e3),
                  modelId: value.response.model
                });
              } else if (isTextDeltaChunk(value)) {
                controller.enqueue({
                  type: "text-delta",
                  id: value.item_id,
                  delta: value.delta
                });
                if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                  logprobs.push(value.logprobs);
                }
              } else if (value.type === "response.reasoning_summary_part.added") {
                if (value.summary_index > 0) {
                  const activeReasoningPart = activeReasoning[value.item_id];
                  activeReasoningPart.summaryParts[value.summary_index] = "active";
                  for (const summaryIndex of Object.keys(
                    activeReasoningPart.summaryParts
                  )) {
                    if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: `${value.item_id}:${summaryIndex}`,
                        providerMetadata: { openai: { itemId: value.item_id } }
                      });
                      activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                    }
                  }
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item_id}:${value.summary_index}`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item_id,
                        reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                      }
                    }
                  });
                }
              } else if (value.type === "response.reasoning_summary_text.delta") {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: `${value.item_id}:${value.summary_index}`,
                  delta: value.delta,
                  providerMetadata: {
                    openai: {
                      itemId: value.item_id
                    }
                  }
                });
              } else if (value.type === "response.reasoning_summary_part.done") {
                if (store) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: `${value.item_id}:${value.summary_index}`,
                    providerMetadata: {
                      openai: { itemId: value.item_id }
                    }
                  });
                  activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                } else {
                  activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                }
              } else if (isResponseFinishedChunk(value)) {
                finishReason = mapOpenAIResponseFinishReason({
                  finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                  hasFunctionCall
                });
                usage.inputTokens = value.response.usage.input_tokens;
                usage.outputTokens = value.response.usage.output_tokens;
                usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                if (typeof value.response.service_tier === "string") {
                  serviceTier = value.response.service_tier;
                }
              } else if (isResponseAnnotationAddedChunk(value)) {
                if (value.annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: (_p = (_o = (_n = self2.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId(),
                    url: value.annotation.url,
                    title: value.annotation.title
                  });
                } else if (value.annotation.type === "file_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "document",
                    id: (_s = (_r = (_q = self2.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId(),
                    mediaType: "text/plain",
                    title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                    filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                  });
                }
              } else if (isErrorChunk(value)) {
                controller.enqueue({ type: "error", error: value });
              }
            },
            flush(controller) {
              const providerMetadata = {
                openai: {
                  responseId
                }
              };
              if (logprobs.length > 0) {
                providerMetadata.openai.logprobs = logprobs;
              }
              if (serviceTier !== void 0) {
                providerMetadata.openai.serviceTier = serviceTier;
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function getResponsesModelConfig(modelId) {
  const supportsFlexProcessing22 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsPriorityProcessing22 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  const defaults2 = {
    systemMessageMode: "system",
    supportsFlexProcessing: supportsFlexProcessing22,
    supportsPriorityProcessing: supportsPriorityProcessing22
  };
  if (modelId.startsWith("gpt-5-chat")) {
    return __spreadProps(__spreadValues({}, defaults2), {
      isReasoningModel: false
    });
  }
  if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
    if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
      return __spreadProps(__spreadValues({}, defaults2), {
        isReasoningModel: true,
        systemMessageMode: "remove"
      });
    }
    return __spreadProps(__spreadValues({}, defaults2), {
      isReasoningModel: true,
      systemMessageMode: "developer"
    });
  }
  return __spreadProps(__spreadValues({}, defaults2), {
    isReasoningModel: false
  });
}
function mapWebSearchOutput(action) {
  var _a4;
  switch (action.type) {
    case "search":
      return { action: { type: "search", query: (_a4 = action.query) != null ? _a4 : void 0 } };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find":
      return {
        action: { type: "find", url: action.url, pattern: action.pattern }
      };
  }
}
var openaiSpeechProviderOptionsSchema = lazyValidator(
  () => zodSchema(
    import_v418.z.object({
      instructions: import_v418.z.string().nullish(),
      speed: import_v418.z.number().min(0.25).max(4).default(1).nullish()
    })
  )
);
var OpenAISpeechModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      text,
      voice = "alloy",
      outputFormat = "mp3",
      speed,
      instructions,
      language,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiSpeechProviderOptionsSchema
      });
      const requestBody = {
        model: this.modelId,
        input: text,
        voice,
        response_format: "mp3",
        speed,
        instructions
      };
      if (outputFormat) {
        if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
          requestBody.response_format = outputFormat;
        } else {
          warnings.push({
            type: "unsupported-setting",
            setting: "outputFormat",
            details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
          });
        }
      }
      if (openAIOptions) {
        const speechModelOptions = {};
        for (const key in speechModelOptions) {
          const value = speechModelOptions[key];
          if (value !== void 0) {
            requestBody[key] = value;
          }
        }
      }
      if (language) {
        warnings.push({
          type: "unsupported-setting",
          setting: "language",
          details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
        });
      }
      return {
        requestBody,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { requestBody, warnings } = yield this.getArgs(options);
      const {
        value: audio,
        responseHeaders,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/audio/speech",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: requestBody,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createBinaryResponseHandler(),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      return {
        audio,
        warnings,
        request: {
          body: JSON.stringify(requestBody)
        },
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
};
var openaiTranscriptionResponseSchema = lazyValidator(
  () => zodSchema(
    import_v419.z.object({
      text: import_v419.z.string(),
      language: import_v419.z.string().nullish(),
      duration: import_v419.z.number().nullish(),
      words: import_v419.z.array(
        import_v419.z.object({
          word: import_v419.z.string(),
          start: import_v419.z.number(),
          end: import_v419.z.number()
        })
      ).nullish(),
      segments: import_v419.z.array(
        import_v419.z.object({
          id: import_v419.z.number(),
          seek: import_v419.z.number(),
          start: import_v419.z.number(),
          end: import_v419.z.number(),
          text: import_v419.z.string(),
          tokens: import_v419.z.array(import_v419.z.number()),
          temperature: import_v419.z.number(),
          avg_logprob: import_v419.z.number(),
          compression_ratio: import_v419.z.number(),
          no_speech_prob: import_v419.z.number()
        })
      ).nullish()
    })
  )
);
var openAITranscriptionProviderOptions = lazyValidator(
  () => zodSchema(
    import_v420.z.object({
      /**
       * Additional information to include in the transcription response.
       */
      include: import_v420.z.array(import_v420.z.string()).optional(),
      /**
       * The language of the input audio in ISO-639-1 format.
       */
      language: import_v420.z.string().optional(),
      /**
       * An optional text to guide the model's style or continue a previous audio segment.
       */
      prompt: import_v420.z.string().optional(),
      /**
       * The sampling temperature, between 0 and 1.
       * @default 0
       */
      temperature: import_v420.z.number().min(0).max(1).default(0).optional(),
      /**
       * The timestamp granularities to populate for this transcription.
       * @default ['segment']
       */
      timestampGranularities: import_v420.z.array(import_v420.z.enum(["word", "segment"])).default(["segment"]).optional()
    })
  )
);
var languageMap = {
  afrikaans: "af",
  arabic: "ar",
  armenian: "hy",
  azerbaijani: "az",
  belarusian: "be",
  bosnian: "bs",
  bulgarian: "bg",
  catalan: "ca",
  chinese: "zh",
  croatian: "hr",
  czech: "cs",
  danish: "da",
  dutch: "nl",
  english: "en",
  estonian: "et",
  finnish: "fi",
  french: "fr",
  galician: "gl",
  german: "de",
  greek: "el",
  hebrew: "he",
  hindi: "hi",
  hungarian: "hu",
  icelandic: "is",
  indonesian: "id",
  italian: "it",
  japanese: "ja",
  kannada: "kn",
  kazakh: "kk",
  korean: "ko",
  latvian: "lv",
  lithuanian: "lt",
  macedonian: "mk",
  malay: "ms",
  marathi: "mr",
  maori: "mi",
  nepali: "ne",
  norwegian: "no",
  persian: "fa",
  polish: "pl",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "sr",
  slovak: "sk",
  slovenian: "sl",
  spanish: "es",
  swahili: "sw",
  swedish: "sv",
  tagalog: "tl",
  tamil: "ta",
  thai: "th",
  turkish: "tr",
  ukrainian: "uk",
  urdu: "ur",
  vietnamese: "vi",
  welsh: "cy"
};
var OpenAITranscriptionModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      audio,
      mediaType,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openAITranscriptionProviderOptions
      });
      const formData = new FormData();
      const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
      formData.append("model", this.modelId);
      const fileExtension = mediaTypeToExtension(mediaType);
      formData.append(
        "file",
        new File([blob], "audio", { type: mediaType }),
        `audio.${fileExtension}`
      );
      if (openAIOptions) {
        const transcriptionModelOptions = {
          include: openAIOptions.include,
          language: openAIOptions.language,
          prompt: openAIOptions.prompt,
          // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
          // prefer verbose_json to get segments for models that support it
          response_format: [
            "gpt-4o-transcribe",
            "gpt-4o-mini-transcribe"
          ].includes(this.modelId) ? "json" : "verbose_json",
          temperature: openAIOptions.temperature,
          timestamp_granularities: openAIOptions.timestampGranularities
        };
        for (const [key, value] of Object.entries(transcriptionModelOptions)) {
          if (value != null) {
            if (Array.isArray(value)) {
              for (const item of value) {
                formData.append(`${key}[]`, String(item));
              }
            } else {
              formData.append(key, String(value));
            }
          }
        }
      }
      return {
        formData,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h;
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { formData, warnings } = yield this.getArgs(options);
      const {
        value: response,
        responseHeaders,
        rawValue: rawResponse
      } = yield postFormDataToApi({
        url: this.config.url({
          path: "/audio/transcriptions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        formData,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiTranscriptionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
      return {
        text: response.text,
        segments: (_g = (_f = (_d2 = response.segments) == null ? void 0 : _d2.map((segment) => ({
          text: segment.text,
          startSecond: segment.start,
          endSecond: segment.end
        }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
          text: word.word,
          startSecond: word.start,
          endSecond: word.end
        }))) != null ? _g : [],
        language,
        durationInSeconds: (_h = response.duration) != null ? _h : void 0,
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
};
var VERSION2 = true ? "2.0.53" : "0.0.0-test";
function createOpenAI(options = {}) {
  var _a4, _b;
  const baseURL = (_a4 = withoutTrailingSlash(
    loadOptionalSetting({
      settingValue: options.baseURL,
      environmentVariableName: "OPENAI_BASE_URL"
    })
  )) != null ? _a4 : "https://api.openai.com/v1";
  const providerName = (_b = options.name) != null ? _b : "openai";
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "OPENAI_API_KEY",
        description: "OpenAI"
      })}`,
      "OpenAI-Organization": options.organization,
      "OpenAI-Project": options.project
    }, options.headers),
    `ai-sdk/openai/${VERSION2}`
  );
  const createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
    provider: `${providerName}.chat`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
    provider: `${providerName}.completion`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
    provider: `${providerName}.embedding`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId) => new OpenAIImageModel(modelId, {
    provider: `${providerName}.image`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  };
  const createResponsesModel = (modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch,
      fileIdPrefixes: ["file-"]
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.responses = createResponsesModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.speechModel = createSpeechModel;
  provider.tools = openaiTools;
  return provider;
}
var openai = createOpenAI();

// ../../node_modules/.pnpm/@ai-sdk+provider-utils@3.0.18_zod@4.2.1/node_modules/@ai-sdk/provider-utils/dist/index.mjs
var import_provider20 = require("@ai-sdk/provider");
var import_provider21 = require("@ai-sdk/provider");
var import_provider22 = require("@ai-sdk/provider");
var import_provider23 = require("@ai-sdk/provider");
var import_provider24 = require("@ai-sdk/provider");
var import_provider25 = require("@ai-sdk/provider");
var import_provider26 = require("@ai-sdk/provider");
var import_provider27 = require("@ai-sdk/provider");
var import_provider28 = require("@ai-sdk/provider");
var import_provider29 = require("@ai-sdk/provider");
var import_provider30 = require("@ai-sdk/provider");
var z44 = __toESM(require("zod/v4"), 1);
var import_v35 = require("zod/v3");
var import_v36 = require("zod/v3");
var import_v37 = require("zod/v3");
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator2 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i2 = 0; i2 < size; i2++) {
      chars[i2] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new import_provider20.InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId2 = createIdGenerator2();
function isAbortError2(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
function handleFetchError2({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError2(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new import_provider22.APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function getRuntimeEnvironmentUserAgent2(globalThisAny = globalThis) {
  var _a4, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a4 = globalThisAny.navigator) == null ? void 0 : _a4.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null) {
    return {};
  }
  const normalized = {};
  if (headers instanceof Headers) {
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  } else {
    if (!Array.isArray(headers)) {
      headers = Object.entries(headers);
    }
    for (const [key, value] of headers) {
      if (value != null) {
        normalized[key.toLowerCase()] = value;
      }
    }
  }
  return normalized;
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const normalizedHeaders = new Headers(normalizeHeaders(headers));
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders.entries());
}
var VERSION3 = true ? "3.0.18" : "0.0.0-test";
function loadApiKey2({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new import_provider23.LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new import_provider23.LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new import_provider23.LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new import_provider23.LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
function loadOptionalSetting2({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
function loadSetting2({
  settingValue,
  environmentVariableName,
  settingName,
  description
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null) {
    throw new import_provider24.LoadSettingError({
      message: `${description} setting must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new import_provider24.LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null) {
    throw new import_provider24.LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof settingValue !== "string") {
    throw new import_provider24.LoadSettingError({
      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return settingValue;
}
var suspectProtoRx2 = /"__proto__"\s*:/;
var suspectConstructorRx2 = /"constructor"\s*:/;
function _parse2(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text) === false && suspectConstructorRx2.test(text) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text) {
  const { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e2) {
    return _parse2(text);
  }
  try {
    return _parse2(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol2 = Symbol.for("vercel.ai.validator");
function validator2(validate) {
  return { [validatorSymbol2]: true, validate };
}
function isValidator2(value) {
  return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
function asValidator2(value) {
  return isValidator2(value) ? value : typeof value === "function" ? value() : standardSchemaValidator2(value);
}
function standardSchemaValidator2(standardSchema) {
  return validator2((value) => __async(null, null, function* () {
    const result = yield standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new import_provider27.TypeValidationError({
        value,
        cause: result.issues
      })
    };
  }));
}
function validateTypes2(_0) {
  return __async(this, arguments, function* ({
    value,
    schema
  }) {
    const result = yield safeValidateTypes2({ value, schema });
    if (!result.success) {
      throw import_provider26.TypeValidationError.wrap({ value, cause: result.error });
    }
    return result.value;
  });
}
function safeValidateTypes2(_0) {
  return __async(this, arguments, function* ({
    value,
    schema
  }) {
    const validator22 = asValidator2(schema);
    try {
      if (validator22.validate == null) {
        return { success: true, value, rawValue: value };
      }
      const result = yield validator22.validate(value);
      if (result.success) {
        return { success: true, value: result.value, rawValue: value };
      }
      return {
        success: false,
        error: import_provider26.TypeValidationError.wrap({ value, cause: result.error }),
        rawValue: value
      };
    } catch (error) {
      return {
        success: false,
        error: import_provider26.TypeValidationError.wrap({ value, cause: error }),
        rawValue: value
      };
    }
  });
}
function parseJSON2(_0) {
  return __async(this, arguments, function* ({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse2(text);
      if (schema == null) {
        return value;
      }
      return validateTypes2({ value, schema });
    } catch (error) {
      if (import_provider25.JSONParseError.isInstance(error) || import_provider25.TypeValidationError.isInstance(error)) {
        throw error;
      }
      throw new import_provider25.JSONParseError({ text, cause: error });
    }
  });
}
function safeParseJSON2(_0) {
  return __async(this, arguments, function* ({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse2(text);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      return yield safeValidateTypes2({ value, schema });
    } catch (error) {
      return {
        success: false,
        error: import_provider25.JSONParseError.isInstance(error) ? error : new import_provider25.JSONParseError({ text, cause: error }),
        rawValue: void 0
      };
    }
  });
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      transform(_0, _1) {
        return __async(this, arguments, function* ({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(yield safeParseJSON2({ text: data, schema }));
        });
      }
    })
  );
}
function parseProviderOptions2(_0) {
  return __async(this, arguments, function* ({
    provider,
    providerOptions,
    schema
  }) {
    if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
      return void 0;
    }
    const parsedProviderOptions = yield safeValidateTypes2({
      value: providerOptions[provider],
      schema
    });
    if (!parsedProviderOptions.success) {
      throw new import_provider28.InvalidArgumentError({
        argument: "providerOptions",
        message: `invalid ${provider} provider options`,
        cause: parsedProviderOptions.error
      });
    }
    return parsedProviderOptions.value;
  });
}
var getOriginalFetch22 = () => globalThis.fetch;
var postJsonToApi2 = (_0) => __async(null, [_0], function* ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch3
}) {
  return postToApi2({
    url,
    headers: __spreadValues({
      "Content-Type": "application/json"
    }, headers),
    body: {
      content: JSON.stringify(body),
      values: body
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch3
  });
});
var postToApi2 = (_0) => __async(null, [_0], function* ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch3 = getOriginalFetch22()
}) {
  try {
    const response = yield fetch3(url, {
      method: "POST",
      headers: withUserAgentSuffix2(
        headers,
        `ai-sdk/provider-utils/${VERSION3}`,
        getRuntimeEnvironmentUserAgent2()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = yield failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError2(error) || import_provider29.APICallError.isInstance(error)) {
          throw error;
        }
        throw new import_provider29.APICallError({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return yield successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError2(error) || import_provider29.APICallError.isInstance(error)) {
          throw error;
        }
      }
      throw new import_provider29.APICallError({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError2({ error, url, requestBodyValues: body.values });
  }
});
function tool20(tool22) {
  return tool22;
}
function createProviderDefinedToolFactory2({
  id,
  name,
  inputSchema
}) {
  return (_a4) => {
    var _b = _a4, {
      execute,
      outputSchema,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    } = _b, args = __objRest(_b, [
      "execute",
      "outputSchema",
      "toModelOutput",
      "onInputStart",
      "onInputDelta",
      "onInputAvailable"
    ]);
    return tool20({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  };
}
function createProviderDefinedToolFactoryWithOutputSchema2({
  id,
  name,
  inputSchema,
  outputSchema
}) {
  return (_a4) => {
    var _b = _a4, {
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    } = _b, args = __objRest(_b, [
      "execute",
      "toModelOutput",
      "onInputStart",
      "onInputDelta",
      "onInputAvailable"
    ]);
    return tool20({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  };
}
function resolve2(value) {
  return __async(this, null, function* () {
    if (typeof value === "function") {
      value = value();
    }
    return Promise.resolve(value);
  });
}
var createJsonErrorResponseHandler2 = ({
  errorSchema,
  errorToMessage: errorToMessage2,
  isRetryable
}) => (_0) => __async(null, [_0], function* ({ response, url, requestBodyValues }) {
  const responseBody = yield response.text();
  const responseHeaders = extractResponseHeaders2(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new import_provider30.APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = yield parseJSON2({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new import_provider30.APICallError({
        message: errorToMessage2(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new import_provider30.APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
});
var createEventSourceResponseHandler2 = (chunkSchema3) => (_0) => __async(null, [_0], function* ({ response }) {
  const responseHeaders = extractResponseHeaders2(response);
  if (response.body == null) {
    throw new import_provider30.EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream2({
      stream: response.body,
      schema: chunkSchema3
    })
  };
});
var createJsonResponseHandler2 = (responseSchema3) => (_0) => __async(null, [_0], function* ({ response, url, requestBodyValues }) {
  const responseBody = yield response.text();
  const parsedResult = yield safeParseJSON2({
    text: responseBody,
    schema: responseSchema3
  });
  const responseHeaders = extractResponseHeaders2(response);
  if (!parsedResult.success) {
    throw new import_provider30.APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
});
var getRelativePath2 = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2]) break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
var ignoreOverride2 = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions2 = (options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions2), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions2), options);
function parseAnyDef2() {
  return {};
}
function parseArrayDef2(def, refs) {
  var _a4, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a4 = def.type) == null ? void 0 : _a4._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== import_v36.ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef2(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef2(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef2() {
  return { type: "boolean" };
}
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
var parseCatchDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef2(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def);
  }
}
var integerDateParser2 = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef2(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef2(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef2(_def.schema._def, refs) : parseAnyDef2();
}
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType2 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef2(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x2) => !!x2);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a4 = schema, { additionalProperties } = _a4, rest = __objRest(_a4, ["additionalProperties"]);
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef2(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
var emojiRegex2 = void 0;
var zodPatterns2 = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef2(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern2(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern2(
            res,
            RegExp(`^${escapeLiteralCheckValue2(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern2(
            res,
            RegExp(`${escapeLiteralCheckValue2(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat2(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern2(
            res,
            RegExp(escapeLiteralCheckValue2(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat2(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat2(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern2(res, zodPatterns2.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern2(res, zodPatterns2.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue2(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(literal) : literal;
}
var ALPHA_NUMERIC2 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC2.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
function addFormat2(schema, value, message, refs) {
  var _a4;
  if (schema.format || ((_a4 = schema.anyOf) == null ? void 0 : _a4.some((x2) => x2.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message && refs.errorMessages && { errorMessage: { format: message } }));
  } else {
    schema.format = value;
  }
}
function addPattern2(schema, regex, message, refs) {
  var _a4;
  if (schema.pattern || ((_a4 = schema.allOf) == null ? void 0 : _a4.some((x2) => x2.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push(__spreadValues({
      pattern: stringifyRegExpWithFlags2(regex, refs)
    }, message && refs.errorMessages && { errorMessage: { pattern: message } }));
  } else {
    schema.pattern = stringifyRegExpWithFlags2(regex, refs);
  }
}
function stringifyRegExpWithFlags2(regex, refs) {
  var _a4;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && ((_a4 = source[i2 + 2]) == null ? void 0 : _a4.match(/[a-z]/))) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e2) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef2(def, refs) {
  var _a4, _b, _c, _d2, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a4 = parseDef2(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a4 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === import_v37.ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const _a5 = parseStringDef2(def.keyType._def, refs), { type } = _a5, keyType = __objRest(_a5, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_d2 = def.keyType) == null ? void 0 : _d2._def.typeName) === import_v37.ZodFirstPartyTypeKind.ZodEnum) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === import_v37.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === import_v37.ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const _b2 = parseBrandedDef2(
      def.keyType._def,
      refs
    ), { type } = _b2, keyType = __objRest(_b2, ["type"]);
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  }
  return schema;
}
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef2(def, refs);
  }
  const keys = parseDef2(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || parseAnyDef2();
  const values = parseDef2(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || parseAnyDef2();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef2(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef2() {
  return { not: parseAnyDef2() };
}
function parseNullDef2() {
  return {
    type: "null"
  };
}
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef2(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x2) => x2._def.typeName in primitiveMappings2 && (!x2._def.checks || !x2._def.checks.length)
  )) {
    const types3 = options.reduce((types22, x2) => {
      const type = primitiveMappings2[x2._def.typeName];
      return type && !types22.includes(type) ? [...types22, type] : types22;
    }, []);
    return {
      type: types3.length > 1 ? types3 : types3[0]
    };
  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types3 = options.reduce(
      (acc, x2) => {
        const type = typeof x2._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x2._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types3.length === options.length) {
      const uniqueTypes = types3.filter((x2, i2, a) => a.indexOf(x2) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x2) => {
            return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x2) => [
          ...acc,
          ...x2._def.values.filter((x22) => !acc.includes(x22))
        ],
        []
      )
    };
  }
  return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x2, i2) => parseDef2(x2._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "anyOf", `${i2}`]
    }))
  ).filter(
    (x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef2(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings2[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef2(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef2(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}
function parseObjectDef2(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional2(propDef);
    const parsedDef = parseDef2(propDef._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    }));
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef2(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }));
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef2 = (def, refs) => {
  var _a4;
  if (refs.currentPath.toString() === ((_a4 = refs.propertyPath) == null ? void 0 : _a4.toString())) {
    return parseDef2(def.innerType._def, refs);
  }
  const innerSchema = parseDef2(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? { anyOf: [{ not: parseAnyDef2() }, innerSchema] } : parseAnyDef2();
};
var parsePipelineDef2 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef2(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef2(def.out._def, refs);
  }
  const a = parseDef2(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef2(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x2) => x2 !== void 0)
  };
};
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef2(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x2, i2) => parseDef2(x2._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i2}`]
        }))
      ).reduce(
        (acc, x2) => x2 === void 0 ? acc : [...acc, x2],
        []
      ),
      additionalItems: parseDef2(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x2, i2) => parseDef2(x2._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i2}`]
        }))
      ).reduce(
        (acc, x2) => x2 === void 0 ? acc : [...acc, x2],
        []
      )
    };
  }
}
function parseUndefinedDef2() {
  return {
    not: parseAnyDef2()
  };
}
function parseUnknownDef2() {
  return parseAnyDef2();
}
var parseReadonlyDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
var selectParser2 = (def, typeName, refs) => {
  switch (typeName) {
    case import_v35.ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def);
    case import_v35.ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def);
    case import_v35.ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodUnion:
    case import_v35.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def);
    case import_v35.ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case import_v35.ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case import_v35.ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case import_v35.ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodNaN:
    case import_v35.ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2();
    case import_v35.ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case import_v35.ZodFirstPartyTypeKind.ZodFunction:
    case import_v35.ZodFirstPartyTypeKind.ZodVoid:
    case import_v35.ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};
function parseDef2(def, refs, forceResolution = false) {
  var _a4;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a4 = refs.override) == null ? void 0 : _a4.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride2) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema22 = typeof jsonSchemaOrGetter === "function" ? parseDef2(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema22) {
    addMeta2(def, refs, jsonSchema22);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema22, def, refs);
    newItem.jsonSchema = jsonSchema22;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema22;
  return jsonSchema22;
}
var get$ref2 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef2();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2() : void 0;
    }
  }
};
var addMeta2 = (def, refs, jsonSchema22) => {
  if (def.description) {
    jsonSchema22.description = def.description;
  }
  return jsonSchema22;
};
var getRefs2 = (options) => {
  const _options = getDefaultOptions2(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
};
var zodToJsonSchema3 = (schema, options) => {
  var _a4;
  const refs = getRefs2(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a22;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a22 = parseDef2(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a22 : parseAnyDef2()
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a4 = parseDef2(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a4 : parseAnyDef2();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default2 = zodToJsonSchema3;
function zod3Schema2(zodSchema22, options) {
  var _a4;
  const useReferences = (_a4 = options == null ? void 0 : options.useReferences) != null ? _a4 : false;
  return jsonSchema2(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default2(zodSchema22, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: (value) => __async(null, null, function* () {
        const result = yield zodSchema22.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      })
    }
  );
}
function zod4Schema2(zodSchema22, options) {
  var _a4;
  const useReferences = (_a4 = options == null ? void 0 : options.useReferences) != null ? _a4 : false;
  return jsonSchema2(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => z44.toJSONSchema(zodSchema22, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: (value) => __async(null, null, function* () {
        const result = yield z44.safeParseAsync(zodSchema22, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      })
    }
  );
}
function isZod4Schema3(zodSchema22) {
  return "_zod" in zodSchema22;
}
function zodSchema2(zodSchema22, options) {
  if (isZod4Schema3(zodSchema22)) {
    return zod4Schema2(zodSchema22, options);
  } else {
    return zod3Schema2(zodSchema22, options);
  }
}
var schemaSymbol2 = Symbol.for("vercel.ai.schema");
function lazySchema2(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema2(jsonSchema22, {
  validate
} = {}) {
  return {
    [schemaSymbol2]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol2]: true,
    get jsonSchema() {
      if (typeof jsonSchema22 === "function") {
        jsonSchema22 = jsonSchema22();
      }
      return jsonSchema22;
    },
    validate
  };
}
var { btoa: btoa2, atob: atob2 } = globalThis;
function convertUint8ArrayToBase642(array) {
  let latin1string = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    latin1string += String.fromCodePoint(array[i2]);
  }
  return btoa2(latin1string);
}
function convertToBase642(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase642(value) : value;
}
function withoutTrailingSlash2(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}

// ../../node_modules/.pnpm/@ai-sdk+google-vertex@3.0.85_zod@4.2.1/node_modules/@ai-sdk/google-vertex/dist/index.mjs
var import_google_auth_library = __toESM(require_src6(), 1);

// ../../node_modules/.pnpm/@ai-sdk+google@2.0.44_zod@4.2.1/node_modules/@ai-sdk/google/dist/internal/index.mjs
var import_v421 = require("zod/v4");
var import_provider31 = require("@ai-sdk/provider");
var import_v422 = require("zod/v4");
var import_v423 = require("zod/v4");
var import_provider32 = require("@ai-sdk/provider");
var import_v424 = require("zod/v4");
var import_v425 = require("zod/v4");
var import_v426 = require("zod/v4");
var import_v427 = require("zod/v4");
var import_v428 = require("zod/v4");
function convertJSONSchemaToOpenAPISchema(jsonSchema3) {
  if (jsonSchema3 == null || isEmptyObjectSchema(jsonSchema3)) {
    return void 0;
  }
  if (typeof jsonSchema3 === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type,
    description,
    required,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema3;
  const result = {};
  if (description) result.description = description;
  if (required) result.required = required;
  if (format) result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type) {
    if (Array.isArray(type)) {
      const hasNull = type.includes("null");
      const nonNullTypes = type.filter((t2) => t2 !== "null");
      if (nonNullTypes.length === 0) {
        result.type = "null";
      } else {
        result.anyOf = nonNullTypes.map((t2) => ({ type: t2 }));
        if (hasNull) {
          result.nullable = true;
        }
      }
    } else {
      result.type = type;
    }
  }
  if (enumValues !== void 0) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema(value);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (anyOf) {
    if (anyOf.some(
      (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
    )) {
      const nonNullSchemas = anyOf.filter(
        (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
      );
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (minLength !== void 0) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema(jsonSchema3) {
  return jsonSchema3 != null && typeof jsonSchema3 === "object" && jsonSchema3.type === "object" && (jsonSchema3.properties == null || Object.keys(jsonSchema3.properties).length === 0) && !jsonSchema3.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
  var _a4;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  const isGemmaModel = (_a4 = options == null ? void 0 : options.isGemmaModel) != null ? _a4 : false;
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new import_provider31.UnsupportedFunctionalityError({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: mediaType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: mediaType,
                    data: convertToBase642(part.data)
                  }
                }
              );
              break;
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a22, _b, _c;
            const thoughtSignature = ((_b = (_a22 = part.providerOptions) == null ? void 0 : _a22.google) == null ? void 0 : _b.thoughtSignature) != null ? String((_c = part.providerOptions.google) == null ? void 0 : _c.thoughtSignature) : void 0;
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature
                };
              }
              case "reasoning": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: true,
                  thoughtSignature
                };
              }
              case "file": {
                if (part.mediaType !== "image/png") {
                  throw new import_provider31.UnsupportedFunctionalityError({
                    functionality: "Only PNG images are supported in assistant messages"
                  });
                }
                if (part.data instanceof URL) {
                  throw new import_provider31.UnsupportedFunctionalityError({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase642(part.data)
                  }
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature
                };
              }
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          const output = part.output;
          if (output.type === "content") {
            for (const contentPart of output.value) {
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "media":
                  parts.push(
                    {
                      inlineData: {
                        mimeType: contentPart.mediaType,
                        data: contentPart.data
                      }
                    },
                    {
                      text: "Tool executed successfully and returned this image as a response"
                    }
                  );
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
            }
          } else {
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.value
                }
              }
            });
          }
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
    contents[0].parts.unshift({ text: systemText + "\n\n" });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleErrorDataSchema = lazySchema2(
  () => zodSchema2(
    import_v422.z.object({
      error: import_v422.z.object({
        code: import_v422.z.number().nullable(),
        message: import_v422.z.string(),
        status: import_v422.z.string()
      })
    })
  )
);
var googleFailedResponseHandler = createJsonErrorResponseHandler2({
  errorSchema: googleErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
var googleGenerativeAIProviderOptions = lazySchema2(
  () => zodSchema2(
    import_v423.z.object({
      responseModalities: import_v423.z.array(import_v423.z.enum(["TEXT", "IMAGE"])).optional(),
      thinkingConfig: import_v423.z.object({
        thinkingBudget: import_v423.z.number().optional(),
        includeThoughts: import_v423.z.boolean().optional(),
        // https://ai.google.dev/gemini-api/docs/gemini-3?thinking=high#thinking_level
        thinkingLevel: import_v423.z.enum(["low", "medium", "high"]).optional()
      }).optional(),
      /**
       * Optional.
       * The name of the cached content used as context to serve the prediction.
       * Format: cachedContents/{cachedContent}
       */
      cachedContent: import_v423.z.string().optional(),
      /**
       * Optional. Enable structured output. Default is true.
       *
       * This is useful when the JSON Schema contains elements that are
       * not supported by the OpenAPI schema version that
       * Google Generative AI uses. You can use this to disable
       * structured outputs if you need to.
       */
      structuredOutputs: import_v423.z.boolean().optional(),
      /**
       * Optional. A list of unique safety settings for blocking unsafe content.
       */
      safetySettings: import_v423.z.array(
        import_v423.z.object({
          category: import_v423.z.enum([
            "HARM_CATEGORY_UNSPECIFIED",
            "HARM_CATEGORY_HATE_SPEECH",
            "HARM_CATEGORY_DANGEROUS_CONTENT",
            "HARM_CATEGORY_HARASSMENT",
            "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "HARM_CATEGORY_CIVIC_INTEGRITY"
          ]),
          threshold: import_v423.z.enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
          ])
        })
      ).optional(),
      threshold: import_v423.z.enum([
        "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE",
        "OFF"
      ]).optional(),
      /**
       * Optional. Enables timestamp understanding for audio-only files.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
       */
      audioTimestamp: import_v423.z.boolean().optional(),
      /**
       * Optional. Defines labels used in billing reports. Available on Vertex AI only.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
       */
      labels: import_v423.z.record(import_v423.z.string(), import_v423.z.string()).optional(),
      /**
       * Optional. If specified, the media resolution specified will be used.
       *
       * https://ai.google.dev/api/generate-content#MediaResolution
       */
      mediaResolution: import_v423.z.enum([
        "MEDIA_RESOLUTION_UNSPECIFIED",
        "MEDIA_RESOLUTION_LOW",
        "MEDIA_RESOLUTION_MEDIUM",
        "MEDIA_RESOLUTION_HIGH"
      ]).optional(),
      /**
       * Optional. Configures the image generation aspect ratio for Gemini models.
       *
       * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
       */
      imageConfig: import_v423.z.object({
        aspectRatio: import_v423.z.enum([
          "1:1",
          "2:3",
          "3:2",
          "3:4",
          "4:3",
          "4:5",
          "5:4",
          "9:16",
          "16:9",
          "21:9"
        ]).optional(),
        imageSize: import_v423.z.enum(["1K", "2K", "4K"]).optional()
      }).optional()
    })
  )
);
function prepareTools({
  tools,
  toolChoice,
  modelId
}) {
  var _a4;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const isLatest = [
    "gemini-flash-latest",
    "gemini-flash-lite-latest",
    "gemini-pro-latest"
  ].some((id) => id === modelId);
  const isGemini2orNewer = modelId.includes("gemini-2") || modelId.includes("gemini-3") || isLatest;
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  const supportsFileSearch = modelId.includes("gemini-2.5");
  if (tools == null) {
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  }
  const hasFunctionTools = tools.some((tool21) => tool21.type === "function");
  const hasProviderDefinedTools = tools.some(
    (tool21) => tool21.type === "provider-defined"
  );
  if (hasFunctionTools && hasProviderDefinedTools) {
    const functionTools = tools.filter((tool21) => tool21.type === "function");
    toolWarnings.push({
      type: "unsupported-tool",
      tool: tools.find((tool21) => tool21.type === "function"),
      details: `Cannot mix function tools with provider-defined tools in the same request. Falling back to provider-defined tools only. The following function tools will be ignored: ${functionTools.map((t2) => t2.name).join(", ")}. Please use either function tools or provider-defined tools, but not both.`
    });
  }
  if (hasProviderDefinedTools) {
    const googleTools22 = [];
    const providerDefinedTools = tools.filter(
      (tool21) => tool21.type === "provider-defined"
    );
    providerDefinedTools.forEach((tool21) => {
      switch (tool21.id) {
        case "google.google_search":
          if (isGemini2orNewer) {
            googleTools22.push({ googleSearch: {} });
          } else if (supportsDynamicRetrieval) {
            googleTools22.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool21.args.mode,
                  dynamicThreshold: tool21.args.dynamicThreshold
                }
              }
            });
          } else {
            googleTools22.push({ googleSearchRetrieval: {} });
          }
          break;
        case "google.url_context":
          if (isGemini2orNewer) {
            googleTools22.push({ urlContext: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.code_execution":
          if (isGemini2orNewer) {
            googleTools22.push({ codeExecution: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.file_search":
          if (supportsFileSearch) {
            googleTools22.push({ fileSearch: __spreadValues({}, tool21.args) });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The file search tool is only supported with Gemini 2.5 models."
            });
          }
          break;
        case "google.vertex_rag_store":
          if (isGemini2orNewer) {
            googleTools22.push({
              retrieval: {
                vertex_rag_store: {
                  rag_resources: {
                    rag_corpus: tool21.args.ragCorpus
                  },
                  similarity_top_k: tool21.args.topK
                }
              }
            });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The RAG store tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
          break;
      }
    });
    return {
      tools: googleTools22.length > 0 ? googleTools22 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const functionDeclarations = [];
  for (const tool21 of tools) {
    switch (tool21.type) {
      case "function":
        functionDeclarations.push({
          name: tool21.name,
          description: (_a4 = tool21.description) != null ? _a4 : "",
          parameters: convertJSONSchemaToOpenAPISchema(tool21.inputSchema)
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
        break;
    }
  }
  if (toolChoice == null) {
    return {
      tools: [{ functionDeclarations }],
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider32.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    default:
      return "unknown";
  }
}
var GoogleGenerativeAILanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a4;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a4 = config.generateId) != null ? _a4 : generateId2;
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).supportedUrls) == null ? void 0 : _b.call(_a4)) != null ? _c : {};
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4;
      const warnings = [];
      const googleOptions = yield parseProviderOptions2({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIProviderOptions
      });
      if ((tools == null ? void 0 : tools.some(
        (tool21) => tool21.type === "provider-defined" && tool21.id === "google.vertex_rag_store"
      )) && !this.config.provider.startsWith("google.vertex.")) {
        warnings.push({
          type: "other",
          message: `The 'vertex_rag_store' tool is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
        });
      }
      const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
      const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
        prompt,
        { isGemmaModel }
      );
      const {
        tools: googleTools22,
        toolConfig: googleToolConfig,
        toolWarnings
      } = prepareTools({
        tools,
        toolChoice,
        modelId: this.modelId
      });
      return {
        args: {
          generationConfig: __spreadValues(__spreadValues(__spreadProps(__spreadValues({
            // standardized settings:
            maxOutputTokens,
            temperature,
            topK,
            topP,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            seed,
            // response format:
            responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
            responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
            // so this is needed as an escape hatch:
            // TODO convert into provider option
            ((_a4 = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _a4 : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0
          }, (googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
            audioTimestamp: googleOptions.audioTimestamp
          }), {
            // provider options:
            responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
            thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig
          }), (googleOptions == null ? void 0 : googleOptions.imageConfig) && {
            imageConfig: googleOptions.imageConfig
          }), (googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
            mediaResolution: googleOptions.mediaResolution
          }),
          contents,
          systemInstruction: isGemmaModel ? void 0 : systemInstruction,
          safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
          tools: googleTools22,
          toolConfig: googleToolConfig,
          cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
          labels: googleOptions == null ? void 0 : googleOptions.labels
        },
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const { args, warnings } = yield this.getArgs(options);
      const body = JSON.stringify(args);
      const mergedHeaders = combineHeaders2(
        yield resolve2(this.config.headers),
        options.headers
      );
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi2({
        url: `${this.config.baseURL}/${getModelPath(
          this.modelId
        )}:generateContent`,
        headers: mergedHeaders,
        body: args,
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler2(responseSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const candidate = response.candidates[0];
      const content = [];
      const parts = (_b = (_a4 = candidate.content) == null ? void 0 : _a4.parts) != null ? _b : [];
      const usageMetadata = response.usageMetadata;
      let lastCodeExecutionToolCallId;
      for (const part of parts) {
        if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
          const toolCallId = this.config.generateId();
          lastCodeExecutionToolCallId = toolCallId;
          content.push({
            type: "tool-call",
            toolCallId,
            toolName: "code_execution",
            input: JSON.stringify(part.executableCode),
            providerExecuted: true
          });
        } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
          content.push({
            type: "tool-result",
            // Assumes a result directly follows its corresponding call part.
            toolCallId: lastCodeExecutionToolCallId,
            toolName: "code_execution",
            result: {
              outcome: part.codeExecutionResult.outcome,
              output: part.codeExecutionResult.output
            },
            providerExecuted: true
          });
          lastCodeExecutionToolCallId = void 0;
        } else if ("text" in part && part.text != null && part.text.length > 0) {
          content.push({
            type: part.thought === true ? "reasoning" : "text",
            text: part.text,
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("functionCall" in part) {
          content.push({
            type: "tool-call",
            toolCallId: this.config.generateId(),
            toolName: part.functionCall.name,
            input: JSON.stringify(part.functionCall.args),
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("inlineData" in part) {
          content.push({
            type: "file",
            data: part.inlineData.data,
            mediaType: part.inlineData.mimeType
          });
        }
      }
      const sources = (_d2 = extractSources({
        groundingMetadata: candidate.groundingMetadata,
        generateId: this.config.generateId
      })) != null ? _d2 : [];
      for (const source of sources) {
        content.push(source);
      }
      return {
        content,
        finishReason: mapGoogleGenerativeAIFinishReason({
          finishReason: candidate.finishReason,
          hasToolCalls: content.some((part) => part.type === "tool-call")
        }),
        usage: {
          inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
          outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
          totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
          reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
          cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
        },
        warnings,
        providerMetadata: {
          google: {
            promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
            groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
            urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
            safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
            usageMetadata: usageMetadata != null ? usageMetadata : null
          }
        },
        request: { body },
        response: {
          // TODO timestamp, model id, id
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = JSON.stringify(args);
      const headers = combineHeaders2(
        yield resolve2(this.config.headers),
        options.headers
      );
      const { responseHeaders, value: response } = yield postJsonToApi2({
        url: `${this.config.baseURL}/${getModelPath(
          this.modelId
        )}:streamGenerateContent?alt=sse`,
        headers,
        body: args,
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler2(chunkSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let providerMetadata = void 0;
      const generateId22 = this.config.generateId;
      let hasToolCalls = false;
      let currentTextBlockId = null;
      let currentReasoningBlockId = null;
      let blockCounter = 0;
      const emittedSourceUrls = /* @__PURE__ */ new Set();
      let lastCodeExecutionToolCallId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              const usageMetadata = value.usageMetadata;
              if (usageMetadata != null) {
                usage.inputTokens = (_a4 = usageMetadata.promptTokenCount) != null ? _a4 : void 0;
                usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                usage.reasoningTokens = (_d2 = usageMetadata.thoughtsTokenCount) != null ? _d2 : void 0;
                usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
              }
              const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
              if (candidate == null) {
                return;
              }
              const content = candidate.content;
              const sources = extractSources({
                groundingMetadata: candidate.groundingMetadata,
                generateId: generateId22
              });
              if (sources != null) {
                for (const source of sources) {
                  if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                    emittedSourceUrls.add(source.url);
                    controller.enqueue(source);
                  }
                }
              }
              if (content != null) {
                const parts = (_g = content.parts) != null ? _g : [];
                for (const part of parts) {
                  if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                    const toolCallId = generateId22();
                    lastCodeExecutionToolCallId = toolCallId;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName: "code_execution",
                      input: JSON.stringify(part.executableCode),
                      providerExecuted: true
                    });
                    hasToolCalls = true;
                  } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                    const toolCallId = lastCodeExecutionToolCallId;
                    if (toolCallId) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId,
                        toolName: "code_execution",
                        result: {
                          outcome: part.codeExecutionResult.outcome,
                          output: part.codeExecutionResult.output
                        },
                        providerExecuted: true
                      });
                      lastCodeExecutionToolCallId = void 0;
                    }
                  } else if ("text" in part && part.text != null && part.text.length > 0) {
                    if (part.thought === true) {
                      if (currentTextBlockId !== null) {
                        controller.enqueue({
                          type: "text-end",
                          id: currentTextBlockId
                        });
                        currentTextBlockId = null;
                      }
                      if (currentReasoningBlockId === null) {
                        currentReasoningBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "reasoning-start",
                          id: currentReasoningBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: currentReasoningBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    } else {
                      if (currentReasoningBlockId !== null) {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: currentReasoningBlockId
                        });
                        currentReasoningBlockId = null;
                      }
                      if (currentTextBlockId === null) {
                        currentTextBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "text-start",
                          id: currentTextBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: currentTextBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    }
                  } else if ("inlineData" in part) {
                    controller.enqueue({
                      type: "file",
                      mediaType: part.inlineData.mimeType,
                      data: part.inlineData.data
                    });
                  }
                }
                const toolCallDeltas = getToolCallsFromParts({
                  parts: content.parts,
                  generateId: generateId22
                });
                if (toolCallDeltas != null) {
                  for (const toolCall of toolCallDeltas) {
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      input: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    hasToolCalls = true;
                  }
                }
              }
              if (candidate.finishReason != null) {
                finishReason = mapGoogleGenerativeAIFinishReason({
                  finishReason: candidate.finishReason,
                  hasToolCalls
                });
                providerMetadata = {
                  google: {
                    promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                    groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                    urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                    safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                  }
                };
                if (usageMetadata != null) {
                  providerMetadata.google.usageMetadata = usageMetadata;
                }
              }
            },
            flush(controller) {
              if (currentTextBlockId !== null) {
                controller.enqueue({
                  type: "text-end",
                  id: currentTextBlockId
                });
              }
              if (currentReasoningBlockId !== null) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: currentReasoningBlockId
                });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        response: { headers: responseHeaders },
        request: { body }
      };
    });
  }
};
function getToolCallsFromParts({
  parts,
  generateId: generateId22
}) {
  const functionCallParts = parts == null ? void 0 : parts.filter(
    (part) => "functionCall" in part
  );
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId22(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
  }));
}
function extractSources({
  groundingMetadata,
  generateId: generateId22
}) {
  var _a4, _b, _c, _d2;
  if (!(groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks)) {
    return void 0;
  }
  const sources = [];
  for (const chunk of groundingMetadata.groundingChunks) {
    if (chunk.web != null) {
      sources.push({
        type: "source",
        sourceType: "url",
        id: generateId22(),
        url: chunk.web.uri,
        title: (_a4 = chunk.web.title) != null ? _a4 : void 0
      });
    } else if (chunk.retrievedContext != null) {
      const uri = chunk.retrievedContext.uri;
      const fileSearchStore = chunk.retrievedContext.fileSearchStore;
      if (uri && (uri.startsWith("http://") || uri.startsWith("https://"))) {
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId22(),
          url: uri,
          title: (_b = chunk.retrievedContext.title) != null ? _b : void 0
        });
      } else if (uri) {
        const title = (_c = chunk.retrievedContext.title) != null ? _c : "Unknown Document";
        let mediaType = "application/octet-stream";
        let filename = void 0;
        if (uri.endsWith(".pdf")) {
          mediaType = "application/pdf";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".txt")) {
          mediaType = "text/plain";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".docx")) {
          mediaType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          filename = uri.split("/").pop();
        } else if (uri.endsWith(".doc")) {
          mediaType = "application/msword";
          filename = uri.split("/").pop();
        } else if (uri.match(/\.(md|markdown)$/)) {
          mediaType = "text/markdown";
          filename = uri.split("/").pop();
        } else {
          filename = uri.split("/").pop();
        }
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId22(),
          mediaType,
          title,
          filename
        });
      } else if (fileSearchStore) {
        const title = (_d2 = chunk.retrievedContext.title) != null ? _d2 : "Unknown Document";
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId22(),
          mediaType: "application/octet-stream",
          title,
          filename: fileSearchStore.split("/").pop()
        });
      }
    }
  }
  return sources.length > 0 ? sources : void 0;
}
var getGroundingMetadataSchema = () => import_v421.z.object({
  webSearchQueries: import_v421.z.array(import_v421.z.string()).nullish(),
  retrievalQueries: import_v421.z.array(import_v421.z.string()).nullish(),
  searchEntryPoint: import_v421.z.object({ renderedContent: import_v421.z.string() }).nullish(),
  groundingChunks: import_v421.z.array(
    import_v421.z.object({
      web: import_v421.z.object({ uri: import_v421.z.string(), title: import_v421.z.string().nullish() }).nullish(),
      retrievedContext: import_v421.z.object({
        uri: import_v421.z.string().nullish(),
        title: import_v421.z.string().nullish(),
        text: import_v421.z.string().nullish(),
        fileSearchStore: import_v421.z.string().nullish()
      }).nullish()
    })
  ).nullish(),
  groundingSupports: import_v421.z.array(
    import_v421.z.object({
      segment: import_v421.z.object({
        startIndex: import_v421.z.number().nullish(),
        endIndex: import_v421.z.number().nullish(),
        text: import_v421.z.string().nullish()
      }),
      segment_text: import_v421.z.string().nullish(),
      groundingChunkIndices: import_v421.z.array(import_v421.z.number()).nullish(),
      supportChunkIndices: import_v421.z.array(import_v421.z.number()).nullish(),
      confidenceScores: import_v421.z.array(import_v421.z.number()).nullish(),
      confidenceScore: import_v421.z.array(import_v421.z.number()).nullish()
    })
  ).nullish(),
  retrievalMetadata: import_v421.z.union([
    import_v421.z.object({
      webDynamicRetrievalScore: import_v421.z.number()
    }),
    import_v421.z.object({})
  ]).nullish()
});
var getContentSchema = () => import_v421.z.object({
  parts: import_v421.z.array(
    import_v421.z.union([
      // note: order matters since text can be fully empty
      import_v421.z.object({
        functionCall: import_v421.z.object({
          name: import_v421.z.string(),
          args: import_v421.z.unknown()
        }),
        thoughtSignature: import_v421.z.string().nullish()
      }),
      import_v421.z.object({
        inlineData: import_v421.z.object({
          mimeType: import_v421.z.string(),
          data: import_v421.z.string()
        })
      }),
      import_v421.z.object({
        executableCode: import_v421.z.object({
          language: import_v421.z.string(),
          code: import_v421.z.string()
        }).nullish(),
        codeExecutionResult: import_v421.z.object({
          outcome: import_v421.z.string(),
          output: import_v421.z.string()
        }).nullish(),
        text: import_v421.z.string().nullish(),
        thought: import_v421.z.boolean().nullish(),
        thoughtSignature: import_v421.z.string().nullish()
      })
    ])
  ).nullish()
});
var getSafetyRatingSchema = () => import_v421.z.object({
  category: import_v421.z.string().nullish(),
  probability: import_v421.z.string().nullish(),
  probabilityScore: import_v421.z.number().nullish(),
  severity: import_v421.z.string().nullish(),
  severityScore: import_v421.z.number().nullish(),
  blocked: import_v421.z.boolean().nullish()
});
var usageSchema = import_v421.z.object({
  cachedContentTokenCount: import_v421.z.number().nullish(),
  thoughtsTokenCount: import_v421.z.number().nullish(),
  promptTokenCount: import_v421.z.number().nullish(),
  candidatesTokenCount: import_v421.z.number().nullish(),
  totalTokenCount: import_v421.z.number().nullish(),
  // https://cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1/GenerateContentResponse#TrafficType
  trafficType: import_v421.z.string().nullish()
});
var getUrlContextMetadataSchema = () => import_v421.z.object({
  urlMetadata: import_v421.z.array(
    import_v421.z.object({
      retrievedUrl: import_v421.z.string(),
      urlRetrievalStatus: import_v421.z.string()
    })
  )
});
var responseSchema = lazySchema2(
  () => zodSchema2(
    import_v421.z.object({
      candidates: import_v421.z.array(
        import_v421.z.object({
          content: getContentSchema().nullish().or(import_v421.z.object({}).strict()),
          finishReason: import_v421.z.string().nullish(),
          safetyRatings: import_v421.z.array(getSafetyRatingSchema()).nullish(),
          groundingMetadata: getGroundingMetadataSchema().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })
      ),
      usageMetadata: usageSchema.nullish(),
      promptFeedback: import_v421.z.object({
        blockReason: import_v421.z.string().nullish(),
        safetyRatings: import_v421.z.array(getSafetyRatingSchema()).nullish()
      }).nullish()
    })
  )
);
var chunkSchema = lazySchema2(
  () => zodSchema2(
    import_v421.z.object({
      candidates: import_v421.z.array(
        import_v421.z.object({
          content: getContentSchema().nullish(),
          finishReason: import_v421.z.string().nullish(),
          safetyRatings: import_v421.z.array(getSafetyRatingSchema()).nullish(),
          groundingMetadata: getGroundingMetadataSchema().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })
      ).nullish(),
      usageMetadata: usageSchema.nullish(),
      promptFeedback: import_v421.z.object({
        blockReason: import_v421.z.string().nullish(),
        safetyRatings: import_v421.z.array(getSafetyRatingSchema()).nullish()
      }).nullish()
    })
  )
);
var codeExecution = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "google.code_execution",
  name: "code_execution",
  inputSchema: import_v424.z.object({
    language: import_v424.z.string().describe("The programming language of the code."),
    code: import_v424.z.string().describe("The code to be executed.")
  }),
  outputSchema: import_v424.z.object({
    outcome: import_v424.z.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
    output: import_v424.z.string().describe("The output from the code execution.")
  })
});
var fileSearchArgsBaseSchema = import_v425.z.object({
  /** The names of the file_search_stores to retrieve from.
   *  Example: `fileSearchStores/my-file-search-store-123`
   */
  fileSearchStoreNames: import_v425.z.array(import_v425.z.string()).describe(
    "The names of the file_search_stores to retrieve from. Example: `fileSearchStores/my-file-search-store-123`"
  ),
  /** The number of file search retrieval chunks to retrieve. */
  topK: import_v425.z.number().int().positive().describe("The number of file search retrieval chunks to retrieve.").optional(),
  /** Metadata filter to apply to the file search retrieval documents.
   *  See https://google.aip.dev/160 for the syntax of the filter expression.
   */
  metadataFilter: import_v425.z.string().describe(
    "Metadata filter to apply to the file search retrieval documents. See https://google.aip.dev/160 for the syntax of the filter expression."
  ).optional()
}).passthrough();
var fileSearchArgsSchema2 = lazySchema2(
  () => zodSchema2(fileSearchArgsBaseSchema)
);
var fileSearch2 = createProviderDefinedToolFactory2({
  id: "google.file_search",
  name: "file_search",
  inputSchema: fileSearchArgsSchema2
});
var googleSearch = createProviderDefinedToolFactory2({
  id: "google.google_search",
  name: "google_search",
  inputSchema: lazySchema2(
    () => zodSchema2(
      import_v426.z.object({
        mode: import_v426.z.enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
        dynamicThreshold: import_v426.z.number().default(1)
      })
    )
  )
});
var urlContext = createProviderDefinedToolFactory2({
  id: "google.url_context",
  name: "url_context",
  inputSchema: lazySchema2(() => zodSchema2(import_v427.z.object({})))
});
var vertexRagStore = createProviderDefinedToolFactory2({
  id: "google.vertex_rag_store",
  name: "vertex_rag_store",
  inputSchema: import_v428.z.object({
    ragCorpus: import_v428.z.string(),
    topK: import_v428.z.number().optional()
  })
});
var googleTools = {
  /**
   * Creates a Google search tool that gives Google direct access to real-time web content.
   * Must have name "google_search".
   */
  googleSearch,
  /**
   * Creates a URL context tool that gives Google direct access to real-time web content.
   * Must have name "url_context".
   */
  urlContext,
  /**
   * Enables Retrieval Augmented Generation (RAG) via the Gemini File Search tool.
   * Must have name "file_search".
   *
   * @param fileSearchStoreNames - Fully-qualified File Search store resource names.
   * @param metadataFilter - Optional filter expression to restrict the files that can be retrieved.
   * @param topK - Optional result limit for the number of chunks returned from File Search.
   *
   * @see https://ai.google.dev/gemini-api/docs/file-search
   */
  fileSearch: fileSearch2,
  /**
   * A tool that enables the model to generate and run Python code.
   * Must have name "code_execution".
   *
   * @note Ensure the selected model supports Code Execution.
   * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
   *
   * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
   * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
   */
  codeExecution,
  /**
   * Creates a Vertex RAG Store tool that enables the model to perform RAG searches against a Vertex RAG Store.
   * Must have name "vertex_rag_store".
   */
  vertexRagStore
};

// ../../node_modules/.pnpm/@ai-sdk+google-vertex@3.0.85_zod@4.2.1/node_modules/@ai-sdk/google-vertex/dist/index.mjs
var import_provider33 = require("@ai-sdk/provider");
var import_v429 = require("zod/v4");
var import_v430 = require("zod/v4");
var import_v431 = require("zod/v4");
var import_v432 = require("zod/v4");
var authInstance = null;
var authOptions = null;
function getAuth(options) {
  if (!authInstance || options !== authOptions) {
    authInstance = new import_google_auth_library.GoogleAuth(__spreadValues({
      scopes: ["https://www.googleapis.com/auth/cloud-platform"]
    }, options));
    authOptions = options;
  }
  return authInstance;
}
function generateAuthToken(options) {
  return __async(this, null, function* () {
    const auth = getAuth(options || {});
    const client = yield auth.getClient();
    const token = yield client.getAccessToken();
    return (token == null ? void 0 : token.token) || null;
  });
}
var VERSION4 = true ? "3.0.85" : "0.0.0-test";
var googleVertexErrorDataSchema = import_v430.z.object({
  error: import_v430.z.object({
    code: import_v430.z.number().nullable(),
    message: import_v430.z.string(),
    status: import_v430.z.string()
  })
});
var googleVertexFailedResponseHandler = createJsonErrorResponseHandler2(
  {
    errorSchema: googleVertexErrorDataSchema,
    errorToMessage: (data) => data.error.message
  }
);
var googleVertexEmbeddingProviderOptions = import_v431.z.object({
  /**
   * Optional. Optional reduced dimension for the output embedding.
   * If set, excessive values in the output embedding are truncated from the end.
   */
  outputDimensionality: import_v431.z.number().optional(),
  /**
   * Optional. Specifies the task type for generating embeddings.
   * Supported task types:
   * - SEMANTIC_SIMILARITY: Optimized for text similarity.
   * - CLASSIFICATION: Optimized for text classification.
   * - CLUSTERING: Optimized for clustering texts based on similarity.
   * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
   * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
   * - QUESTION_ANSWERING: Optimized for answering questions.
   * - FACT_VERIFICATION: Optimized for verifying factual information.
   * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
   */
  taskType: import_v431.z.enum([
    "SEMANTIC_SIMILARITY",
    "CLASSIFICATION",
    "CLUSTERING",
    "RETRIEVAL_DOCUMENT",
    "RETRIEVAL_QUERY",
    "QUESTION_ANSWERING",
    "FACT_VERIFICATION",
    "CODE_RETRIEVAL_QUERY"
  ]).optional(),
  /**
   * Optional. The title of the document being embedded.
   * Only valid when task_type is set to 'RETRIEVAL_DOCUMENT'.
   * Helps the model produce better embeddings by providing additional context.
   */
  title: import_v431.z.string().optional(),
  /**
   * Optional. When set to true, input text will be truncated. When set to false,
   * an error is returned if the input text is longer than the maximum length supported by the model. Defaults to true.
   */
  autoTruncate: import_v431.z.boolean().optional()
});
var GoogleVertexEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a4;
      const googleOptions = (_a4 = yield parseProviderOptions2({
        provider: "google",
        providerOptions,
        schema: googleVertexEmbeddingProviderOptions
      })) != null ? _a4 : {};
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider33.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const mergedHeaders = combineHeaders2(
        yield resolve2(this.config.headers),
        headers
      );
      const url = `${this.config.baseURL}/models/${this.modelId}:predict`;
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi2({
        url,
        headers: mergedHeaders,
        body: {
          instances: values.map((value) => ({
            content: value,
            task_type: googleOptions.taskType,
            title: googleOptions.title
          })),
          parameters: {
            outputDimensionality: googleOptions.outputDimensionality,
            autoTruncate: googleOptions.autoTruncate
          }
        },
        failedResponseHandler: googleVertexFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler2(
          googleVertexTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.predictions.map(
          (prediction) => prediction.embeddings.values
        ),
        usage: {
          tokens: response.predictions.reduce(
            (tokenCount, prediction) => tokenCount + prediction.embeddings.statistics.token_count,
            0
          )
        },
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var googleVertexTextEmbeddingResponseSchema = import_v429.z.object({
  predictions: import_v429.z.array(
    import_v429.z.object({
      embeddings: import_v429.z.object({
        values: import_v429.z.array(import_v429.z.number()),
        statistics: import_v429.z.object({
          token_count: import_v429.z.number()
        })
      })
    })
  )
});
var GoogleVertexImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 4;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(_0) {
    return __async(this, arguments, function* ({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g;
      const warnings = [];
      if (size != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "size",
          details: "This model does not support the `size` option. Use `aspectRatio` instead."
        });
      }
      const vertexImageOptions = yield parseProviderOptions2({
        provider: "vertex",
        providerOptions,
        schema: vertexImageProviderOptionsSchema
      });
      const body = {
        instances: [{ prompt }],
        parameters: __spreadValues(__spreadValues(__spreadValues({
          sampleCount: n
        }, aspectRatio != null ? { aspectRatio } : {}), seed != null ? { seed } : {}), vertexImageOptions != null ? vertexImageOptions : {})
      };
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = yield postJsonToApi2({
        url: `${this.config.baseURL}/models/${this.modelId}:predict`,
        headers: combineHeaders2(yield resolve2(this.config.headers), headers),
        body,
        failedResponseHandler: googleVertexFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler2(
          vertexImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: (_e = (_d2 = response.predictions) == null ? void 0 : _d2.map(
          ({ bytesBase64Encoded }) => bytesBase64Encoded
        )) != null ? _e : [],
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        },
        providerMetadata: {
          vertex: {
            images: (_g = (_f = response.predictions) == null ? void 0 : _f.map((prediction) => {
              const {
                // normalize revised prompt property
                prompt: revisedPrompt
              } = prediction;
              return __spreadValues({}, revisedPrompt != null && { revisedPrompt });
            })) != null ? _g : []
          }
        }
      };
    });
  }
};
var vertexImageResponseSchema = import_v432.z.object({
  predictions: import_v432.z.array(
    import_v432.z.object({
      bytesBase64Encoded: import_v432.z.string(),
      mimeType: import_v432.z.string(),
      prompt: import_v432.z.string().nullish()
    })
  ).nullish()
});
var vertexImageProviderOptionsSchema = import_v432.z.object({
  negativePrompt: import_v432.z.string().nullish(),
  personGeneration: import_v432.z.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
  safetySetting: import_v432.z.enum([
    "block_low_and_above",
    "block_medium_and_above",
    "block_only_high",
    "block_none"
  ]).nullish(),
  addWatermark: import_v432.z.boolean().nullish(),
  storageUri: import_v432.z.string().nullish()
});
var googleVertexTools = {
  googleSearch: googleTools.googleSearch,
  urlContext: googleTools.urlContext,
  fileSearch: googleTools.fileSearch,
  codeExecution: googleTools.codeExecution,
  vertexRagStore: googleTools.vertexRagStore
};
function createVertex(options = {}) {
  const loadVertexProject = () => loadSetting2({
    settingValue: options.project,
    settingName: "project",
    environmentVariableName: "GOOGLE_VERTEX_PROJECT",
    description: "Google Vertex project"
  });
  const loadVertexLocation = () => loadSetting2({
    settingValue: options.location,
    settingName: "location",
    environmentVariableName: "GOOGLE_VERTEX_LOCATION",
    description: "Google Vertex location"
  });
  const loadBaseURL = () => {
    var _a4;
    const region = loadVertexLocation();
    const project = loadVertexProject();
    const baseHost = `${region === "global" ? "" : region + "-"}aiplatform.googleapis.com`;
    return (_a4 = withoutTrailingSlash2(options.baseURL)) != null ? _a4 : `https://${baseHost}/v1beta1/projects/${project}/locations/${region}/publishers/google`;
  };
  const createConfig = (name) => {
    const getHeaders = () => __async(null, null, function* () {
      var _a4;
      const originalHeaders = yield resolve2((_a4 = options.headers) != null ? _a4 : {});
      return withUserAgentSuffix2(
        originalHeaders,
        `ai-sdk/google-vertex/${VERSION4}`
      );
    });
    return {
      provider: `google.vertex.${name}`,
      headers: getHeaders,
      fetch: options.fetch,
      baseURL: loadBaseURL()
    };
  };
  const createChatModel = (modelId) => {
    var _a4;
    return new GoogleGenerativeAILanguageModel(modelId, __spreadProps(__spreadValues({}, createConfig("chat")), {
      generateId: (_a4 = options.generateId) != null ? _a4 : generateId2,
      supportedUrls: () => ({
        "*": [
          // HTTP URLs:
          /^https?:\/\/.*$/,
          // Google Cloud Storage URLs:
          /^gs:\/\/.*$/
        ]
      })
    }));
  };
  const createEmbeddingModel = (modelId) => new GoogleVertexEmbeddingModel(modelId, createConfig("embedding"));
  const createImageModel = (modelId) => new GoogleVertexImageModel(modelId, createConfig("image"));
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Vertex AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = googleVertexTools;
  return provider;
}
function createVertex2(options = {}) {
  return createVertex(__spreadProps(__spreadValues({}, options), {
    headers: () => __async(null, null, function* () {
      return __spreadValues({
        Authorization: `Bearer ${yield generateAuthToken(
          options.googleAuthOptions
        )}`
      }, yield resolve2(options.headers));
    })
  }));
}
var vertex = createVertex2();

// ../../node_modules/.pnpm/@ai-sdk+anthropic@2.0.53_zod@4.2.1/node_modules/@ai-sdk/anthropic/dist/index.mjs
var import_provider34 = require("@ai-sdk/provider");
var import_provider35 = require("@ai-sdk/provider");
var import_v433 = require("zod/v4");
var import_v434 = require("zod/v4");
var import_v435 = require("zod/v4");
var import_provider36 = require("@ai-sdk/provider");
var import_v436 = require("zod/v4");
var import_v437 = require("zod/v4");
var import_v438 = require("zod/v4");
var import_provider37 = require("@ai-sdk/provider");
var import_v439 = require("zod/v4");
var import_v440 = require("zod/v4");
var import_v441 = require("zod/v4");
var import_v442 = require("zod/v4");
var import_v443 = require("zod/v4");
var import_v444 = require("zod/v4");
var import_v445 = require("zod/v4");
var import_v446 = require("zod/v4");
var import_v447 = require("zod/v4");
var import_v448 = require("zod/v4");
var VERSION5 = true ? "2.0.53" : "0.0.0-test";
var anthropicErrorDataSchema = lazySchema2(
  () => zodSchema2(
    import_v433.z.object({
      type: import_v433.z.literal("error"),
      error: import_v433.z.object({
        type: import_v433.z.string(),
        message: import_v433.z.string()
      })
    })
  )
);
var anthropicFailedResponseHandler = createJsonErrorResponseHandler2({
  errorSchema: anthropicErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
var anthropicMessagesResponseSchema = lazySchema2(
  () => zodSchema2(
    import_v434.z.object({
      type: import_v434.z.literal("message"),
      id: import_v434.z.string().nullish(),
      model: import_v434.z.string().nullish(),
      content: import_v434.z.array(
        import_v434.z.discriminatedUnion("type", [
          import_v434.z.object({
            type: import_v434.z.literal("text"),
            text: import_v434.z.string(),
            citations: import_v434.z.array(
              import_v434.z.discriminatedUnion("type", [
                import_v434.z.object({
                  type: import_v434.z.literal("web_search_result_location"),
                  cited_text: import_v434.z.string(),
                  url: import_v434.z.string(),
                  title: import_v434.z.string(),
                  encrypted_index: import_v434.z.string()
                }),
                import_v434.z.object({
                  type: import_v434.z.literal("page_location"),
                  cited_text: import_v434.z.string(),
                  document_index: import_v434.z.number(),
                  document_title: import_v434.z.string().nullable(),
                  start_page_number: import_v434.z.number(),
                  end_page_number: import_v434.z.number()
                }),
                import_v434.z.object({
                  type: import_v434.z.literal("char_location"),
                  cited_text: import_v434.z.string(),
                  document_index: import_v434.z.number(),
                  document_title: import_v434.z.string().nullable(),
                  start_char_index: import_v434.z.number(),
                  end_char_index: import_v434.z.number()
                })
              ])
            ).optional()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("thinking"),
            thinking: import_v434.z.string(),
            signature: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("redacted_thinking"),
            data: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("tool_use"),
            id: import_v434.z.string(),
            name: import_v434.z.string(),
            input: import_v434.z.unknown()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("server_tool_use"),
            id: import_v434.z.string(),
            name: import_v434.z.string(),
            input: import_v434.z.record(import_v434.z.string(), import_v434.z.unknown()).nullish()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("web_fetch_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.object({
                type: import_v434.z.literal("web_fetch_result"),
                url: import_v434.z.string(),
                retrieved_at: import_v434.z.string(),
                content: import_v434.z.object({
                  type: import_v434.z.literal("document"),
                  title: import_v434.z.string().nullable(),
                  citations: import_v434.z.object({ enabled: import_v434.z.boolean() }).optional(),
                  source: import_v434.z.object({
                    type: import_v434.z.literal("text"),
                    media_type: import_v434.z.string(),
                    data: import_v434.z.string()
                  })
                })
              }),
              import_v434.z.object({
                type: import_v434.z.literal("web_fetch_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          import_v434.z.object({
            type: import_v434.z.literal("web_search_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.array(
                import_v434.z.object({
                  type: import_v434.z.literal("web_search_result"),
                  url: import_v434.z.string(),
                  title: import_v434.z.string(),
                  encrypted_content: import_v434.z.string(),
                  page_age: import_v434.z.string().nullish()
                })
              ),
              import_v434.z.object({
                type: import_v434.z.literal("web_search_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          import_v434.z.object({
            type: import_v434.z.literal("code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.object({
                type: import_v434.z.literal("code_execution_result"),
                stdout: import_v434.z.string(),
                stderr: import_v434.z.string(),
                return_code: import_v434.z.number()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          import_v434.z.object({
            type: import_v434.z.literal("bash_code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.discriminatedUnion("type", [
              import_v434.z.object({
                type: import_v434.z.literal("bash_code_execution_result"),
                content: import_v434.z.array(
                  import_v434.z.object({
                    type: import_v434.z.literal("bash_code_execution_output"),
                    file_id: import_v434.z.string()
                  })
                ),
                stdout: import_v434.z.string(),
                stderr: import_v434.z.string(),
                return_code: import_v434.z.number()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("bash_code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          import_v434.z.object({
            type: import_v434.z.literal("text_editor_code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.discriminatedUnion("type", [
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_view_result"),
                content: import_v434.z.string(),
                file_type: import_v434.z.string(),
                num_lines: import_v434.z.number().nullable(),
                start_line: import_v434.z.number().nullable(),
                total_lines: import_v434.z.number().nullable()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_create_result"),
                is_file_update: import_v434.z.boolean()
              }),
              import_v434.z.object({
                type: import_v434.z.literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: import_v434.z.array(import_v434.z.string()).nullable(),
                new_lines: import_v434.z.number().nullable(),
                new_start: import_v434.z.number().nullable(),
                old_lines: import_v434.z.number().nullable(),
                old_start: import_v434.z.number().nullable()
              })
            ])
          })
        ])
      ),
      stop_reason: import_v434.z.string().nullish(),
      stop_sequence: import_v434.z.string().nullish(),
      usage: import_v434.z.looseObject({
        input_tokens: import_v434.z.number(),
        output_tokens: import_v434.z.number(),
        cache_creation_input_tokens: import_v434.z.number().nullish(),
        cache_read_input_tokens: import_v434.z.number().nullish()
      }),
      container: import_v434.z.object({
        expires_at: import_v434.z.string(),
        id: import_v434.z.string(),
        skills: import_v434.z.array(
          import_v434.z.object({
            type: import_v434.z.union([import_v434.z.literal("anthropic"), import_v434.z.literal("custom")]),
            skill_id: import_v434.z.string(),
            version: import_v434.z.string()
          })
        ).nullish()
      }).nullish()
    })
  )
);
var anthropicMessagesChunkSchema = lazySchema2(
  () => zodSchema2(
    import_v434.z.discriminatedUnion("type", [
      import_v434.z.object({
        type: import_v434.z.literal("message_start"),
        message: import_v434.z.object({
          id: import_v434.z.string().nullish(),
          model: import_v434.z.string().nullish(),
          usage: import_v434.z.looseObject({
            input_tokens: import_v434.z.number(),
            cache_creation_input_tokens: import_v434.z.number().nullish(),
            cache_read_input_tokens: import_v434.z.number().nullish()
          })
        })
      }),
      import_v434.z.object({
        type: import_v434.z.literal("content_block_start"),
        index: import_v434.z.number(),
        content_block: import_v434.z.discriminatedUnion("type", [
          import_v434.z.object({
            type: import_v434.z.literal("text"),
            text: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("thinking"),
            thinking: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("tool_use"),
            id: import_v434.z.string(),
            name: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("redacted_thinking"),
            data: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("server_tool_use"),
            id: import_v434.z.string(),
            name: import_v434.z.string(),
            input: import_v434.z.record(import_v434.z.string(), import_v434.z.unknown()).nullish()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("web_fetch_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.object({
                type: import_v434.z.literal("web_fetch_result"),
                url: import_v434.z.string(),
                retrieved_at: import_v434.z.string(),
                content: import_v434.z.object({
                  type: import_v434.z.literal("document"),
                  title: import_v434.z.string().nullable(),
                  citations: import_v434.z.object({ enabled: import_v434.z.boolean() }).optional(),
                  source: import_v434.z.object({
                    type: import_v434.z.literal("text"),
                    media_type: import_v434.z.string(),
                    data: import_v434.z.string()
                  })
                })
              }),
              import_v434.z.object({
                type: import_v434.z.literal("web_fetch_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          import_v434.z.object({
            type: import_v434.z.literal("web_search_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.array(
                import_v434.z.object({
                  type: import_v434.z.literal("web_search_result"),
                  url: import_v434.z.string(),
                  title: import_v434.z.string(),
                  encrypted_content: import_v434.z.string(),
                  page_age: import_v434.z.string().nullish()
                })
              ),
              import_v434.z.object({
                type: import_v434.z.literal("web_search_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          import_v434.z.object({
            type: import_v434.z.literal("code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.union([
              import_v434.z.object({
                type: import_v434.z.literal("code_execution_result"),
                stdout: import_v434.z.string(),
                stderr: import_v434.z.string(),
                return_code: import_v434.z.number()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          import_v434.z.object({
            type: import_v434.z.literal("bash_code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.discriminatedUnion("type", [
              import_v434.z.object({
                type: import_v434.z.literal("bash_code_execution_result"),
                content: import_v434.z.array(
                  import_v434.z.object({
                    type: import_v434.z.literal("bash_code_execution_output"),
                    file_id: import_v434.z.string()
                  })
                ),
                stdout: import_v434.z.string(),
                stderr: import_v434.z.string(),
                return_code: import_v434.z.number()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("bash_code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          import_v434.z.object({
            type: import_v434.z.literal("text_editor_code_execution_tool_result"),
            tool_use_id: import_v434.z.string(),
            content: import_v434.z.discriminatedUnion("type", [
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_tool_result_error"),
                error_code: import_v434.z.string()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_view_result"),
                content: import_v434.z.string(),
                file_type: import_v434.z.string(),
                num_lines: import_v434.z.number().nullable(),
                start_line: import_v434.z.number().nullable(),
                total_lines: import_v434.z.number().nullable()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("text_editor_code_execution_create_result"),
                is_file_update: import_v434.z.boolean()
              }),
              import_v434.z.object({
                type: import_v434.z.literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: import_v434.z.array(import_v434.z.string()).nullable(),
                new_lines: import_v434.z.number().nullable(),
                new_start: import_v434.z.number().nullable(),
                old_lines: import_v434.z.number().nullable(),
                old_start: import_v434.z.number().nullable()
              })
            ])
          })
        ])
      }),
      import_v434.z.object({
        type: import_v434.z.literal("content_block_delta"),
        index: import_v434.z.number(),
        delta: import_v434.z.discriminatedUnion("type", [
          import_v434.z.object({
            type: import_v434.z.literal("input_json_delta"),
            partial_json: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("text_delta"),
            text: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("thinking_delta"),
            thinking: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("signature_delta"),
            signature: import_v434.z.string()
          }),
          import_v434.z.object({
            type: import_v434.z.literal("citations_delta"),
            citation: import_v434.z.discriminatedUnion("type", [
              import_v434.z.object({
                type: import_v434.z.literal("web_search_result_location"),
                cited_text: import_v434.z.string(),
                url: import_v434.z.string(),
                title: import_v434.z.string(),
                encrypted_index: import_v434.z.string()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("page_location"),
                cited_text: import_v434.z.string(),
                document_index: import_v434.z.number(),
                document_title: import_v434.z.string().nullable(),
                start_page_number: import_v434.z.number(),
                end_page_number: import_v434.z.number()
              }),
              import_v434.z.object({
                type: import_v434.z.literal("char_location"),
                cited_text: import_v434.z.string(),
                document_index: import_v434.z.number(),
                document_title: import_v434.z.string().nullable(),
                start_char_index: import_v434.z.number(),
                end_char_index: import_v434.z.number()
              })
            ])
          })
        ])
      }),
      import_v434.z.object({
        type: import_v434.z.literal("content_block_stop"),
        index: import_v434.z.number()
      }),
      import_v434.z.object({
        type: import_v434.z.literal("error"),
        error: import_v434.z.object({
          type: import_v434.z.string(),
          message: import_v434.z.string()
        })
      }),
      import_v434.z.object({
        type: import_v434.z.literal("message_delta"),
        delta: import_v434.z.object({
          stop_reason: import_v434.z.string().nullish(),
          stop_sequence: import_v434.z.string().nullish(),
          container: import_v434.z.object({
            expires_at: import_v434.z.string(),
            id: import_v434.z.string(),
            skills: import_v434.z.array(
              import_v434.z.object({
                type: import_v434.z.union([
                  import_v434.z.literal("anthropic"),
                  import_v434.z.literal("custom")
                ]),
                skill_id: import_v434.z.string(),
                version: import_v434.z.string()
              })
            ).nullish()
          }).nullish()
        }),
        usage: import_v434.z.looseObject({
          output_tokens: import_v434.z.number(),
          cache_creation_input_tokens: import_v434.z.number().nullish()
        })
      }),
      import_v434.z.object({
        type: import_v434.z.literal("message_stop")
      }),
      import_v434.z.object({
        type: import_v434.z.literal("ping")
      })
    ])
  )
);
var anthropicReasoningMetadataSchema = lazySchema2(
  () => zodSchema2(
    import_v434.z.object({
      signature: import_v434.z.string().optional(),
      redactedData: import_v434.z.string().optional()
    })
  )
);
var anthropicFilePartProviderOptions = import_v435.z.object({
  /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */
  citations: import_v435.z.object({
    /**
     * Enable citations for this document
     */
    enabled: import_v435.z.boolean()
  }).optional(),
  /**
   * Custom title for the document.
   * If not provided, the filename will be used.
   */
  title: import_v435.z.string().optional(),
  /**
   * Context about the document that will be passed to the model
   * but not used towards cited content.
   * Useful for storing document metadata as text or stringified JSON.
   */
  context: import_v435.z.string().optional()
});
var anthropicProviderOptions = import_v435.z.object({
  sendReasoning: import_v435.z.boolean().optional(),
  /**
   * Determines how structured outputs are generated.
   *
   * - `outputFormat`: Use the `output_format` parameter to specify the structured output format.
   * - `jsonTool`: Use a special 'json' tool to specify the structured output format (default).
   * - `auto`: Use 'outputFormat' when supported, otherwise use 'jsonTool'.
   */
  structuredOutputMode: import_v435.z.enum(["outputFormat", "jsonTool", "auto"]).optional(),
  /**
   * Configuration for enabling Claude's extended thinking.
   *
   * When enabled, responses include thinking content blocks showing Claude's thinking process before the final answer.
   * Requires a minimum budget of 1,024 tokens and counts towards the `max_tokens` limit.
   */
  thinking: import_v435.z.object({
    type: import_v435.z.union([import_v435.z.literal("enabled"), import_v435.z.literal("disabled")]),
    budgetTokens: import_v435.z.number().optional()
  }).optional(),
  /**
   * Whether to disable parallel function calling during tool use. Default is false.
   * When set to true, Claude will use at most one tool per response.
   */
  disableParallelToolUse: import_v435.z.boolean().optional(),
  /**
   * Cache control settings for this message.
   * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
   */
  cacheControl: import_v435.z.object({
    type: import_v435.z.literal("ephemeral"),
    ttl: import_v435.z.union([import_v435.z.literal("5m"), import_v435.z.literal("1h")]).optional()
  }).optional(),
  /**
   * Agent Skills configuration. Skills enable Claude to perform specialized tasks
   * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
   * Requires code execution tool to be enabled.
   */
  container: import_v435.z.object({
    id: import_v435.z.string().optional(),
    skills: import_v435.z.array(
      import_v435.z.object({
        type: import_v435.z.union([import_v435.z.literal("anthropic"), import_v435.z.literal("custom")]),
        skillId: import_v435.z.string(),
        version: import_v435.z.string().optional()
      })
    ).optional()
  }).optional(),
  /**
   * @default 'high'
   */
  effort: import_v435.z.enum(["low", "medium", "high"]).optional()
});
var MAX_CACHE_BREAKPOINTS = 4;
function getCacheControl(providerMetadata) {
  var _a4;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a4 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a4 : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
var CacheControlValidator = class {
  constructor() {
    this.breakpointCount = 0;
    this.warnings = [];
  }
  getCacheControl(providerMetadata, context) {
    const cacheControlValue = getCacheControl(providerMetadata);
    if (!cacheControlValue) {
      return void 0;
    }
    if (!context.canCache) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `cache_control cannot be set on ${context.type}. It will be ignored.`
      });
      return void 0;
    }
    this.breakpointCount++;
    if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
      });
      return void 0;
    }
    return cacheControlValue;
  }
  getWarnings() {
    return this.warnings;
  }
};
var textEditor_20250728ArgsSchema = lazySchema2(
  () => zodSchema2(
    import_v436.z.object({
      maxCharacters: import_v436.z.number().optional()
    })
  )
);
var textEditor_20250728InputSchema = lazySchema2(
  () => zodSchema2(
    import_v436.z.object({
      command: import_v436.z.enum(["view", "create", "str_replace", "insert"]),
      path: import_v436.z.string(),
      file_text: import_v436.z.string().optional(),
      insert_line: import_v436.z.number().int().optional(),
      new_str: import_v436.z.string().optional(),
      old_str: import_v436.z.string().optional(),
      view_range: import_v436.z.array(import_v436.z.number().int()).optional()
    })
  )
);
var factory = createProviderDefinedToolFactory2({
  id: "anthropic.text_editor_20250728",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250728InputSchema
});
var textEditor_20250728 = (args = {}) => {
  return factory(args);
};
var webSearch_20250305ArgsSchema = lazySchema2(
  () => zodSchema2(
    import_v437.z.object({
      maxUses: import_v437.z.number().optional(),
      allowedDomains: import_v437.z.array(import_v437.z.string()).optional(),
      blockedDomains: import_v437.z.array(import_v437.z.string()).optional(),
      userLocation: import_v437.z.object({
        type: import_v437.z.literal("approximate"),
        city: import_v437.z.string().optional(),
        region: import_v437.z.string().optional(),
        country: import_v437.z.string().optional(),
        timezone: import_v437.z.string().optional()
      }).optional()
    })
  )
);
var webSearch_20250305OutputSchema = lazySchema2(
  () => zodSchema2(
    import_v437.z.array(
      import_v437.z.object({
        url: import_v437.z.string(),
        title: import_v437.z.string(),
        pageAge: import_v437.z.string().nullable(),
        encryptedContent: import_v437.z.string(),
        type: import_v437.z.literal("web_search_result")
      })
    )
  )
);
var webSearch_20250305InputSchema = lazySchema2(
  () => zodSchema2(
    import_v437.z.object({
      query: import_v437.z.string()
    })
  )
);
var factory2 = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "anthropic.web_search_20250305",
  name: "web_search",
  inputSchema: webSearch_20250305InputSchema,
  outputSchema: webSearch_20250305OutputSchema
});
var webSearch_20250305 = (args = {}) => {
  return factory2(args);
};
var webFetch_20250910ArgsSchema = lazySchema2(
  () => zodSchema2(
    import_v438.z.object({
      maxUses: import_v438.z.number().optional(),
      allowedDomains: import_v438.z.array(import_v438.z.string()).optional(),
      blockedDomains: import_v438.z.array(import_v438.z.string()).optional(),
      citations: import_v438.z.object({ enabled: import_v438.z.boolean() }).optional(),
      maxContentTokens: import_v438.z.number().optional()
    })
  )
);
var webFetch_20250910OutputSchema = lazySchema2(
  () => zodSchema2(
    import_v438.z.object({
      type: import_v438.z.literal("web_fetch_result"),
      url: import_v438.z.string(),
      content: import_v438.z.object({
        type: import_v438.z.literal("document"),
        title: import_v438.z.string(),
        citations: import_v438.z.object({ enabled: import_v438.z.boolean() }).optional(),
        source: import_v438.z.union([
          import_v438.z.object({
            type: import_v438.z.literal("base64"),
            mediaType: import_v438.z.literal("application/pdf"),
            data: import_v438.z.string()
          }),
          import_v438.z.object({
            type: import_v438.z.literal("text"),
            mediaType: import_v438.z.literal("text/plain"),
            data: import_v438.z.string()
          })
        ])
      }),
      retrievedAt: import_v438.z.string().nullable()
    })
  )
);
var webFetch_20250910InputSchema = lazySchema2(
  () => zodSchema2(
    import_v438.z.object({
      url: import_v438.z.string()
    })
  )
);
var factory3 = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "anthropic.web_fetch_20250910",
  name: "web_fetch",
  inputSchema: webFetch_20250910InputSchema,
  outputSchema: webFetch_20250910OutputSchema
});
var webFetch_20250910 = (args = {}) => {
  return factory3(args);
};
function prepareTools2(_0) {
  return __async(this, arguments, function* ({
    tools,
    toolChoice,
    disableParallelToolUse,
    cacheControlValidator
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    const betas = /* @__PURE__ */ new Set();
    const validator3 = cacheControlValidator || new CacheControlValidator();
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    }
    const anthropicTools2 = [];
    for (const tool21 of tools) {
      switch (tool21.type) {
        case "function": {
          const cacheControl = validator3.getCacheControl(tool21.providerOptions, {
            type: "tool definition",
            canCache: true
          });
          anthropicTools2.push({
            name: tool21.name,
            description: tool21.description,
            input_schema: tool21.inputSchema,
            cache_control: cacheControl
          });
          break;
        }
        case "provider-defined": {
          switch (tool21.id) {
            case "anthropic.code_execution_20250522": {
              betas.add("code-execution-2025-05-22");
              anthropicTools2.push({
                type: "code_execution_20250522",
                name: "code_execution",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.code_execution_20250825": {
              betas.add("code-execution-2025-08-25");
              anthropicTools2.push({
                type: "code_execution_20250825",
                name: "code_execution"
              });
              break;
            }
            case "anthropic.computer_20250124": {
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "computer",
                type: "computer_20250124",
                display_width_px: tool21.args.displayWidthPx,
                display_height_px: tool21.args.displayHeightPx,
                display_number: tool21.args.displayNumber,
                cache_control: void 0
              });
              break;
            }
            case "anthropic.computer_20241022": {
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "computer",
                type: "computer_20241022",
                display_width_px: tool21.args.displayWidthPx,
                display_height_px: tool21.args.displayHeightPx,
                display_number: tool21.args.displayNumber,
                cache_control: void 0
              });
              break;
            }
            case "anthropic.text_editor_20250124": {
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "str_replace_editor",
                type: "text_editor_20250124",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.text_editor_20241022": {
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "str_replace_editor",
                type: "text_editor_20241022",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.text_editor_20250429": {
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "str_replace_based_edit_tool",
                type: "text_editor_20250429",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.text_editor_20250728": {
              const args = yield validateTypes2({
                value: tool21.args,
                schema: textEditor_20250728ArgsSchema
              });
              anthropicTools2.push({
                name: "str_replace_based_edit_tool",
                type: "text_editor_20250728",
                max_characters: args.maxCharacters,
                cache_control: void 0
              });
              break;
            }
            case "anthropic.bash_20250124": {
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "bash",
                type: "bash_20250124",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.bash_20241022": {
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "bash",
                type: "bash_20241022",
                cache_control: void 0
              });
              break;
            }
            case "anthropic.memory_20250818": {
              betas.add("context-management-2025-06-27");
              anthropicTools2.push({
                name: "memory",
                type: "memory_20250818"
              });
              break;
            }
            case "anthropic.web_fetch_20250910": {
              betas.add("web-fetch-2025-09-10");
              const args = yield validateTypes2({
                value: tool21.args,
                schema: webFetch_20250910ArgsSchema
              });
              anthropicTools2.push({
                type: "web_fetch_20250910",
                name: "web_fetch",
                max_uses: args.maxUses,
                allowed_domains: args.allowedDomains,
                blocked_domains: args.blockedDomains,
                citations: args.citations,
                max_content_tokens: args.maxContentTokens,
                cache_control: void 0
              });
              break;
            }
            case "anthropic.web_search_20250305": {
              const args = yield validateTypes2({
                value: tool21.args,
                schema: webSearch_20250305ArgsSchema
              });
              anthropicTools2.push({
                type: "web_search_20250305",
                name: "web_search",
                max_uses: args.maxUses,
                allowed_domains: args.allowedDomains,
                blocked_domains: args.blockedDomains,
                user_location: args.userLocation,
                cache_control: void 0
              });
              break;
            }
            default: {
              toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
              break;
            }
          }
          break;
        }
        default: {
          toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
          break;
        }
      }
    }
    if (toolChoice == null) {
      return {
        tools: anthropicTools2,
        toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
        toolWarnings,
        betas
      };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "auto",
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      case "required":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "any",
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      case "none":
        return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
      case "tool":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "tool",
            name: toolChoice.toolName,
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      default: {
        const _exhaustiveCheck = type;
        throw new import_provider36.UnsupportedFunctionalityError({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  });
}
var codeExecution_20250522OutputSchema = lazySchema2(
  () => zodSchema2(
    import_v439.z.object({
      type: import_v439.z.literal("code_execution_result"),
      stdout: import_v439.z.string(),
      stderr: import_v439.z.string(),
      return_code: import_v439.z.number()
    })
  )
);
var codeExecution_20250522InputSchema = lazySchema2(
  () => zodSchema2(
    import_v439.z.object({
      code: import_v439.z.string()
    })
  )
);
var factory4 = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "anthropic.code_execution_20250522",
  name: "code_execution",
  inputSchema: codeExecution_20250522InputSchema,
  outputSchema: codeExecution_20250522OutputSchema
});
var codeExecution_20250522 = (args = {}) => {
  return factory4(args);
};
var codeExecution_20250825OutputSchema = lazySchema2(
  () => zodSchema2(
    import_v440.z.discriminatedUnion("type", [
      import_v440.z.object({
        type: import_v440.z.literal("bash_code_execution_result"),
        content: import_v440.z.array(
          import_v440.z.object({
            type: import_v440.z.literal("bash_code_execution_output"),
            file_id: import_v440.z.string()
          })
        ),
        stdout: import_v440.z.string(),
        stderr: import_v440.z.string(),
        return_code: import_v440.z.number()
      }),
      import_v440.z.object({
        type: import_v440.z.literal("bash_code_execution_tool_result_error"),
        error_code: import_v440.z.string()
      }),
      import_v440.z.object({
        type: import_v440.z.literal("text_editor_code_execution_tool_result_error"),
        error_code: import_v440.z.string()
      }),
      import_v440.z.object({
        type: import_v440.z.literal("text_editor_code_execution_view_result"),
        content: import_v440.z.string(),
        file_type: import_v440.z.string(),
        num_lines: import_v440.z.number().nullable(),
        start_line: import_v440.z.number().nullable(),
        total_lines: import_v440.z.number().nullable()
      }),
      import_v440.z.object({
        type: import_v440.z.literal("text_editor_code_execution_create_result"),
        is_file_update: import_v440.z.boolean()
      }),
      import_v440.z.object({
        type: import_v440.z.literal("text_editor_code_execution_str_replace_result"),
        lines: import_v440.z.array(import_v440.z.string()).nullable(),
        new_lines: import_v440.z.number().nullable(),
        new_start: import_v440.z.number().nullable(),
        old_lines: import_v440.z.number().nullable(),
        old_start: import_v440.z.number().nullable()
      })
    ])
  )
);
var codeExecution_20250825InputSchema = lazySchema2(
  () => zodSchema2(
    import_v440.z.discriminatedUnion("type", [
      import_v440.z.object({
        type: import_v440.z.literal("bash_code_execution"),
        command: import_v440.z.string()
      }),
      import_v440.z.discriminatedUnion("command", [
        import_v440.z.object({
          type: import_v440.z.literal("text_editor_code_execution"),
          command: import_v440.z.literal("view"),
          path: import_v440.z.string()
        }),
        import_v440.z.object({
          type: import_v440.z.literal("text_editor_code_execution"),
          command: import_v440.z.literal("create"),
          path: import_v440.z.string(),
          file_text: import_v440.z.string().nullish()
        }),
        import_v440.z.object({
          type: import_v440.z.literal("text_editor_code_execution"),
          command: import_v440.z.literal("str_replace"),
          path: import_v440.z.string(),
          old_str: import_v440.z.string(),
          new_str: import_v440.z.string()
        })
      ])
    ])
  )
);
var factory5 = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "anthropic.code_execution_20250825",
  name: "code_execution",
  inputSchema: codeExecution_20250825InputSchema,
  outputSchema: codeExecution_20250825OutputSchema
});
var codeExecution_20250825 = (args = {}) => {
  return factory5(args);
};
function convertToString(data) {
  if (typeof data === "string") {
    return Buffer.from(data, "base64").toString("utf-8");
  }
  if (data instanceof Uint8Array) {
    return new TextDecoder().decode(data);
  }
  if (data instanceof URL) {
    throw new import_provider37.UnsupportedFunctionalityError({
      functionality: "URL-based text documents are not supported for citations"
    });
  }
  throw new import_provider37.UnsupportedFunctionalityError({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
function convertToAnthropicMessagesPrompt(_0) {
  return __async(this, arguments, function* ({
    prompt,
    sendReasoning,
    warnings,
    cacheControlValidator
  }) {
    var _a4, _b, _c, _d2, _e;
    const betas = /* @__PURE__ */ new Set();
    const blocks = groupIntoBlocks(prompt);
    const validator3 = cacheControlValidator || new CacheControlValidator();
    let system = void 0;
    const messages = [];
    function shouldEnableCitations(providerMetadata) {
      return __async(this, null, function* () {
        var _a22, _b2;
        const anthropicOptions = yield parseProviderOptions2({
          provider: "anthropic",
          providerOptions: providerMetadata,
          schema: anthropicFilePartProviderOptions
        });
        return (_b2 = (_a22 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a22.enabled) != null ? _b2 : false;
      });
    }
    function getDocumentMetadata(providerMetadata) {
      return __async(this, null, function* () {
        const anthropicOptions = yield parseProviderOptions2({
          provider: "anthropic",
          providerOptions: providerMetadata,
          schema: anthropicFilePartProviderOptions
        });
        return {
          title: anthropicOptions == null ? void 0 : anthropicOptions.title,
          context: anthropicOptions == null ? void 0 : anthropicOptions.context
        };
      });
    }
    for (let i2 = 0; i2 < blocks.length; i2++) {
      const block = blocks[i2];
      const isLastBlock = i2 === blocks.length - 1;
      const type = block.type;
      switch (type) {
        case "system": {
          if (system != null) {
            throw new import_provider37.UnsupportedFunctionalityError({
              functionality: "Multiple system messages that are separated by user/assistant messages"
            });
          }
          system = block.messages.map(({ content, providerOptions }) => ({
            type: "text",
            text: content,
            cache_control: validator3.getCacheControl(providerOptions, {
              type: "system message",
              canCache: true
            })
          }));
          break;
        }
        case "user": {
          const anthropicContent = [];
          for (const message of block.messages) {
            const { role, content } = message;
            switch (role) {
              case "user": {
                for (let j = 0; j < content.length; j++) {
                  const part = content[j];
                  const isLastPart = j === content.length - 1;
                  const cacheControl = (_a4 = validator3.getCacheControl(part.providerOptions, {
                    type: "user message part",
                    canCache: true
                  })) != null ? _a4 : isLastPart ? validator3.getCacheControl(message.providerOptions, {
                    type: "user message",
                    canCache: true
                  }) : void 0;
                  switch (part.type) {
                    case "text": {
                      anthropicContent.push({
                        type: "text",
                        text: part.text,
                        cache_control: cacheControl
                      });
                      break;
                    }
                    case "file": {
                      if (part.mediaType.startsWith("image/")) {
                        anthropicContent.push({
                          type: "image",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "base64",
                            media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                            data: convertToBase642(part.data)
                          },
                          cache_control: cacheControl
                        });
                      } else if (part.mediaType === "application/pdf") {
                        betas.add("pdfs-2024-09-25");
                        const enableCitations = yield shouldEnableCitations(
                          part.providerOptions
                        );
                        const metadata = yield getDocumentMetadata(
                          part.providerOptions
                        );
                        anthropicContent.push(__spreadProps(__spreadValues(__spreadValues({
                          type: "document",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "base64",
                            media_type: "application/pdf",
                            data: convertToBase642(part.data)
                          },
                          title: (_b = metadata.title) != null ? _b : part.filename
                        }, metadata.context && { context: metadata.context }), enableCitations && {
                          citations: { enabled: true }
                        }), {
                          cache_control: cacheControl
                        }));
                      } else if (part.mediaType === "text/plain") {
                        const enableCitations = yield shouldEnableCitations(
                          part.providerOptions
                        );
                        const metadata = yield getDocumentMetadata(
                          part.providerOptions
                        );
                        anthropicContent.push(__spreadProps(__spreadValues(__spreadValues({
                          type: "document",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "text",
                            media_type: "text/plain",
                            data: convertToString(part.data)
                          },
                          title: (_c = metadata.title) != null ? _c : part.filename
                        }, metadata.context && { context: metadata.context }), enableCitations && {
                          citations: { enabled: true }
                        }), {
                          cache_control: cacheControl
                        }));
                      } else {
                        throw new import_provider37.UnsupportedFunctionalityError({
                          functionality: `media type: ${part.mediaType}`
                        });
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case "tool": {
                for (let i22 = 0; i22 < content.length; i22++) {
                  const part = content[i22];
                  const isLastPart = i22 === content.length - 1;
                  const cacheControl = (_d2 = validator3.getCacheControl(part.providerOptions, {
                    type: "tool result part",
                    canCache: true
                  })) != null ? _d2 : isLastPart ? validator3.getCacheControl(message.providerOptions, {
                    type: "tool result message",
                    canCache: true
                  }) : void 0;
                  const output = part.output;
                  let contentValue;
                  switch (output.type) {
                    case "content":
                      contentValue = output.value.map((contentPart) => {
                        switch (contentPart.type) {
                          case "text":
                            return {
                              type: "text",
                              text: contentPart.text
                            };
                          case "media": {
                            if (contentPart.mediaType.startsWith("image/")) {
                              return {
                                type: "image",
                                source: {
                                  type: "base64",
                                  media_type: contentPart.mediaType,
                                  data: contentPart.data
                                }
                              };
                            }
                            if (contentPart.mediaType === "application/pdf") {
                              betas.add("pdfs-2024-09-25");
                              return {
                                type: "document",
                                source: {
                                  type: "base64",
                                  media_type: contentPart.mediaType,
                                  data: contentPart.data
                                }
                              };
                            }
                            throw new import_provider37.UnsupportedFunctionalityError({
                              functionality: `media type: ${contentPart.mediaType}`
                            });
                          }
                        }
                      });
                      break;
                    case "text":
                    case "error-text":
                      contentValue = output.value;
                      break;
                    case "json":
                    case "error-json":
                    default:
                      contentValue = JSON.stringify(output.value);
                      break;
                  }
                  anthropicContent.push({
                    type: "tool_result",
                    tool_use_id: part.toolCallId,
                    content: contentValue,
                    is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                    cache_control: cacheControl
                  });
                }
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          messages.push({ role: "user", content: anthropicContent });
          break;
        }
        case "assistant": {
          const anthropicContent = [];
          for (let j = 0; j < block.messages.length; j++) {
            const message = block.messages[j];
            const isLastMessage = j === block.messages.length - 1;
            const { content } = message;
            for (let k = 0; k < content.length; k++) {
              const part = content[k];
              const isLastContentPart = k === content.length - 1;
              const cacheControl = (_e = validator3.getCacheControl(part.providerOptions, {
                type: "assistant message part",
                canCache: true
              })) != null ? _e : isLastContentPart ? validator3.getCacheControl(message.providerOptions, {
                type: "assistant message",
                canCache: true
              }) : void 0;
              switch (part.type) {
                case "text": {
                  anthropicContent.push({
                    type: "text",
                    text: (
                      // trim the last text part if it's the last message in the block
                      // because Anthropic does not allow trailing whitespace
                      // in pre-filled assistant responses
                      isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                    ),
                    cache_control: cacheControl
                  });
                  break;
                }
                case "reasoning": {
                  if (sendReasoning) {
                    const reasoningMetadata = yield parseProviderOptions2({
                      provider: "anthropic",
                      providerOptions: part.providerOptions,
                      schema: anthropicReasoningMetadataSchema
                    });
                    if (reasoningMetadata != null) {
                      if (reasoningMetadata.signature != null) {
                        validator3.getCacheControl(part.providerOptions, {
                          type: "thinking block",
                          canCache: false
                        });
                        anthropicContent.push({
                          type: "thinking",
                          thinking: part.text,
                          signature: reasoningMetadata.signature
                        });
                      } else if (reasoningMetadata.redactedData != null) {
                        validator3.getCacheControl(part.providerOptions, {
                          type: "redacted thinking block",
                          canCache: false
                        });
                        anthropicContent.push({
                          type: "redacted_thinking",
                          data: reasoningMetadata.redactedData
                        });
                      } else {
                        warnings.push({
                          type: "other",
                          message: "unsupported reasoning metadata"
                        });
                      }
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "sending reasoning content is disabled for this model"
                    });
                  }
                  break;
                }
                case "tool-call": {
                  if (part.providerExecuted) {
                    if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: part.input.type,
                        // map back to subtool name
                        input: part.input,
                        cache_control: cacheControl
                      });
                    } else if (part.toolName === "code_execution" || // code execution 20250522
                    part.toolName === "web_fetch" || part.toolName === "web_search") {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: part.toolName,
                        input: part.input,
                        cache_control: cacheControl
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool call for tool ${part.toolName} is not supported`
                      });
                    }
                    break;
                  }
                  anthropicContent.push({
                    type: "tool_use",
                    id: part.toolCallId,
                    name: part.toolName,
                    input: part.input,
                    cache_control: cacheControl
                  });
                  break;
                }
                case "tool-result": {
                  if (part.toolName === "code_execution") {
                    const output = part.output;
                    if (output.type !== "json") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                      });
                      break;
                    }
                    if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                      });
                      break;
                    }
                    if (output.value.type === "code_execution_result") {
                      const codeExecutionOutput = yield validateTypes2({
                        value: output.value,
                        schema: codeExecution_20250522OutputSchema
                      });
                      anthropicContent.push({
                        type: "code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        content: {
                          type: codeExecutionOutput.type,
                          stdout: codeExecutionOutput.stdout,
                          stderr: codeExecutionOutput.stderr,
                          return_code: codeExecutionOutput.return_code
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      const codeExecutionOutput = yield validateTypes2({
                        value: output.value,
                        schema: codeExecution_20250825OutputSchema
                      });
                      anthropicContent.push(
                        codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                          type: "bash_code_execution_tool_result",
                          tool_use_id: part.toolCallId,
                          cache_control: cacheControl,
                          content: codeExecutionOutput
                        } : {
                          type: "text_editor_code_execution_tool_result",
                          tool_use_id: part.toolCallId,
                          cache_control: cacheControl,
                          content: codeExecutionOutput
                        }
                      );
                    }
                    break;
                  }
                  if (part.toolName === "web_fetch") {
                    const output = part.output;
                    if (output.type !== "json") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                      });
                      break;
                    }
                    const webFetchOutput = yield validateTypes2({
                      value: output.value,
                      schema: webFetch_20250910OutputSchema
                    });
                    anthropicContent.push({
                      type: "web_fetch_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: "web_fetch_result",
                        url: webFetchOutput.url,
                        retrieved_at: webFetchOutput.retrievedAt,
                        content: {
                          type: "document",
                          title: webFetchOutput.content.title,
                          citations: webFetchOutput.content.citations,
                          source: {
                            type: webFetchOutput.content.source.type,
                            media_type: webFetchOutput.content.source.mediaType,
                            data: webFetchOutput.content.source.data
                          }
                        }
                      },
                      cache_control: cacheControl
                    });
                    break;
                  }
                  if (part.toolName === "web_search") {
                    const output = part.output;
                    if (output.type !== "json") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                      });
                      break;
                    }
                    const webSearchOutput = yield validateTypes2({
                      value: output.value,
                      schema: webSearch_20250305OutputSchema
                    });
                    anthropicContent.push({
                      type: "web_search_tool_result",
                      tool_use_id: part.toolCallId,
                      content: webSearchOutput.map((result) => ({
                        url: result.url,
                        title: result.title,
                        page_age: result.pageAge,
                        encrypted_content: result.encryptedContent,
                        type: result.type
                      })),
                      cache_control: cacheControl
                    });
                    break;
                  }
                  warnings.push({
                    type: "other",
                    message: `provider executed tool result for tool ${part.toolName} is not supported`
                  });
                  break;
                }
              }
            }
          }
          messages.push({ role: "assistant", content: anthropicContent });
          break;
        }
        default: {
          const _exhaustiveCheck = type;
          throw new Error(`content type: ${_exhaustiveCheck}`);
        }
      }
    }
    return {
      prompt: { system, messages },
      betas
    };
  });
}
function groupIntoBlocks(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
      return "length";
    default:
      return "unknown";
  }
}
function createCitationSource(citation, citationDocuments, generateId3) {
  var _a4;
  if (citation.type !== "page_location" && citation.type !== "char_location") {
    return;
  }
  const documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo) {
    return;
  }
  return {
    type: "source",
    sourceType: "document",
    id: generateId3(),
    mediaType: documentInfo.mediaType,
    title: (_a4 = citation.document_title) != null ? _a4 : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
var AnthropicMessagesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a4;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a4 = config.generateId) != null ? _a4 : generateId2;
  }
  supportsUrl(url) {
    return url.protocol === "https:";
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).supportedUrls) == null ? void 0 : _b.call(_a4)) != null ? _c : {};
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      userSuppliedBetas,
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4, _b, _c, _d2, _e;
      const warnings = [];
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (seed != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "seed"
        });
      }
      if (temperature != null && temperature > 1) {
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: `${temperature} exceeds anthropic maximum of 1.0. clamped to 1.0`
        });
        temperature = 1;
      } else if (temperature != null && temperature < 0) {
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: `${temperature} is below anthropic minimum of 0. clamped to 0`
        });
        temperature = 0;
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
        if (responseFormat.schema == null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format requires a schema. The response format is ignored."
          });
        } else if (tools != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "tools",
            details: "JSON response format does not support tools. The provided tools are ignored."
          });
        }
      }
      const anthropicOptions = yield parseProviderOptions2({
        provider: "anthropic",
        providerOptions,
        schema: anthropicProviderOptions
      });
      const {
        maxOutputTokens: maxOutputTokensForModel,
        supportsStructuredOutput,
        isKnownModel
      } = getModelCapabilities(this.modelId);
      const structureOutputMode = (_a4 = anthropicOptions == null ? void 0 : anthropicOptions.structuredOutputMode) != null ? _a4 : "jsonTool";
      const useStructuredOutput = structureOutputMode === "outputFormat" || structureOutputMode === "auto" && supportsStructuredOutput;
      const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !useStructuredOutput ? {
        type: "function",
        name: "json",
        description: "Respond with a JSON object.",
        inputSchema: responseFormat.schema
      } : void 0;
      const cacheControlValidator = new CacheControlValidator();
      const { prompt: messagesPrompt, betas } = yield convertToAnthropicMessagesPrompt({
        prompt,
        sendReasoning: (_b = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _b : true,
        warnings,
        cacheControlValidator
      });
      const isThinking = ((_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.type) === "enabled";
      const thinkingBudget = (_d2 = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _d2.budgetTokens;
      const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
      const baseArgs = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
        // model id:
        model: this.modelId,
        // standardized settings:
        max_tokens: maxTokens,
        temperature,
        top_k: topK,
        top_p: topP,
        stop_sequences: stopSequences
      }, isThinking && {
        thinking: { type: "enabled", budget_tokens: thinkingBudget }
      }), (anthropicOptions == null ? void 0 : anthropicOptions.effort) && {
        output_config: { effort: anthropicOptions.effort }
      }), useStructuredOutput && (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && {
        output_format: {
          type: "json_schema",
          schema: responseFormat.schema
        }
      }), (anthropicOptions == null ? void 0 : anthropicOptions.container) && {
        container: {
          id: anthropicOptions.container.id,
          skills: (_e = anthropicOptions.container.skills) == null ? void 0 : _e.map((skill) => ({
            type: skill.type,
            skill_id: skill.skillId,
            version: skill.version
          }))
        }
      }), {
        // prompt:
        system: messagesPrompt.system,
        messages: messagesPrompt.messages
      });
      if (isThinking) {
        if (thinkingBudget == null) {
          throw new import_provider35.UnsupportedFunctionalityError({
            functionality: "thinking requires a budget"
          });
        }
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported when thinking is enabled"
          });
        }
        if (topK != null) {
          baseArgs.top_k = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topK",
            details: "topK is not supported when thinking is enabled"
          });
        }
        if (topP != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported when thinking is enabled"
          });
        }
        baseArgs.max_tokens = maxTokens + thinkingBudget;
      }
      if (isKnownModel && baseArgs.max_tokens > maxOutputTokensForModel) {
        if (maxOutputTokens != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "maxOutputTokens",
            details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
          });
        }
        baseArgs.max_tokens = maxOutputTokensForModel;
      }
      if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
        betas.add("code-execution-2025-08-25");
        betas.add("skills-2025-10-02");
        betas.add("files-api-2025-04-14");
        if (!(tools == null ? void 0 : tools.some(
          (tool21) => tool21.type === "provider-defined" && tool21.id === "anthropic.code_execution_20250825"
        ))) {
          warnings.push({
            type: "other",
            message: "code execution tool is required when using skills"
          });
        }
      }
      if (anthropicOptions == null ? void 0 : anthropicOptions.effort) {
        betas.add("effort-2025-11-24");
      }
      if (useStructuredOutput) {
        betas.add("structured-outputs-2025-11-13");
      }
      const {
        tools: anthropicTools2,
        toolChoice: anthropicToolChoice,
        toolWarnings,
        betas: toolsBetas
      } = yield prepareTools2(
        jsonResponseTool != null ? {
          tools: [jsonResponseTool],
          toolChoice: { type: "tool", toolName: jsonResponseTool.name },
          disableParallelToolUse: true,
          cacheControlValidator
        } : {
          tools: tools != null ? tools : [],
          toolChoice,
          disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
          cacheControlValidator
        }
      );
      const cacheWarnings = cacheControlValidator.getWarnings();
      return {
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: anthropicTools2,
          tool_choice: anthropicToolChoice
        }),
        warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
        betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas, ...userSuppliedBetas]),
        usesJsonResponseTool: jsonResponseTool != null
      };
    });
  }
  getHeaders(_0) {
    return __async(this, arguments, function* ({
      betas,
      headers
    }) {
      return combineHeaders2(
        yield resolve2(this.config.headers),
        headers,
        betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {}
      );
    });
  }
  getBetasFromHeaders(requestHeaders) {
    return __async(this, null, function* () {
      var _a4, _b;
      const configHeaders = yield resolve2(this.config.headers);
      const configBetaHeader = (_a4 = configHeaders["anthropic-beta"]) != null ? _a4 : "";
      const requestBetaHeader = (_b = requestHeaders == null ? void 0 : requestHeaders["anthropic-beta"]) != null ? _b : "";
      return new Set(
        [
          ...configBetaHeader.toLowerCase().split(","),
          ...requestBetaHeader.toLowerCase().split(",")
        ].map((beta) => beta.trim()).filter((beta) => beta !== "")
      );
    });
  }
  buildRequestUrl(isStreaming) {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a4, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
  }
  transformRequestBody(args) {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).transformRequestBody) == null ? void 0 : _b.call(_a4, args)) != null ? _c : args;
  }
  extractCitationDocuments(prompt) {
    const isCitationPart = (part) => {
      var _a4, _b;
      if (part.type !== "file") {
        return false;
      }
      if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
        return false;
      }
      const anthropic2 = (_a4 = part.providerOptions) == null ? void 0 : _a4.anthropic;
      const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
      return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
    };
    return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
      var _a4;
      const filePart = part;
      return {
        title: (_a4 = filePart.filename) != null ? _a4 : "Untitled Document",
        filename: filePart.filename,
        mediaType: filePart.mediaType
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h;
      const { args, warnings, betas, usesJsonResponseTool } = yield this.getArgs(__spreadProps(__spreadValues({}, options), {
        userSuppliedBetas: yield this.getBetasFromHeaders(options.headers)
      }));
      const citationDocuments = this.extractCitationDocuments(options.prompt);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi2({
        url: this.buildRequestUrl(false),
        headers: yield this.getHeaders({ betas, headers: options.headers }),
        body: this.transformRequestBody(args),
        failedResponseHandler: anthropicFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler2(
          anthropicMessagesResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const content = [];
      for (const part of response.content) {
        switch (part.type) {
          case "text": {
            if (!usesJsonResponseTool) {
              content.push({ type: "text", text: part.text });
              if (part.citations) {
                for (const citation of part.citations) {
                  const source = createCitationSource(
                    citation,
                    citationDocuments,
                    this.generateId
                  );
                  if (source) {
                    content.push(source);
                  }
                }
              }
            }
            break;
          }
          case "thinking": {
            content.push({
              type: "reasoning",
              text: part.thinking,
              providerMetadata: {
                anthropic: {
                  signature: part.signature
                }
              }
            });
            break;
          }
          case "redacted_thinking": {
            content.push({
              type: "reasoning",
              text: "",
              providerMetadata: {
                anthropic: {
                  redactedData: part.data
                }
              }
            });
            break;
          }
          case "tool_use": {
            content.push(
              // when a json response tool is used, the tool call becomes the text:
              usesJsonResponseTool ? {
                type: "text",
                text: JSON.stringify(part.input)
              } : {
                type: "tool-call",
                toolCallId: part.id,
                toolName: part.name,
                input: JSON.stringify(part.input)
              }
            );
            break;
          }
          case "server_tool_use": {
            if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: "code_execution",
                input: JSON.stringify(__spreadValues({ type: part.name }, part.input)),
                providerExecuted: true
              });
            } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: part.name,
                input: JSON.stringify(part.input),
                providerExecuted: true
              });
            }
            break;
          }
          case "web_fetch_tool_result": {
            if (part.content.type === "web_fetch_result") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_fetch",
                result: {
                  type: "web_fetch_result",
                  url: part.content.url,
                  retrievedAt: part.content.retrieved_at,
                  content: {
                    type: part.content.content.type,
                    title: part.content.content.title,
                    citations: part.content.content.citations,
                    source: {
                      type: part.content.content.source.type,
                      mediaType: part.content.content.source.media_type,
                      data: part.content.content.source.data
                    }
                  }
                },
                providerExecuted: true
              });
            } else if (part.content.type === "web_fetch_tool_result_error") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_fetch",
                isError: true,
                result: {
                  type: "web_fetch_tool_result_error",
                  errorCode: part.content.error_code
                },
                providerExecuted: true
              });
            }
            break;
          }
          case "web_search_tool_result": {
            if (Array.isArray(part.content)) {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_search",
                result: part.content.map((result) => {
                  var _a22;
                  return {
                    url: result.url,
                    title: result.title,
                    pageAge: (_a22 = result.page_age) != null ? _a22 : null,
                    encryptedContent: result.encrypted_content,
                    type: result.type
                  };
                }),
                providerExecuted: true
              });
              for (const result of part.content) {
                content.push({
                  type: "source",
                  sourceType: "url",
                  id: this.generateId(),
                  url: result.url,
                  title: result.title,
                  providerMetadata: {
                    anthropic: {
                      pageAge: (_a4 = result.page_age) != null ? _a4 : null
                    }
                  }
                });
              }
            } else {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_search",
                isError: true,
                result: {
                  type: "web_search_tool_result_error",
                  errorCode: part.content.error_code
                },
                providerExecuted: true
              });
            }
            break;
          }
          // code execution 20250522:
          case "code_execution_tool_result": {
            if (part.content.type === "code_execution_result") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "code_execution",
                result: {
                  type: part.content.type,
                  stdout: part.content.stdout,
                  stderr: part.content.stderr,
                  return_code: part.content.return_code
                },
                providerExecuted: true
              });
            } else if (part.content.type === "code_execution_tool_result_error") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "code_execution",
                isError: true,
                result: {
                  type: "code_execution_tool_result_error",
                  errorCode: part.content.error_code
                },
                providerExecuted: true
              });
            }
            break;
          }
          // code execution 20250825:
          case "bash_code_execution_tool_result":
          case "text_editor_code_execution_tool_result": {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "code_execution",
              result: part.content,
              providerExecuted: true
            });
            break;
          }
        }
      }
      return {
        content,
        finishReason: mapAnthropicStopReason({
          finishReason: response.stop_reason,
          isJsonResponseFromTool: usesJsonResponseTool
        }),
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
          cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
        },
        request: { body: args },
        response: {
          id: (_c = response.id) != null ? _c : void 0,
          modelId: (_d2 = response.model) != null ? _d2 : void 0,
          headers: responseHeaders,
          body: rawResponse
        },
        warnings,
        providerMetadata: {
          anthropic: {
            usage: response.usage,
            cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
            stopSequence: (_f = response.stop_sequence) != null ? _f : null,
            container: response.container ? {
              expiresAt: response.container.expires_at,
              id: response.container.id,
              skills: (_h = (_g = response.container.skills) == null ? void 0 : _g.map((skill) => ({
                type: skill.type,
                skillId: skill.skill_id,
                version: skill.version
              }))) != null ? _h : null
            } : null
          }
        }
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      var _a4, _b;
      const { args, warnings, betas, usesJsonResponseTool } = yield this.getArgs(__spreadProps(__spreadValues({}, options), {
        userSuppliedBetas: yield this.getBetasFromHeaders(options.headers)
      }));
      const citationDocuments = this.extractCitationDocuments(options.prompt);
      const body = __spreadProps(__spreadValues({}, args), { stream: true });
      const url = this.buildRequestUrl(true);
      const { responseHeaders, value: response } = yield postJsonToApi2({
        url,
        headers: yield this.getHeaders({ betas, headers: options.headers }),
        body: this.transformRequestBody(body),
        failedResponseHandler: anthropicFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler2(
          anthropicMessagesChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const contentBlocks = {};
      let rawUsage = void 0;
      let cacheCreationInputTokens = null;
      let stopSequence = null;
      let container = null;
      let blockType = void 0;
      const generateId3 = this.generateId;
      const transformedStream = response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a22, _b2, _c, _d2, _e, _f, _g, _h, _i, _j;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            switch (value.type) {
              case "ping": {
                return;
              }
              case "content_block_start": {
                const contentBlockType = value.content_block.type;
                blockType = contentBlockType;
                switch (contentBlockType) {
                  case "text": {
                    contentBlocks[value.index] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "redacted_thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index),
                      providerMetadata: {
                        anthropic: {
                          redactedData: value.content_block.data
                        }
                      }
                    });
                    return;
                  }
                  case "tool_use": {
                    contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                      type: "tool-call",
                      toolCallId: value.content_block.id,
                      toolName: value.content_block.name,
                      input: "",
                      firstDelta: true
                    };
                    controller.enqueue(
                      usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: value.content_block.name
                      }
                    );
                    return;
                  }
                  case "server_tool_use": {
                    if ([
                      "web_fetch",
                      "web_search",
                      // code execution 20250825:
                      "code_execution",
                      // code execution 20250825 text editor:
                      "text_editor_code_execution",
                      // code execution 20250825 bash:
                      "bash_code_execution"
                    ].includes(value.content_block.name)) {
                      contentBlocks[value.index] = {
                        type: "tool-call",
                        toolCallId: value.content_block.id,
                        toolName: value.content_block.name,
                        input: "",
                        providerExecuted: true,
                        firstDelta: true
                      };
                      const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                      controller.enqueue({
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: mappedToolName,
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_fetch_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "web_fetch_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        result: {
                          type: "web_fetch_result",
                          url: part.content.url,
                          retrievedAt: part.content.retrieved_at,
                          content: {
                            type: part.content.content.type,
                            title: part.content.content.title,
                            citations: part.content.content.citations,
                            source: {
                              type: part.content.content.source.type,
                              mediaType: part.content.content.source.media_type,
                              data: part.content.content.source.data
                            }
                          }
                        },
                        providerExecuted: true
                      });
                    } else if (part.content.type === "web_fetch_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        isError: true,
                        result: {
                          type: "web_fetch_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_search_tool_result": {
                    const part = value.content_block;
                    if (Array.isArray(part.content)) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        result: part.content.map((result) => {
                          var _a32;
                          return {
                            url: result.url,
                            title: result.title,
                            pageAge: (_a32 = result.page_age) != null ? _a32 : null,
                            encryptedContent: result.encrypted_content,
                            type: result.type
                          };
                        }),
                        providerExecuted: true
                      });
                      for (const result of part.content) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: generateId3(),
                          url: result.url,
                          title: result.title,
                          providerMetadata: {
                            anthropic: {
                              pageAge: (_a22 = result.page_age) != null ? _a22 : null
                            }
                          }
                        });
                      }
                    } else {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        isError: true,
                        result: {
                          type: "web_search_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250522:
                  case "code_execution_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "code_execution_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        result: {
                          type: part.content.type,
                          stdout: part.content.stdout,
                          stderr: part.content.stderr,
                          return_code: part.content.return_code
                        },
                        providerExecuted: true
                      });
                    } else if (part.content.type === "code_execution_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        isError: true,
                        result: {
                          type: "code_execution_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250825:
                  case "bash_code_execution_tool_result":
                  case "text_editor_code_execution_tool_result": {
                    const part = value.content_block;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "code_execution",
                      result: part.content,
                      providerExecuted: true
                    });
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = contentBlockType;
                    throw new Error(
                      `Unsupported content block type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "content_block_stop": {
                if (contentBlocks[value.index] != null) {
                  const contentBlock = contentBlocks[value.index];
                  switch (contentBlock.type) {
                    case "text": {
                      controller.enqueue({
                        type: "text-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "reasoning": {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "tool-call":
                      if (!usesJsonResponseTool) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: contentBlock.toolCallId
                        });
                        const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: contentBlock.toolCallId,
                          toolName,
                          input: contentBlock.input === "" ? "{}" : contentBlock.input,
                          providerExecuted: contentBlock.providerExecuted
                        });
                      }
                      break;
                  }
                  delete contentBlocks[value.index];
                }
                blockType = void 0;
                return;
              }
              case "content_block_delta": {
                const deltaType = value.delta.type;
                switch (deltaType) {
                  case "text_delta": {
                    if (usesJsonResponseTool) {
                      return;
                    }
                    controller.enqueue({
                      type: "text-delta",
                      id: String(value.index),
                      delta: value.delta.text
                    });
                    return;
                  }
                  case "thinking_delta": {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(value.index),
                      delta: value.delta.thinking
                    });
                    return;
                  }
                  case "signature_delta": {
                    if (blockType === "thinking") {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: String(value.index),
                        delta: "",
                        providerMetadata: {
                          anthropic: {
                            signature: value.delta.signature
                          }
                        }
                      });
                    }
                    return;
                  }
                  case "input_json_delta": {
                    const contentBlock = contentBlocks[value.index];
                    let delta = value.delta.partial_json;
                    if (delta.length === 0) {
                      return;
                    }
                    if (usesJsonResponseTool) {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                        return;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: String(value.index),
                        delta
                      });
                    } else {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                        return;
                      }
                      if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                        delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                      }
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: contentBlock.toolCallId,
                        delta
                      });
                      contentBlock.input += delta;
                      contentBlock.firstDelta = false;
                    }
                    return;
                  }
                  case "citations_delta": {
                    const citation = value.delta.citation;
                    const source = createCitationSource(
                      citation,
                      citationDocuments,
                      generateId3
                    );
                    if (source) {
                      controller.enqueue(source);
                    }
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = deltaType;
                    throw new Error(
                      `Unsupported delta type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "message_start": {
                usage.inputTokens = value.message.usage.input_tokens;
                usage.cachedInputTokens = (_b2 = value.message.usage.cache_read_input_tokens) != null ? _b2 : void 0;
                rawUsage = __spreadValues({}, value.message.usage);
                cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                controller.enqueue({
                  type: "response-metadata",
                  id: (_d2 = value.message.id) != null ? _d2 : void 0,
                  modelId: (_e = value.message.model) != null ? _e : void 0
                });
                return;
              }
              case "message_delta": {
                usage.outputTokens = value.usage.output_tokens;
                usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                finishReason = mapAnthropicStopReason({
                  finishReason: value.delta.stop_reason,
                  isJsonResponseFromTool: usesJsonResponseTool
                });
                stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                container = value.delta.container != null ? {
                  expiresAt: value.delta.container.expires_at,
                  id: value.delta.container.id,
                  skills: (_j = (_i = value.delta.container.skills) == null ? void 0 : _i.map((skill) => ({
                    type: skill.type,
                    skillId: skill.skill_id,
                    version: skill.version
                  }))) != null ? _j : null
                } : null;
                rawUsage = __spreadValues(__spreadValues({}, rawUsage), value.usage);
                return;
              }
              case "message_stop": {
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    anthropic: {
                      usage: rawUsage != null ? rawUsage : null,
                      cacheCreationInputTokens,
                      stopSequence,
                      container
                    }
                  }
                });
                return;
              }
              case "error": {
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              default: {
                const _exhaustiveCheck = value;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      );
      const [streamForFirstChunk, streamForConsumer] = transformedStream.tee();
      const firstChunkReader = streamForFirstChunk.getReader();
      try {
        yield firstChunkReader.read();
        let result = yield firstChunkReader.read();
        if (((_a4 = result.value) == null ? void 0 : _a4.type) === "raw") {
          result = yield firstChunkReader.read();
        }
        if (((_b = result.value) == null ? void 0 : _b.type) === "error") {
          const error = result.value.error;
          throw new import_provider35.APICallError({
            message: error.message,
            url,
            requestBodyValues: body,
            statusCode: error.type === "overloaded_error" ? 529 : 500,
            responseHeaders,
            responseBody: JSON.stringify(error),
            isRetryable: error.type === "overloaded_error"
          });
        }
      } finally {
        firstChunkReader.cancel().catch(() => {
        });
        firstChunkReader.releaseLock();
      }
      return {
        stream: streamForConsumer,
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function getModelCapabilities(modelId) {
  if (modelId.includes("claude-sonnet-4-5") || modelId.includes("claude-opus-4-5")) {
    return {
      maxOutputTokens: 64e3,
      supportsStructuredOutput: true,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-opus-4-1")) {
    return {
      maxOutputTokens: 32e3,
      supportsStructuredOutput: true,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
    return {
      maxOutputTokens: 64e3,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-opus-4-")) {
    return {
      maxOutputTokens: 32e3,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-3-5-haiku")) {
    return {
      maxOutputTokens: 8192,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else if (modelId.includes("claude-3-haiku")) {
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: false,
      isKnownModel: true
    };
  } else {
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: false,
      isKnownModel: false
    };
  }
}
var bash_20241022InputSchema = lazySchema2(
  () => zodSchema2(
    import_v441.z.object({
      command: import_v441.z.string(),
      restart: import_v441.z.boolean().optional()
    })
  )
);
var bash_20241022 = createProviderDefinedToolFactory2({
  id: "anthropic.bash_20241022",
  name: "bash",
  inputSchema: bash_20241022InputSchema
});
var bash_20250124InputSchema = lazySchema2(
  () => zodSchema2(
    import_v442.z.object({
      command: import_v442.z.string(),
      restart: import_v442.z.boolean().optional()
    })
  )
);
var bash_20250124 = createProviderDefinedToolFactory2({
  id: "anthropic.bash_20250124",
  name: "bash",
  inputSchema: bash_20250124InputSchema
});
var computer_20241022InputSchema = lazySchema2(
  () => zodSchema2(
    import_v443.z.object({
      action: import_v443.z.enum([
        "key",
        "type",
        "mouse_move",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "screenshot",
        "cursor_position"
      ]),
      coordinate: import_v443.z.array(import_v443.z.number().int()).optional(),
      text: import_v443.z.string().optional()
    })
  )
);
var computer_20241022 = createProviderDefinedToolFactory2({
  id: "anthropic.computer_20241022",
  name: "computer",
  inputSchema: computer_20241022InputSchema
});
var computer_20250124InputSchema = lazySchema2(
  () => zodSchema2(
    import_v444.z.object({
      action: import_v444.z.enum([
        "key",
        "hold_key",
        "type",
        "cursor_position",
        "mouse_move",
        "left_mouse_down",
        "left_mouse_up",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "triple_click",
        "scroll",
        "wait",
        "screenshot"
      ]),
      coordinate: import_v444.z.tuple([import_v444.z.number().int(), import_v444.z.number().int()]).optional(),
      duration: import_v444.z.number().optional(),
      scroll_amount: import_v444.z.number().optional(),
      scroll_direction: import_v444.z.enum(["up", "down", "left", "right"]).optional(),
      start_coordinate: import_v444.z.tuple([import_v444.z.number().int(), import_v444.z.number().int()]).optional(),
      text: import_v444.z.string().optional()
    })
  )
);
var computer_20250124 = createProviderDefinedToolFactory2({
  id: "anthropic.computer_20250124",
  name: "computer",
  inputSchema: computer_20250124InputSchema
});
var memory_20250818InputSchema = lazySchema2(
  () => zodSchema2(
    import_v445.z.discriminatedUnion("command", [
      import_v445.z.object({
        command: import_v445.z.literal("view"),
        path: import_v445.z.string(),
        view_range: import_v445.z.tuple([import_v445.z.number(), import_v445.z.number()]).optional()
      }),
      import_v445.z.object({
        command: import_v445.z.literal("create"),
        path: import_v445.z.string(),
        file_text: import_v445.z.string()
      }),
      import_v445.z.object({
        command: import_v445.z.literal("str_replace"),
        path: import_v445.z.string(),
        old_str: import_v445.z.string(),
        new_str: import_v445.z.string()
      }),
      import_v445.z.object({
        command: import_v445.z.literal("insert"),
        path: import_v445.z.string(),
        insert_line: import_v445.z.number(),
        insert_text: import_v445.z.string()
      }),
      import_v445.z.object({
        command: import_v445.z.literal("delete"),
        path: import_v445.z.string()
      }),
      import_v445.z.object({
        command: import_v445.z.literal("rename"),
        old_path: import_v445.z.string(),
        new_path: import_v445.z.string()
      })
    ])
  )
);
var memory_20250818 = createProviderDefinedToolFactory2({
  id: "anthropic.memory_20250818",
  name: "memory",
  inputSchema: memory_20250818InputSchema
});
var textEditor_20241022InputSchema = lazySchema2(
  () => zodSchema2(
    import_v446.z.object({
      command: import_v446.z.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: import_v446.z.string(),
      file_text: import_v446.z.string().optional(),
      insert_line: import_v446.z.number().int().optional(),
      new_str: import_v446.z.string().optional(),
      old_str: import_v446.z.string().optional(),
      view_range: import_v446.z.array(import_v446.z.number().int()).optional()
    })
  )
);
var textEditor_20241022 = createProviderDefinedToolFactory2({
  id: "anthropic.text_editor_20241022",
  name: "str_replace_editor",
  inputSchema: textEditor_20241022InputSchema
});
var textEditor_20250124InputSchema = lazySchema2(
  () => zodSchema2(
    import_v447.z.object({
      command: import_v447.z.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: import_v447.z.string(),
      file_text: import_v447.z.string().optional(),
      insert_line: import_v447.z.number().int().optional(),
      new_str: import_v447.z.string().optional(),
      old_str: import_v447.z.string().optional(),
      view_range: import_v447.z.array(import_v447.z.number().int()).optional()
    })
  )
);
var textEditor_20250124 = createProviderDefinedToolFactory2({
  id: "anthropic.text_editor_20250124",
  name: "str_replace_editor",
  inputSchema: textEditor_20250124InputSchema
});
var textEditor_20250429InputSchema = lazySchema2(
  () => zodSchema2(
    import_v448.z.object({
      command: import_v448.z.enum(["view", "create", "str_replace", "insert"]),
      path: import_v448.z.string(),
      file_text: import_v448.z.string().optional(),
      insert_line: import_v448.z.number().int().optional(),
      new_str: import_v448.z.string().optional(),
      old_str: import_v448.z.string().optional(),
      view_range: import_v448.z.array(import_v448.z.number().int()).optional()
    })
  )
);
var textEditor_20250429 = createProviderDefinedToolFactory2({
  id: "anthropic.text_editor_20250429",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250429InputSchema
});
var anthropicTools = {
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20241022,
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20250124,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250522,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * This is the latest version with enhanced Bash support and file operations.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250825,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20241022,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20250124,
  /**
   * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
   * Claude can create, read, update, and delete files that persist between sessions,
   * allowing it to build knowledge over time without keeping everything in the context window.
   * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
   *
   * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
   *
   * Tool name must be `memory`.
   */
  memory_20250818,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.5
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20241022,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.7
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20250124,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command.
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @deprecated Use textEditor_20250728 instead
   */
  textEditor_20250429,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
   *
   * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @param maxCharacters - Optional maximum number of characters to view in the file
   */
  textEditor_20250728,
  /**
   * Creates a web fetch tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_fetch`.
   *
   * @param maxUses - The max_uses parameter limits the number of web fetches performed
   * @param allowedDomains - Only fetch from these domains
   * @param blockedDomains - Never fetch from these domains
   * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
   * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
   */
  webFetch_20250910,
  /**
   * Creates a web search tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_search`.
   *
   * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
   * @param allowedDomains - Optional list of domains that Claude is allowed to search.
   * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
   * @param userLocation - Optional user location information to provide geographically relevant search results.
   */
  webSearch_20250305
};
function createAnthropic(options = {}) {
  var _a4, _b;
  const baseURL = (_a4 = withoutTrailingSlash2(
    loadOptionalSetting2({
      settingValue: options.baseURL,
      environmentVariableName: "ANTHROPIC_BASE_URL"
    })
  )) != null ? _a4 : "https://api.anthropic.com/v1";
  const providerName = (_b = options.name) != null ? _b : "anthropic.messages";
  const getHeaders = () => withUserAgentSuffix2(
    __spreadValues({
      "anthropic-version": "2023-06-01",
      "x-api-key": loadApiKey2({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      })
    }, options.headers),
    `ai-sdk/anthropic/${VERSION5}`
  );
  const createChatModel = (modelId) => {
    var _a22;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a22 = options.generateId) != null ? _a22 : generateId2,
      supportedUrls: () => ({
        "image/*": [/^https?:\/\/.*$/]
      })
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider34.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider34.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.tools = anthropicTools;
  return provider;
}
var anthropic = createAnthropic();

// ../../node_modules/.pnpm/@ai-sdk+google@2.0.23_zod@4.2.1/node_modules/@ai-sdk/google/dist/index.mjs
var import_provider38 = require("@ai-sdk/provider");
var import_v449 = require("zod/v4");
var import_v450 = require("zod/v4");
var import_v451 = require("zod/v4");
var import_v452 = require("zod/v4");
var import_provider39 = require("@ai-sdk/provider");
var import_v453 = require("zod/v4");
var import_provider40 = require("@ai-sdk/provider");
var import_v454 = require("zod/v4");
var import_v455 = require("zod/v4");
var import_v456 = require("zod/v4");
var import_v457 = require("zod/v4");
var VERSION6 = true ? "2.0.23" : "0.0.0-test";
var googleErrorDataSchema2 = lazySchema(
  () => zodSchema(
    import_v450.z.object({
      error: import_v450.z.object({
        code: import_v450.z.number().nullable(),
        message: import_v450.z.string(),
        status: import_v450.z.string()
      })
    })
  )
);
var googleFailedResponseHandler2 = createJsonErrorResponseHandler({
  errorSchema: googleErrorDataSchema2,
  errorToMessage: (data) => data.error.message
});
var googleGenerativeAIEmbeddingProviderOptions = lazySchema(
  () => zodSchema(
    import_v451.z.object({
      /**
       * Optional. Optional reduced dimension for the output embedding.
       * If set, excessive values in the output embedding are truncated from the end.
       */
      outputDimensionality: import_v451.z.number().optional(),
      /**
       * Optional. Specifies the task type for generating embeddings.
       * Supported task types:
       * - SEMANTIC_SIMILARITY: Optimized for text similarity.
       * - CLASSIFICATION: Optimized for text classification.
       * - CLUSTERING: Optimized for clustering texts based on similarity.
       * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
       * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
       * - QUESTION_ANSWERING: Optimized for answering questions.
       * - FACT_VERIFICATION: Optimized for verifying factual information.
       * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
       */
      taskType: import_v451.z.enum([
        "SEMANTIC_SIMILARITY",
        "CLASSIFICATION",
        "CLUSTERING",
        "RETRIEVAL_DOCUMENT",
        "RETRIEVAL_QUERY",
        "QUESTION_ANSWERING",
        "FACT_VERIFICATION",
        "CODE_RETRIEVAL_QUERY"
      ]).optional()
    })
  )
);
var GoogleGenerativeAIEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      const googleOptions = yield parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIEmbeddingProviderOptions
      });
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider38.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const mergedHeaders = combineHeaders(
        yield resolve(this.config.headers),
        headers
      );
      if (values.length === 1) {
        const {
          responseHeaders: responseHeaders2,
          value: response2,
          rawValue: rawValue2
        } = yield postJsonToApi({
          url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
          headers: mergedHeaders,
          body: {
            model: `models/${this.modelId}`,
            content: {
              parts: [{ text: values[0] }]
            },
            outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
            taskType: googleOptions == null ? void 0 : googleOptions.taskType
          },
          failedResponseHandler: googleFailedResponseHandler2,
          successfulResponseHandler: createJsonResponseHandler(
            googleGenerativeAISingleEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: [response2.embedding.values],
          usage: void 0,
          response: { headers: responseHeaders2, body: rawValue2 }
        };
      }
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
        headers: mergedHeaders,
        body: {
          requests: values.map((value) => ({
            model: `models/${this.modelId}`,
            content: { role: "user", parts: [{ text: value }] },
            outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
            taskType: googleOptions == null ? void 0 : googleOptions.taskType
          }))
        },
        failedResponseHandler: googleFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          googleGenerativeAITextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.embeddings.map((item) => item.values),
        usage: void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var googleGenerativeAITextEmbeddingResponseSchema = lazySchema(
  () => zodSchema(
    import_v449.z.object({
      embeddings: import_v449.z.array(import_v449.z.object({ values: import_v449.z.array(import_v449.z.number()) }))
    })
  )
);
var googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(
  () => zodSchema(
    import_v449.z.object({
      embedding: import_v449.z.object({ values: import_v449.z.array(import_v449.z.number()) })
    })
  )
);
function convertJSONSchemaToOpenAPISchema2(jsonSchema3) {
  if (jsonSchema3 == null || isEmptyObjectSchema2(jsonSchema3)) {
    return void 0;
  }
  if (typeof jsonSchema3 === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type,
    description,
    required,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema3;
  const result = {};
  if (description) result.description = description;
  if (required) result.required = required;
  if (format) result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type) {
    if (Array.isArray(type)) {
      if (type.includes("null")) {
        result.type = type.filter((t2) => t2 !== "null")[0];
        result.nullable = true;
      } else {
        result.type = type;
      }
    } else if (type === "null") {
      result.type = "null";
    } else {
      result.type = type;
    }
  }
  if (enumValues !== void 0) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema2(value);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema2) : convertJSONSchemaToOpenAPISchema2(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema2);
  }
  if (anyOf) {
    if (anyOf.some(
      (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
    )) {
      const nonNullSchemas = anyOf.filter(
        (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
      );
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema2(nonNullSchemas[0]);
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema2);
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema2);
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema2);
  }
  if (minLength !== void 0) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema2(jsonSchema3) {
  return jsonSchema3 != null && typeof jsonSchema3 === "object" && jsonSchema3.type === "object" && (jsonSchema3.properties == null || Object.keys(jsonSchema3.properties).length === 0) && !jsonSchema3.additionalProperties;
}
function convertToGoogleGenerativeAIMessages2(prompt, options) {
  var _a4;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  const isGemmaModel = (_a4 = options == null ? void 0 : options.isGemmaModel) != null ? _a4 : false;
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new import_provider39.UnsupportedFunctionalityError({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: mediaType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: mediaType,
                    data: convertToBase64(part.data)
                  }
                }
              );
              break;
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a22, _b, _c, _d2, _e, _f;
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature: (_b = (_a22 = part.providerOptions) == null ? void 0 : _a22.google) == null ? void 0 : _b.thoughtSignature
                };
              }
              case "reasoning": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: true,
                  thoughtSignature: (_d2 = (_c = part.providerOptions) == null ? void 0 : _c.google) == null ? void 0 : _d2.thoughtSignature
                };
              }
              case "file": {
                if (part.mediaType !== "image/png") {
                  throw new import_provider39.UnsupportedFunctionalityError({
                    functionality: "Only PNG images are supported in assistant messages"
                  });
                }
                if (part.data instanceof URL) {
                  throw new import_provider39.UnsupportedFunctionalityError({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase64(part.data)
                  }
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature: (_f = (_e = part.providerOptions) == null ? void 0 : _e.google) == null ? void 0 : _f.thoughtSignature
                };
              }
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          const output = part.output;
          if (output.type === "content") {
            for (const contentPart of output.value) {
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "media":
                  parts.push(
                    {
                      inlineData: {
                        mimeType: contentPart.mediaType,
                        data: contentPart.data
                      }
                    },
                    {
                      text: "Tool executed successfully and returned this image as a response"
                    }
                  );
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
            }
          } else {
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.value
                }
              }
            });
          }
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
    contents[0].parts.unshift({ text: systemText + "\n\n" });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}
function getModelPath2(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleGenerativeAIProviderOptions2 = lazySchema(
  () => zodSchema(
    import_v453.z.object({
      responseModalities: import_v453.z.array(import_v453.z.enum(["TEXT", "IMAGE"])).optional(),
      thinkingConfig: import_v453.z.object({
        thinkingBudget: import_v453.z.number().optional(),
        includeThoughts: import_v453.z.boolean().optional()
      }).optional(),
      /**
       * Optional.
       * The name of the cached content used as context to serve the prediction.
       * Format: cachedContents/{cachedContent}
       */
      cachedContent: import_v453.z.string().optional(),
      /**
       * Optional. Enable structured output. Default is true.
       *
       * This is useful when the JSON Schema contains elements that are
       * not supported by the OpenAPI schema version that
       * Google Generative AI uses. You can use this to disable
       * structured outputs if you need to.
       */
      structuredOutputs: import_v453.z.boolean().optional(),
      /**
       * Optional. A list of unique safety settings for blocking unsafe content.
       */
      safetySettings: import_v453.z.array(
        import_v453.z.object({
          category: import_v453.z.enum([
            "HARM_CATEGORY_UNSPECIFIED",
            "HARM_CATEGORY_HATE_SPEECH",
            "HARM_CATEGORY_DANGEROUS_CONTENT",
            "HARM_CATEGORY_HARASSMENT",
            "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "HARM_CATEGORY_CIVIC_INTEGRITY"
          ]),
          threshold: import_v453.z.enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
          ])
        })
      ).optional(),
      threshold: import_v453.z.enum([
        "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE",
        "OFF"
      ]).optional(),
      /**
       * Optional. Enables timestamp understanding for audio-only files.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
       */
      audioTimestamp: import_v453.z.boolean().optional(),
      /**
       * Optional. Defines labels used in billing reports. Available on Vertex AI only.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
       */
      labels: import_v453.z.record(import_v453.z.string(), import_v453.z.string()).optional(),
      /**
       * Optional. If specified, the media resolution specified will be used.
       *
       * https://ai.google.dev/api/generate-content#MediaResolution
       */
      mediaResolution: import_v453.z.enum([
        "MEDIA_RESOLUTION_UNSPECIFIED",
        "MEDIA_RESOLUTION_LOW",
        "MEDIA_RESOLUTION_MEDIUM",
        "MEDIA_RESOLUTION_HIGH"
      ]).optional(),
      /**
       * Optional. Configures the image generation aspect ratio for Gemini models.
       *
       * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
       */
      imageConfig: import_v453.z.object({
        aspectRatio: import_v453.z.enum([
          "1:1",
          "2:3",
          "3:2",
          "3:4",
          "4:3",
          "4:5",
          "5:4",
          "9:16",
          "16:9",
          "21:9"
        ]).optional()
      }).optional()
    })
  )
);
function prepareTools3({
  tools,
  toolChoice,
  modelId
}) {
  var _a4;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const isGemini2 = modelId.includes("gemini-2");
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  if (tools == null) {
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  }
  const hasFunctionTools = tools.some((tool21) => tool21.type === "function");
  const hasProviderDefinedTools = tools.some(
    (tool21) => tool21.type === "provider-defined"
  );
  if (hasFunctionTools && hasProviderDefinedTools) {
    toolWarnings.push({
      type: "unsupported-tool",
      tool: tools.find((tool21) => tool21.type === "function"),
      details: "Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both."
    });
  }
  if (hasProviderDefinedTools) {
    const googleTools22 = [];
    const providerDefinedTools = tools.filter(
      (tool21) => tool21.type === "provider-defined"
    );
    providerDefinedTools.forEach((tool21) => {
      switch (tool21.id) {
        case "google.google_search":
          if (isGemini2) {
            googleTools22.push({ googleSearch: {} });
          } else if (supportsDynamicRetrieval) {
            googleTools22.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool21.args.mode,
                  dynamicThreshold: tool21.args.dynamicThreshold
                }
              }
            });
          } else {
            googleTools22.push({ googleSearchRetrieval: {} });
          }
          break;
        case "google.url_context":
          if (isGemini2) {
            googleTools22.push({ urlContext: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.code_execution":
          if (isGemini2) {
            googleTools22.push({ codeExecution: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tool21,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
          break;
      }
    });
    return {
      tools: googleTools22.length > 0 ? googleTools22 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const functionDeclarations = [];
  for (const tool21 of tools) {
    switch (tool21.type) {
      case "function":
        functionDeclarations.push({
          name: tool21.name,
          description: (_a4 = tool21.description) != null ? _a4 : "",
          parameters: convertJSONSchemaToOpenAPISchema2(tool21.inputSchema)
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
        break;
    }
  }
  if (toolChoice == null) {
    return {
      tools: { functionDeclarations },
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: { functionDeclarations },
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider40.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGoogleGenerativeAIFinishReason2({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    default:
      return "unknown";
  }
}
var GoogleGenerativeAILanguageModel2 = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a4;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a4 = config.generateId) != null ? _a4 : generateId;
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).supportedUrls) == null ? void 0 : _b.call(_a4)) != null ? _c : {};
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4, _b;
      const warnings = [];
      const googleOptions = yield parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIProviderOptions2
      });
      if (((_a4 = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a4.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
        warnings.push({
          type: "other",
          message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
        });
      }
      const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
      const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages2(
        prompt,
        { isGemmaModel }
      );
      const {
        tools: googleTools22,
        toolConfig: googleToolConfig,
        toolWarnings
      } = prepareTools3({
        tools,
        toolChoice,
        modelId: this.modelId
      });
      return {
        args: {
          generationConfig: __spreadValues(__spreadValues(__spreadProps(__spreadValues({
            // standardized settings:
            maxOutputTokens,
            temperature,
            topK,
            topP,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            seed,
            // response format:
            responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
            responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
            // so this is needed as an escape hatch:
            // TODO convert into provider option
            ((_b = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _b : true) ? convertJSONSchemaToOpenAPISchema2(responseFormat.schema) : void 0
          }, (googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
            audioTimestamp: googleOptions.audioTimestamp
          }), {
            // provider options:
            responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
            thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig
          }), (googleOptions == null ? void 0 : googleOptions.imageConfig) && {
            imageConfig: googleOptions.imageConfig
          }), (googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
            mediaResolution: googleOptions.mediaResolution
          }),
          contents,
          systemInstruction: isGemmaModel ? void 0 : systemInstruction,
          safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
          tools: googleTools22,
          toolConfig: googleToolConfig,
          cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
          labels: googleOptions == null ? void 0 : googleOptions.labels
        },
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const { args, warnings } = yield this.getArgs(options);
      const body = JSON.stringify(args);
      const mergedHeaders = combineHeaders(
        yield resolve(this.config.headers),
        options.headers
      );
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: `${this.config.baseURL}/${getModelPath2(
          this.modelId
        )}:generateContent`,
        headers: mergedHeaders,
        body: args,
        failedResponseHandler: googleFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(responseSchema2),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const candidate = response.candidates[0];
      const content = [];
      const parts = (_b = (_a4 = candidate.content) == null ? void 0 : _a4.parts) != null ? _b : [];
      const usageMetadata = response.usageMetadata;
      let lastCodeExecutionToolCallId;
      for (const part of parts) {
        if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
          const toolCallId = this.config.generateId();
          lastCodeExecutionToolCallId = toolCallId;
          content.push({
            type: "tool-call",
            toolCallId,
            toolName: "code_execution",
            input: JSON.stringify(part.executableCode),
            providerExecuted: true
          });
        } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
          content.push({
            type: "tool-result",
            // Assumes a result directly follows its corresponding call part.
            toolCallId: lastCodeExecutionToolCallId,
            toolName: "code_execution",
            result: {
              outcome: part.codeExecutionResult.outcome,
              output: part.codeExecutionResult.output
            },
            providerExecuted: true
          });
          lastCodeExecutionToolCallId = void 0;
        } else if ("text" in part && part.text != null && part.text.length > 0) {
          content.push({
            type: part.thought === true ? "reasoning" : "text",
            text: part.text,
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("functionCall" in part) {
          content.push({
            type: "tool-call",
            toolCallId: this.config.generateId(),
            toolName: part.functionCall.name,
            input: JSON.stringify(part.functionCall.args),
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("inlineData" in part) {
          content.push({
            type: "file",
            data: part.inlineData.data,
            mediaType: part.inlineData.mimeType
          });
        }
      }
      const sources = (_d2 = extractSources2({
        groundingMetadata: candidate.groundingMetadata,
        generateId: this.config.generateId
      })) != null ? _d2 : [];
      for (const source of sources) {
        content.push(source);
      }
      return {
        content,
        finishReason: mapGoogleGenerativeAIFinishReason2({
          finishReason: candidate.finishReason,
          hasToolCalls: content.some((part) => part.type === "tool-call")
        }),
        usage: {
          inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
          outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
          totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
          reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
          cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
        },
        warnings,
        providerMetadata: {
          google: {
            promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
            groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
            urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
            safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
            usageMetadata: usageMetadata != null ? usageMetadata : null
          }
        },
        request: { body },
        response: {
          // TODO timestamp, model id, id
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = JSON.stringify(args);
      const headers = combineHeaders(
        yield resolve(this.config.headers),
        options.headers
      );
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: `${this.config.baseURL}/${getModelPath2(
          this.modelId
        )}:streamGenerateContent?alt=sse`,
        headers,
        body: args,
        failedResponseHandler: googleFailedResponseHandler2,
        successfulResponseHandler: createEventSourceResponseHandler(chunkSchema2),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let providerMetadata = void 0;
      const generateId3 = this.config.generateId;
      let hasToolCalls = false;
      let currentTextBlockId = null;
      let currentReasoningBlockId = null;
      let blockCounter = 0;
      const emittedSourceUrls = /* @__PURE__ */ new Set();
      let lastCodeExecutionToolCallId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              const usageMetadata = value.usageMetadata;
              if (usageMetadata != null) {
                usage.inputTokens = (_a4 = usageMetadata.promptTokenCount) != null ? _a4 : void 0;
                usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                usage.reasoningTokens = (_d2 = usageMetadata.thoughtsTokenCount) != null ? _d2 : void 0;
                usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
              }
              const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
              if (candidate == null) {
                return;
              }
              const content = candidate.content;
              const sources = extractSources2({
                groundingMetadata: candidate.groundingMetadata,
                generateId: generateId3
              });
              if (sources != null) {
                for (const source of sources) {
                  if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                    emittedSourceUrls.add(source.url);
                    controller.enqueue(source);
                  }
                }
              }
              if (content != null) {
                const parts = (_g = content.parts) != null ? _g : [];
                for (const part of parts) {
                  if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                    const toolCallId = generateId3();
                    lastCodeExecutionToolCallId = toolCallId;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName: "code_execution",
                      input: JSON.stringify(part.executableCode),
                      providerExecuted: true
                    });
                    hasToolCalls = true;
                  } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                    const toolCallId = lastCodeExecutionToolCallId;
                    if (toolCallId) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId,
                        toolName: "code_execution",
                        result: {
                          outcome: part.codeExecutionResult.outcome,
                          output: part.codeExecutionResult.output
                        },
                        providerExecuted: true
                      });
                      lastCodeExecutionToolCallId = void 0;
                    }
                  } else if ("text" in part && part.text != null && part.text.length > 0) {
                    if (part.thought === true) {
                      if (currentTextBlockId !== null) {
                        controller.enqueue({
                          type: "text-end",
                          id: currentTextBlockId
                        });
                        currentTextBlockId = null;
                      }
                      if (currentReasoningBlockId === null) {
                        currentReasoningBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "reasoning-start",
                          id: currentReasoningBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: currentReasoningBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    } else {
                      if (currentReasoningBlockId !== null) {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: currentReasoningBlockId
                        });
                        currentReasoningBlockId = null;
                      }
                      if (currentTextBlockId === null) {
                        currentTextBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "text-start",
                          id: currentTextBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: currentTextBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    }
                  }
                }
                const inlineDataParts = getInlineDataParts(content.parts);
                if (inlineDataParts != null) {
                  for (const part of inlineDataParts) {
                    controller.enqueue({
                      type: "file",
                      mediaType: part.inlineData.mimeType,
                      data: part.inlineData.data
                    });
                  }
                }
                const toolCallDeltas = getToolCallsFromParts2({
                  parts: content.parts,
                  generateId: generateId3
                });
                if (toolCallDeltas != null) {
                  for (const toolCall of toolCallDeltas) {
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      input: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    hasToolCalls = true;
                  }
                }
              }
              if (candidate.finishReason != null) {
                finishReason = mapGoogleGenerativeAIFinishReason2({
                  finishReason: candidate.finishReason,
                  hasToolCalls
                });
                providerMetadata = {
                  google: {
                    promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                    groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                    urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                    safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                  }
                };
                if (usageMetadata != null) {
                  providerMetadata.google.usageMetadata = usageMetadata;
                }
              }
            },
            flush(controller) {
              if (currentTextBlockId !== null) {
                controller.enqueue({
                  type: "text-end",
                  id: currentTextBlockId
                });
              }
              if (currentReasoningBlockId !== null) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: currentReasoningBlockId
                });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        response: { headers: responseHeaders },
        request: { body }
      };
    });
  }
};
function getToolCallsFromParts2({
  parts,
  generateId: generateId3
}) {
  const functionCallParts = parts == null ? void 0 : parts.filter(
    (part) => "functionCall" in part
  );
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId3(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
  }));
}
function getInlineDataParts(parts) {
  return parts == null ? void 0 : parts.filter(
    (part) => "inlineData" in part
  );
}
function extractSources2({
  groundingMetadata,
  generateId: generateId3
}) {
  var _a4;
  return (_a4 = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a4.filter(
    (chunk) => chunk.web != null
  ).map((chunk) => ({
    type: "source",
    sourceType: "url",
    id: generateId3(),
    url: chunk.web.uri,
    title: chunk.web.title
  }));
}
var getGroundingMetadataSchema2 = () => import_v452.z.object({
  webSearchQueries: import_v452.z.array(import_v452.z.string()).nullish(),
  retrievalQueries: import_v452.z.array(import_v452.z.string()).nullish(),
  searchEntryPoint: import_v452.z.object({ renderedContent: import_v452.z.string() }).nullish(),
  groundingChunks: import_v452.z.array(
    import_v452.z.object({
      web: import_v452.z.object({ uri: import_v452.z.string(), title: import_v452.z.string() }).nullish(),
      retrievedContext: import_v452.z.object({ uri: import_v452.z.string(), title: import_v452.z.string() }).nullish()
    })
  ).nullish(),
  groundingSupports: import_v452.z.array(
    import_v452.z.object({
      segment: import_v452.z.object({
        startIndex: import_v452.z.number().nullish(),
        endIndex: import_v452.z.number().nullish(),
        text: import_v452.z.string().nullish()
      }),
      segment_text: import_v452.z.string().nullish(),
      groundingChunkIndices: import_v452.z.array(import_v452.z.number()).nullish(),
      supportChunkIndices: import_v452.z.array(import_v452.z.number()).nullish(),
      confidenceScores: import_v452.z.array(import_v452.z.number()).nullish(),
      confidenceScore: import_v452.z.array(import_v452.z.number()).nullish()
    })
  ).nullish(),
  retrievalMetadata: import_v452.z.union([
    import_v452.z.object({
      webDynamicRetrievalScore: import_v452.z.number()
    }),
    import_v452.z.object({})
  ]).nullish()
});
var getContentSchema2 = () => import_v452.z.object({
  parts: import_v452.z.array(
    import_v452.z.union([
      // note: order matters since text can be fully empty
      import_v452.z.object({
        functionCall: import_v452.z.object({
          name: import_v452.z.string(),
          args: import_v452.z.unknown()
        }),
        thoughtSignature: import_v452.z.string().nullish()
      }),
      import_v452.z.object({
        inlineData: import_v452.z.object({
          mimeType: import_v452.z.string(),
          data: import_v452.z.string()
        })
      }),
      import_v452.z.object({
        executableCode: import_v452.z.object({
          language: import_v452.z.string(),
          code: import_v452.z.string()
        }).nullish(),
        codeExecutionResult: import_v452.z.object({
          outcome: import_v452.z.string(),
          output: import_v452.z.string()
        }).nullish(),
        text: import_v452.z.string().nullish(),
        thought: import_v452.z.boolean().nullish(),
        thoughtSignature: import_v452.z.string().nullish()
      })
    ])
  ).nullish()
});
var getSafetyRatingSchema2 = () => import_v452.z.object({
  category: import_v452.z.string().nullish(),
  probability: import_v452.z.string().nullish(),
  probabilityScore: import_v452.z.number().nullish(),
  severity: import_v452.z.string().nullish(),
  severityScore: import_v452.z.number().nullish(),
  blocked: import_v452.z.boolean().nullish()
});
var usageSchema2 = import_v452.z.object({
  cachedContentTokenCount: import_v452.z.number().nullish(),
  thoughtsTokenCount: import_v452.z.number().nullish(),
  promptTokenCount: import_v452.z.number().nullish(),
  candidatesTokenCount: import_v452.z.number().nullish(),
  totalTokenCount: import_v452.z.number().nullish()
});
var getUrlContextMetadataSchema2 = () => import_v452.z.object({
  urlMetadata: import_v452.z.array(
    import_v452.z.object({
      retrievedUrl: import_v452.z.string(),
      urlRetrievalStatus: import_v452.z.string()
    })
  )
});
var responseSchema2 = lazySchema(
  () => zodSchema(
    import_v452.z.object({
      candidates: import_v452.z.array(
        import_v452.z.object({
          content: getContentSchema2().nullish().or(import_v452.z.object({}).strict()),
          finishReason: import_v452.z.string().nullish(),
          safetyRatings: import_v452.z.array(getSafetyRatingSchema2()).nullish(),
          groundingMetadata: getGroundingMetadataSchema2().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema2().nullish()
        })
      ),
      usageMetadata: usageSchema2.nullish(),
      promptFeedback: import_v452.z.object({
        blockReason: import_v452.z.string().nullish(),
        safetyRatings: import_v452.z.array(getSafetyRatingSchema2()).nullish()
      }).nullish()
    })
  )
);
var chunkSchema2 = lazySchema(
  () => zodSchema(
    import_v452.z.object({
      candidates: import_v452.z.array(
        import_v452.z.object({
          content: getContentSchema2().nullish(),
          finishReason: import_v452.z.string().nullish(),
          safetyRatings: import_v452.z.array(getSafetyRatingSchema2()).nullish(),
          groundingMetadata: getGroundingMetadataSchema2().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema2().nullish()
        })
      ).nullish(),
      usageMetadata: usageSchema2.nullish(),
      promptFeedback: import_v452.z.object({
        blockReason: import_v452.z.string().nullish(),
        safetyRatings: import_v452.z.array(getSafetyRatingSchema2()).nullish()
      }).nullish()
    })
  )
);
var codeExecution2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "google.code_execution",
  name: "code_execution",
  inputSchema: import_v454.z.object({
    language: import_v454.z.string().describe("The programming language of the code."),
    code: import_v454.z.string().describe("The code to be executed.")
  }),
  outputSchema: import_v454.z.object({
    outcome: import_v454.z.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
    output: import_v454.z.string().describe("The output from the code execution.")
  })
});
var googleSearch2 = createProviderDefinedToolFactory({
  id: "google.google_search",
  name: "google_search",
  inputSchema: lazySchema(
    () => zodSchema(
      import_v455.z.object({
        mode: import_v455.z.enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
        dynamicThreshold: import_v455.z.number().default(1)
      })
    )
  )
});
var urlContext2 = createProviderDefinedToolFactory({
  id: "google.url_context",
  name: "url_context",
  inputSchema: lazySchema(() => zodSchema(import_v456.z.object({})))
});
var googleTools2 = {
  /**
   * Creates a Google search tool that gives Google direct access to real-time web content.
   * Must have name "google_search".
   */
  googleSearch: googleSearch2,
  /**
   * Creates a URL context tool that gives Google direct access to real-time web content.
   * Must have name "url_context".
   */
  urlContext: urlContext2,
  /**
   * A tool that enables the model to generate and run Python code.
   * Must have name "code_execution".
   *
   * @note Ensure the selected model supports Code Execution.
   * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
   *
   * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
   * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
   */
  codeExecution: codeExecution2
};
var GoogleGenerativeAIImageModel = class {
  constructor(modelId, settings, config) {
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get maxImagesPerCall() {
    var _a4;
    return (_a4 = this.settings.maxImagesPerCall) != null ? _a4 : 4;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const {
        prompt,
        n = 1,
        size = "1024x1024",
        aspectRatio = "1:1",
        seed,
        providerOptions,
        headers,
        abortSignal
      } = options;
      const warnings = [];
      if (size != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "size",
          details: "This model does not support the `size` option. Use `aspectRatio` instead."
        });
      }
      if (seed != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "seed",
          details: "This model does not support the `seed` option through this provider."
        });
      }
      const googleOptions = yield parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleImageProviderOptionsSchema
      });
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const parameters = {
        sampleCount: n
      };
      if (aspectRatio != null) {
        parameters.aspectRatio = aspectRatio;
      }
      if (googleOptions) {
        Object.assign(parameters, googleOptions);
      }
      const body = {
        instances: [{ prompt }],
        parameters
      };
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: `${this.config.baseURL}/models/${this.modelId}:predict`,
        headers: combineHeaders(yield resolve(this.config.headers), headers),
        body,
        failedResponseHandler: googleFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          googleImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.predictions.map(
          (p) => p.bytesBase64Encoded
        ),
        warnings: warnings != null ? warnings : [],
        providerMetadata: {
          google: {
            images: response.predictions.map((prediction) => ({
              // Add any prediction-specific metadata here
            }))
          }
        },
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    });
  }
};
var googleImageResponseSchema = lazySchema(
  () => zodSchema(
    import_v457.z.object({
      predictions: import_v457.z.array(import_v457.z.object({ bytesBase64Encoded: import_v457.z.string() })).default([])
    })
  )
);
var googleImageProviderOptionsSchema = lazySchema(
  () => zodSchema(
    import_v457.z.object({
      personGeneration: import_v457.z.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
      aspectRatio: import_v457.z.enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
    })
  )
);
function createGoogleGenerativeAI(options = {}) {
  var _a4;
  const baseURL = (_a4 = withoutTrailingSlash(options.baseURL)) != null ? _a4 : "https://generativelanguage.googleapis.com/v1beta";
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      "x-goog-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
        description: "Google Generative AI"
      })
    }, options.headers),
    `ai-sdk/google/${VERSION6}`
  );
  const createChatModel = (modelId) => {
    var _a22;
    return new GoogleGenerativeAILanguageModel2(modelId, {
      provider: "google.generative-ai",
      baseURL,
      headers: getHeaders,
      generateId: (_a22 = options.generateId) != null ? _a22 : generateId,
      supportedUrls: () => ({
        "*": [
          // Google Generative Language "files" endpoint
          // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
          new RegExp(`^${baseURL}/files/.*$`),
          // YouTube URLs (public or unlisted videos)
          new RegExp(
            `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
          ),
          new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
        ]
      }),
      fetch: options.fetch
    });
  };
  const createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
    provider: "google.generative-ai",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
    provider: "google.generative-ai",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Generative AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.generativeAI = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = googleTools2;
  return provider;
}
var google = createGoogleGenerativeAI();

// ../../node_modules/.pnpm/@ai-sdk+openai-compatible@1.0.22_zod@4.2.1/node_modules/@ai-sdk/openai-compatible/dist/index.mjs
var import_provider41 = require("@ai-sdk/provider");
var import_v458 = require("zod/v4");
var import_provider42 = require("@ai-sdk/provider");
var import_v459 = require("zod/v4");
var import_v460 = require("zod/v4");
var import_provider43 = require("@ai-sdk/provider");
var import_v461 = require("zod/v4");
var import_provider44 = require("@ai-sdk/provider");
var import_v462 = require("zod/v4");
var import_provider45 = require("@ai-sdk/provider");
var import_v463 = require("zod/v4");
var import_v464 = require("zod/v4");
var import_v465 = require("zod/v4");
function getOpenAIMetadata(message) {
  var _a4, _b;
  return (_b = (_a4 = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a4.openaiCompatible) != null ? _b : {};
}
function convertToOpenAICompatibleChatMessages(prompt) {
  const messages = [];
  for (const _a4 of prompt) {
    const _b = _a4, { role, content } = _b, message = __objRest(_b, ["role", "content"]);
    const metadata = getOpenAIMetadata(__spreadValues({}, message));
    switch (role) {
      case "system": {
        messages.push(__spreadValues({ role: "system", content }, metadata));
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push(__spreadValues({
            role: "user",
            content: content[0].text
          }, getOpenAIMetadata(content[0])));
          break;
        }
        messages.push(__spreadValues({
          role: "user",
          content: content.map((part) => {
            const partMetadata = getOpenAIMetadata(part);
            switch (part.type) {
              case "text": {
                return __spreadValues({ type: "text", text: part.text }, partMetadata);
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return __spreadValues({
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }
                  }, partMetadata);
                } else {
                  throw new import_provider42.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        }, metadata));
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          const partMetadata = getOpenAIMetadata(part);
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push(__spreadValues({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              }, partMetadata));
              break;
            }
          }
        }
        messages.push(__spreadValues({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        }, metadata));
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          const toolResponseMetadata = getOpenAIMetadata(toolResponse);
          messages.push(__spreadValues({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          }, toolResponseMetadata));
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata3({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompatibleProviderOptions = import_v459.z.object({
  /**
   * A unique identifier representing your end-user, which can help the provider to
   * monitor and detect abuse.
   */
  user: import_v459.z.string().optional(),
  /**
   * Reasoning effort for reasoning models. Defaults to `medium`.
   */
  reasoningEffort: import_v459.z.string().optional(),
  /**
   * Controls the verbosity of the generated text. Defaults to `medium`.
   */
  textVerbosity: import_v459.z.string().optional()
});
var openaiCompatibleErrorDataSchema = import_v460.z.object({
  error: import_v460.z.object({
    message: import_v460.z.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: import_v460.z.string().nullish(),
    param: import_v460.z.any().nullish(),
    code: import_v460.z.union([import_v460.z.string(), import_v460.z.number()]).nullish()
  })
});
var defaultOpenAICompatibleErrorStructure = {
  errorSchema: openaiCompatibleErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function prepareTools4({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiCompatTools = [];
  for (const tool21 of tools) {
    if (tool21.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
    } else {
      openaiCompatTools.push({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: tool21.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiCompatTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiCompatTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider43.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var OpenAICompatibleChatLanguageModel = class {
  // type inferred via constructor
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a4, _b;
    this.modelId = modelId;
    this.config = config;
    const errorStructure = (_a4 = config.errorStructure) != null ? _a4 : defaultOpenAICompatibleErrorStructure;
    this.chunkSchema = createOpenAICompatibleChatChunkSchema(
      errorStructure.errorSchema
    );
    this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
    this.supportsStructuredOutputs = (_b = config.supportsStructuredOutputs) != null ? _b : false;
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get supportedUrls() {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).supportedUrls) == null ? void 0 : _b.call(_a4)) != null ? _c : {};
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      providerOptions,
      stopSequences,
      responseFormat,
      seed,
      toolChoice,
      tools
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const compatibleOptions = Object.assign(
        (_a4 = yield parseProviderOptions({
          provider: "openai-compatible",
          providerOptions,
          schema: openaiCompatibleProviderOptions
        })) != null ? _a4 : {},
        (_b = yield parseProviderOptions({
          provider: this.providerOptionsName,
          providerOptions,
          schema: openaiCompatibleProviderOptions
        })) != null ? _b : {}
      );
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is only supported with structuredOutputs"
        });
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = prepareTools4({
        tools,
        toolChoice
      });
      return {
        args: __spreadProps(__spreadValues({
          // model id:
          model: this.modelId,
          // model specific settings:
          user: compatibleOptions.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              schema: responseFormat.schema,
              name: (_c = responseFormat.name) != null ? _c : "response",
              description: responseFormat.description
            }
          } : { type: "json_object" } : void 0,
          stop: stopSequences,
          seed
        }, Object.fromEntries(
          Object.entries(
            (_d2 = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _d2 : {}
          ).filter(
            ([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key)
          )
        )), {
          reasoning_effort: compatibleOptions.reasoningEffort,
          verbosity: compatibleOptions.textVerbosity,
          // messages:
          messages: convertToOpenAICompatibleChatMessages(prompt),
          // tools:
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        }),
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
      const { args, warnings } = yield this.getArgs(__spreadValues({}, options));
      const body = JSON.stringify(args);
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: this.failedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          OpenAICompatibleChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = responseBody.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
      const reasoning = (_a4 = choice.message.reasoning_content) != null ? _a4 : choice.message.reasoning;
      if (reasoning != null && reasoning.length > 0) {
        content.push({
          type: "reasoning",
          text: reasoning
        });
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      const providerMetadata = __spreadValues({
        [this.providerOptionsName]: {}
      }, yield (_d2 = (_c = this.config.metadataExtractor) == null ? void 0 : _c.extractMetadata) == null ? void 0 : _d2.call(_c, {
        parsedBody: rawResponse
      }));
      const completionTokenDetails = (_e = responseBody.usage) == null ? void 0 : _e.completion_tokens_details;
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
        providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
      }
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
        providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
      }
      return {
        content,
        finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : void 0,
          outputTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : void 0,
          totalTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.total_tokens) != null ? _k : void 0,
          reasoningTokens: (_n = (_m = (_l = responseBody.usage) == null ? void 0 : _l.completion_tokens_details) == null ? void 0 : _m.reasoning_tokens) != null ? _n : void 0,
          cachedInputTokens: (_q = (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
        },
        providerMetadata,
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata3(responseBody)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      var _a4;
      const { args, warnings } = yield this.getArgs(__spreadValues({}, options));
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.includeUsage ? { include_usage: true } : void 0
      });
      const metadataExtractor = (_a4 = this.config.metadataExtractor) == null ? void 0 : _a4.createStreamExtractor();
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: this.failedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          this.chunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const toolCalls = [];
      let finishReason = "unknown";
      const usage = {
        completionTokens: void 0,
        completionTokensDetails: {
          reasoningTokens: void 0,
          acceptedPredictionTokens: void 0,
          rejectedPredictionTokens: void 0
        },
        promptTokens: void 0,
        promptTokensDetails: {
          cachedTokens: void 0
        },
        totalTokens: void 0
      };
      let isFirstChunk = true;
      const providerOptionsName = this.providerOptionsName;
      let isActiveReasoning = false;
      let isActiveText = false;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
            transform(chunk, controller) {
              var _a22, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error.message });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata3(value)));
              }
              if (value.usage != null) {
                const {
                  prompt_tokens,
                  completion_tokens,
                  total_tokens,
                  prompt_tokens_details,
                  completion_tokens_details
                } = value.usage;
                usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;
                usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;
                usage.totalTokens = total_tokens != null ? total_tokens : void 0;
                if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                  usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
                }
                if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                  usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
                }
                if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                  usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
                }
                if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                  usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
                }
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAICompatibleFinishReason(
                  choice.finish_reason
                );
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              const reasoningContent = (_a22 = delta.reasoning_content) != null ? _a22 : delta.reasoning;
              if (reasoningContent) {
                if (!isActiveReasoning) {
                  controller.enqueue({
                    type: "reasoning-start",
                    id: "reasoning-0"
                  });
                  isActiveReasoning = true;
                }
                controller.enqueue({
                  type: "reasoning-delta",
                  id: "reasoning-0",
                  delta: reasoningContent
                });
              }
              if (delta.content) {
                if (!isActiveText) {
                  controller.enqueue({ type: "text-start", id: "txt-0" });
                  isActiveText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "txt-0",
                  delta: delta.content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCallDelta of delta.tool_calls) {
                  const index = toolCallDelta.index;
                  if (toolCalls[index] == null) {
                    if (toolCallDelta.id == null) {
                      throw new import_provider41.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'id' to be a string.`
                      });
                    }
                    if (((_b = toolCallDelta.function) == null ? void 0 : _b.name) == null) {
                      throw new import_provider41.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function.name' to be a string.`
                      });
                    }
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallDelta.id,
                      toolName: toolCallDelta.function.name
                    });
                    toolCalls[index] = {
                      id: toolCallDelta.id,
                      type: "function",
                      function: {
                        name: toolCallDelta.function.name,
                        arguments: (_c = toolCallDelta.function.arguments) != null ? _c : ""
                      },
                      hasFinished: false
                    };
                    const toolCall2 = toolCalls[index];
                    if (((_d2 = toolCall2.function) == null ? void 0 : _d2.name) != null && ((_e = toolCall2.function) == null ? void 0 : _e.arguments) != null) {
                      if (toolCall2.function.arguments.length > 0) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                      }
                      if (isParsableJson(toolCall2.function.arguments)) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: (_f = toolCall2.id) != null ? _f : generateId(),
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.hasFinished = true;
                      }
                    }
                    continue;
                  }
                  const toolCall = toolCalls[index];
                  if (toolCall.hasFinished) {
                    continue;
                  }
                  if (((_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null) {
                    toolCall.function.arguments += (_i = (_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null ? _i : "";
                  }
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.id,
                    delta: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                  });
                  if (((_k = toolCall.function) == null ? void 0 : _k.name) != null && ((_l = toolCall.function) == null ? void 0 : _l.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_m = toolCall.id) != null ? _m : generateId(),
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                    toolCall.hasFinished = true;
                  }
                }
              }
            },
            flush(controller) {
              var _a22, _b, _c, _d2, _e, _f;
              if (isActiveReasoning) {
                controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
              }
              if (isActiveText) {
                controller.enqueue({ type: "text-end", id: "txt-0" });
              }
              for (const toolCall of toolCalls.filter(
                (toolCall2) => !toolCall2.hasFinished
              )) {
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.id
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: (_a22 = toolCall.id) != null ? _a22 : generateId(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
              }
              const providerMetadata = __spreadValues({
                [providerOptionsName]: {}
              }, metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata());
              if (usage.completionTokensDetails.acceptedPredictionTokens != null) {
                providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;
              }
              if (usage.completionTokensDetails.rejectedPredictionTokens != null) {
                providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage: {
                  inputTokens: (_b = usage.promptTokens) != null ? _b : void 0,
                  outputTokens: (_c = usage.completionTokens) != null ? _c : void 0,
                  totalTokens: (_d2 = usage.totalTokens) != null ? _d2 : void 0,
                  reasoningTokens: (_e = usage.completionTokensDetails.reasoningTokens) != null ? _e : void 0,
                  cachedInputTokens: (_f = usage.promptTokensDetails.cachedTokens) != null ? _f : void 0
                },
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var openaiCompatibleTokenUsageSchema = import_v458.z.object({
  prompt_tokens: import_v458.z.number().nullish(),
  completion_tokens: import_v458.z.number().nullish(),
  total_tokens: import_v458.z.number().nullish(),
  prompt_tokens_details: import_v458.z.object({
    cached_tokens: import_v458.z.number().nullish()
  }).nullish(),
  completion_tokens_details: import_v458.z.object({
    reasoning_tokens: import_v458.z.number().nullish(),
    accepted_prediction_tokens: import_v458.z.number().nullish(),
    rejected_prediction_tokens: import_v458.z.number().nullish()
  }).nullish()
}).nullish();
var OpenAICompatibleChatResponseSchema = import_v458.z.object({
  id: import_v458.z.string().nullish(),
  created: import_v458.z.number().nullish(),
  model: import_v458.z.string().nullish(),
  choices: import_v458.z.array(
    import_v458.z.object({
      message: import_v458.z.object({
        role: import_v458.z.literal("assistant").nullish(),
        content: import_v458.z.string().nullish(),
        reasoning_content: import_v458.z.string().nullish(),
        reasoning: import_v458.z.string().nullish(),
        tool_calls: import_v458.z.array(
          import_v458.z.object({
            id: import_v458.z.string().nullish(),
            function: import_v458.z.object({
              name: import_v458.z.string(),
              arguments: import_v458.z.string()
            })
          })
        ).nullish()
      }),
      finish_reason: import_v458.z.string().nullish()
    })
  ),
  usage: openaiCompatibleTokenUsageSchema
});
var createOpenAICompatibleChatChunkSchema = (errorSchema) => import_v458.z.union([
  import_v458.z.object({
    id: import_v458.z.string().nullish(),
    created: import_v458.z.number().nullish(),
    model: import_v458.z.string().nullish(),
    choices: import_v458.z.array(
      import_v458.z.object({
        delta: import_v458.z.object({
          role: import_v458.z.enum(["assistant"]).nullish(),
          content: import_v458.z.string().nullish(),
          // Most openai-compatible models set `reasoning_content`, but some
          // providers serving `gpt-oss` set `reasoning`. See #7866
          reasoning_content: import_v458.z.string().nullish(),
          reasoning: import_v458.z.string().nullish(),
          tool_calls: import_v458.z.array(
            import_v458.z.object({
              index: import_v458.z.number(),
              id: import_v458.z.string().nullish(),
              function: import_v458.z.object({
                name: import_v458.z.string().nullish(),
                arguments: import_v458.z.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        finish_reason: import_v458.z.string().nullish()
      })
    ),
    usage: openaiCompatibleTokenUsageSchema
  }),
  errorSchema
]);
function convertToOpenAICompatibleCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new import_provider44.InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new import_provider44.UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new import_provider44.UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata22({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAICompatibleFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompatibleCompletionProviderOptions = import_v462.z.object({
  /**
   * Echo back the prompt in addition to the completion.
   */
  echo: import_v462.z.boolean().optional(),
  /**
   * Modify the likelihood of specified tokens appearing in the completion.
   *
   * Accepts a JSON object that maps tokens (specified by their token ID in
   * the GPT tokenizer) to an associated bias value from -100 to 100.
   */
  logitBias: import_v462.z.record(import_v462.z.string(), import_v462.z.number()).optional(),
  /**
   * The suffix that comes after a completion of inserted text.
   */
  suffix: import_v462.z.string().optional(),
  /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */
  user: import_v462.z.string().optional()
});
var OpenAICompatibleCompletionLanguageModel = class {
  // type inferred via constructor
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a4;
    this.modelId = modelId;
    this.config = config;
    const errorStructure = (_a4 = config.errorStructure) != null ? _a4 : defaultOpenAICompatibleErrorStructure;
    this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(
      errorStructure.errorSchema
    );
    this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure);
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get supportedUrls() {
    var _a4, _b, _c;
    return (_c = (_b = (_a4 = this.config).supportedUrls) == null ? void 0 : _b.call(_a4)) != null ? _c : {};
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences: userStopSequences,
      responseFormat,
      seed,
      providerOptions,
      tools,
      toolChoice
    }) {
      var _a4;
      const warnings = [];
      const completionOptions = (_a4 = yield parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompatibleCompletionProviderOptions
      })) != null ? _a4 : {};
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (tools == null ? void 0 : tools.length) {
        warnings.push({ type: "unsupported-setting", setting: "tools" });
      }
      if (toolChoice != null) {
        warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
      }
      if (responseFormat != null && responseFormat.type !== "text") {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format is not supported."
        });
      }
      const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt });
      const stop2 = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
      return {
        args: __spreadProps(__spreadValues({
          // model id:
          model: this.modelId,
          // model specific settings:
          echo: completionOptions.echo,
          logit_bias: completionOptions.logitBias,
          suffix: completionOptions.suffix,
          user: completionOptions.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed
        }, providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]), {
          // prompt:
          prompt: completionPrompt,
          // stop sequences:
          stop: stop2.length > 0 ? stop2 : void 0
        }),
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f;
      const { args, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: this.failedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          openaiCompatibleCompletionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      if (choice.text != null && choice.text.length > 0) {
        content.push({ type: "text", text: choice.text });
      }
      return {
        content,
        usage: {
          inputTokens: (_b = (_a4 = response.usage) == null ? void 0 : _a4.prompt_tokens) != null ? _b : void 0,
          outputTokens: (_d2 = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d2 : void 0,
          totalTokens: (_f = (_e = response.usage) == null ? void 0 : _e.total_tokens) != null ? _f : void 0
        },
        finishReason: mapOpenAICompatibleFinishReason2(choice.finish_reason),
        request: { body: args },
        response: __spreadProps(__spreadValues({}, getResponseMetadata22(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.includeUsage ? { include_usage: true } : void 0
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: this.failedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          this.chunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata22(value)));
                controller.enqueue({
                  type: "text-start",
                  id: "0"
                });
              }
              if (value.usage != null) {
                usage.inputTokens = (_a4 = value.usage.prompt_tokens) != null ? _a4 : void 0;
                usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAICompatibleFinishReason2(
                  choice.finish_reason
                );
              }
              if ((choice == null ? void 0 : choice.text) != null) {
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: choice.text
                });
              }
            },
            flush(controller) {
              if (!isFirstChunk) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var usageSchema3 = import_v461.z.object({
  prompt_tokens: import_v461.z.number(),
  completion_tokens: import_v461.z.number(),
  total_tokens: import_v461.z.number()
});
var openaiCompatibleCompletionResponseSchema = import_v461.z.object({
  id: import_v461.z.string().nullish(),
  created: import_v461.z.number().nullish(),
  model: import_v461.z.string().nullish(),
  choices: import_v461.z.array(
    import_v461.z.object({
      text: import_v461.z.string(),
      finish_reason: import_v461.z.string()
    })
  ),
  usage: usageSchema3.nullish()
});
var createOpenAICompatibleCompletionChunkSchema = (errorSchema) => import_v461.z.union([
  import_v461.z.object({
    id: import_v461.z.string().nullish(),
    created: import_v461.z.number().nullish(),
    model: import_v461.z.string().nullish(),
    choices: import_v461.z.array(
      import_v461.z.object({
        text: import_v461.z.string(),
        finish_reason: import_v461.z.string().nullish(),
        index: import_v461.z.number()
      })
    ),
    usage: usageSchema3.nullish()
  }),
  errorSchema
]);
var openaiCompatibleEmbeddingProviderOptions = import_v464.z.object({
  /**
   * The number of dimensions the resulting output embeddings should have.
   * Only supported in text-embedding-3 and later models.
   */
  dimensions: import_v464.z.number().optional(),
  /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */
  user: import_v464.z.string().optional()
});
var OpenAICompatibleEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var _a4;
    return (_a4 = this.config.maxEmbeddingsPerCall) != null ? _a4 : 2048;
  }
  get supportsParallelCalls() {
    var _a4;
    return (_a4 = this.config.supportsParallelCalls) != null ? _a4 : true;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a4, _b, _c;
      const compatibleOptions = Object.assign(
        (_a4 = yield parseProviderOptions({
          provider: "openai-compatible",
          providerOptions,
          schema: openaiCompatibleEmbeddingProviderOptions
        })) != null ? _a4 : {},
        (_b = yield parseProviderOptions({
          provider: this.providerOptionsName,
          providerOptions,
          schema: openaiCompatibleEmbeddingProviderOptions
        })) != null ? _b : {}
      );
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider45.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/embeddings",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float",
          dimensions: compatibleOptions.dimensions,
          user: compatibleOptions.user
        },
        failedResponseHandler: createJsonErrorResponseHandler(
          (_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure
        ),
        successfulResponseHandler: createJsonResponseHandler(
          openaiTextEmbeddingResponseSchema2
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        providerMetadata: response.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var openaiTextEmbeddingResponseSchema2 = import_v463.z.object({
  data: import_v463.z.array(import_v463.z.object({ embedding: import_v463.z.array(import_v463.z.number()) })),
  usage: import_v463.z.object({ prompt_tokens: import_v463.z.number() }).nullish(),
  providerMetadata: import_v463.z.record(import_v463.z.string(), import_v463.z.record(import_v463.z.string(), import_v463.z.any())).optional()
});
var OpenAICompatibleImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 10;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(_0) {
    return __async(this, arguments, function* ({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a4, _b, _c, _d2, _e;
      const warnings = [];
      if (aspectRatio != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support aspect ratio. Use `size` instead."
        });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = yield postJsonToApi({
        url: this.config.url({
          path: "/images/generations",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: __spreadProps(__spreadValues({
          model: this.modelId,
          prompt,
          n,
          size
        }, (_d2 = providerOptions.openai) != null ? _d2 : {}), {
          response_format: "b64_json"
        }),
        failedResponseHandler: createJsonErrorResponseHandler(
          (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
        ),
        successfulResponseHandler: createJsonResponseHandler(
          openaiCompatibleImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    });
  }
};
var openaiCompatibleImageResponseSchema = import_v465.z.object({
  data: import_v465.z.array(import_v465.z.object({ b64_json: import_v465.z.string() }))
});

// ../../node_modules/.pnpm/@ai-sdk+xai@2.0.26_zod@4.2.1/node_modules/@ai-sdk/xai/dist/index.mjs
var import_provider46 = require("@ai-sdk/provider");
var import_v466 = require("zod/v4");
var import_provider47 = require("@ai-sdk/provider");
var import_v467 = require("zod/v4");
var import_v468 = require("zod/v4");
var import_provider48 = require("@ai-sdk/provider");
function convertToXaiChatMessages(prompt) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new import_provider47.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata4({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}
var webSourceSchema = import_v467.z.object({
  type: import_v467.z.literal("web"),
  country: import_v467.z.string().length(2).optional(),
  excludedWebsites: import_v467.z.array(import_v467.z.string()).max(5).optional(),
  allowedWebsites: import_v467.z.array(import_v467.z.string()).max(5).optional(),
  safeSearch: import_v467.z.boolean().optional()
});
var xSourceSchema = import_v467.z.object({
  type: import_v467.z.literal("x"),
  excludedXHandles: import_v467.z.array(import_v467.z.string()).optional(),
  includedXHandles: import_v467.z.array(import_v467.z.string()).optional(),
  postFavoriteCount: import_v467.z.number().int().optional(),
  postViewCount: import_v467.z.number().int().optional(),
  /**
   * @deprecated use `includedXHandles` instead
   */
  xHandles: import_v467.z.array(import_v467.z.string()).optional()
});
var newsSourceSchema = import_v467.z.object({
  type: import_v467.z.literal("news"),
  country: import_v467.z.string().length(2).optional(),
  excludedWebsites: import_v467.z.array(import_v467.z.string()).max(5).optional(),
  safeSearch: import_v467.z.boolean().optional()
});
var rssSourceSchema = import_v467.z.object({
  type: import_v467.z.literal("rss"),
  links: import_v467.z.array(import_v467.z.string().url()).max(1)
  // currently only supports one RSS link
});
var searchSourceSchema = import_v467.z.discriminatedUnion("type", [
  webSourceSchema,
  xSourceSchema,
  newsSourceSchema,
  rssSourceSchema
]);
var xaiProviderOptions = import_v467.z.object({
  reasoningEffort: import_v467.z.enum(["low", "high"]).optional(),
  searchParameters: import_v467.z.object({
    /**
     * search mode preference
     * - "off": disables search completely
     * - "auto": model decides whether to search (default)
     * - "on": always enables search
     */
    mode: import_v467.z.enum(["off", "auto", "on"]),
    /**
     * whether to return citations in the response
     * defaults to true
     */
    returnCitations: import_v467.z.boolean().optional(),
    /**
     * start date for search data (ISO8601 format: YYYY-MM-DD)
     */
    fromDate: import_v467.z.string().optional(),
    /**
     * end date for search data (ISO8601 format: YYYY-MM-DD)
     */
    toDate: import_v467.z.string().optional(),
    /**
     * maximum number of search results to consider
     * defaults to 20
     */
    maxSearchResults: import_v467.z.number().min(1).max(50).optional(),
    /**
     * data sources to search from
     * defaults to ["web", "x"] if not specified
     */
    sources: import_v467.z.array(searchSourceSchema).optional()
  }).optional()
});
var xaiErrorDataSchema = import_v468.z.object({
  error: import_v468.z.object({
    message: import_v468.z.string(),
    type: import_v468.z.string().nullish(),
    param: import_v468.z.any().nullish(),
    code: import_v468.z.union([import_v468.z.string(), import_v468.z.number()]).nullish()
  })
});
var xaiFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function prepareTools5({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools = [];
  for (const tool21 of tools) {
    if (tool21.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
    } else {
      xaiTools.push({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: tool21.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider48.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var XaiChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      seed,
      responseFormat,
      providerOptions,
      tools,
      toolChoice
    }) {
      var _a4, _b, _c;
      const warnings = [];
      const options = (_a4 = yield parseProviderOptions({
        provider: "xai",
        providerOptions,
        schema: xaiProviderOptions
      })) != null ? _a4 : {};
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "stopSequences"
        });
      }
      if (responseFormat != null && responseFormat.type === "json" && responseFormat.schema != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is not supported"
        });
      }
      const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
      warnings.push(...messageWarnings);
      const {
        tools: xaiTools,
        toolChoice: xaiToolChoice,
        toolWarnings
      } = prepareTools5({
        tools,
        toolChoice
      });
      warnings.push(...toolWarnings);
      const baseArgs = {
        // model id
        model: this.modelId,
        // standard generation settings
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        seed,
        reasoning_effort: options.reasoningEffort,
        // response format
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            name: (_b = responseFormat.name) != null ? _b : "response",
            schema: responseFormat.schema,
            strict: true
          }
        } : { type: "json_object" } : void 0,
        // search parameters
        search_parameters: options.searchParameters ? {
          mode: options.searchParameters.mode,
          return_citations: options.searchParameters.returnCitations,
          from_date: options.searchParameters.fromDate,
          to_date: options.searchParameters.toDate,
          max_search_results: options.searchParameters.maxSearchResults,
          sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
            var _a22;
            return __spreadValues(__spreadValues(__spreadValues(__spreadValues({
              type: source.type
            }, source.type === "web" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              allowed_websites: source.allowedWebsites,
              safe_search: source.safeSearch
            }), source.type === "x" && {
              excluded_x_handles: source.excludedXHandles,
              included_x_handles: (_a22 = source.includedXHandles) != null ? _a22 : source.xHandles,
              post_favorite_count: source.postFavoriteCount,
              post_view_count: source.postViewCount
            }), source.type === "news" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              safe_search: source.safeSearch
            }), source.type === "rss" && {
              links: source.links
            });
          })
        } : void 0,
        // messages in xai format
        messages,
        // tools in xai format
        tools: xaiTools,
        tool_choice: xaiToolChoice
      };
      return {
        args: baseArgs,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const { args: body, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: `${(_a4 = this.config.baseURL) != null ? _a4 : "https://api.x.ai/v1"}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: xaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          xaiChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      if (choice.message.content != null && choice.message.content.length > 0) {
        let text = choice.message.content;
        const lastMessage = body.messages[body.messages.length - 1];
        if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text === lastMessage.content) {
          text = "";
        }
        if (text.length > 0) {
          content.push({ type: "text", text });
        }
      }
      if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
        content.push({
          type: "reasoning",
          text: choice.message.reasoning_content
        });
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      if (response.citations != null) {
        for (const url of response.citations) {
          content.push({
            type: "source",
            sourceType: "url",
            id: this.config.generateId(),
            url
          });
        }
      }
      return {
        content,
        finishReason: mapXaiFinishReason(choice.finish_reason),
        usage: {
          inputTokens: response.usage.prompt_tokens,
          outputTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens,
          reasoningTokens: (_c = (_b = response.usage.completion_tokens_details) == null ? void 0 : _b.reasoning_tokens) != null ? _c : void 0
        },
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata4(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      var _a4;
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: {
          include_usage: true
        }
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: `${(_a4 = this.config.baseURL) != null ? _a4 : "https://api.x.ai/v1"}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: xaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(xaiChatChunkSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      const contentBlocks = {};
      const lastReasoningDeltas = {};
      const self2 = this;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a22, _b;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata4(value)));
                isFirstChunk = false;
              }
              if (value.citations != null) {
                for (const url of value.citations) {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: self2.config.generateId(),
                    url
                  });
                }
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
                usage.reasoningTokens = (_b = (_a22 = value.usage.completion_tokens_details) == null ? void 0 : _a22.reasoning_tokens) != null ? _b : void 0;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapXaiFinishReason(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              const choiceIndex = choice.index;
              if (delta.content != null && delta.content.length > 0) {
                const textContent = delta.content;
                const lastMessage = body.messages[body.messages.length - 1];
                if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                  return;
                }
                const blockId = `text-${value.id || choiceIndex}`;
                if (contentBlocks[blockId] == null) {
                  contentBlocks[blockId] = { type: "text" };
                  controller.enqueue({
                    type: "text-start",
                    id: blockId
                  });
                }
                controller.enqueue({
                  type: "text-delta",
                  id: blockId,
                  delta: textContent
                });
              }
              if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
                const blockId = `reasoning-${value.id || choiceIndex}`;
                if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                  return;
                }
                lastReasoningDeltas[blockId] = delta.reasoning_content;
                if (contentBlocks[blockId] == null) {
                  contentBlocks[blockId] = { type: "reasoning" };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: blockId
                  });
                }
                controller.enqueue({
                  type: "reasoning-delta",
                  id: blockId,
                  delta: delta.reasoning_content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCall of delta.tool_calls) {
                  const toolCallId = toolCall.id;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallId,
                    toolName: toolCall.function.name
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCallId,
                    delta: toolCall.function.arguments
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId,
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                }
              }
            },
            flush(controller) {
              for (const [blockId, block] of Object.entries(contentBlocks)) {
                controller.enqueue({
                  type: block.type === "text" ? "text-end" : "reasoning-end",
                  id: blockId
                });
              }
              controller.enqueue({ type: "finish", finishReason, usage });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var xaiUsageSchema = import_v466.z.object({
  prompt_tokens: import_v466.z.number(),
  completion_tokens: import_v466.z.number(),
  total_tokens: import_v466.z.number(),
  completion_tokens_details: import_v466.z.object({
    reasoning_tokens: import_v466.z.number().nullish()
  }).nullish()
});
var xaiChatResponseSchema = import_v466.z.object({
  id: import_v466.z.string().nullish(),
  created: import_v466.z.number().nullish(),
  model: import_v466.z.string().nullish(),
  choices: import_v466.z.array(
    import_v466.z.object({
      message: import_v466.z.object({
        role: import_v466.z.literal("assistant"),
        content: import_v466.z.string().nullish(),
        reasoning_content: import_v466.z.string().nullish(),
        tool_calls: import_v466.z.array(
          import_v466.z.object({
            id: import_v466.z.string(),
            type: import_v466.z.literal("function"),
            function: import_v466.z.object({
              name: import_v466.z.string(),
              arguments: import_v466.z.string()
            })
          })
        ).nullish()
      }),
      index: import_v466.z.number(),
      finish_reason: import_v466.z.string().nullish()
    })
  ),
  object: import_v466.z.literal("chat.completion"),
  usage: xaiUsageSchema,
  citations: import_v466.z.array(import_v466.z.string().url()).nullish()
});
var xaiChatChunkSchema = import_v466.z.object({
  id: import_v466.z.string().nullish(),
  created: import_v466.z.number().nullish(),
  model: import_v466.z.string().nullish(),
  choices: import_v466.z.array(
    import_v466.z.object({
      delta: import_v466.z.object({
        role: import_v466.z.enum(["assistant"]).optional(),
        content: import_v466.z.string().nullish(),
        reasoning_content: import_v466.z.string().nullish(),
        tool_calls: import_v466.z.array(
          import_v466.z.object({
            id: import_v466.z.string(),
            type: import_v466.z.literal("function"),
            function: import_v466.z.object({
              name: import_v466.z.string(),
              arguments: import_v466.z.string()
            })
          })
        ).nullish()
      }),
      finish_reason: import_v466.z.string().nullish(),
      index: import_v466.z.number()
    })
  ),
  usage: xaiUsageSchema.nullish(),
  citations: import_v466.z.array(import_v466.z.string().url()).nullish()
});
var VERSION7 = true ? "2.0.26" : "0.0.0-test";
var xaiErrorStructure = {
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function createXai(options = {}) {
  var _a4;
  const baseURL = withoutTrailingSlash(
    (_a4 = options.baseURL) != null ? _a4 : "https://api.x.ai/v1"
  );
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "XAI_API_KEY",
        description: "xAI API key"
      })}`
    }, options.headers),
    `ai-sdk/xai/${VERSION7}`
  );
  const createLanguageModel = (modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const createImageModel = (modelId) => {
    return new OpenAICompatibleImageModel(modelId, {
      provider: "xai.image",
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider46.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = createImageModel;
  provider.image = createImageModel;
  return provider;
}
var xai = createXai();

// ../../node_modules/.pnpm/@ai-sdk+openai@2.0.53_zod@4.2.1/node_modules/@ai-sdk/openai/dist/internal/index.mjs
var import_provider49 = require("@ai-sdk/provider");
var import_v469 = require("zod/v4");
var import_provider50 = require("@ai-sdk/provider");
var import_v470 = require("zod/v4");
var import_v471 = require("zod/v4");
var import_provider51 = require("@ai-sdk/provider");
var import_provider52 = require("@ai-sdk/provider");
var import_v472 = require("zod/v4");
var import_v473 = require("zod/v4");
var import_provider53 = require("@ai-sdk/provider");
var import_v474 = require("zod/v4");
var import_v475 = require("zod/v4");
var import_v476 = require("zod/v4");
var import_v477 = require("zod/v4");
var import_v478 = require("zod/v4");
var import_v479 = require("zod/v4");
var import_provider54 = require("@ai-sdk/provider");
var import_provider55 = require("@ai-sdk/provider");
var import_v480 = require("zod/v4");
var import_v481 = require("zod/v4");
var import_v482 = require("zod/v4");
var import_v483 = require("zod/v4");
var import_provider56 = require("@ai-sdk/provider");
var import_v484 = require("zod/v4");
var import_v485 = require("zod/v4");
var import_v486 = require("zod/v4");
var import_v487 = require("zod/v4");
var import_v488 = require("zod/v4");
var openaiErrorDataSchema2 = import_v469.z.object({
  error: import_v469.z.object({
    message: import_v469.z.string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: import_v469.z.string().nullish(),
    param: import_v469.z.any().nullish(),
    code: import_v469.z.union([import_v469.z.string(), import_v469.z.number()]).nullish()
  })
});
var openaiFailedResponseHandler2 = createJsonErrorResponseHandler({
  errorSchema: openaiErrorDataSchema2,
  errorToMessage: (data) => data.error.message
});
function convertToOpenAIChatMessages2({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a4, _b, _c;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                      // OpenAI specific extension: image detail
                      detail: (_b = (_a4 = part.providerOptions) == null ? void 0 : _a4.openai) == null ? void 0 : _b.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new import_provider50.UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  switch (part.mediaType) {
                    case "audio/wav": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "wav"
                        }
                      };
                    }
                    case "audio/mp3":
                    case "audio/mpeg": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "mp3"
                        }
                      };
                    }
                    default: {
                      throw new import_provider50.UnsupportedFunctionalityError({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                    }
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new import_provider50.UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new import_provider50.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata5({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason3(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiChatResponseSchema2 = lazyValidator(
  () => zodSchema(
    import_v470.z.object({
      id: import_v470.z.string().nullish(),
      created: import_v470.z.number().nullish(),
      model: import_v470.z.string().nullish(),
      choices: import_v470.z.array(
        import_v470.z.object({
          message: import_v470.z.object({
            role: import_v470.z.literal("assistant").nullish(),
            content: import_v470.z.string().nullish(),
            tool_calls: import_v470.z.array(
              import_v470.z.object({
                id: import_v470.z.string().nullish(),
                type: import_v470.z.literal("function"),
                function: import_v470.z.object({
                  name: import_v470.z.string(),
                  arguments: import_v470.z.string()
                })
              })
            ).nullish(),
            annotations: import_v470.z.array(
              import_v470.z.object({
                type: import_v470.z.literal("url_citation"),
                start_index: import_v470.z.number(),
                end_index: import_v470.z.number(),
                url: import_v470.z.string(),
                title: import_v470.z.string()
              })
            ).nullish()
          }),
          index: import_v470.z.number(),
          logprobs: import_v470.z.object({
            content: import_v470.z.array(
              import_v470.z.object({
                token: import_v470.z.string(),
                logprob: import_v470.z.number(),
                top_logprobs: import_v470.z.array(
                  import_v470.z.object({
                    token: import_v470.z.string(),
                    logprob: import_v470.z.number()
                  })
                )
              })
            ).nullish()
          }).nullish(),
          finish_reason: import_v470.z.string().nullish()
        })
      ),
      usage: import_v470.z.object({
        prompt_tokens: import_v470.z.number().nullish(),
        completion_tokens: import_v470.z.number().nullish(),
        total_tokens: import_v470.z.number().nullish(),
        prompt_tokens_details: import_v470.z.object({
          cached_tokens: import_v470.z.number().nullish()
        }).nullish(),
        completion_tokens_details: import_v470.z.object({
          reasoning_tokens: import_v470.z.number().nullish(),
          accepted_prediction_tokens: import_v470.z.number().nullish(),
          rejected_prediction_tokens: import_v470.z.number().nullish()
        }).nullish()
      }).nullish()
    })
  )
);
var openaiChatChunkSchema2 = lazyValidator(
  () => zodSchema(
    import_v470.z.union([
      import_v470.z.object({
        id: import_v470.z.string().nullish(),
        created: import_v470.z.number().nullish(),
        model: import_v470.z.string().nullish(),
        choices: import_v470.z.array(
          import_v470.z.object({
            delta: import_v470.z.object({
              role: import_v470.z.enum(["assistant"]).nullish(),
              content: import_v470.z.string().nullish(),
              tool_calls: import_v470.z.array(
                import_v470.z.object({
                  index: import_v470.z.number(),
                  id: import_v470.z.string().nullish(),
                  type: import_v470.z.literal("function").nullish(),
                  function: import_v470.z.object({
                    name: import_v470.z.string().nullish(),
                    arguments: import_v470.z.string().nullish()
                  })
                })
              ).nullish(),
              annotations: import_v470.z.array(
                import_v470.z.object({
                  type: import_v470.z.literal("url_citation"),
                  start_index: import_v470.z.number(),
                  end_index: import_v470.z.number(),
                  url: import_v470.z.string(),
                  title: import_v470.z.string()
                })
              ).nullish()
            }).nullish(),
            logprobs: import_v470.z.object({
              content: import_v470.z.array(
                import_v470.z.object({
                  token: import_v470.z.string(),
                  logprob: import_v470.z.number(),
                  top_logprobs: import_v470.z.array(
                    import_v470.z.object({
                      token: import_v470.z.string(),
                      logprob: import_v470.z.number()
                    })
                  )
                })
              ).nullish()
            }).nullish(),
            finish_reason: import_v470.z.string().nullish(),
            index: import_v470.z.number()
          })
        ),
        usage: import_v470.z.object({
          prompt_tokens: import_v470.z.number().nullish(),
          completion_tokens: import_v470.z.number().nullish(),
          total_tokens: import_v470.z.number().nullish(),
          prompt_tokens_details: import_v470.z.object({
            cached_tokens: import_v470.z.number().nullish()
          }).nullish(),
          completion_tokens_details: import_v470.z.object({
            reasoning_tokens: import_v470.z.number().nullish(),
            accepted_prediction_tokens: import_v470.z.number().nullish(),
            rejected_prediction_tokens: import_v470.z.number().nullish()
          }).nullish()
        }).nullish()
      }),
      openaiErrorDataSchema2
    ])
  )
);
var openaiChatLanguageModelOptions2 = lazyValidator(
  () => zodSchema(
    import_v471.z.object({
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: import_v471.z.record(import_v471.z.coerce.number(), import_v471.z.number()).optional(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       */
      logprobs: import_v471.z.union([import_v471.z.boolean(), import_v471.z.number()]).optional(),
      /**
       * Whether to enable parallel function calling during tool use. Default to true.
       */
      parallelToolCalls: import_v471.z.boolean().optional(),
      /**
       * A unique identifier representing your end-user, which can help OpenAI to
       * monitor and detect abuse.
       */
      user: import_v471.z.string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: import_v471.z.enum(["minimal", "low", "medium", "high"]).optional(),
      /**
       * Maximum number of completion tokens to generate. Useful for reasoning models.
       */
      maxCompletionTokens: import_v471.z.number().optional(),
      /**
       * Whether to enable persistence in responses API.
       */
      store: import_v471.z.boolean().optional(),
      /**
       * Metadata to associate with the request.
       */
      metadata: import_v471.z.record(import_v471.z.string().max(64), import_v471.z.string().max(512)).optional(),
      /**
       * Parameters for prediction mode.
       */
      prediction: import_v471.z.record(import_v471.z.string(), import_v471.z.any()).optional(),
      /**
       * Whether to use structured outputs.
       *
       * @default true
       */
      structuredOutputs: import_v471.z.boolean().optional(),
      /**
       * Service tier for the request.
       * - 'auto': Default service tier. The request will be processed with the service tier configured in the
       *           Project settings. Unless otherwise configured, the Project will use 'default'.
       * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
       * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
       * - 'default': The request will be processed with the standard pricing and performance for the selected model.
       *
       * @default 'auto'
       */
      serviceTier: import_v471.z.enum(["auto", "flex", "priority", "default"]).optional(),
      /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */
      strictJsonSchema: import_v471.z.boolean().optional(),
      /**
       * Controls the verbosity of the model's responses.
       * Lower values will result in more concise responses, while higher values will result in more verbose responses.
       */
      textVerbosity: import_v471.z.enum(["low", "medium", "high"]).optional(),
      /**
       * A cache key for prompt caching. Allows manual control over prompt caching behavior.
       * Useful for improving cache hit rates and working around automatic caching issues.
       */
      promptCacheKey: import_v471.z.string().optional(),
      /**
       * A stable identifier used to help detect users of your application
       * that may be violating OpenAI's usage policies. The IDs should be a
       * string that uniquely identifies each user. We recommend hashing their
       * username or email address, in order to avoid sending us any identifying
       * information.
       */
      safetyIdentifier: import_v471.z.string().optional()
    })
  )
);
function prepareChatTools2({
  tools,
  toolChoice,
  structuredOutputs,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool21 of tools) {
    switch (tool21.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool21.name,
            description: tool21.description,
            parameters: tool21.inputSchema,
            strict: structuredOutputs ? strictJsonSchema : void 0
          }
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider51.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var OpenAIChatLanguageModel2 = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const openaiOptions = (_a4 = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiChatLanguageModelOptions2
      })) != null ? _a4 : {};
      const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is only supported with structuredOutputs"
        });
      }
      const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages2(
        {
          prompt,
          systemMessageMode: getSystemMessageMode2(this.modelId)
        }
      );
      warnings.push(...messageWarnings);
      const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
      const baseArgs = {
        // model id:
        model: this.modelId,
        // model specific settings:
        logit_bias: openaiOptions.logitBias,
        logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
        top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
        user: openaiOptions.user,
        parallel_tool_calls: openaiOptions.parallelToolCalls,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d2 = responseFormat.name) != null ? _d2 : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        stop: stopSequences,
        seed,
        verbosity: openaiOptions.textVerbosity,
        // openai specific settings:
        // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
        max_completion_tokens: openaiOptions.maxCompletionTokens,
        store: openaiOptions.store,
        metadata: openaiOptions.metadata,
        prediction: openaiOptions.prediction,
        reasoning_effort: openaiOptions.reasoningEffort,
        service_tier: openaiOptions.serviceTier,
        prompt_cache_key: openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions.safetyIdentifier,
        // messages:
        messages
      };
      if (isReasoningModel2(this.modelId)) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
        if (baseArgs.frequency_penalty != null) {
          baseArgs.frequency_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty",
            details: "frequencyPenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.presence_penalty != null) {
          baseArgs.presence_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty",
            details: "presencePenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.logit_bias != null) {
          baseArgs.logit_bias = void 0;
          warnings.push({
            type: "other",
            message: "logitBias is not supported for reasoning models"
          });
        }
        if (baseArgs.logprobs != null) {
          baseArgs.logprobs = void 0;
          warnings.push({
            type: "other",
            message: "logprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.top_logprobs != null) {
          baseArgs.top_logprobs = void 0;
          warnings.push({
            type: "other",
            message: "topLogprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.max_tokens != null) {
          if (baseArgs.max_completion_tokens == null) {
            baseArgs.max_completion_tokens = baseArgs.max_tokens;
          }
          baseArgs.max_tokens = void 0;
        }
      } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for the search preview models and has been removed."
          });
        }
      }
      if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing2(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        baseArgs.service_tier = void 0;
      }
      if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing2(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        baseArgs.service_tier = void 0;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = prepareChatTools2({
        tools,
        toolChoice,
        structuredOutputs,
        strictJsonSchema
      });
      return {
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        }),
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const { args: body, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiChatResponseSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
      for (const toolCall of (_a4 = choice.message.tool_calls) != null ? _a4 : []) {
        content.push({
          type: "tool-call",
          toolCallId: (_b = toolCall.id) != null ? _b : generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
      for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
        content.push({
          type: "source",
          sourceType: "url",
          id: generateId(),
          url: annotation.url,
          title: annotation.title
        });
      }
      const completionTokenDetails = (_d2 = response.usage) == null ? void 0 : _d2.completion_tokens_details;
      const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
      const providerMetadata = { openai: {} };
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
        providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
      }
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
        providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
      }
      if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
        providerMetadata.openai.logprobs = choice.logprobs.content;
      }
      return {
        content,
        finishReason: mapOpenAIFinishReason3(choice.finish_reason),
        usage: {
          inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
          outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
          totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
          reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
          cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
        },
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata5(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings,
        providerMetadata
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: {
          include_usage: true
        }
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiChatChunkSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const toolCalls = [];
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      let isActiveText = false;
      const providerMetadata = { openai: {} };
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata5(value)));
              }
              if (value.usage != null) {
                usage.inputTokens = (_a4 = value.usage.prompt_tokens) != null ? _a4 : void 0;
                usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                usage.reasoningTokens = (_e = (_d2 = value.usage.completion_tokens_details) == null ? void 0 : _d2.reasoning_tokens) != null ? _e : void 0;
                usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                  providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                }
                if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                  providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                }
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason3(choice.finish_reason);
              }
              if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                providerMetadata.openai.logprobs = choice.logprobs.content;
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              if (delta.content != null) {
                if (!isActiveText) {
                  controller.enqueue({ type: "text-start", id: "0" });
                  isActiveText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: delta.content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCallDelta of delta.tool_calls) {
                  const index = toolCallDelta.index;
                  if (toolCalls[index] == null) {
                    if (toolCallDelta.type !== "function") {
                      throw new import_provider49.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function' type.`
                      });
                    }
                    if (toolCallDelta.id == null) {
                      throw new import_provider49.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'id' to be a string.`
                      });
                    }
                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                      throw new import_provider49.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function.name' to be a string.`
                      });
                    }
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallDelta.id,
                      toolName: toolCallDelta.function.name
                    });
                    toolCalls[index] = {
                      id: toolCallDelta.id,
                      type: "function",
                      function: {
                        name: toolCallDelta.function.name,
                        arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                      },
                      hasFinished: false
                    };
                    const toolCall2 = toolCalls[index];
                    if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                      if (toolCall2.function.arguments.length > 0) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                      }
                      if (isParsableJson(toolCall2.function.arguments)) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: (_q = toolCall2.id) != null ? _q : generateId(),
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.hasFinished = true;
                      }
                    }
                    continue;
                  }
                  const toolCall = toolCalls[index];
                  if (toolCall.hasFinished) {
                    continue;
                  }
                  if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                    toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                  }
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.id,
                    delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                  });
                  if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_x = toolCall.id) != null ? _x : generateId(),
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                    toolCall.hasFinished = true;
                  }
                }
              }
              if (delta.annotations != null) {
                for (const annotation of delta.annotations) {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: generateId(),
                    url: annotation.url,
                    title: annotation.title
                  });
                }
              }
            },
            flush(controller) {
              if (isActiveText) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue(__spreadValues({
                type: "finish",
                finishReason,
                usage
              }, providerMetadata != null ? { providerMetadata } : {}));
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function isReasoningModel2(modelId) {
  return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing2(modelId) {
  return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing2(modelId) {
  return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode2(modelId) {
  var _a4, _b;
  if (!isReasoningModel2(modelId)) {
    return "system";
  }
  return (_b = (_a4 = reasoningModels2[modelId]) == null ? void 0 : _a4.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels2 = {
  "o1-mini": {
    systemMessageMode: "remove"
  },
  "o1-mini-2024-09-12": {
    systemMessageMode: "remove"
  },
  "o1-preview": {
    systemMessageMode: "remove"
  },
  "o1-preview-2024-09-12": {
    systemMessageMode: "remove"
  },
  o3: {
    systemMessageMode: "developer"
  },
  "o3-2025-04-16": {
    systemMessageMode: "developer"
  },
  "o3-mini": {
    systemMessageMode: "developer"
  },
  "o3-mini-2025-01-31": {
    systemMessageMode: "developer"
  },
  "o4-mini": {
    systemMessageMode: "developer"
  },
  "o4-mini-2025-04-16": {
    systemMessageMode: "developer"
  }
};
function convertToOpenAICompletionPrompt2({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new import_provider52.InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new import_provider52.UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new import_provider52.UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata23({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapOpenAIFinishReason22(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompletionResponseSchema2 = lazyValidator(
  () => zodSchema(
    import_v472.z.object({
      id: import_v472.z.string().nullish(),
      created: import_v472.z.number().nullish(),
      model: import_v472.z.string().nullish(),
      choices: import_v472.z.array(
        import_v472.z.object({
          text: import_v472.z.string(),
          finish_reason: import_v472.z.string(),
          logprobs: import_v472.z.object({
            tokens: import_v472.z.array(import_v472.z.string()),
            token_logprobs: import_v472.z.array(import_v472.z.number()),
            top_logprobs: import_v472.z.array(import_v472.z.record(import_v472.z.string(), import_v472.z.number())).nullish()
          }).nullish()
        })
      ),
      usage: import_v472.z.object({
        prompt_tokens: import_v472.z.number(),
        completion_tokens: import_v472.z.number(),
        total_tokens: import_v472.z.number()
      }).nullish()
    })
  )
);
var openaiCompletionChunkSchema2 = lazyValidator(
  () => zodSchema(
    import_v472.z.union([
      import_v472.z.object({
        id: import_v472.z.string().nullish(),
        created: import_v472.z.number().nullish(),
        model: import_v472.z.string().nullish(),
        choices: import_v472.z.array(
          import_v472.z.object({
            text: import_v472.z.string(),
            finish_reason: import_v472.z.string().nullish(),
            index: import_v472.z.number(),
            logprobs: import_v472.z.object({
              tokens: import_v472.z.array(import_v472.z.string()),
              token_logprobs: import_v472.z.array(import_v472.z.number()),
              top_logprobs: import_v472.z.array(import_v472.z.record(import_v472.z.string(), import_v472.z.number())).nullish()
            }).nullish()
          })
        ),
        usage: import_v472.z.object({
          prompt_tokens: import_v472.z.number(),
          completion_tokens: import_v472.z.number(),
          total_tokens: import_v472.z.number()
        }).nullish()
      }),
      openaiErrorDataSchema2
    ])
  )
);
var openaiCompletionProviderOptions2 = lazyValidator(
  () => zodSchema(
    import_v473.z.object({
      /**
      Echo back the prompt in addition to the completion.
         */
      echo: import_v473.z.boolean().optional(),
      /**
      Modify the likelihood of specified tokens appearing in the completion.
      
      Accepts a JSON object that maps tokens (specified by their token ID in
      the GPT tokenizer) to an associated bias value from -100 to 100. You
      can use this tokenizer tool to convert text to token IDs. Mathematically,
      the bias is added to the logits generated by the model prior to sampling.
      The exact effect will vary per model, but values between -1 and 1 should
      decrease or increase likelihood of selection; values like -100 or 100
      should result in a ban or exclusive selection of the relevant token.
      
      As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
      token from being generated.
       */
      logitBias: import_v473.z.record(import_v473.z.string(), import_v473.z.number()).optional(),
      /**
      The suffix that comes after a completion of inserted text.
       */
      suffix: import_v473.z.string().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
       */
      user: import_v473.z.string().optional(),
      /**
      Return the log probabilities of the tokens. Including logprobs will increase
      the response size and can slow down response times. However, it can
      be useful to better understand how the model is behaving.
      Setting to true will return the log probabilities of the tokens that
      were generated.
      Setting to a number will return the log probabilities of the top n
      tokens that were generated.
         */
      logprobs: import_v473.z.union([import_v473.z.boolean(), import_v473.z.number()]).optional()
    })
  )
);
var OpenAICompletionLanguageModel2 = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      // No URLs are supported for completion models.
    };
    this.modelId = modelId;
    this.config = config;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences: userStopSequences,
      responseFormat,
      tools,
      toolChoice,
      seed,
      providerOptions
    }) {
      const warnings = [];
      const openaiOptions = __spreadValues(__spreadValues({}, yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiCompletionProviderOptions2
      })), yield parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompletionProviderOptions2
      }));
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (tools == null ? void 0 : tools.length) {
        warnings.push({ type: "unsupported-setting", setting: "tools" });
      }
      if (toolChoice != null) {
        warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
      }
      if (responseFormat != null && responseFormat.type !== "text") {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format is not supported."
        });
      }
      const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt2({ prompt });
      const stop2 = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
      return {
        args: {
          // model id:
          model: this.modelId,
          // model specific settings:
          echo: openaiOptions.echo,
          logit_bias: openaiOptions.logitBias,
          logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
          suffix: openaiOptions.suffix,
          user: openaiOptions.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          // prompt:
          prompt: completionPrompt,
          // stop sequences:
          stop: stop2.length > 0 ? stop2 : void 0
        },
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const { args, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiCompletionResponseSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const providerMetadata = { openai: {} };
      if (choice.logprobs != null) {
        providerMetadata.openai.logprobs = choice.logprobs;
      }
      return {
        content: [{ type: "text", text: choice.text }],
        usage: {
          inputTokens: (_a4 = response.usage) == null ? void 0 : _a4.prompt_tokens,
          outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
          totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
        },
        finishReason: mapOpenAIFinishReason22(choice.finish_reason),
        request: { body: args },
        response: __spreadProps(__spreadValues({}, getResponseMetadata23(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        providerMetadata,
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: {
          include_usage: true
        }
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiCompletionChunkSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const providerMetadata = { openai: {} };
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata23(value)));
                controller.enqueue({ type: "text-start", id: "0" });
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason22(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.logprobs) != null) {
                providerMetadata.openai.logprobs = choice.logprobs;
              }
              if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: choice.text
                });
              }
            },
            flush(controller) {
              if (!isFirstChunk) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                providerMetadata,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var openaiEmbeddingProviderOptions2 = lazyValidator(
  () => zodSchema(
    import_v474.z.object({
      /**
      The number of dimensions the resulting output embeddings should have.
      Only supported in text-embedding-3 and later models.
         */
      dimensions: import_v474.z.number().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
      */
      user: import_v474.z.string().optional()
    })
  )
);
var openaiTextEmbeddingResponseSchema3 = lazyValidator(
  () => zodSchema(
    import_v475.z.object({
      data: import_v475.z.array(import_v475.z.object({ embedding: import_v475.z.array(import_v475.z.number()) })),
      usage: import_v475.z.object({ prompt_tokens: import_v475.z.number() }).nullish()
    })
  )
);
var OpenAIEmbeddingModel2 = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a4;
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider53.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const openaiOptions = (_a4 = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiEmbeddingProviderOptions2
      })) != null ? _a4 : {};
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/embeddings",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float",
          dimensions: openaiOptions.dimensions,
          user: openaiOptions.user
        },
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiTextEmbeddingResponseSchema3
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var openaiImageResponseSchema2 = lazyValidator(
  () => zodSchema(
    import_v476.z.object({
      data: import_v476.z.array(
        import_v476.z.object({
          b64_json: import_v476.z.string(),
          revised_prompt: import_v476.z.string().optional()
        })
      )
    })
  )
);
var modelMaxImagesPerCall2 = {
  "dall-e-3": 1,
  "dall-e-2": 10,
  "gpt-image-1": 10,
  "gpt-image-1-mini": 10
};
var hasDefaultResponseFormat2 = /* @__PURE__ */ new Set([
  "gpt-image-1",
  "gpt-image-1-mini"
]);
var OpenAIImageModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get maxImagesPerCall() {
    var _a4;
    return (_a4 = modelMaxImagesPerCall2[this.modelId]) != null ? _a4 : 1;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(_0) {
    return __async(this, arguments, function* ({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      if (aspectRatio != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support aspect ratio. Use `size` instead."
        });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = yield postJsonToApi({
        url: this.config.url({
          path: "/images/generations",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: __spreadValues(__spreadValues({
          model: this.modelId,
          prompt,
          n,
          size
        }, (_d2 = providerOptions.openai) != null ? _d2 : {}), !hasDefaultResponseFormat2.has(this.modelId) ? { response_format: "b64_json" } : {}),
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiImageResponseSchema2
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        },
        providerMetadata: {
          openai: {
            images: response.data.map(
              (item) => item.revised_prompt ? {
                revisedPrompt: item.revised_prompt
              } : null
            )
          }
        }
      };
    });
  }
};
var openaiTranscriptionResponseSchema2 = lazyValidator(
  () => zodSchema(
    import_v477.z.object({
      text: import_v477.z.string(),
      language: import_v477.z.string().nullish(),
      duration: import_v477.z.number().nullish(),
      words: import_v477.z.array(
        import_v477.z.object({
          word: import_v477.z.string(),
          start: import_v477.z.number(),
          end: import_v477.z.number()
        })
      ).nullish(),
      segments: import_v477.z.array(
        import_v477.z.object({
          id: import_v477.z.number(),
          seek: import_v477.z.number(),
          start: import_v477.z.number(),
          end: import_v477.z.number(),
          text: import_v477.z.string(),
          tokens: import_v477.z.array(import_v477.z.number()),
          temperature: import_v477.z.number(),
          avg_logprob: import_v477.z.number(),
          compression_ratio: import_v477.z.number(),
          no_speech_prob: import_v477.z.number()
        })
      ).nullish()
    })
  )
);
var openAITranscriptionProviderOptions2 = lazyValidator(
  () => zodSchema(
    import_v478.z.object({
      /**
       * Additional information to include in the transcription response.
       */
      include: import_v478.z.array(import_v478.z.string()).optional(),
      /**
       * The language of the input audio in ISO-639-1 format.
       */
      language: import_v478.z.string().optional(),
      /**
       * An optional text to guide the model's style or continue a previous audio segment.
       */
      prompt: import_v478.z.string().optional(),
      /**
       * The sampling temperature, between 0 and 1.
       * @default 0
       */
      temperature: import_v478.z.number().min(0).max(1).default(0).optional(),
      /**
       * The timestamp granularities to populate for this transcription.
       * @default ['segment']
       */
      timestampGranularities: import_v478.z.array(import_v478.z.enum(["word", "segment"])).default(["segment"]).optional()
    })
  )
);
var languageMap2 = {
  afrikaans: "af",
  arabic: "ar",
  armenian: "hy",
  azerbaijani: "az",
  belarusian: "be",
  bosnian: "bs",
  bulgarian: "bg",
  catalan: "ca",
  chinese: "zh",
  croatian: "hr",
  czech: "cs",
  danish: "da",
  dutch: "nl",
  english: "en",
  estonian: "et",
  finnish: "fi",
  french: "fr",
  galician: "gl",
  german: "de",
  greek: "el",
  hebrew: "he",
  hindi: "hi",
  hungarian: "hu",
  icelandic: "is",
  indonesian: "id",
  italian: "it",
  japanese: "ja",
  kannada: "kn",
  kazakh: "kk",
  korean: "ko",
  latvian: "lv",
  lithuanian: "lt",
  macedonian: "mk",
  malay: "ms",
  marathi: "mr",
  maori: "mi",
  nepali: "ne",
  norwegian: "no",
  persian: "fa",
  polish: "pl",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "sr",
  slovak: "sk",
  slovenian: "sl",
  spanish: "es",
  swahili: "sw",
  swedish: "sv",
  tagalog: "tl",
  tamil: "ta",
  thai: "th",
  turkish: "tr",
  ukrainian: "uk",
  urdu: "ur",
  vietnamese: "vi",
  welsh: "cy"
};
var OpenAITranscriptionModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      audio,
      mediaType,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openAITranscriptionProviderOptions2
      });
      const formData = new FormData();
      const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
      formData.append("model", this.modelId);
      const fileExtension = mediaTypeToExtension(mediaType);
      formData.append(
        "file",
        new File([blob], "audio", { type: mediaType }),
        `audio.${fileExtension}`
      );
      if (openAIOptions) {
        const transcriptionModelOptions = {
          include: openAIOptions.include,
          language: openAIOptions.language,
          prompt: openAIOptions.prompt,
          // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
          // prefer verbose_json to get segments for models that support it
          response_format: [
            "gpt-4o-transcribe",
            "gpt-4o-mini-transcribe"
          ].includes(this.modelId) ? "json" : "verbose_json",
          temperature: openAIOptions.temperature,
          timestamp_granularities: openAIOptions.timestampGranularities
        };
        for (const [key, value] of Object.entries(transcriptionModelOptions)) {
          if (value != null) {
            if (Array.isArray(value)) {
              for (const item of value) {
                formData.append(`${key}[]`, String(item));
              }
            } else {
              formData.append(key, String(value));
            }
          }
        }
      }
      return {
        formData,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h;
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { formData, warnings } = yield this.getArgs(options);
      const {
        value: response,
        responseHeaders,
        rawValue: rawResponse
      } = yield postFormDataToApi({
        url: this.config.url({
          path: "/audio/transcriptions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        formData,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiTranscriptionResponseSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const language = response.language != null && response.language in languageMap2 ? languageMap2[response.language] : void 0;
      return {
        text: response.text,
        segments: (_g = (_f = (_d2 = response.segments) == null ? void 0 : _d2.map((segment) => ({
          text: segment.text,
          startSecond: segment.start,
          endSecond: segment.end
        }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
          text: word.word,
          startSecond: word.start,
          endSecond: word.end
        }))) != null ? _g : [],
        language,
        durationInSeconds: (_h = response.duration) != null ? _h : void 0,
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
};
var openaiSpeechProviderOptionsSchema2 = lazyValidator(
  () => zodSchema(
    import_v479.z.object({
      instructions: import_v479.z.string().nullish(),
      speed: import_v479.z.number().min(0.25).max(4).default(1).nullish()
    })
  )
);
var OpenAISpeechModel2 = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      text,
      voice = "alloy",
      outputFormat = "mp3",
      speed,
      instructions,
      language,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiSpeechProviderOptionsSchema2
      });
      const requestBody = {
        model: this.modelId,
        input: text,
        voice,
        response_format: "mp3",
        speed,
        instructions
      };
      if (outputFormat) {
        if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
          requestBody.response_format = outputFormat;
        } else {
          warnings.push({
            type: "unsupported-setting",
            setting: "outputFormat",
            details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
          });
        }
      }
      if (openAIOptions) {
        const speechModelOptions = {};
        for (const key in speechModelOptions) {
          const value = speechModelOptions[key];
          if (value !== void 0) {
            requestBody[key] = value;
          }
        }
      }
      if (language) {
        warnings.push({
          type: "unsupported-setting",
          setting: "language",
          details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
        });
      }
      return {
        requestBody,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { requestBody, warnings } = yield this.getArgs(options);
      const {
        value: audio,
        responseHeaders,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/audio/speech",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: requestBody,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createBinaryResponseHandler(),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      return {
        audio,
        warnings,
        request: {
          body: JSON.stringify(requestBody)
        },
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
};
var localShellInputSchema2 = lazySchema(
  () => zodSchema(
    import_v481.z.object({
      action: import_v481.z.object({
        type: import_v481.z.literal("exec"),
        command: import_v481.z.array(import_v481.z.string()),
        timeoutMs: import_v481.z.number().optional(),
        user: import_v481.z.string().optional(),
        workingDirectory: import_v481.z.string().optional(),
        env: import_v481.z.record(import_v481.z.string(), import_v481.z.string()).optional()
      })
    })
  )
);
var localShellOutputSchema2 = lazySchema(
  () => zodSchema(import_v481.z.object({ output: import_v481.z.string() }))
);
var localShell2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.local_shell",
  name: "local_shell",
  inputSchema: localShellInputSchema2,
  outputSchema: localShellOutputSchema2
});
function isFileId2(data, prefixes) {
  if (!prefixes) return false;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
function convertToOpenAIResponsesInput2(_0) {
  return __async(this, arguments, function* ({
    prompt,
    systemMessageMode,
    fileIdPrefixes,
    store,
    hasLocalShellTool = false
  }) {
    var _a4, _b, _c, _d2;
    const input = [];
    const warnings = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          switch (systemMessageMode) {
            case "system": {
              input.push({ role: "system", content });
              break;
            }
            case "developer": {
              input.push({ role: "developer", content });
              break;
            }
            case "remove": {
              warnings.push({
                type: "other",
                message: "system messages are removed for this model"
              });
              break;
            }
            default: {
              const _exhaustiveCheck = systemMessageMode;
              throw new Error(
                `Unsupported system message mode: ${_exhaustiveCheck}`
              );
            }
          }
          break;
        }
        case "user": {
          input.push({
            role: "user",
            content: content.map((part, index) => {
              var _a22, _b2, _c2;
              switch (part.type) {
                case "text": {
                  return { type: "input_text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return __spreadProps(__spreadValues({
                      type: "input_image"
                    }, part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId2(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }), {
                      detail: (_b2 = (_a22 = part.providerOptions) == null ? void 0 : _a22.openai) == null ? void 0 : _b2.imageDetail
                    });
                  } else if (part.mediaType === "application/pdf") {
                    if (part.data instanceof URL) {
                      return {
                        type: "input_file",
                        file_url: part.data.toString()
                      };
                    }
                    return __spreadValues({
                      type: "input_file"
                    }, typeof part.data === "string" && isFileId2(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    });
                  } else {
                    throw new import_provider55.UnsupportedFunctionalityError({
                      functionality: `file part media type ${part.mediaType}`
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          const reasoningMessages = {};
          const toolCallParts = {};
          for (const part of content) {
            switch (part.type) {
              case "text": {
                const id = (_b = (_a4 = part.providerOptions) == null ? void 0 : _a4.openai) == null ? void 0 : _b.itemId;
                if (store && id != null) {
                  input.push({ type: "item_reference", id });
                  break;
                }
                input.push({
                  role: "assistant",
                  content: [{ type: "output_text", text: part.text }],
                  id
                });
                break;
              }
              case "tool-call": {
                toolCallParts[part.toolCallId] = part;
                if (part.providerExecuted) {
                  break;
                }
                const id = (_d2 = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d2.itemId;
                if (store && id != null) {
                  input.push({ type: "item_reference", id });
                  break;
                }
                if (hasLocalShellTool && part.toolName === "local_shell") {
                  const parsedInput = yield validateTypes({
                    value: part.input,
                    schema: localShellInputSchema2
                  });
                  input.push({
                    type: "local_shell_call",
                    call_id: part.toolCallId,
                    id,
                    action: {
                      type: "exec",
                      command: parsedInput.action.command,
                      timeout_ms: parsedInput.action.timeoutMs,
                      user: parsedInput.action.user,
                      working_directory: parsedInput.action.workingDirectory,
                      env: parsedInput.action.env
                    }
                  });
                  break;
                }
                input.push({
                  type: "function_call",
                  call_id: part.toolCallId,
                  name: part.toolName,
                  arguments: JSON.stringify(part.input),
                  id
                });
                break;
              }
              // assistant tool result parts are from provider-executed tools:
              case "tool-result": {
                if (store) {
                  input.push({ type: "item_reference", id: part.toolCallId });
                } else {
                  warnings.push({
                    type: "other",
                    message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                  });
                }
                break;
              }
              case "reasoning": {
                const providerOptions = yield parseProviderOptions({
                  provider: "openai",
                  providerOptions: part.providerOptions,
                  schema: openaiResponsesReasoningProviderOptionsSchema2
                });
                const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                if (reasoningId != null) {
                  const reasoningMessage = reasoningMessages[reasoningId];
                  if (store) {
                    if (reasoningMessage === void 0) {
                      input.push({ type: "item_reference", id: reasoningId });
                      reasoningMessages[reasoningId] = {
                        type: "reasoning",
                        id: reasoningId,
                        summary: []
                      };
                    }
                  } else {
                    const summaryParts = [];
                    if (part.text.length > 0) {
                      summaryParts.push({
                        type: "summary_text",
                        text: part.text
                      });
                    } else if (reasoningMessage !== void 0) {
                      warnings.push({
                        type: "other",
                        message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                      });
                    }
                    if (reasoningMessage === void 0) {
                      reasoningMessages[reasoningId] = {
                        type: "reasoning",
                        id: reasoningId,
                        encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                        summary: summaryParts
                      };
                      input.push(reasoningMessages[reasoningId]);
                    } else {
                      reasoningMessage.summary.push(...summaryParts);
                      if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                        reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                      }
                    }
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                  });
                }
                break;
              }
            }
          }
          break;
        }
        case "tool": {
          for (const part of content) {
            const output = part.output;
            if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
              const parsedOutput = yield validateTypes({
                value: output.value,
                schema: localShellOutputSchema2
              });
              input.push({
                type: "local_shell_call_output",
                call_id: part.toolCallId,
                output: parsedOutput.output
              });
              break;
            }
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
              case "content":
                contentValue = output.value.map((item) => {
                  switch (item.type) {
                    case "text": {
                      return { type: "input_text", text: item.text };
                    }
                    case "media": {
                      return item.mediaType.startsWith("image/") ? {
                        type: "input_image",
                        image_url: `data:${item.mediaType};base64,${item.data}`
                      } : {
                        type: "input_file",
                        filename: "data",
                        file_data: `data:${item.mediaType};base64,${item.data}`
                      };
                    }
                  }
                });
                break;
            }
            input.push({
              type: "function_call_output",
              call_id: part.toolCallId,
              output: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return { input, warnings };
  });
}
var openaiResponsesReasoningProviderOptionsSchema2 = import_v480.z.object({
  itemId: import_v480.z.string().nullish(),
  reasoningEncryptedContent: import_v480.z.string().nullish()
});
function mapOpenAIResponseFinishReason2({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "unknown";
  }
}
var openaiResponsesChunkSchema2 = lazyValidator(
  () => zodSchema(
    import_v482.z.union([
      import_v482.z.object({
        type: import_v482.z.literal("response.output_text.delta"),
        item_id: import_v482.z.string(),
        delta: import_v482.z.string(),
        logprobs: import_v482.z.array(
          import_v482.z.object({
            token: import_v482.z.string(),
            logprob: import_v482.z.number(),
            top_logprobs: import_v482.z.array(
              import_v482.z.object({
                token: import_v482.z.string(),
                logprob: import_v482.z.number()
              })
            )
          })
        ).nullish()
      }),
      import_v482.z.object({
        type: import_v482.z.enum(["response.completed", "response.incomplete"]),
        response: import_v482.z.object({
          incomplete_details: import_v482.z.object({ reason: import_v482.z.string() }).nullish(),
          usage: import_v482.z.object({
            input_tokens: import_v482.z.number(),
            input_tokens_details: import_v482.z.object({ cached_tokens: import_v482.z.number().nullish() }).nullish(),
            output_tokens: import_v482.z.number(),
            output_tokens_details: import_v482.z.object({ reasoning_tokens: import_v482.z.number().nullish() }).nullish()
          }),
          service_tier: import_v482.z.string().nullish()
        })
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.created"),
        response: import_v482.z.object({
          id: import_v482.z.string(),
          created_at: import_v482.z.number(),
          model: import_v482.z.string(),
          service_tier: import_v482.z.string().nullish()
        })
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.output_item.added"),
        output_index: import_v482.z.number(),
        item: import_v482.z.discriminatedUnion("type", [
          import_v482.z.object({
            type: import_v482.z.literal("message"),
            id: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("reasoning"),
            id: import_v482.z.string(),
            encrypted_content: import_v482.z.string().nullish()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("function_call"),
            id: import_v482.z.string(),
            call_id: import_v482.z.string(),
            name: import_v482.z.string(),
            arguments: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("web_search_call"),
            id: import_v482.z.string(),
            status: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("computer_call"),
            id: import_v482.z.string(),
            status: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("file_search_call"),
            id: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("image_generation_call"),
            id: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("code_interpreter_call"),
            id: import_v482.z.string(),
            container_id: import_v482.z.string(),
            code: import_v482.z.string().nullable(),
            outputs: import_v482.z.array(
              import_v482.z.discriminatedUnion("type", [
                import_v482.z.object({ type: import_v482.z.literal("logs"), logs: import_v482.z.string() }),
                import_v482.z.object({ type: import_v482.z.literal("image"), url: import_v482.z.string() })
              ])
            ).nullable(),
            status: import_v482.z.string()
          })
        ])
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.output_item.done"),
        output_index: import_v482.z.number(),
        item: import_v482.z.discriminatedUnion("type", [
          import_v482.z.object({
            type: import_v482.z.literal("message"),
            id: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("reasoning"),
            id: import_v482.z.string(),
            encrypted_content: import_v482.z.string().nullish()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("function_call"),
            id: import_v482.z.string(),
            call_id: import_v482.z.string(),
            name: import_v482.z.string(),
            arguments: import_v482.z.string(),
            status: import_v482.z.literal("completed")
          }),
          import_v482.z.object({
            type: import_v482.z.literal("code_interpreter_call"),
            id: import_v482.z.string(),
            code: import_v482.z.string().nullable(),
            container_id: import_v482.z.string(),
            outputs: import_v482.z.array(
              import_v482.z.discriminatedUnion("type", [
                import_v482.z.object({ type: import_v482.z.literal("logs"), logs: import_v482.z.string() }),
                import_v482.z.object({ type: import_v482.z.literal("image"), url: import_v482.z.string() })
              ])
            ).nullable()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("image_generation_call"),
            id: import_v482.z.string(),
            result: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("web_search_call"),
            id: import_v482.z.string(),
            status: import_v482.z.string(),
            action: import_v482.z.discriminatedUnion("type", [
              import_v482.z.object({
                type: import_v482.z.literal("search"),
                query: import_v482.z.string().nullish()
              }),
              import_v482.z.object({
                type: import_v482.z.literal("open_page"),
                url: import_v482.z.string()
              }),
              import_v482.z.object({
                type: import_v482.z.literal("find"),
                url: import_v482.z.string(),
                pattern: import_v482.z.string()
              })
            ])
          }),
          import_v482.z.object({
            type: import_v482.z.literal("file_search_call"),
            id: import_v482.z.string(),
            queries: import_v482.z.array(import_v482.z.string()),
            results: import_v482.z.array(
              import_v482.z.object({
                attributes: import_v482.z.record(import_v482.z.string(), import_v482.z.unknown()),
                file_id: import_v482.z.string(),
                filename: import_v482.z.string(),
                score: import_v482.z.number(),
                text: import_v482.z.string()
              })
            ).nullish()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("local_shell_call"),
            id: import_v482.z.string(),
            call_id: import_v482.z.string(),
            action: import_v482.z.object({
              type: import_v482.z.literal("exec"),
              command: import_v482.z.array(import_v482.z.string()),
              timeout_ms: import_v482.z.number().optional(),
              user: import_v482.z.string().optional(),
              working_directory: import_v482.z.string().optional(),
              env: import_v482.z.record(import_v482.z.string(), import_v482.z.string()).optional()
            })
          }),
          import_v482.z.object({
            type: import_v482.z.literal("computer_call"),
            id: import_v482.z.string(),
            status: import_v482.z.literal("completed")
          })
        ])
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.function_call_arguments.delta"),
        item_id: import_v482.z.string(),
        output_index: import_v482.z.number(),
        delta: import_v482.z.string()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.image_generation_call.partial_image"),
        item_id: import_v482.z.string(),
        output_index: import_v482.z.number(),
        partial_image_b64: import_v482.z.string()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.code_interpreter_call_code.delta"),
        item_id: import_v482.z.string(),
        output_index: import_v482.z.number(),
        delta: import_v482.z.string()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.code_interpreter_call_code.done"),
        item_id: import_v482.z.string(),
        output_index: import_v482.z.number(),
        code: import_v482.z.string()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.output_text.annotation.added"),
        annotation: import_v482.z.discriminatedUnion("type", [
          import_v482.z.object({
            type: import_v482.z.literal("url_citation"),
            url: import_v482.z.string(),
            title: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("file_citation"),
            file_id: import_v482.z.string(),
            filename: import_v482.z.string().nullish(),
            index: import_v482.z.number().nullish(),
            start_index: import_v482.z.number().nullish(),
            end_index: import_v482.z.number().nullish(),
            quote: import_v482.z.string().nullish()
          })
        ])
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.reasoning_summary_part.added"),
        item_id: import_v482.z.string(),
        summary_index: import_v482.z.number()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.reasoning_summary_text.delta"),
        item_id: import_v482.z.string(),
        summary_index: import_v482.z.number(),
        delta: import_v482.z.string()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("response.reasoning_summary_part.done"),
        item_id: import_v482.z.string(),
        summary_index: import_v482.z.number()
      }),
      import_v482.z.object({
        type: import_v482.z.literal("error"),
        code: import_v482.z.string(),
        message: import_v482.z.string(),
        param: import_v482.z.string().nullish(),
        sequence_number: import_v482.z.number()
      }),
      import_v482.z.object({ type: import_v482.z.string() }).loose().transform((value) => ({
        type: "unknown_chunk",
        message: value.type
      }))
      // fallback for unknown chunks
    ])
  )
);
var openaiResponsesResponseSchema2 = lazyValidator(
  () => zodSchema(
    import_v482.z.object({
      id: import_v482.z.string(),
      created_at: import_v482.z.number(),
      error: import_v482.z.object({
        code: import_v482.z.string(),
        message: import_v482.z.string()
      }).nullish(),
      model: import_v482.z.string(),
      output: import_v482.z.array(
        import_v482.z.discriminatedUnion("type", [
          import_v482.z.object({
            type: import_v482.z.literal("message"),
            role: import_v482.z.literal("assistant"),
            id: import_v482.z.string(),
            content: import_v482.z.array(
              import_v482.z.object({
                type: import_v482.z.literal("output_text"),
                text: import_v482.z.string(),
                logprobs: import_v482.z.array(
                  import_v482.z.object({
                    token: import_v482.z.string(),
                    logprob: import_v482.z.number(),
                    top_logprobs: import_v482.z.array(
                      import_v482.z.object({
                        token: import_v482.z.string(),
                        logprob: import_v482.z.number()
                      })
                    )
                  })
                ).nullish(),
                annotations: import_v482.z.array(
                  import_v482.z.discriminatedUnion("type", [
                    import_v482.z.object({
                      type: import_v482.z.literal("url_citation"),
                      start_index: import_v482.z.number(),
                      end_index: import_v482.z.number(),
                      url: import_v482.z.string(),
                      title: import_v482.z.string()
                    }),
                    import_v482.z.object({
                      type: import_v482.z.literal("file_citation"),
                      file_id: import_v482.z.string(),
                      filename: import_v482.z.string().nullish(),
                      index: import_v482.z.number().nullish(),
                      start_index: import_v482.z.number().nullish(),
                      end_index: import_v482.z.number().nullish(),
                      quote: import_v482.z.string().nullish()
                    }),
                    import_v482.z.object({
                      type: import_v482.z.literal("container_file_citation")
                    })
                  ])
                )
              })
            )
          }),
          import_v482.z.object({
            type: import_v482.z.literal("web_search_call"),
            id: import_v482.z.string(),
            status: import_v482.z.string(),
            action: import_v482.z.discriminatedUnion("type", [
              import_v482.z.object({
                type: import_v482.z.literal("search"),
                query: import_v482.z.string().nullish()
              }),
              import_v482.z.object({
                type: import_v482.z.literal("open_page"),
                url: import_v482.z.string()
              }),
              import_v482.z.object({
                type: import_v482.z.literal("find"),
                url: import_v482.z.string(),
                pattern: import_v482.z.string()
              })
            ])
          }),
          import_v482.z.object({
            type: import_v482.z.literal("file_search_call"),
            id: import_v482.z.string(),
            queries: import_v482.z.array(import_v482.z.string()),
            results: import_v482.z.array(
              import_v482.z.object({
                attributes: import_v482.z.record(import_v482.z.string(), import_v482.z.unknown()),
                file_id: import_v482.z.string(),
                filename: import_v482.z.string(),
                score: import_v482.z.number(),
                text: import_v482.z.string()
              })
            ).nullish()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("code_interpreter_call"),
            id: import_v482.z.string(),
            code: import_v482.z.string().nullable(),
            container_id: import_v482.z.string(),
            outputs: import_v482.z.array(
              import_v482.z.discriminatedUnion("type", [
                import_v482.z.object({ type: import_v482.z.literal("logs"), logs: import_v482.z.string() }),
                import_v482.z.object({ type: import_v482.z.literal("image"), url: import_v482.z.string() })
              ])
            ).nullable()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("image_generation_call"),
            id: import_v482.z.string(),
            result: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("local_shell_call"),
            id: import_v482.z.string(),
            call_id: import_v482.z.string(),
            action: import_v482.z.object({
              type: import_v482.z.literal("exec"),
              command: import_v482.z.array(import_v482.z.string()),
              timeout_ms: import_v482.z.number().optional(),
              user: import_v482.z.string().optional(),
              working_directory: import_v482.z.string().optional(),
              env: import_v482.z.record(import_v482.z.string(), import_v482.z.string()).optional()
            })
          }),
          import_v482.z.object({
            type: import_v482.z.literal("function_call"),
            call_id: import_v482.z.string(),
            name: import_v482.z.string(),
            arguments: import_v482.z.string(),
            id: import_v482.z.string()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("computer_call"),
            id: import_v482.z.string(),
            status: import_v482.z.string().optional()
          }),
          import_v482.z.object({
            type: import_v482.z.literal("reasoning"),
            id: import_v482.z.string(),
            encrypted_content: import_v482.z.string().nullish(),
            summary: import_v482.z.array(
              import_v482.z.object({
                type: import_v482.z.literal("summary_text"),
                text: import_v482.z.string()
              })
            )
          })
        ])
      ),
      service_tier: import_v482.z.string().nullish(),
      incomplete_details: import_v482.z.object({ reason: import_v482.z.string() }).nullish(),
      usage: import_v482.z.object({
        input_tokens: import_v482.z.number(),
        input_tokens_details: import_v482.z.object({ cached_tokens: import_v482.z.number().nullish() }).nullish(),
        output_tokens: import_v482.z.number(),
        output_tokens_details: import_v482.z.object({ reasoning_tokens: import_v482.z.number().nullish() }).nullish()
      })
    })
  )
);
var TOP_LOGPROBS_MAX2 = 20;
var openaiResponsesReasoningModelIds2 = [
  "o1",
  "o1-2024-12-17",
  "o3-mini",
  "o3-mini-2025-01-31",
  "o3",
  "o3-2025-04-16",
  "o4-mini",
  "o4-mini-2025-04-16",
  "codex-mini-latest",
  "computer-use-preview",
  "gpt-5",
  "gpt-5-2025-08-07",
  "gpt-5-codex",
  "gpt-5-mini",
  "gpt-5-mini-2025-08-07",
  "gpt-5-nano",
  "gpt-5-nano-2025-08-07",
  "gpt-5-pro",
  "gpt-5-pro-2025-10-06"
];
var openaiResponsesModelIds2 = [
  "gpt-4.1",
  "gpt-4.1-2025-04-14",
  "gpt-4.1-mini",
  "gpt-4.1-mini-2025-04-14",
  "gpt-4.1-nano",
  "gpt-4.1-nano-2025-04-14",
  "gpt-4o",
  "gpt-4o-2024-05-13",
  "gpt-4o-2024-08-06",
  "gpt-4o-2024-11-20",
  "gpt-4o-audio-preview",
  "gpt-4o-audio-preview-2024-10-01",
  "gpt-4o-audio-preview-2024-12-17",
  "gpt-4o-search-preview",
  "gpt-4o-search-preview-2025-03-11",
  "gpt-4o-mini-search-preview",
  "gpt-4o-mini-search-preview-2025-03-11",
  "gpt-4o-mini",
  "gpt-4o-mini-2024-07-18",
  "gpt-4-turbo",
  "gpt-4-turbo-2024-04-09",
  "gpt-4-turbo-preview",
  "gpt-4-0125-preview",
  "gpt-4-1106-preview",
  "gpt-4",
  "gpt-4-0613",
  "gpt-4.5-preview",
  "gpt-4.5-preview-2025-02-27",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-1106",
  "chatgpt-4o-latest",
  "gpt-5-chat-latest",
  ...openaiResponsesReasoningModelIds2
];
var openaiResponsesProviderOptionsSchema2 = lazyValidator(
  () => zodSchema(
    import_v483.z.object({
      include: import_v483.z.array(
        import_v483.z.enum([
          "reasoning.encrypted_content",
          // handled internally by default, only needed for unknown reasoning models
          "file_search_call.results",
          "message.output_text.logprobs"
        ])
      ).nullish(),
      instructions: import_v483.z.string().nullish(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       *
       * @see https://platform.openai.com/docs/api-reference/responses/create
       * @see https://cookbook.openai.com/examples/using_logprobs
       */
      logprobs: import_v483.z.union([import_v483.z.boolean(), import_v483.z.number().min(1).max(TOP_LOGPROBS_MAX2)]).optional(),
      /**
       * The maximum number of total calls to built-in tools that can be processed in a response.
       * This maximum number applies across all built-in tool calls, not per individual tool.
       * Any further attempts to call a tool by the model will be ignored.
       */
      maxToolCalls: import_v483.z.number().nullish(),
      metadata: import_v483.z.any().nullish(),
      parallelToolCalls: import_v483.z.boolean().nullish(),
      previousResponseId: import_v483.z.string().nullish(),
      promptCacheKey: import_v483.z.string().nullish(),
      reasoningEffort: import_v483.z.string().nullish(),
      reasoningSummary: import_v483.z.string().nullish(),
      safetyIdentifier: import_v483.z.string().nullish(),
      serviceTier: import_v483.z.enum(["auto", "flex", "priority", "default"]).nullish(),
      store: import_v483.z.boolean().nullish(),
      strictJsonSchema: import_v483.z.boolean().nullish(),
      textVerbosity: import_v483.z.enum(["low", "medium", "high"]).nullish(),
      truncation: import_v483.z.enum(["auto", "disabled"]).nullish(),
      user: import_v483.z.string().nullish()
    })
  )
);
var codeInterpreterInputSchema2 = lazySchema(
  () => zodSchema(
    import_v484.z.object({
      code: import_v484.z.string().nullish(),
      containerId: import_v484.z.string()
    })
  )
);
var codeInterpreterOutputSchema2 = lazySchema(
  () => zodSchema(
    import_v484.z.object({
      outputs: import_v484.z.array(
        import_v484.z.discriminatedUnion("type", [
          import_v484.z.object({ type: import_v484.z.literal("logs"), logs: import_v484.z.string() }),
          import_v484.z.object({ type: import_v484.z.literal("image"), url: import_v484.z.string() })
        ])
      ).nullish()
    })
  )
);
var codeInterpreterArgsSchema2 = lazySchema(
  () => zodSchema(
    import_v484.z.object({
      container: import_v484.z.union([
        import_v484.z.string(),
        import_v484.z.object({
          fileIds: import_v484.z.array(import_v484.z.string()).optional()
        })
      ]).optional()
    })
  )
);
var codeInterpreterToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.code_interpreter",
  name: "code_interpreter",
  inputSchema: codeInterpreterInputSchema2,
  outputSchema: codeInterpreterOutputSchema2
});
var codeInterpreter2 = (args = {}) => {
  return codeInterpreterToolFactory2(args);
};
var comparisonFilterSchema2 = import_v485.z.object({
  key: import_v485.z.string(),
  type: import_v485.z.enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
  value: import_v485.z.union([import_v485.z.string(), import_v485.z.number(), import_v485.z.boolean()])
});
var compoundFilterSchema2 = import_v485.z.object({
  type: import_v485.z.enum(["and", "or"]),
  filters: import_v485.z.array(
    import_v485.z.union([comparisonFilterSchema2, import_v485.z.lazy(() => compoundFilterSchema2)])
  )
});
var fileSearchArgsSchema3 = lazySchema(
  () => zodSchema(
    import_v485.z.object({
      vectorStoreIds: import_v485.z.array(import_v485.z.string()),
      maxNumResults: import_v485.z.number().optional(),
      ranking: import_v485.z.object({
        ranker: import_v485.z.string().optional(),
        scoreThreshold: import_v485.z.number().optional()
      }).optional(),
      filters: import_v485.z.union([comparisonFilterSchema2, compoundFilterSchema2]).optional()
    })
  )
);
var fileSearchOutputSchema2 = lazySchema(
  () => zodSchema(
    import_v485.z.object({
      queries: import_v485.z.array(import_v485.z.string()),
      results: import_v485.z.array(
        import_v485.z.object({
          attributes: import_v485.z.record(import_v485.z.string(), import_v485.z.unknown()),
          fileId: import_v485.z.string(),
          filename: import_v485.z.string(),
          score: import_v485.z.number(),
          text: import_v485.z.string()
        })
      ).nullable()
    })
  )
);
var fileSearch3 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.file_search",
  name: "file_search",
  inputSchema: import_v485.z.object({}),
  outputSchema: fileSearchOutputSchema2
});
var webSearchArgsSchema2 = lazySchema(
  () => zodSchema(
    import_v486.z.object({
      filters: import_v486.z.object({ allowedDomains: import_v486.z.array(import_v486.z.string()).optional() }).optional(),
      searchContextSize: import_v486.z.enum(["low", "medium", "high"]).optional(),
      userLocation: import_v486.z.object({
        type: import_v486.z.literal("approximate"),
        country: import_v486.z.string().optional(),
        city: import_v486.z.string().optional(),
        region: import_v486.z.string().optional(),
        timezone: import_v486.z.string().optional()
      }).optional()
    })
  )
);
var webSearchInputSchema2 = lazySchema(() => zodSchema(import_v486.z.object({})));
var webSearchOutputSchema2 = lazySchema(
  () => zodSchema(
    import_v486.z.object({
      action: import_v486.z.discriminatedUnion("type", [
        import_v486.z.object({
          type: import_v486.z.literal("search"),
          query: import_v486.z.string().optional()
        }),
        import_v486.z.object({
          type: import_v486.z.literal("openPage"),
          url: import_v486.z.string()
        }),
        import_v486.z.object({
          type: import_v486.z.literal("find"),
          url: import_v486.z.string(),
          pattern: import_v486.z.string()
        })
      ])
    })
  )
);
var webSearchToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search",
  name: "web_search",
  inputSchema: webSearchInputSchema2,
  outputSchema: webSearchOutputSchema2
});
var webSearchPreviewArgsSchema2 = lazySchema(
  () => zodSchema(
    import_v487.z.object({
      searchContextSize: import_v487.z.enum(["low", "medium", "high"]).optional(),
      userLocation: import_v487.z.object({
        type: import_v487.z.literal("approximate"),
        country: import_v487.z.string().optional(),
        city: import_v487.z.string().optional(),
        region: import_v487.z.string().optional(),
        timezone: import_v487.z.string().optional()
      }).optional()
    })
  )
);
var webSearchPreviewInputSchema2 = lazySchema(
  () => zodSchema(import_v487.z.object({}))
);
var webSearchPreviewOutputSchema2 = lazySchema(
  () => zodSchema(
    import_v487.z.object({
      action: import_v487.z.discriminatedUnion("type", [
        import_v487.z.object({
          type: import_v487.z.literal("search"),
          query: import_v487.z.string().optional()
        }),
        import_v487.z.object({
          type: import_v487.z.literal("openPage"),
          url: import_v487.z.string()
        }),
        import_v487.z.object({
          type: import_v487.z.literal("find"),
          url: import_v487.z.string(),
          pattern: import_v487.z.string()
        })
      ])
    })
  )
);
var webSearchPreview2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search_preview",
  name: "web_search_preview",
  inputSchema: webSearchPreviewInputSchema2,
  outputSchema: webSearchPreviewOutputSchema2
});
var imageGenerationArgsSchema2 = lazySchema(
  () => zodSchema(
    import_v488.z.object({
      background: import_v488.z.enum(["auto", "opaque", "transparent"]).optional(),
      inputFidelity: import_v488.z.enum(["low", "high"]).optional(),
      inputImageMask: import_v488.z.object({
        fileId: import_v488.z.string().optional(),
        imageUrl: import_v488.z.string().optional()
      }).optional(),
      model: import_v488.z.string().optional(),
      moderation: import_v488.z.enum(["auto"]).optional(),
      outputCompression: import_v488.z.number().int().min(0).max(100).optional(),
      outputFormat: import_v488.z.enum(["png", "jpeg", "webp"]).optional(),
      partialImages: import_v488.z.number().int().min(0).max(3).optional(),
      quality: import_v488.z.enum(["auto", "low", "medium", "high"]).optional(),
      size: import_v488.z.enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
    }).strict()
  )
);
var imageGenerationInputSchema2 = lazySchema(() => zodSchema(import_v488.z.object({})));
var imageGenerationOutputSchema2 = lazySchema(
  () => zodSchema(import_v488.z.object({ result: import_v488.z.string() }))
);
var imageGenerationToolFactory2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.image_generation",
  name: "image_generation",
  inputSchema: imageGenerationInputSchema2,
  outputSchema: imageGenerationOutputSchema2
});
var imageGeneration2 = (args = {}) => {
  return imageGenerationToolFactory2(args);
};
function prepareResponsesTools2(_0) {
  return __async(this, arguments, function* ({
    tools,
    toolChoice,
    strictJsonSchema
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const openaiTools2 = [];
    for (const tool21 of tools) {
      switch (tool21.type) {
        case "function":
          openaiTools2.push({
            type: "function",
            name: tool21.name,
            description: tool21.description,
            parameters: tool21.inputSchema,
            strict: strictJsonSchema
          });
          break;
        case "provider-defined": {
          switch (tool21.id) {
            case "openai.file_search": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: fileSearchArgsSchema3
              });
              openaiTools2.push({
                type: "file_search",
                vector_store_ids: args.vectorStoreIds,
                max_num_results: args.maxNumResults,
                ranking_options: args.ranking ? {
                  ranker: args.ranking.ranker,
                  score_threshold: args.ranking.scoreThreshold
                } : void 0,
                filters: args.filters
              });
              break;
            }
            case "openai.local_shell": {
              openaiTools2.push({
                type: "local_shell"
              });
              break;
            }
            case "openai.web_search_preview": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: webSearchPreviewArgsSchema2
              });
              openaiTools2.push({
                type: "web_search_preview",
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            case "openai.web_search": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: webSearchArgsSchema2
              });
              openaiTools2.push({
                type: "web_search",
                filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            case "openai.code_interpreter": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: codeInterpreterArgsSchema2
              });
              openaiTools2.push({
                type: "code_interpreter",
                container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
              });
              break;
            }
            case "openai.image_generation": {
              const args = yield validateTypes({
                value: tool21.args,
                schema: imageGenerationArgsSchema2
              });
              openaiTools2.push({
                type: "image_generation",
                background: args.background,
                input_fidelity: args.inputFidelity,
                input_image_mask: args.inputImageMask ? {
                  file_id: args.inputImageMask.fileId,
                  image_url: args.inputImageMask.imageUrl
                } : void 0,
                model: args.model,
                size: args.size,
                quality: args.quality,
                moderation: args.moderation,
                output_format: args.outputFormat,
                output_compression: args.outputCompression
              });
              break;
            }
          }
          break;
        }
        default:
          toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
          break;
      }
    }
    if (toolChoice == null) {
      return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
      case "required":
        return { tools: openaiTools2, toolChoice: type, toolWarnings };
      case "tool":
        return {
          tools: openaiTools2,
          toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new import_provider56.UnsupportedFunctionalityError({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  });
}
var OpenAIResponsesLanguageModel2 = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/],
      "application/pdf": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      maxOutputTokens,
      temperature,
      stopSequences,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      seed,
      prompt,
      providerOptions,
      tools,
      toolChoice,
      responseFormat
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const modelConfig = getResponsesModelConfig2(this.modelId);
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
      }
      const openaiOptions = yield parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiResponsesProviderOptionsSchema2
      });
      const { input, warnings: inputWarnings } = yield convertToOpenAIResponsesInput2({
        prompt,
        systemMessageMode: modelConfig.systemMessageMode,
        fileIdPrefixes: this.config.fileIdPrefixes,
        store: (_a4 = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a4 : true,
        hasLocalShellTool: hasOpenAITool("openai.local_shell")
      });
      warnings.push(...inputWarnings);
      const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
      let include = openaiOptions == null ? void 0 : openaiOptions.include;
      function addInclude(key) {
        if (include == null) {
          include = [key];
        } else if (!include.includes(key)) {
          include = [...include, key];
        }
      }
      function hasOpenAITool(id) {
        return (tools == null ? void 0 : tools.find(
          (tool21) => tool21.type === "provider-defined" && tool21.id === id
        )) != null;
      }
      const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX2 : void 0;
      if (topLogprobs) {
        addInclude("message.output_text.logprobs");
      }
      const webSearchToolName = (_c = tools == null ? void 0 : tools.find(
        (tool21) => tool21.type === "provider-defined" && (tool21.id === "openai.web_search" || tool21.id === "openai.web_search_preview")
      )) == null ? void 0 : _c.name;
      if (webSearchToolName) {
        addInclude("web_search_call.action.sources");
      }
      if (hasOpenAITool("openai.code_interpreter")) {
        addInclude("code_interpreter_call.outputs");
      }
      const store = openaiOptions == null ? void 0 : openaiOptions.store;
      if (store === false && modelConfig.isReasoningModel) {
        addInclude("reasoning.encrypted_content");
      }
      const baseArgs = __spreadValues(__spreadProps(__spreadValues({
        model: this.modelId,
        input,
        temperature,
        top_p: topP,
        max_output_tokens: maxOutputTokens
      }, ((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
        text: __spreadValues(__spreadValues({}, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
          format: responseFormat.schema != null ? {
            type: "json_schema",
            strict: strictJsonSchema,
            name: (_d2 = responseFormat.name) != null ? _d2 : "response",
            description: responseFormat.description,
            schema: responseFormat.schema
          } : { type: "json_object" }
        }), (openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
          verbosity: openaiOptions.textVerbosity
        })
      }), {
        // provider options:
        max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
        metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
        parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
        previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
        store,
        user: openaiOptions == null ? void 0 : openaiOptions.user,
        instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
        service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
        include,
        prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
        top_logprobs: topLogprobs,
        truncation: openaiOptions == null ? void 0 : openaiOptions.truncation
      }), modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
        reasoning: __spreadValues(__spreadValues({}, (openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
          effort: openaiOptions.reasoningEffort
        }), (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
          summary: openaiOptions.reasoningSummary
        })
      });
      if (modelConfig.isReasoningModel) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
      } else {
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningEffort",
            details: "reasoningEffort is not supported for non-reasoning models"
          });
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningSummary",
            details: "reasoningSummary is not supported for non-reasoning models"
          });
        }
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        delete baseArgs.service_tier;
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        delete baseArgs.service_tier;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = yield prepareResponsesTools2({
        tools,
        toolChoice,
        strictJsonSchema
      });
      return {
        webSearchToolName,
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        }),
        warnings: [...warnings, ...toolWarnings],
        store
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
      const {
        args: body,
        warnings,
        webSearchToolName
      } = yield this.getArgs(options);
      const url = this.config.url({
        path: "/responses",
        modelId: this.modelId
      });
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createJsonResponseHandler(
          openaiResponsesResponseSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      if (response.error) {
        throw new import_provider54.APICallError({
          message: response.error.message,
          url,
          requestBodyValues: body,
          statusCode: 400,
          responseHeaders,
          responseBody: rawResponse,
          isRetryable: false
        });
      }
      const content = [];
      const logprobs = [];
      let hasFunctionCall = false;
      for (const part of response.output) {
        switch (part.type) {
          case "reasoning": {
            if (part.summary.length === 0) {
              part.summary.push({ type: "summary_text", text: "" });
            }
            for (const summary of part.summary) {
              content.push({
                type: "reasoning",
                text: summary.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id,
                    reasoningEncryptedContent: (_a4 = part.encrypted_content) != null ? _a4 : null
                  }
                }
              });
            }
            break;
          }
          case "image_generation_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "image_generation",
              input: "{}",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "image_generation",
              result: {
                result: part.result
              },
              providerExecuted: true
            });
            break;
          }
          case "local_shell_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.call_id,
              toolName: "local_shell",
              input: JSON.stringify({
                action: part.action
              }),
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            break;
          }
          case "message": {
            for (const contentPart of part.content) {
              if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                logprobs.push(contentPart.logprobs);
              }
              content.push({
                type: "text",
                text: contentPart.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id
                  }
                }
              });
              for (const annotation of contentPart.annotations) {
                if (annotation.type === "url_citation") {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: (_f = (_e = (_d2 = this.config).generateId) == null ? void 0 : _e.call(_d2)) != null ? _f : generateId(),
                    url: annotation.url,
                    title: annotation.title
                  });
                } else if (annotation.type === "file_citation") {
                  content.push({
                    type: "source",
                    sourceType: "document",
                    id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                    mediaType: "text/plain",
                    title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                    filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                  });
                }
              }
            }
            break;
          }
          case "function_call": {
            hasFunctionCall = true;
            content.push({
              type: "tool-call",
              toolCallId: part.call_id,
              toolName: part.name,
              input: part.arguments,
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            break;
          }
          case "web_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: webSearchToolName != null ? webSearchToolName : "web_search",
              input: JSON.stringify({}),
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: webSearchToolName != null ? webSearchToolName : "web_search",
              result: mapWebSearchOutput2(part.action),
              providerExecuted: true
            });
            break;
          }
          case "computer_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "computer_use",
              input: "",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "computer_use",
              result: {
                type: "computer_use_tool_result",
                status: part.status || "completed"
              },
              providerExecuted: true
            });
            break;
          }
          case "file_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "file_search",
              input: "{}",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "file_search",
              result: {
                queries: part.queries,
                results: (_n = (_m = part.results) == null ? void 0 : _m.map((result) => ({
                  attributes: result.attributes,
                  fileId: result.file_id,
                  filename: result.filename,
                  score: result.score,
                  text: result.text
                }))) != null ? _n : null
              },
              providerExecuted: true
            });
            break;
          }
          case "code_interpreter_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "code_interpreter",
              input: JSON.stringify({
                code: part.code,
                containerId: part.container_id
              }),
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "code_interpreter",
              result: {
                outputs: part.outputs
              },
              providerExecuted: true
            });
            break;
          }
        }
      }
      const providerMetadata = {
        openai: { responseId: response.id }
      };
      if (logprobs.length > 0) {
        providerMetadata.openai.logprobs = logprobs;
      }
      if (typeof response.service_tier === "string") {
        providerMetadata.openai.serviceTier = response.service_tier;
      }
      return {
        content,
        finishReason: mapOpenAIResponseFinishReason2({
          finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
          hasFunctionCall
        }),
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
          reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
          cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
        },
        request: { body },
        response: {
          id: response.id,
          timestamp: new Date(response.created_at * 1e3),
          modelId: response.model,
          headers: responseHeaders,
          body: rawResponse
        },
        providerMetadata,
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const {
        args: body,
        warnings,
        webSearchToolName,
        store
      } = yield this.getArgs(options);
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/responses",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, body), {
          stream: true
        }),
        failedResponseHandler: openaiFailedResponseHandler2,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiResponsesChunkSchema2
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const self2 = this;
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const logprobs = [];
      let responseId = null;
      const ongoingToolCalls = {};
      let hasFunctionCall = false;
      const activeReasoning = {};
      let serviceTier;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isResponseOutputItemAddedChunk2(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: value.item.name,
                    toolCallId: value.item.call_id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.call_id,
                    toolName: value.item.name
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "web_search",
                    input: JSON.stringify({}),
                    providerExecuted: true
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "computer_use",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "computer_use",
                    providerExecuted: true
                  });
                } else if (value.item.type === "code_interpreter_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "code_interpreter",
                    toolCallId: value.item.id,
                    codeInterpreter: {
                      containerId: value.item.container_id
                    }
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "code_interpreter",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: value.item.id,
                    delta: `{"containerId":"${value.item.container_id}","code":"`
                  });
                } else if (value.item.type === "file_search_call") {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    input: "{}",
                    providerExecuted: true
                  });
                } else if (value.item.type === "image_generation_call") {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "image_generation",
                    input: "{}",
                    providerExecuted: true
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-start",
                    id: value.item.id,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (isResponseOutputItemAddedChunk2(value) && value.item.type === "reasoning") {
                  activeReasoning[value.item.id] = {
                    encryptedContent: value.item.encrypted_content,
                    summaryParts: { 0: "active" }
                  };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item.id}:0`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id,
                        reasoningEncryptedContent: (_a4 = value.item.encrypted_content) != null ? _a4 : null
                      }
                    }
                  });
                }
              } else if (isResponseOutputItemDoneChunk2(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasFunctionCall = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.call_id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.call_id,
                    toolName: value.item.name,
                    input: value.item.arguments,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "web_search",
                    result: mapWebSearchOutput2(value.item.action),
                    providerExecuted: true
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    input: "",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    result: {
                      type: "computer_use_tool_result",
                      status: value.item.status || "completed"
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "file_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    result: {
                      queries: value.item.queries,
                      results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result) => ({
                        attributes: result.attributes,
                        fileId: result.file_id,
                        filename: result.filename,
                        score: result.score,
                        text: result.text
                      }))) != null ? _c : null
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "code_interpreter_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "code_interpreter",
                    result: {
                      outputs: value.item.outputs
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "image_generation_call") {
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "image_generation",
                    result: {
                      result: value.item.result
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "local_shell_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.call_id,
                    toolName: "local_shell",
                    input: JSON.stringify({
                      action: {
                        type: "exec",
                        command: value.item.action.command,
                        timeoutMs: value.item.action.timeout_ms,
                        user: value.item.action.user,
                        workingDirectory: value.item.action.working_directory,
                        env: value.item.action.env
                      }
                    }),
                    providerMetadata: {
                      openai: { itemId: value.item.id }
                    }
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-end",
                    id: value.item.id
                  });
                } else if (value.item.type === "reasoning") {
                  const activeReasoningPart = activeReasoning[value.item.id];
                  const summaryPartIndices = Object.entries(
                    activeReasoningPart.summaryParts
                  ).filter(
                    ([_, status]) => status === "active" || status === "can-conclude"
                  ).map(([summaryIndex]) => summaryIndex);
                  for (const summaryIndex of summaryPartIndices) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value.item.id}:${summaryIndex}`,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id,
                          reasoningEncryptedContent: (_d2 = value.item.encrypted_content) != null ? _d2 : null
                        }
                      }
                    });
                  }
                  delete activeReasoning[value.item.id];
                }
              } else if (isResponseFunctionCallArgumentsDeltaChunk2(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: value.delta
                  });
                }
              } else if (isResponseCodeInterpreterCallCodeDeltaChunk2(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    // The delta is code, which is embedding in a JSON string.
                    // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                    delta: JSON.stringify(value.delta).slice(1, -1)
                  });
                }
              } else if (isResponseCodeInterpreterCallCodeDoneChunk2(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: '"}'
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: toolCall.toolCallId,
                    toolName: "code_interpreter",
                    input: JSON.stringify({
                      code: value.code,
                      containerId: toolCall.codeInterpreter.containerId
                    }),
                    providerExecuted: true
                  });
                }
              } else if (isResponseCreatedChunk2(value)) {
                responseId = value.response.id;
                controller.enqueue({
                  type: "response-metadata",
                  id: value.response.id,
                  timestamp: new Date(value.response.created_at * 1e3),
                  modelId: value.response.model
                });
              } else if (isTextDeltaChunk2(value)) {
                controller.enqueue({
                  type: "text-delta",
                  id: value.item_id,
                  delta: value.delta
                });
                if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                  logprobs.push(value.logprobs);
                }
              } else if (value.type === "response.reasoning_summary_part.added") {
                if (value.summary_index > 0) {
                  const activeReasoningPart = activeReasoning[value.item_id];
                  activeReasoningPart.summaryParts[value.summary_index] = "active";
                  for (const summaryIndex of Object.keys(
                    activeReasoningPart.summaryParts
                  )) {
                    if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: `${value.item_id}:${summaryIndex}`,
                        providerMetadata: { openai: { itemId: value.item_id } }
                      });
                      activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                    }
                  }
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item_id}:${value.summary_index}`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item_id,
                        reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                      }
                    }
                  });
                }
              } else if (value.type === "response.reasoning_summary_text.delta") {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: `${value.item_id}:${value.summary_index}`,
                  delta: value.delta,
                  providerMetadata: {
                    openai: {
                      itemId: value.item_id
                    }
                  }
                });
              } else if (value.type === "response.reasoning_summary_part.done") {
                if (store) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: `${value.item_id}:${value.summary_index}`,
                    providerMetadata: {
                      openai: { itemId: value.item_id }
                    }
                  });
                  activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                } else {
                  activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                }
              } else if (isResponseFinishedChunk2(value)) {
                finishReason = mapOpenAIResponseFinishReason2({
                  finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                  hasFunctionCall
                });
                usage.inputTokens = value.response.usage.input_tokens;
                usage.outputTokens = value.response.usage.output_tokens;
                usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                if (typeof value.response.service_tier === "string") {
                  serviceTier = value.response.service_tier;
                }
              } else if (isResponseAnnotationAddedChunk2(value)) {
                if (value.annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: (_p = (_o = (_n = self2.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId(),
                    url: value.annotation.url,
                    title: value.annotation.title
                  });
                } else if (value.annotation.type === "file_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "document",
                    id: (_s = (_r = (_q = self2.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId(),
                    mediaType: "text/plain",
                    title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                    filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                  });
                }
              } else if (isErrorChunk2(value)) {
                controller.enqueue({ type: "error", error: value });
              }
            },
            flush(controller) {
              const providerMetadata = {
                openai: {
                  responseId
                }
              };
              if (logprobs.length > 0) {
                providerMetadata.openai.logprobs = logprobs;
              }
              if (serviceTier !== void 0) {
                providerMetadata.openai.serviceTier = serviceTier;
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function isTextDeltaChunk2(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk2(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk2(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk2(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk2(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk2(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk2(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk2(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk2(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk2(chunk) {
  return chunk.type === "error";
}
function getResponsesModelConfig2(modelId) {
  const supportsFlexProcessing22 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsPriorityProcessing22 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  const defaults2 = {
    systemMessageMode: "system",
    supportsFlexProcessing: supportsFlexProcessing22,
    supportsPriorityProcessing: supportsPriorityProcessing22
  };
  if (modelId.startsWith("gpt-5-chat")) {
    return __spreadProps(__spreadValues({}, defaults2), {
      isReasoningModel: false
    });
  }
  if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
    if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
      return __spreadProps(__spreadValues({}, defaults2), {
        isReasoningModel: true,
        systemMessageMode: "remove"
      });
    }
    return __spreadProps(__spreadValues({}, defaults2), {
      isReasoningModel: true,
      systemMessageMode: "developer"
    });
  }
  return __spreadProps(__spreadValues({}, defaults2), {
    isReasoningModel: false
  });
}
function mapWebSearchOutput2(action) {
  var _a4;
  switch (action.type) {
    case "search":
      return { action: { type: "search", query: (_a4 = action.query) != null ? _a4 : void 0 } };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find":
      return {
        action: { type: "find", url: action.url, pattern: action.pattern }
      };
  }
}

// ../../node_modules/.pnpm/@ai-sdk+azure@2.0.54_zod@4.2.1/node_modules/@ai-sdk/azure/dist/index.mjs
var azureOpenaiTools = {
  codeInterpreter: codeInterpreter2,
  fileSearch: fileSearch3,
  imageGeneration: imageGeneration2
};
var VERSION8 = true ? "2.0.54" : "0.0.0-test";
function createAzure(options = {}) {
  var _a4;
  const getHeaders = () => {
    const baseHeaders = __spreadValues({
      "api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "AZURE_API_KEY",
        description: "Azure OpenAI"
      })
    }, options.headers);
    return withUserAgentSuffix(baseHeaders, `ai-sdk/azure/${VERSION8}`);
  };
  const getResourceName = () => loadSetting({
    settingValue: options.resourceName,
    settingName: "resourceName",
    environmentVariableName: "AZURE_RESOURCE_NAME",
    description: "Azure OpenAI resource name"
  });
  const apiVersion = (_a4 = options.apiVersion) != null ? _a4 : "v1";
  const url = ({ path: path8, modelId }) => {
    var _a22;
    const baseUrlPrefix = (_a22 = options.baseURL) != null ? _a22 : `https://${getResourceName()}.openai.azure.com/openai`;
    let fullUrl;
    if (options.useDeploymentBasedUrls) {
      fullUrl = new URL(`${baseUrlPrefix}/deployments/${modelId}${path8}`);
    } else {
      fullUrl = new URL(`${baseUrlPrefix}/v1${path8}`);
    }
    fullUrl.searchParams.set("api-version", apiVersion);
    return fullUrl.toString();
  };
  const createChatModel = (deploymentName) => new OpenAIChatLanguageModel2(deploymentName, {
    provider: "azure.chat",
    url,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel2(modelId, {
    provider: "azure.completion",
    url,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel2(modelId, {
    provider: "azure.embeddings",
    headers: getHeaders,
    url,
    fetch: options.fetch
  });
  const createResponsesModel = (modelId) => new OpenAIResponsesLanguageModel2(modelId, {
    provider: "azure.responses",
    url,
    headers: getHeaders,
    fetch: options.fetch,
    fileIdPrefixes: ["assistant-"]
  });
  const createImageModel = (modelId) => new OpenAIImageModel2(modelId, {
    provider: "azure.image",
    url,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel2(modelId, {
    provider: "azure.transcription",
    url,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createSpeechModel = (modelId) => new OpenAISpeechModel2(modelId, {
    provider: "azure.speech",
    url,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(deploymentId) {
    if (new.target) {
      throw new Error(
        "The Azure OpenAI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(deploymentId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.embedding = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.responses = createResponsesModel;
  provider.transcription = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.tools = azureOpenaiTools;
  return provider;
}
var azure = createAzure();

// ../../node_modules/.pnpm/@ai-sdk+groq@2.0.24_zod@4.2.1/node_modules/@ai-sdk/groq/dist/index.mjs
var import_provider57 = require("@ai-sdk/provider");
var import_provider58 = require("@ai-sdk/provider");
var import_v489 = require("zod/v4");
var import_provider59 = require("@ai-sdk/provider");
var import_v490 = require("zod/v4");
var import_v491 = require("zod/v4");
var import_provider60 = require("@ai-sdk/provider");
var import_v492 = require("zod/v4");
var import_v493 = require("zod/v4");
function convertToGroqChatMessages(prompt) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (!part.mediaType.startsWith("image/")) {
                  throw new import_provider59.UnsupportedFunctionalityError({
                    functionality: "Non-image file content parts"
                  });
                }
                const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                return {
                  type: "image_url",
                  image_url: {
                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                  }
                };
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            // groq supports reasoning for tool-calls in multi-turn conversations
            // https://github.com/vercel/ai/issues/7860
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push(__spreadValues(__spreadValues({
          role: "assistant",
          content: text
        }, reasoning.length > 0 ? { reasoning } : null), toolCalls.length > 0 ? { tool_calls: toolCalls } : null));
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata6({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
var groqProviderOptions = import_v490.z.object({
  reasoningFormat: import_v490.z.enum(["parsed", "raw", "hidden"]).optional(),
  reasoningEffort: import_v490.z.string().optional(),
  /**
   * Whether to enable parallel function calling during tool use. Default to true.
   */
  parallelToolCalls: import_v490.z.boolean().optional(),
  /**
   * A unique identifier representing your end-user, which can help OpenAI to
   * monitor and detect abuse. Learn more.
   */
  user: import_v490.z.string().optional(),
  /**
   * Whether to use structured outputs.
   *
   * @default true
   */
  structuredOutputs: import_v490.z.boolean().optional(),
  /**
   * Service tier for the request.
   * - 'on_demand': Default tier with consistent performance and fairness
   * - 'flex': Higher throughput tier optimized for workloads that can handle occasional request failures
   * - 'auto': Uses on_demand rate limits, then falls back to flex tier if exceeded
   *
   * @default 'on_demand'
   */
  serviceTier: import_v490.z.enum(["on_demand", "flex", "auto"]).optional()
});
var groqErrorDataSchema = import_v491.z.object({
  error: import_v491.z.object({
    message: import_v491.z.string(),
    type: import_v491.z.string()
  })
});
var groqFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: groqErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
var BROWSER_SEARCH_SUPPORTED_MODELS = [
  "openai/gpt-oss-20b",
  "openai/gpt-oss-120b"
];
function isBrowserSearchSupportedModel(modelId) {
  return BROWSER_SEARCH_SUPPORTED_MODELS.includes(modelId);
}
function getSupportedModelsString() {
  return BROWSER_SEARCH_SUPPORTED_MODELS.join(", ");
}
function prepareTools6({
  tools,
  toolChoice,
  modelId
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const groqTools2 = [];
  for (const tool21 of tools) {
    if (tool21.type === "provider-defined") {
      if (tool21.id === "groq.browser_search") {
        if (!isBrowserSearchSupportedModel(modelId)) {
          toolWarnings.push({
            type: "unsupported-tool",
            tool: tool21,
            details: `Browser search is only supported on the following models: ${getSupportedModelsString()}. Current model: ${modelId}`
          });
        } else {
          groqTools2.push({
            type: "browser_search"
          });
        }
      } else {
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
      }
    } else {
      groqTools2.push({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: tool21.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: groqTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: groqTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: groqTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider60.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGroqFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var GroqChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      stream,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a4, _b;
      const warnings = [];
      const groqOptions = yield parseProviderOptions({
        provider: "groq",
        providerOptions,
        schema: groqProviderOptions
      });
      const structuredOutputs = (_a4 = groqOptions == null ? void 0 : groqOptions.structuredOutputs) != null ? _a4 : true;
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is only supported with structuredOutputs"
        });
      }
      const {
        tools: groqTools2,
        toolChoice: groqToolChoice,
        toolWarnings
      } = prepareTools6({ tools, toolChoice, modelId: this.modelId });
      return {
        args: {
          // model id:
          model: this.modelId,
          // model specific settings:
          user: groqOptions == null ? void 0 : groqOptions.user,
          parallel_tool_calls: groqOptions == null ? void 0 : groqOptions.parallelToolCalls,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          stop: stopSequences,
          seed,
          // response format:
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
            type: "json_schema",
            json_schema: {
              schema: responseFormat.schema,
              name: (_b = responseFormat.name) != null ? _b : "response",
              description: responseFormat.description
            }
          } : { type: "json_object" } : void 0,
          // provider options:
          reasoning_format: groqOptions == null ? void 0 : groqOptions.reasoningFormat,
          reasoning_effort: groqOptions == null ? void 0 : groqOptions.reasoningEffort,
          service_tier: groqOptions == null ? void 0 : groqOptions.serviceTier,
          // messages:
          messages: convertToGroqChatMessages(prompt),
          // tools:
          tools: groqTools2,
          tool_choice: groqToolChoice
        },
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j;
      const { args, warnings } = yield this.getArgs(__spreadProps(__spreadValues({}, options), {
        stream: false
      }));
      const body = JSON.stringify(args);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: groqFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          groqChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
      const reasoning = choice.message.reasoning;
      if (reasoning != null && reasoning.length > 0) {
        content.push({
          type: "reasoning",
          text: reasoning
        });
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: (_a4 = toolCall.id) != null ? _a4 : generateId(),
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      return {
        content,
        finishReason: mapGroqFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : void 0,
          outputTokens: (_e = (_d2 = response.usage) == null ? void 0 : _d2.completion_tokens) != null ? _e : void 0,
          totalTokens: (_g = (_f = response.usage) == null ? void 0 : _f.total_tokens) != null ? _g : void 0,
          cachedInputTokens: (_j = (_i = (_h = response.usage) == null ? void 0 : _h.prompt_tokens_details) == null ? void 0 : _i.cached_tokens) != null ? _j : void 0
        },
        response: __spreadProps(__spreadValues({}, getResponseMetadata6(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings,
        request: { body }
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(__spreadProps(__spreadValues({}, options), { stream: true }));
      const body = JSON.stringify(__spreadProps(__spreadValues({}, args), { stream: true }));
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, args), {
          stream: true
        }),
        failedResponseHandler: groqFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(groqChatChunkSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const toolCalls = [];
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0,
        cachedInputTokens: void 0
      };
      let isFirstChunk = true;
      let isActiveText = false;
      let isActiveReasoning = false;
      let providerMetadata;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata6(value)));
              }
              if (((_a4 = value.x_groq) == null ? void 0 : _a4.usage) != null) {
                usage.inputTokens = (_b = value.x_groq.usage.prompt_tokens) != null ? _b : void 0;
                usage.outputTokens = (_c = value.x_groq.usage.completion_tokens) != null ? _c : void 0;
                usage.totalTokens = (_d2 = value.x_groq.usage.total_tokens) != null ? _d2 : void 0;
                usage.cachedInputTokens = (_f = (_e = value.x_groq.usage.prompt_tokens_details) == null ? void 0 : _e.cached_tokens) != null ? _f : void 0;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapGroqFinishReason(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              if (delta.reasoning != null && delta.reasoning.length > 0) {
                if (!isActiveReasoning) {
                  controller.enqueue({
                    type: "reasoning-start",
                    id: "reasoning-0"
                  });
                  isActiveReasoning = true;
                }
                controller.enqueue({
                  type: "reasoning-delta",
                  id: "reasoning-0",
                  delta: delta.reasoning
                });
              }
              if (delta.content != null && delta.content.length > 0) {
                if (!isActiveText) {
                  controller.enqueue({ type: "text-start", id: "txt-0" });
                  isActiveText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "txt-0",
                  delta: delta.content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCallDelta of delta.tool_calls) {
                  const index = toolCallDelta.index;
                  if (toolCalls[index] == null) {
                    if (toolCallDelta.type !== "function") {
                      throw new import_provider58.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function' type.`
                      });
                    }
                    if (toolCallDelta.id == null) {
                      throw new import_provider58.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'id' to be a string.`
                      });
                    }
                    if (((_g = toolCallDelta.function) == null ? void 0 : _g.name) == null) {
                      throw new import_provider58.InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function.name' to be a string.`
                      });
                    }
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallDelta.id,
                      toolName: toolCallDelta.function.name
                    });
                    toolCalls[index] = {
                      id: toolCallDelta.id,
                      type: "function",
                      function: {
                        name: toolCallDelta.function.name,
                        arguments: (_h = toolCallDelta.function.arguments) != null ? _h : ""
                      },
                      hasFinished: false
                    };
                    const toolCall2 = toolCalls[index];
                    if (((_i = toolCall2.function) == null ? void 0 : _i.name) != null && ((_j = toolCall2.function) == null ? void 0 : _j.arguments) != null) {
                      if (toolCall2.function.arguments.length > 0) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                      }
                      if (isParsableJson(toolCall2.function.arguments)) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: (_k = toolCall2.id) != null ? _k : generateId(),
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.hasFinished = true;
                      }
                    }
                    continue;
                  }
                  const toolCall = toolCalls[index];
                  if (toolCall.hasFinished) {
                    continue;
                  }
                  if (((_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null) {
                    toolCall.function.arguments += (_n = (_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null ? _n : "";
                  }
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.id,
                    delta: (_o = toolCallDelta.function.arguments) != null ? _o : ""
                  });
                  if (((_p = toolCall.function) == null ? void 0 : _p.name) != null && ((_q = toolCall.function) == null ? void 0 : _q.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_r = toolCall.id) != null ? _r : generateId(),
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                    toolCall.hasFinished = true;
                  }
                }
              }
            },
            flush(controller) {
              if (isActiveReasoning) {
                controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
              }
              if (isActiveText) {
                controller.enqueue({ type: "text-end", id: "txt-0" });
              }
              controller.enqueue(__spreadValues({
                type: "finish",
                finishReason,
                usage
              }, providerMetadata != null ? { providerMetadata } : {}));
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
var groqChatResponseSchema = import_v489.z.object({
  id: import_v489.z.string().nullish(),
  created: import_v489.z.number().nullish(),
  model: import_v489.z.string().nullish(),
  choices: import_v489.z.array(
    import_v489.z.object({
      message: import_v489.z.object({
        content: import_v489.z.string().nullish(),
        reasoning: import_v489.z.string().nullish(),
        tool_calls: import_v489.z.array(
          import_v489.z.object({
            id: import_v489.z.string().nullish(),
            type: import_v489.z.literal("function"),
            function: import_v489.z.object({
              name: import_v489.z.string(),
              arguments: import_v489.z.string()
            })
          })
        ).nullish()
      }),
      index: import_v489.z.number(),
      finish_reason: import_v489.z.string().nullish()
    })
  ),
  usage: import_v489.z.object({
    prompt_tokens: import_v489.z.number().nullish(),
    completion_tokens: import_v489.z.number().nullish(),
    total_tokens: import_v489.z.number().nullish(),
    prompt_tokens_details: import_v489.z.object({
      cached_tokens: import_v489.z.number().nullish()
    }).nullish()
  }).nullish()
});
var groqChatChunkSchema = import_v489.z.union([
  import_v489.z.object({
    id: import_v489.z.string().nullish(),
    created: import_v489.z.number().nullish(),
    model: import_v489.z.string().nullish(),
    choices: import_v489.z.array(
      import_v489.z.object({
        delta: import_v489.z.object({
          content: import_v489.z.string().nullish(),
          reasoning: import_v489.z.string().nullish(),
          tool_calls: import_v489.z.array(
            import_v489.z.object({
              index: import_v489.z.number(),
              id: import_v489.z.string().nullish(),
              type: import_v489.z.literal("function").optional(),
              function: import_v489.z.object({
                name: import_v489.z.string().nullish(),
                arguments: import_v489.z.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        finish_reason: import_v489.z.string().nullable().optional(),
        index: import_v489.z.number()
      })
    ),
    x_groq: import_v489.z.object({
      usage: import_v489.z.object({
        prompt_tokens: import_v489.z.number().nullish(),
        completion_tokens: import_v489.z.number().nullish(),
        total_tokens: import_v489.z.number().nullish(),
        prompt_tokens_details: import_v489.z.object({
          cached_tokens: import_v489.z.number().nullish()
        }).nullish()
      }).nullish()
    }).nullish()
  }),
  groqErrorDataSchema
]);
var groqProviderOptionsSchema = import_v492.z.object({
  language: import_v492.z.string().nullish(),
  prompt: import_v492.z.string().nullish(),
  responseFormat: import_v492.z.string().nullish(),
  temperature: import_v492.z.number().min(0).max(1).nullish(),
  timestampGranularities: import_v492.z.array(import_v492.z.string()).nullish()
});
var GroqTranscriptionModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      audio,
      mediaType,
      providerOptions
    }) {
      var _a4, _b, _c, _d2, _e;
      const warnings = [];
      const groqOptions = yield parseProviderOptions({
        provider: "groq",
        providerOptions,
        schema: groqProviderOptionsSchema
      });
      const formData = new FormData();
      const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
      formData.append("model", this.modelId);
      const fileExtension = mediaTypeToExtension(mediaType);
      formData.append(
        "file",
        new File([blob], "audio", { type: mediaType }),
        `audio.${fileExtension}`
      );
      if (groqOptions) {
        const transcriptionModelOptions = {
          language: (_a4 = groqOptions.language) != null ? _a4 : void 0,
          prompt: (_b = groqOptions.prompt) != null ? _b : void 0,
          response_format: (_c = groqOptions.responseFormat) != null ? _c : void 0,
          temperature: (_d2 = groqOptions.temperature) != null ? _d2 : void 0,
          timestamp_granularities: (_e = groqOptions.timestampGranularities) != null ? _e : void 0
        };
        for (const key in transcriptionModelOptions) {
          const value = transcriptionModelOptions[key];
          if (value !== void 0) {
            formData.append(key, String(value));
          }
        }
      }
      return {
        formData,
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g;
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const { formData, warnings } = yield this.getArgs(options);
      const {
        value: response,
        responseHeaders,
        rawValue: rawResponse
      } = yield postFormDataToApi({
        url: this.config.url({
          path: "/audio/transcriptions",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        formData,
        failedResponseHandler: groqFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          groqTranscriptionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      return {
        text: response.text,
        segments: (_e = (_d2 = response.segments) == null ? void 0 : _d2.map((segment) => ({
          text: segment.text,
          startSecond: segment.start,
          endSecond: segment.end
        }))) != null ? _e : [],
        language: (_f = response.language) != null ? _f : void 0,
        durationInSeconds: (_g = response.duration) != null ? _g : void 0,
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    });
  }
};
var groqTranscriptionResponseSchema = import_v492.z.object({
  text: import_v492.z.string(),
  x_groq: import_v492.z.object({
    id: import_v492.z.string()
  }),
  // additional properties are returned when `response_format: 'verbose_json'` is
  task: import_v492.z.string().nullish(),
  language: import_v492.z.string().nullish(),
  duration: import_v492.z.number().nullish(),
  segments: import_v492.z.array(
    import_v492.z.object({
      id: import_v492.z.number(),
      seek: import_v492.z.number(),
      start: import_v492.z.number(),
      end: import_v492.z.number(),
      text: import_v492.z.string(),
      tokens: import_v492.z.array(import_v492.z.number()),
      temperature: import_v492.z.number(),
      avg_logprob: import_v492.z.number(),
      compression_ratio: import_v492.z.number(),
      no_speech_prob: import_v492.z.number()
    })
  ).nullish()
});
var browserSearch = createProviderDefinedToolFactory({
  id: "groq.browser_search",
  name: "browser_search",
  inputSchema: import_v493.z.object({})
});
var groqTools = {
  browserSearch
};
var VERSION9 = true ? "2.0.24" : "0.0.0-test";
function createGroq(options = {}) {
  var _a4;
  const baseURL = (_a4 = withoutTrailingSlash(options.baseURL)) != null ? _a4 : "https://api.groq.com/openai/v1";
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "GROQ_API_KEY",
        description: "Groq"
      })}`
    }, options.headers),
    `ai-sdk/groq/${VERSION9}`
  );
  const createChatModel = (modelId) => new GroqChatLanguageModel(modelId, {
    provider: "groq.chat",
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The Groq model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  const createTranscriptionModel = (modelId) => {
    return new GroqTranscriptionModel(modelId, {
      provider: "groq.transcription",
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider57.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider57.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.tools = groqTools;
  return provider;
}
var groq = createGroq();

// ../../node_modules/.pnpm/@ai-sdk+cerebras@1.0.25_zod@4.2.1/node_modules/@ai-sdk/cerebras/dist/index.mjs
var import_provider61 = require("@ai-sdk/provider");
var import_v494 = require("zod/v4");
var VERSION10 = true ? "1.0.25" : "0.0.0-test";
var cerebrasErrorSchema = import_v494.z.object({
  message: import_v494.z.string(),
  type: import_v494.z.string(),
  param: import_v494.z.string(),
  code: import_v494.z.string()
});
var cerebrasErrorStructure = {
  errorSchema: cerebrasErrorSchema,
  errorToMessage: (data) => data.message
};
function createCerebras(options = {}) {
  var _a4;
  const baseURL = withoutTrailingSlash(
    (_a4 = options.baseURL) != null ? _a4 : "https://api.cerebras.ai/v1"
  );
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "CEREBRAS_API_KEY",
        description: "Cerebras API key"
      })}`
    }, options.headers),
    `ai-sdk/cerebras/${VERSION10}`
  );
  const createLanguageModel = (modelId) => {
    return new OpenAICompatibleChatLanguageModel(modelId, {
      provider: `cerebras.chat`,
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: cerebrasErrorStructure,
      supportsStructuredOutputs: true
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider61.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider61.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var cerebras = createCerebras();

// ../../node_modules/.pnpm/@ai-sdk+togetherai@1.0.23_zod@4.2.1/node_modules/@ai-sdk/togetherai/dist/index.mjs
var import_v495 = require("zod/v4");
var TogetherAIImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 1;
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(_0) {
    return __async(this, arguments, function* ({
      prompt,
      n,
      size,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      if (size != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support the `aspectRatio` option. Use `size` instead."
        });
      }
      const currentDate = (_c = (_b = (_a4 = this.config._internal) == null ? void 0 : _a4.currentDate) == null ? void 0 : _b.call(_a4)) != null ? _c : /* @__PURE__ */ new Date();
      const splitSize = size == null ? void 0 : size.split("x");
      const { value: response, responseHeaders } = yield postJsonToApi({
        url: `${this.config.baseURL}/images/generations`,
        headers: combineHeaders(this.config.headers(), headers),
        body: __spreadValues(__spreadProps(__spreadValues({
          model: this.modelId,
          prompt,
          seed,
          n
        }, splitSize && {
          width: parseInt(splitSize[0]),
          height: parseInt(splitSize[1])
        }), {
          response_format: "base64"
        }), (_d2 = providerOptions.togetherai) != null ? _d2 : {}),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: togetheraiErrorSchema,
          errorToMessage: (data) => data.error.message
        }),
        successfulResponseHandler: createJsonResponseHandler(
          togetheraiImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    });
  }
};
var togetheraiImageResponseSchema = import_v495.z.object({
  data: import_v495.z.array(
    import_v495.z.object({
      b64_json: import_v495.z.string()
    })
  )
});
var togetheraiErrorSchema = import_v495.z.object({
  error: import_v495.z.object({
    message: import_v495.z.string()
  })
});
var VERSION11 = true ? "1.0.23" : "0.0.0-test";
function createTogetherAI(options = {}) {
  var _a4;
  const baseURL = withoutTrailingSlash(
    (_a4 = options.baseURL) != null ? _a4 : "https://api.together.xyz/v1/"
  );
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "TOGETHER_AI_API_KEY",
        description: "TogetherAI"
      })}`
    }, options.headers),
    `ai-sdk/togetherai/${VERSION11}`
  );
  const getCommonModelConfig = (modelType) => ({
    provider: `togetherai.${modelType}`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createChatModel = (modelId) => {
    return new OpenAICompatibleChatLanguageModel(
      modelId,
      getCommonModelConfig("chat")
    );
  };
  const createCompletionModel = (modelId) => new OpenAICompatibleCompletionLanguageModel(
    modelId,
    getCommonModelConfig("completion")
  );
  const createTextEmbeddingModel = (modelId) => new OpenAICompatibleEmbeddingModel(
    modelId,
    getCommonModelConfig("embedding")
  );
  const createImageModel = (modelId) => new TogetherAIImageModel(modelId, __spreadProps(__spreadValues({}, getCommonModelConfig("image")), {
    baseURL: baseURL != null ? baseURL : "https://api.together.xyz/v1/"
  }));
  const provider = (modelId) => createChatModel(modelId);
  provider.completionModel = createCompletionModel;
  provider.languageModel = createChatModel;
  provider.chatModel = createChatModel;
  provider.textEmbeddingModel = createTextEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  return provider;
}
var togetherai = createTogetherAI();

// ../../node_modules/.pnpm/@ai-sdk+mistral@2.0.19_zod@4.2.1/node_modules/@ai-sdk/mistral/dist/index.mjs
var import_provider62 = require("@ai-sdk/provider");
var import_v496 = require("zod/v4");
var import_provider63 = require("@ai-sdk/provider");
var import_v497 = require("zod/v4");
var import_v498 = require("zod/v4");
var import_provider64 = require("@ai-sdk/provider");
var import_provider65 = require("@ai-sdk/provider");
var import_v499 = require("zod/v4");
function convertToMistralChatMessages(prompt) {
  const messages = [];
  for (let i2 = 0; i2 < prompt.length; i2++) {
    const { role, content } = prompt[i2];
    const isLastMessage = i2 === prompt.length - 1;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                  };
                } else if (part.mediaType === "application/pdf") {
                  return {
                    type: "document_url",
                    document_url: part.data.toString()
                  };
                } else {
                  throw new import_provider63.UnsupportedFunctionalityError({
                    functionality: "Only images and PDF file parts are supported"
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              text += part.text;
              break;
            }
            default: {
              throw new Error(
                `Unsupported content type in assistant message: ${part.type}`
              );
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          prefix: isLastMessage ? true : void 0,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            name: toolResponse.toolName,
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata7({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapMistralFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
    case "model_length":
      return "length";
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var mistralLanguageModelOptions = import_v497.z.object({
  /**
  Whether to inject a safety prompt before all conversations.
  
  Defaults to `false`.
     */
  safePrompt: import_v497.z.boolean().optional(),
  documentImageLimit: import_v497.z.number().optional(),
  documentPageLimit: import_v497.z.number().optional(),
  /**
   * Whether to use structured outputs.
   *
   * @default true
   */
  structuredOutputs: import_v497.z.boolean().optional(),
  /**
   * Whether to use strict JSON schema validation.
   *
   * @default false
   */
  strictJsonSchema: import_v497.z.boolean().optional(),
  /**
   * Whether to enable parallel function calling during tool use.
   * When set to false, the model will use at most one tool per response.
   *
   * @default true
   */
  parallelToolCalls: import_v497.z.boolean().optional()
});
var mistralErrorDataSchema = import_v498.z.object({
  object: import_v498.z.literal("error"),
  message: import_v498.z.string(),
  type: import_v498.z.string(),
  param: import_v498.z.string().nullable(),
  code: import_v498.z.string().nullable()
});
var mistralFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: mistralErrorDataSchema,
  errorToMessage: (data) => data.message
});
function prepareTools7({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const mistralTools = [];
  for (const tool21 of tools) {
    if (tool21.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
    } else {
      mistralTools.push({
        type: "function",
        function: {
          name: tool21.name,
          description: tool21.description,
          parameters: tool21.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: mistralTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: mistralTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: mistralTools, toolChoice: "any", toolWarnings };
    // mistral does not support tool mode directly,
    // so we filter the tools and force the tool choice through 'any'
    case "tool":
      return {
        tools: mistralTools.filter(
          (tool21) => tool21.function.name === toolChoice.toolName
        ),
        toolChoice: "any",
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider64.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var MistralChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "application/pdf": [/^https:\/\/.*$/]
    };
    var _a4;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a4 = config.generateId) != null ? _a4 : generateId;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      providerOptions,
      tools,
      toolChoice
    }) {
      var _a4, _b, _c, _d2;
      const warnings = [];
      const options = (_a4 = yield parseProviderOptions({
        provider: "mistral",
        providerOptions,
        schema: mistralLanguageModelOptions
      })) != null ? _a4 : {};
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "stopSequences"
        });
      }
      const structuredOutputs = (_b = options.structuredOutputs) != null ? _b : true;
      const strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : false;
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema)) {
        prompt = injectJsonInstructionIntoMessages({
          messages: prompt,
          schema: responseFormat.schema
        });
      }
      const baseArgs = {
        // model id:
        model: this.modelId,
        // model specific settings:
        safe_prompt: options.safePrompt,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        random_seed: seed,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d2 = responseFormat.name) != null ? _d2 : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        // mistral-specific provider options:
        document_image_limit: options.documentImageLimit,
        document_page_limit: options.documentPageLimit,
        // messages:
        messages: convertToMistralChatMessages(prompt)
      };
      const {
        tools: mistralTools,
        toolChoice: mistralToolChoice,
        toolWarnings
      } = prepareTools7({
        tools,
        toolChoice
      });
      return {
        args: __spreadValues(__spreadProps(__spreadValues({}, baseArgs), {
          tools: mistralTools,
          tool_choice: mistralToolChoice
        }), mistralTools != null && options.parallelToolCalls !== void 0 ? { parallel_tool_calls: options.parallelToolCalls } : {}),
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      const { args: body, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          mistralChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      if (choice.message.content != null && Array.isArray(choice.message.content)) {
        for (const part of choice.message.content) {
          if (part.type === "thinking") {
            const reasoningText = extractReasoningContent(part.thinking);
            if (reasoningText.length > 0) {
              content.push({ type: "reasoning", text: reasoningText });
            }
          } else if (part.type === "text") {
            if (part.text.length > 0) {
              content.push({ type: "text", text: part.text });
            }
          }
        }
      } else {
        const text = extractTextContent(choice.message.content);
        if (text != null && text.length > 0) {
          content.push({ type: "text", text });
        }
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      return {
        content,
        finishReason: mapMistralFinishReason(choice.finish_reason),
        usage: {
          inputTokens: response.usage.prompt_tokens,
          outputTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens
        },
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata7(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), { stream: true });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          mistralChatChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      let activeText = false;
      let activeReasoningId = null;
      const generateId22 = this.generateId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata7(value)));
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
              }
              const choice = value.choices[0];
              const delta = choice.delta;
              const textContent = extractTextContent(delta.content);
              if (delta.content != null && Array.isArray(delta.content)) {
                for (const part of delta.content) {
                  if (part.type === "thinking") {
                    const reasoningDelta = extractReasoningContent(part.thinking);
                    if (reasoningDelta.length > 0) {
                      if (activeReasoningId == null) {
                        if (activeText) {
                          controller.enqueue({ type: "text-end", id: "0" });
                          activeText = false;
                        }
                        activeReasoningId = generateId22();
                        controller.enqueue({
                          type: "reasoning-start",
                          id: activeReasoningId
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: activeReasoningId,
                        delta: reasoningDelta
                      });
                    }
                  }
                }
              }
              if (textContent != null && textContent.length > 0) {
                if (!activeText) {
                  if (activeReasoningId != null) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: activeReasoningId
                    });
                    activeReasoningId = null;
                  }
                  controller.enqueue({ type: "text-start", id: "0" });
                  activeText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: textContent
                });
              }
              if ((delta == null ? void 0 : delta.tool_calls) != null) {
                for (const toolCall of delta.tool_calls) {
                  const toolCallId = toolCall.id;
                  const toolName = toolCall.function.name;
                  const input = toolCall.function.arguments;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallId,
                    toolName
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCallId,
                    delta: input
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId,
                    toolName,
                    input
                  });
                }
              }
              if (choice.finish_reason != null) {
                finishReason = mapMistralFinishReason(choice.finish_reason);
              }
            },
            flush(controller) {
              if (activeReasoningId != null) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: activeReasoningId
                });
              }
              if (activeText) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function extractReasoningContent(thinking) {
  return thinking.filter((chunk) => chunk.type === "text").map((chunk) => chunk.text).join("");
}
function extractTextContent(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content == null) {
    return void 0;
  }
  const textContent = [];
  for (const chunk of content) {
    const { type } = chunk;
    switch (type) {
      case "text":
        textContent.push(chunk.text);
        break;
      case "thinking":
      case "image_url":
      case "reference":
        break;
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  return textContent.length ? textContent.join("") : void 0;
}
var mistralContentSchema = import_v496.z.union([
  import_v496.z.string(),
  import_v496.z.array(
    import_v496.z.discriminatedUnion("type", [
      import_v496.z.object({
        type: import_v496.z.literal("text"),
        text: import_v496.z.string()
      }),
      import_v496.z.object({
        type: import_v496.z.literal("image_url"),
        image_url: import_v496.z.union([
          import_v496.z.string(),
          import_v496.z.object({
            url: import_v496.z.string(),
            detail: import_v496.z.string().nullable()
          })
        ])
      }),
      import_v496.z.object({
        type: import_v496.z.literal("reference"),
        reference_ids: import_v496.z.array(import_v496.z.number())
      }),
      import_v496.z.object({
        type: import_v496.z.literal("thinking"),
        thinking: import_v496.z.array(
          import_v496.z.object({
            type: import_v496.z.literal("text"),
            text: import_v496.z.string()
          })
        )
      })
    ])
  )
]).nullish();
var mistralUsageSchema = import_v496.z.object({
  prompt_tokens: import_v496.z.number(),
  completion_tokens: import_v496.z.number(),
  total_tokens: import_v496.z.number()
});
var mistralChatResponseSchema = import_v496.z.object({
  id: import_v496.z.string().nullish(),
  created: import_v496.z.number().nullish(),
  model: import_v496.z.string().nullish(),
  choices: import_v496.z.array(
    import_v496.z.object({
      message: import_v496.z.object({
        role: import_v496.z.literal("assistant"),
        content: mistralContentSchema,
        tool_calls: import_v496.z.array(
          import_v496.z.object({
            id: import_v496.z.string(),
            function: import_v496.z.object({ name: import_v496.z.string(), arguments: import_v496.z.string() })
          })
        ).nullish()
      }),
      index: import_v496.z.number(),
      finish_reason: import_v496.z.string().nullish()
    })
  ),
  object: import_v496.z.literal("chat.completion"),
  usage: mistralUsageSchema
});
var mistralChatChunkSchema = import_v496.z.object({
  id: import_v496.z.string().nullish(),
  created: import_v496.z.number().nullish(),
  model: import_v496.z.string().nullish(),
  choices: import_v496.z.array(
    import_v496.z.object({
      delta: import_v496.z.object({
        role: import_v496.z.enum(["assistant"]).optional(),
        content: mistralContentSchema,
        tool_calls: import_v496.z.array(
          import_v496.z.object({
            id: import_v496.z.string(),
            function: import_v496.z.object({ name: import_v496.z.string(), arguments: import_v496.z.string() })
          })
        ).nullish()
      }),
      finish_reason: import_v496.z.string().nullish(),
      index: import_v496.z.number()
    })
  ),
  usage: mistralUsageSchema.nullish()
});
var MistralEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 32;
    this.supportsParallelCalls = false;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      abortSignal,
      headers
    }) {
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider65.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: `${this.config.baseURL}/embeddings`,
        headers: combineHeaders(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float"
        },
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          MistralTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var MistralTextEmbeddingResponseSchema = import_v499.z.object({
  data: import_v499.z.array(import_v499.z.object({ embedding: import_v499.z.array(import_v499.z.number()) })),
  usage: import_v499.z.object({ prompt_tokens: import_v499.z.number() }).nullish()
});
var VERSION12 = true ? "2.0.19" : "0.0.0-test";
function createMistral(options = {}) {
  var _a4;
  const baseURL = (_a4 = withoutTrailingSlash(options.baseURL)) != null ? _a4 : "https://api.mistral.ai/v1";
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "MISTRAL_API_KEY",
        description: "Mistral"
      })}`
    }, options.headers),
    `ai-sdk/mistral/${VERSION12}`
  );
  const createChatModel = (modelId) => new MistralChatLanguageModel(modelId, {
    provider: "mistral.chat",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch,
    generateId: options.generateId
  });
  const createEmbeddingModel = (modelId) => new MistralEmbeddingModel(modelId, {
    provider: "mistral.embedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Mistral model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new import_provider62.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var mistral = createMistral();

// ../../node_modules/.pnpm/@ai-sdk+deepseek@1.0.23_zod@4.2.1/node_modules/@ai-sdk/deepseek/dist/index.mjs
var import_provider66 = require("@ai-sdk/provider");
var import_v4100 = require("zod/v4");
var buildDeepseekMetadata = (usage) => {
  var _a4, _b;
  return usage == null ? void 0 : {
    deepseek: {
      promptCacheHitTokens: (_a4 = usage.prompt_cache_hit_tokens) != null ? _a4 : NaN,
      promptCacheMissTokens: (_b = usage.prompt_cache_miss_tokens) != null ? _b : NaN
    }
  };
};
var deepSeekMetadataExtractor = {
  extractMetadata: (_0) => __async(null, [_0], function* ({ parsedBody }) {
    const parsed = yield safeValidateTypes({
      value: parsedBody,
      schema: deepSeekResponseSchema
    });
    return !parsed.success || parsed.value.usage == null ? void 0 : buildDeepseekMetadata(parsed.value.usage);
  }),
  createStreamExtractor: () => {
    let usage;
    return {
      processChunk: (chunk) => __async(null, null, function* () {
        var _a4, _b;
        const parsed = yield safeValidateTypes({
          value: chunk,
          schema: deepSeekStreamChunkSchema
        });
        if (parsed.success && ((_b = (_a4 = parsed.value.choices) == null ? void 0 : _a4[0]) == null ? void 0 : _b.finish_reason) === "stop" && parsed.value.usage) {
          usage = parsed.value.usage;
        }
      }),
      buildMetadata: () => buildDeepseekMetadata(usage)
    };
  }
};
var deepSeekUsageSchema = import_v4100.z.object({
  prompt_cache_hit_tokens: import_v4100.z.number().nullish(),
  prompt_cache_miss_tokens: import_v4100.z.number().nullish()
});
var deepSeekResponseSchema = import_v4100.z.object({
  usage: deepSeekUsageSchema.nullish()
});
var deepSeekStreamChunkSchema = import_v4100.z.object({
  choices: import_v4100.z.array(
    import_v4100.z.object({
      finish_reason: import_v4100.z.string().nullish()
    })
  ).nullish(),
  usage: deepSeekUsageSchema.nullish()
});
var VERSION13 = true ? "1.0.23" : "0.0.0-test";
function createDeepSeek(options = {}) {
  var _a4;
  const baseURL = withoutTrailingSlash(
    (_a4 = options.baseURL) != null ? _a4 : "https://api.deepseek.com/v1"
  );
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "DEEPSEEK_API_KEY",
        description: "DeepSeek API key"
      })}`
    }, options.headers),
    `ai-sdk/deepseek/${VERSION13}`
  );
  const createLanguageModel = (modelId) => {
    return new OpenAICompatibleChatLanguageModel(modelId, {
      provider: `deepseek.chat`,
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch,
      metadataExtractor: deepSeekMetadataExtractor
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider66.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider66.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var deepseek = createDeepSeek();

// ../../node_modules/.pnpm/@ai-sdk+perplexity@2.0.13_zod@4.2.1/node_modules/@ai-sdk/perplexity/dist/index.mjs
var import_provider67 = require("@ai-sdk/provider");
var import_v4101 = require("zod/v4");
var import_provider68 = require("@ai-sdk/provider");
function convertToPerplexityMessages(prompt) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user":
      case "assistant": {
        const hasImage = content.some(
          (part) => part.type === "file" && part.mediaType.startsWith("image/")
        );
        const messageContent = content.map((part) => {
          var _a4;
          switch (part.type) {
            case "text": {
              return {
                type: "text",
                text: part.text
              };
            }
            case "file": {
              return part.data instanceof URL ? {
                type: "image_url",
                image_url: {
                  url: part.data.toString()
                }
              } : {
                type: "image_url",
                image_url: {
                  url: `data:${(_a4 = part.mediaType) != null ? _a4 : "image/jpeg"};base64,${typeof part.data === "string" ? part.data : convertUint8ArrayToBase64(part.data)}`
                }
              };
            }
          }
        }).filter(Boolean);
        messages.push({
          role,
          content: hasImage ? messageContent : messageContent.filter((part) => part.type === "text").map((part) => part.text).join("")
        });
        break;
      }
      case "tool": {
        throw new import_provider68.UnsupportedFunctionalityError({
          functionality: "Tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function mapPerplexityFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "length":
      return finishReason;
    default:
      return "unknown";
  }
}
var PerplexityLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.provider = "perplexity";
    this.supportedUrls = {
      // No URLs are supported.
    };
    this.modelId = modelId;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerOptions
  }) {
    var _a4;
    const warnings = [];
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    return {
      args: __spreadProps(__spreadValues({
        // model id:
        model: this.modelId,
        // standardized settings:
        frequency_penalty: frequencyPenalty,
        max_tokens: maxOutputTokens,
        presence_penalty: presencePenalty,
        temperature,
        top_k: topK,
        top_p: topP,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? {
          type: "json_schema",
          json_schema: { schema: responseFormat.schema }
        } : void 0
      }, (_a4 = providerOptions == null ? void 0 : providerOptions.perplexity) != null ? _a4 : {}), {
        // messages:
        messages: convertToPerplexityMessages(prompt)
      }),
      warnings
    };
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j;
      const { args: body, warnings } = this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: perplexityErrorSchema,
          errorToMessage
        }),
        successfulResponseHandler: createJsonResponseHandler(
          perplexityResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text.length > 0) {
        content.push({ type: "text", text });
      }
      if (response.citations != null) {
        for (const url of response.citations) {
          content.push({
            type: "source",
            sourceType: "url",
            id: this.config.generateId(),
            url
          });
        }
      }
      return {
        content,
        finishReason: mapPerplexityFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_a4 = response.usage) == null ? void 0 : _a4.prompt_tokens,
          outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
          totalTokens: (_d2 = (_c = response.usage) == null ? void 0 : _c.total_tokens) != null ? _d2 : void 0
        },
        request: { body },
        response: __spreadProps(__spreadValues({}, getResponseMetadata8(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings,
        providerMetadata: {
          perplexity: {
            images: (_f = (_e = response.images) == null ? void 0 : _e.map((image) => ({
              imageUrl: image.image_url,
              originUrl: image.origin_url,
              height: image.height,
              width: image.width
            }))) != null ? _f : null,
            usage: {
              citationTokens: (_h = (_g = response.usage) == null ? void 0 : _g.citation_tokens) != null ? _h : null,
              numSearchQueries: (_j = (_i = response.usage) == null ? void 0 : _i.num_search_queries) != null ? _j : null
            }
          }
        }
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), { stream: true });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: perplexityErrorSchema,
          errorToMessage
        }),
        successfulResponseHandler: createEventSourceResponseHandler(
          perplexityChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const providerMetadata = {
        perplexity: {
          usage: {
            citationTokens: null,
            numSearchQueries: null
          },
          images: null
        }
      };
      let isFirstChunk = true;
      let isActive = false;
      const self2 = this;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a4, _b, _c;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata8(value)));
                (_a4 = value.citations) == null ? void 0 : _a4.forEach((url) => {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: self2.config.generateId(),
                    url
                  });
                });
                isFirstChunk = false;
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                providerMetadata.perplexity.usage = {
                  citationTokens: (_b = value.usage.citation_tokens) != null ? _b : null,
                  numSearchQueries: (_c = value.usage.num_search_queries) != null ? _c : null
                };
              }
              if (value.images != null) {
                providerMetadata.perplexity.images = value.images.map((image) => ({
                  imageUrl: image.image_url,
                  originUrl: image.origin_url,
                  height: image.height,
                  width: image.width
                }));
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapPerplexityFinishReason(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              const textContent = delta.content;
              if (textContent != null) {
                if (!isActive) {
                  controller.enqueue({ type: "text-start", id: "0" });
                  isActive = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: textContent
                });
              }
            },
            flush(controller) {
              if (isActive) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
};
function getResponseMetadata8({
  id,
  model,
  created
}) {
  return {
    id,
    modelId: model,
    timestamp: new Date(created * 1e3)
  };
}
var perplexityUsageSchema = import_v4101.z.object({
  prompt_tokens: import_v4101.z.number(),
  completion_tokens: import_v4101.z.number(),
  total_tokens: import_v4101.z.number().nullish(),
  citation_tokens: import_v4101.z.number().nullish(),
  num_search_queries: import_v4101.z.number().nullish()
});
var perplexityImageSchema = import_v4101.z.object({
  image_url: import_v4101.z.string(),
  origin_url: import_v4101.z.string(),
  height: import_v4101.z.number(),
  width: import_v4101.z.number()
});
var perplexityResponseSchema = import_v4101.z.object({
  id: import_v4101.z.string(),
  created: import_v4101.z.number(),
  model: import_v4101.z.string(),
  choices: import_v4101.z.array(
    import_v4101.z.object({
      message: import_v4101.z.object({
        role: import_v4101.z.literal("assistant"),
        content: import_v4101.z.string()
      }),
      finish_reason: import_v4101.z.string().nullish()
    })
  ),
  citations: import_v4101.z.array(import_v4101.z.string()).nullish(),
  images: import_v4101.z.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
});
var perplexityChunkSchema = import_v4101.z.object({
  id: import_v4101.z.string(),
  created: import_v4101.z.number(),
  model: import_v4101.z.string(),
  choices: import_v4101.z.array(
    import_v4101.z.object({
      delta: import_v4101.z.object({
        role: import_v4101.z.literal("assistant"),
        content: import_v4101.z.string()
      }),
      finish_reason: import_v4101.z.string().nullish()
    })
  ),
  citations: import_v4101.z.array(import_v4101.z.string()).nullish(),
  images: import_v4101.z.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
});
var perplexityErrorSchema = import_v4101.z.object({
  error: import_v4101.z.object({
    code: import_v4101.z.number(),
    message: import_v4101.z.string().nullish(),
    type: import_v4101.z.string().nullish()
  })
});
var errorToMessage = (data) => {
  var _a4, _b;
  return (_b = (_a4 = data.error.message) != null ? _a4 : data.error.type) != null ? _b : "unknown error";
};
var VERSION14 = true ? "2.0.13" : "0.0.0-test";
function createPerplexity(options = {}) {
  const getHeaders = () => withUserAgentSuffix(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "PERPLEXITY_API_KEY",
        description: "Perplexity"
      })}`
    }, options.headers),
    `ai-sdk/perplexity/${VERSION14}`
  );
  const createLanguageModel = (modelId) => {
    var _a4;
    return new PerplexityLanguageModel(modelId, {
      baseURL: withoutTrailingSlash(
        (_a4 = options.baseURL) != null ? _a4 : "https://api.perplexity.ai"
      ),
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider67.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider67.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
var perplexity = createPerplexity();

// ../../node_modules/.pnpm/ollama-ai-provider-v2@1.5.0_zod@4.2.1/node_modules/ollama-ai-provider-v2/dist/index.mjs
var import_provider69 = require("@ai-sdk/provider");
var import_v4102 = require("zod/v4");
var import_v4103 = require("zod/v4");
var import_provider70 = require("@ai-sdk/provider");
var import_provider71 = require("@ai-sdk/provider");
var import_v4104 = require("zod/v4");
var import_provider72 = require("@ai-sdk/provider");
var import_provider73 = require("@ai-sdk/provider");
var import_v4105 = require("zod/v4");
var import_v4106 = require("zod/v4");
var import_provider74 = require("@ai-sdk/provider");
var ollamaErrorDataSchema = import_v4103.z.object({
  error: import_v4103.z.object({
    message: import_v4103.z.string(),
    // The additional information below is handled loosely to support
    // Ollama-compatible providers that have slightly different error
    // responses:
    type: import_v4103.z.string().nullish(),
    param: import_v4103.z.any().nullish(),
    code: import_v4103.z.union([import_v4103.z.string(), import_v4103.z.number()]).nullish()
  })
});
var ollamaFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: ollamaErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function convertToOllamaCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new import_provider70.InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new import_provider70.UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new import_provider70.UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}
function mapOllamaFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function getResponseMetadata9({
  model,
  created_at
}) {
  return {
    id: void 0,
    modelId: model != null ? model : void 0,
    timestamp: created_at != null ? new Date(created_at) : void 0
  };
}
var ollamaCompletionProviderOptions = import_v4102.z.object({
  think: import_v4102.z.boolean().optional(),
  user: import_v4102.z.string().optional(),
  suffix: import_v4102.z.string().optional(),
  echo: import_v4102.z.boolean().optional()
});
var OllamaCompletionLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      // No URLs are supported for completion models.
    };
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences: userStopSequences,
      responseFormat,
      tools,
      toolChoice,
      seed,
      providerOptions
    }) {
      var _a4;
      const warnings = [];
      const ollamaOptions = (_a4 = yield parseProviderOptions({
        provider: "ollama",
        providerOptions,
        schema: ollamaCompletionProviderOptions
      })) != null ? _a4 : {};
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (tools == null ? void 0 : tools.length) {
        warnings.push({ type: "unsupported-setting", setting: "tools" });
      }
      if (toolChoice != null) {
        warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
      }
      if (responseFormat != null && responseFormat.type !== "text") {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format is not supported."
        });
      }
      const { prompt: completionPrompt, stopSequences } = convertToOllamaCompletionPrompt({ prompt });
      const stop2 = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
      return {
        args: {
          // model id:
          model: this.modelId,
          // Ollama-supported settings:
          user: ollamaOptions.user,
          think: ollamaOptions.think,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          stop: stop2,
          // prompt:
          prompt: completionPrompt,
          // other settings:
          suffix: ollamaOptions.suffix,
          echo: ollamaOptions.echo,
          stream: false
          // always disabled for doGenerate
        },
        warnings
      };
    });
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2;
      const { args: body, warnings } = yield this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/generate",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, body), { stream: false }),
        failedResponseHandler: ollamaFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          baseOllamaResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const _a5 = body, { prompt: rawPrompt } = _a5, rawSettings = __objRest(_a5, ["prompt"]);
      const providerMetadata = { ollama: {} };
      return {
        content: [
          {
            type: "text",
            text: response.response
          }
        ],
        usage: {
          inputTokens: (_a4 = response.prompt_eval_count) != null ? _a4 : void 0,
          outputTokens: (_b = response.eval_count) != null ? _b : void 0,
          totalTokens: ((_c = response.prompt_eval_count) != null ? _c : 0) + ((_d2 = response.eval_count) != null ? _d2 : 0)
        },
        finishReason: mapOllamaFinishReason("stop"),
        request: { body: JSON.stringify(body) },
        response: __spreadProps(__spreadValues({}, getResponseMetadata9(response)), {
          headers: responseHeaders,
          body: rawResponse
        }),
        warnings,
        providerMetadata
      };
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args, warnings } = yield this.getArgs(options);
      const body = __spreadProps(__spreadValues({}, args), {
        stream: true
      });
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/generate",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body,
        failedResponseHandler: ollamaFailedResponseHandler,
        successfulResponseHandler: createJsonStreamResponseHandler(
          baseOllamaResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const _a4 = args, { prompt: rawPrompt } = _a4, rawSettings = __objRest(_a4, ["prompt"]);
      let finishReason = "unknown";
      let usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue(__spreadValues({
                  type: "response-metadata"
                }, getResponseMetadata9(value)));
              }
              if (value.done) {
                finishReason = mapOllamaFinishReason("stop");
              }
              if (value.response != null) {
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: value.response
                });
              }
            },
            flush(controller) {
              controller.enqueue({
                type: "finish",
                finishReason,
                usage
              });
            }
          })
        ),
        request: { body: JSON.stringify(body) },
        response: { headers: responseHeaders }
      };
    });
  }
};
var baseOllamaResponseSchema = import_v4102.z.object({
  model: import_v4102.z.string(),
  created_at: import_v4102.z.string(),
  response: import_v4102.z.string(),
  done: import_v4102.z.boolean(),
  context: import_v4102.z.array(import_v4102.z.number()),
  eval_count: import_v4102.z.number().optional(),
  eval_duration: import_v4102.z.number().optional(),
  load_duration: import_v4102.z.number().optional(),
  total_duration: import_v4102.z.number().optional(),
  prompt_eval_count: import_v4102.z.number().optional(),
  prompt_eval_duration: import_v4102.z.number().optional()
});
var ollamaEmbeddingProviderOptions = import_v4104.z.object({
  dimensions: import_v4104.z.number().optional(),
  truncate: import_v4104.z.boolean().optional(),
  keepAlive: import_v4104.z.string().optional()
});
var OllamaEmbeddingModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var _a4;
    return (_a4 = this.settings.maxEmbeddingsPerCall) != null ? _a4 : 2048;
  }
  get supportsParallelCalls() {
    var _a4;
    return (_a4 = this.settings.supportsParallelCalls) != null ? _a4 : true;
  }
  getArgs(_0) {
    return __async(this, arguments, function* ({
      values,
      providerOptions
    }) {
      var _a4, _b;
      const ollamaOptions = (_a4 = yield parseProviderOptions({
        provider: "ollama",
        providerOptions,
        schema: ollamaEmbeddingProviderOptions
      })) != null ? _a4 : {};
      return {
        args: {
          // model id:
          model: this.modelId,
          input: values,
          // advanced parameters:
          dimensions: (_b = ollamaOptions.dimensions) != null ? _b : this.settings.dimensions,
          truncate: ollamaOptions.truncate,
          keep_alive: ollamaOptions.keepAlive
        }
      };
    });
  }
  doEmbed(_0) {
    return __async(this, arguments, function* ({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new import_provider71.TooManyEmbeddingValuesForCallError({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const { args: body } = yield this.getArgs({ values, providerOptions });
      const {
        responseHeaders,
        value: response,
        rawValue
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/embed",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        body: __spreadValues({}, body),
        failedResponseHandler: ollamaFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(
          ollamaTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.embeddings.map((item) => item),
        usage: { tokens: response.prompt_eval_count },
        response: { headers: responseHeaders, body: rawValue }
      };
    });
  }
};
var ollamaTextEmbeddingResponseSchema = import_v4104.z.object({
  model: import_v4104.z.string(),
  embeddings: import_v4104.z.array(import_v4104.z.array(import_v4104.z.number())),
  total_duration: import_v4104.z.number(),
  load_duration: import_v4104.z.number(),
  prompt_eval_count: import_v4104.z.number()
});
function convertToOllamaResponsesMessages({
  prompt,
  systemMessageMode
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a4, _b, _c;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${part.data}`,
                    // Ollama specific extension: image detail
                    detail: (_b = (_a4 = part.providerOptions) == null ? void 0 : _a4.ollama) == null ? void 0 : _b.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new import_provider72.UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "input_file",
                    filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                    file_data: `data:application/pdf;base64,${part.data}`
                  };
                } else {
                  throw new import_provider72.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        for (const part of content) {
          switch (part.type) {
            case "text": {
              messages.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }]
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted) {
                break;
              }
              messages.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input)
              });
              break;
            }
            case "tool-result": {
              warnings.push({
                type: "other",
                message: `tool result parts in assistant messages are not supported for Ollama responses`
              });
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          const output = part.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function convertToOllamaChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        const userText = content.filter((part) => part.type === "text").map((part) => part.text).join("");
        const images = content.filter((part) => part.type === "file" && part.mediaType.startsWith("image/")).map((part) => part.data);
        messages.push({
          role: "user",
          content: userText.length > 0 ? userText : [],
          images: images.length > 0 ? images : void 0
        });
        break;
      }
      case "assistant": {
        let text = "";
        let thinking = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: part.input
                }
              });
              break;
            }
            case "reasoning": {
              thinking += part.text;
              break;
            }
            default: {
              throw new Error(`Unsupported part: ${part}`);
            }
          }
        }
        messages.push(__spreadProps(__spreadValues({
          role: "assistant",
          content: text
        }, thinking && { thinking }), {
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        }));
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function prepareResponsesTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const ollamaTools = [];
  for (const tool21 of tools) {
    switch (tool21.type) {
      case "function": {
        let parameters = tool21.inputSchema;
        if (!parameters) {
          parameters = {
            type: "object",
            properties: {},
            required: []
          };
        } else if (parameters && typeof parameters === "object" && parameters.type === "object" && parameters.properties && Object.keys(parameters.properties).length === 0) {
          parameters = __spreadProps(__spreadValues({}, parameters), {
            properties: {},
            required: []
          });
        }
        ollamaTools.push({
          type: "function",
          function: {
            name: tool21.name,
            description: tool21.description,
            parameters
          }
        });
        break;
      }
      default:
        toolWarnings.push({ type: "unsupported-tool", tool: tool21 });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: ollamaTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: ollamaTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: ollamaTools,
        toolChoice: toolChoice.toolName == "web_search_preview" ? { type: "web_search_preview" } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider73.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var ollamaProviderOptions = import_v4105.z.object({
  /**
   * Enable or disable the model's thinking process. When enabled, the output will separate
   * the model's thinking from the model's output. When disabled, the model will not think
   * and directly output the content.
   *
   * Only supported by certain models like DeepSeek R1 and Qwen 3.
   */
  think: import_v4105.z.boolean().optional(),
  options: import_v4105.z.object({
    num_ctx: import_v4105.z.number().optional(),
    repeat_last_n: import_v4105.z.number().optional(),
    repeat_penalty: import_v4105.z.number().optional(),
    temperature: import_v4105.z.number().optional(),
    seed: import_v4105.z.number().optional(),
    stop: import_v4105.z.array(import_v4105.z.string()).optional(),
    num_predict: import_v4105.z.number().optional(),
    top_k: import_v4105.z.number().optional(),
    top_p: import_v4105.z.number().optional(),
    min_p: import_v4105.z.number().optional()
  }).optional()
});
var OllamaRequestBuilder = class {
  buildRequest(_0) {
    return __async(this, arguments, function* ({
      modelId,
      maxOutputTokens,
      temperature,
      stopSequences,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      seed,
      prompt,
      providerOptions,
      tools,
      toolChoice,
      responseFormat
    }) {
      const warnings = this.collectUnsupportedSettingsWarnings({
        topK,
        seed,
        presencePenalty,
        frequencyPenalty,
        stopSequences
      });
      const { messages, warnings: messageWarnings } = convertToOllamaResponsesMessages({
        prompt,
        systemMessageMode: "system"
      });
      warnings.push(...messageWarnings);
      const ollamaOptions = yield this.parseProviderOptions(providerOptions);
      const baseArgs = this.buildBaseArgs({
        modelId,
        prompt,
        temperature,
        topP,
        maxOutputTokens,
        responseFormat,
        ollamaOptions
      });
      const { tools: ollamaTools, toolChoice: ollamaToolChoice, toolWarnings } = prepareResponsesTools3({
        tools,
        toolChoice
      });
      return {
        args: __spreadProps(__spreadValues({}, baseArgs), {
          tools: ollamaTools,
          tool_choice: ollamaToolChoice
        }),
        warnings: [...warnings, ...toolWarnings]
      };
    });
  }
  collectUnsupportedSettingsWarnings({
    topK,
    seed,
    presencePenalty,
    frequencyPenalty,
    stopSequences
  }) {
    const warnings = [];
    const unsupportedSettings = [
      { value: topK, name: "topK" },
      { value: seed, name: "seed" },
      { value: presencePenalty, name: "presencePenalty" },
      { value: frequencyPenalty, name: "frequencyPenalty" },
      { value: stopSequences, name: "stopSequences" }
    ];
    for (const { value, name } of unsupportedSettings) {
      if (value != null) {
        warnings.push({ type: "unsupported-setting", setting: name });
      }
    }
    return warnings;
  }
  parseProviderOptions(providerOptions) {
    return __async(this, null, function* () {
      const result = yield parseProviderOptions({
        provider: "ollama",
        providerOptions,
        schema: ollamaProviderOptions
      });
      return result != null ? result : null;
    });
  }
  buildBaseArgs({
    modelId,
    prompt,
    temperature,
    topP,
    maxOutputTokens,
    responseFormat,
    ollamaOptions
  }) {
    var _a4, _b;
    return __spreadProps(__spreadValues({
      model: modelId,
      messages: convertToOllamaChatMessages({
        prompt,
        systemMessageMode: "system"
      }),
      temperature,
      top_p: topP,
      max_output_tokens: maxOutputTokens
    }, (responseFormat == null ? void 0 : responseFormat.type) === "json" && {
      format: responseFormat.schema != null ? responseFormat.schema : "json"
    }), {
      think: (_a4 = ollamaOptions == null ? void 0 : ollamaOptions.think) != null ? _a4 : false,
      options: (_b = ollamaOptions == null ? void 0 : ollamaOptions.options) != null ? _b : void 0
    });
  }
};
var baseOllamaResponseSchema2 = import_v4106.z.object({
  model: import_v4106.z.string(),
  created_at: import_v4106.z.string(),
  done: import_v4106.z.boolean(),
  message: import_v4106.z.object({
    content: import_v4106.z.string(),
    role: import_v4106.z.string(),
    thinking: import_v4106.z.string().optional(),
    tool_calls: import_v4106.z.array(
      import_v4106.z.object({
        function: import_v4106.z.object({
          name: import_v4106.z.string(),
          arguments: import_v4106.z.record(import_v4106.z.string(), import_v4106.z.any())
        }),
        id: import_v4106.z.string().optional()
      })
    ).optional().nullable()
  }),
  done_reason: import_v4106.z.string().optional(),
  eval_count: import_v4106.z.number().optional(),
  eval_duration: import_v4106.z.number().optional(),
  load_duration: import_v4106.z.number().optional(),
  prompt_eval_count: import_v4106.z.number().optional(),
  prompt_eval_duration: import_v4106.z.number().optional(),
  total_duration: import_v4106.z.number().optional()
});
var OllamaResponseProcessor = class {
  constructor(config) {
    this.config = config;
  }
  processGenerateResponse(response) {
    const content = this.extractContent(response);
    const finishReason = mapOllamaFinishReason(response.done_reason);
    const usage = this.extractUsage(response);
    const providerMetadata = { ollama: {} };
    return {
      content,
      finishReason,
      usage,
      providerMetadata
    };
  }
  extractContent(response) {
    var _a4, _b, _c, _d2, _e;
    const content = [];
    const text = response.message.content;
    if (text != null && text.length > 0) {
      content.push({
        type: "text",
        text
      });
    }
    for (const toolCall of (_a4 = response.message.tool_calls) != null ? _a4 : []) {
      content.push({
        type: "tool-call",
        toolCallId: (_e = toolCall.id) != null ? _e : (_d2 = (_c = (_b = this.config).generateId) == null ? void 0 : _c.call(_b)) != null ? _d2 : generateId(),
        toolName: toolCall.function.name,
        input: JSON.stringify(toolCall.function.arguments)
      });
    }
    return content;
  }
  extractUsage(response) {
    var _a4, _b, _c, _d2;
    return {
      inputTokens: (_a4 = response.prompt_eval_count) != null ? _a4 : void 0,
      outputTokens: (_b = response.eval_count) != null ? _b : void 0,
      totalTokens: ((_c = response.prompt_eval_count) != null ? _c : 0) + ((_d2 = response.eval_count) != null ? _d2 : 0),
      reasoningTokens: void 0,
      // Ollama doesn't provide separate reasoning tokens
      cachedInputTokens: void 0
    };
  }
};
function extractOllamaResponseObjectsFromChunk(chunk) {
  var _a4;
  if (chunk.success) {
    return [chunk.value];
  }
  const results = [];
  const raw = (_a4 = chunk.error) == null ? void 0 : _a4.text;
  if (typeof raw !== "string" || raw.length === 0) {
    return results;
  }
  const lines = raw.split(/\r?\n/);
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "") continue;
    try {
      const parsed = JSON.parse(trimmed);
      const validated = baseOllamaResponseSchema2.safeParse(parsed);
      if (validated.success) {
        results.push(validated.data);
      }
    } catch (e2) {
    }
  }
  return results;
}
var OllamaStreamProcessor = class {
  constructor(config) {
    this.config = config;
    this.state = this.initializeState();
  }
  createTransformStream(warnings, options) {
    return new TransformStream({
      start: (controller) => {
        controller.enqueue({ type: "stream-start", warnings });
      },
      transform: (chunk, controller) => {
        this.processChunk(chunk, controller, options);
      },
      flush: (controller) => {
        this.finalizeStream(controller);
      }
    });
  }
  initializeState() {
    return {
      finishReason: "unknown",
      usage: {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      },
      responseId: null,
      ongoingToolCalls: {},
      hasToolCalls: false,
      isFirstChunk: true,
      hasTextStarted: false,
      hasReasoningStarted: false,
      textEnded: false,
      reasoningEnded: false,
      textId: generateId()
    };
  }
  processChunk(chunk, controller, options) {
    if (options == null ? void 0 : options.includeRawChunks) {
      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
    }
    const values = extractOllamaResponseObjectsFromChunk(chunk);
    if (values.length === 0) {
      if (!chunk.success) {
        this.state.finishReason = "error";
        controller.enqueue({ type: "error", error: chunk.error });
      }
      return;
    }
    for (const value of values) {
      this.processResponseValue(value, controller);
    }
  }
  processResponseValue(value, controller) {
    if (value && typeof value === "object" && "error" in value) {
      this.state.finishReason = "error";
      controller.enqueue({ type: "error", error: value.error });
      return;
    }
    if (this.state.isFirstChunk) {
      this.state.isFirstChunk = false;
      controller.enqueue(__spreadValues({
        type: "response-metadata"
      }, getResponseMetadata9(value)));
    }
    if (value.done) {
      this.handleDoneChunk(value, controller);
    }
    const delta = value == null ? void 0 : value.message;
    if (delta) {
      this.processDelta(delta, controller);
    }
  }
  handleDoneChunk(value, controller) {
    var _a4, _b, _c;
    this.state.finishReason = mapOllamaFinishReason(value.done_reason);
    this.state.usage = {
      inputTokens: value.prompt_eval_count || 0,
      outputTokens: (_a4 = value.eval_count) != null ? _a4 : void 0,
      totalTokens: ((_b = value.prompt_eval_count) != null ? _b : 0) + ((_c = value.eval_count) != null ? _c : 0)
    };
    if (this.state.hasTextStarted && !this.state.textEnded) {
      controller.enqueue({ type: "text-end", id: this.state.textId });
      this.state.textEnded = true;
    }
    if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
      controller.enqueue({ type: "reasoning-end", id: "0" });
      this.state.reasoningEnded = true;
    }
  }
  processDelta(delta, controller) {
    this.processTextContent(delta, controller);
    this.processThinking(delta, controller);
    this.processToolCalls(delta, controller);
  }
  processTextContent(delta, controller) {
    if ((delta == null ? void 0 : delta.content) != null) {
      if (!this.state.hasTextStarted) {
        controller.enqueue({ type: "text-start", id: this.state.textId });
        this.state.hasTextStarted = true;
      }
      controller.enqueue({
        type: "text-delta",
        id: this.state.textId,
        delta: delta.content
      });
    }
  }
  processThinking(delta, controller) {
    if (delta == null ? void 0 : delta.thinking) {
      if (!this.state.hasReasoningStarted) {
        controller.enqueue({ type: "reasoning-start", id: "0" });
        this.state.hasReasoningStarted = true;
      }
      controller.enqueue({
        type: "reasoning-delta",
        id: "0",
        delta: delta.thinking
      });
    }
  }
  processToolCalls(delta, controller) {
    var _a4, _b, _c, _d2;
    for (const toolCall of (_a4 = delta.tool_calls) != null ? _a4 : []) {
      if (((_b = toolCall.function) == null ? void 0 : _b.name) == null) {
        throw new import_provider74.InvalidResponseDataError({
          data: toolCall,
          message: `Expected 'function.name' to be a string.`
        });
      }
      if (((_c = toolCall.function) == null ? void 0 : _c.name) != null && ((_d2 = toolCall.function) == null ? void 0 : _d2.arguments) != null) {
        this.emitToolCall(toolCall, controller);
      }
    }
  }
  emitToolCall(toolCall, controller) {
    var _a4, _b, _c, _d2;
    const id = (_d2 = toolCall.id) != null ? _d2 : (_c = (_b = (_a4 = this.config).generateId) == null ? void 0 : _b.call(_a4)) != null ? _c : generateId();
    controller.enqueue({
      type: "tool-input-start",
      id,
      toolName: toolCall.function.name
    });
    controller.enqueue({
      type: "tool-input-delta",
      id,
      delta: JSON.stringify(toolCall.function.arguments)
    });
    controller.enqueue({
      type: "tool-input-end",
      id
    });
    controller.enqueue({
      type: "tool-call",
      toolCallId: id,
      toolName: toolCall.function.name,
      input: JSON.stringify(toolCall.function.arguments)
    });
    this.state.hasToolCalls = true;
  }
  finalizeStream(controller) {
    if (this.state.hasTextStarted && !this.state.textEnded) {
      controller.enqueue({ type: "text-end", id: "0" });
    }
    if (this.state.hasReasoningStarted && !this.state.reasoningEnded) {
      controller.enqueue({ type: "reasoning-end", id: "0" });
    }
    controller.enqueue({
      type: "finish",
      finishReason: this.state.finishReason,
      usage: this.state.usage,
      providerMetadata: {
        ollama: {
          responseId: this.state.responseId
        }
      }
    });
  }
};
var OllamaResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [
        /^https?:\/\/.*$/
      ]
    };
    this.modelId = modelId;
    this.config = config;
    this.requestBuilder = new OllamaRequestBuilder();
    this.responseProcessor = new OllamaResponseProcessor(config);
  }
  get provider() {
    return this.config.provider;
  }
  doGenerate(options) {
    return __async(this, null, function* () {
      const { args: body, warnings } = yield this.prepareRequest(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, body), { stream: false }),
        failedResponseHandler: ollamaFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema2),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const processedResponse = this.responseProcessor.processGenerateResponse(response);
      return __spreadProps(__spreadValues({}, processedResponse), {
        request: { body: JSON.stringify(body) },
        response: {
          modelId: this.modelId,
          timestamp: /* @__PURE__ */ new Date(),
          headers: responseHeaders,
          body: rawResponse
        },
        warnings
      });
    });
  }
  doStream(options) {
    return __async(this, null, function* () {
      const { args: body, warnings } = yield this.prepareRequest(options);
      const { responseHeaders, value: response } = yield postJsonToApi({
        url: this.config.url({
          path: "/chat",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), options.headers),
        body: __spreadProps(__spreadValues({}, body), { stream: true }),
        failedResponseHandler: ollamaFailedResponseHandler,
        successfulResponseHandler: createJsonStreamResponseHandler(baseOllamaResponseSchema2),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const streamProcessor = new OllamaStreamProcessor(this.config);
      return {
        stream: response.pipeThrough(
          streamProcessor.createTransformStream(warnings, options)
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    });
  }
  prepareRequest(options) {
    return __async(this, null, function* () {
      return yield this.requestBuilder.buildRequest(__spreadValues({
        modelId: this.modelId
      }, options));
    });
  }
};
function createOllama(options = {}) {
  var _a4, _b;
  const baseURL = (_a4 = withoutTrailingSlash(options.baseURL)) != null ? _a4 : "http://127.0.0.1:11434/api";
  const providerName = (_b = options.name) != null ? _b : "ollama";
  const getHeaders = () => __spreadValues({
    "Ollama-Organization": options.organization,
    "Ollama-Project": options.project
  }, options.headers);
  const createCompletionModel = (modelId, settings = {}) => new OllamaCompletionLanguageModel(modelId, settings, {
    provider: `${providerName}.completion`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId, settings = {}) => new OllamaEmbeddingModel(modelId, settings, {
    provider: `${providerName}.embedding`,
    url: ({ path: path8 }) => `${baseURL}${path8}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The Ollama model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  };
  const createResponsesModel = (modelId) => {
    return new OllamaResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path: path8 }) => `${baseURL}${path8}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.completion = createCompletionModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new import_provider69.NoSuchModelError({
      modelId,
      modelType: "imageModel",
      message: "Image generation is unsupported with Ollama"
    });
  };
  return provider;
}
var ollama = createOllama();

// lib/v3/llm/LLMProvider.ts
var AISDKProviders = {
  openai,
  anthropic,
  google,
  xai,
  azure,
  groq,
  cerebras,
  togetherai,
  mistral,
  deepseek,
  perplexity,
  ollama,
  vertex
};
var AISDKProvidersWithAPIKey = {
  openai: createOpenAI,
  anthropic: createAnthropic,
  google: createGoogleGenerativeAI,
  vertex: createVertex2,
  xai: createXai,
  azure: createAzure,
  groq: createGroq,
  cerebras: createCerebras,
  togetherai: createTogetherAI,
  mistral: createMistral,
  deepseek: createDeepSeek,
  perplexity: createPerplexity
};
var modelToProviderMap = {
  "gpt-4.1": "openai",
  "gpt-4.1-mini": "openai",
  "gpt-4.1-nano": "openai",
  "o4-mini": "openai",
  //prettier-ignore
  "o3": "openai",
  "o3-mini": "openai",
  //prettier-ignore
  "o1": "openai",
  "o1-mini": "openai",
  "gpt-4o": "openai",
  "gpt-4o-mini": "openai",
  "gpt-4o-2024-08-06": "openai",
  "gpt-4.5-preview": "openai",
  "o1-preview": "openai",
  "claude-3-5-sonnet-latest": "anthropic",
  "claude-3-5-sonnet-20240620": "anthropic",
  "claude-3-5-sonnet-20241022": "anthropic",
  "claude-3-7-sonnet-20250219": "anthropic",
  "claude-3-7-sonnet-latest": "anthropic",
  "cerebras-llama-3.3-70b": "cerebras",
  "cerebras-llama-3.1-8b": "cerebras",
  "groq-llama-3.3-70b-versatile": "groq",
  "groq-llama-3.3-70b-specdec": "groq",
  "moonshotai/kimi-k2-instruct": "groq",
  "gemini-1.5-flash": "google",
  "gemini-1.5-pro": "google",
  "gemini-1.5-flash-8b": "google",
  "gemini-2.0-flash-lite": "google",
  "gemini-2.0-flash": "google",
  "gemini-2.5-flash-preview-04-17": "google",
  "gemini-2.5-pro-preview-03-25": "google"
};
function getAISDKLanguageModel(subProvider, subModelName, clientOptions) {
  if (clientOptions && Object.keys(clientOptions).length > 0) {
    const creator = AISDKProvidersWithAPIKey[subProvider];
    if (!creator) {
      throw new UnsupportedAISDKModelProviderError(
        subProvider,
        Object.keys(AISDKProvidersWithAPIKey)
      );
    }
    const provider = creator(clientOptions);
    return provider(subModelName);
  } else {
    const provider = AISDKProviders[subProvider];
    if (!provider) {
      throw new UnsupportedAISDKModelProviderError(
        subProvider,
        Object.keys(AISDKProviders)
      );
    }
    return provider(subModelName);
  }
}
var LLMProvider = class {
  constructor(logger) {
    this.logger = logger;
  }
  getClient(modelName, clientOptions, options) {
    if (modelName.includes("/")) {
      const firstSlashIndex = modelName.indexOf("/");
      const subProvider = modelName.substring(0, firstSlashIndex);
      const subModelName = modelName.substring(firstSlashIndex + 1);
      if (subProvider === "vertex" && !(options == null ? void 0 : options.disableAPI) && !(options == null ? void 0 : options.experimental)) {
        throw new ExperimentalNotConfiguredError("Vertex provider");
      }
      const languageModel = getAISDKLanguageModel(
        subProvider,
        subModelName,
        clientOptions
      );
      return new AISdkClient({
        model: languageModel,
        logger: this.logger
      });
    }
    const provider = modelToProviderMap[modelName];
    if (!provider) {
      throw new UnsupportedModelError(Object.keys(modelToProviderMap));
    }
    const availableModel = modelName;
    switch (provider) {
      case "openai":
        return new OpenAIClient({
          logger: this.logger,
          modelName: availableModel,
          clientOptions
        });
      case "anthropic":
        return new AnthropicClient({
          logger: this.logger,
          modelName: availableModel,
          clientOptions
        });
      case "cerebras":
        return new CerebrasClient({
          logger: this.logger,
          modelName: availableModel,
          clientOptions
        });
      case "groq":
        return new GroqClient({
          logger: this.logger,
          modelName: availableModel,
          clientOptions
        });
      case "google":
        return new GoogleClient({
          logger: this.logger,
          modelName: availableModel,
          clientOptions
        });
      default:
        throw new UnsupportedModelProviderError([
          ...new Set(Object.values(modelToProviderMap))
        ]);
    }
  }
  static getModelProvider(modelName) {
    if (modelName.includes("/")) {
      const firstSlashIndex = modelName.indexOf("/");
      const subProvider = modelName.substring(0, firstSlashIndex);
      if (AISDKProviders[subProvider]) {
        return "aisdk";
      }
    }
    const provider = modelToProviderMap[modelName];
    return provider;
  }
};

// lib/v3/v3.ts
init_logger();

// lib/v3/mcp/connection.ts
var import_client = require("@modelcontextprotocol/sdk/client/index.js");
var import_streamableHttp = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
var import_stdio = require("@modelcontextprotocol/sdk/client/stdio.js");
init_sdkErrors();
var connectToMCPServer = (serverConfig) => __async(null, null, function* () {
  try {
    let transport;
    let clientOptions;
    if (typeof serverConfig === "object" && "command" in serverConfig) {
      transport = new import_stdio.StdioClientTransport(serverConfig);
    } else {
      let serverUrl;
      if (typeof serverConfig === "string" || serverConfig instanceof URL) {
        serverUrl = serverConfig;
      } else {
        serverUrl = serverConfig.serverUrl;
        clientOptions = serverConfig.clientOptions;
      }
      transport = new import_streamableHttp.StreamableHTTPClientTransport(new URL(serverUrl));
    }
    const client = new import_client.Client(__spreadValues({
      name: "Stagehand",
      version: "1.0.0"
    }, clientOptions));
    yield client.connect(transport);
    try {
      yield client.ping();
    } catch (pingError) {
      yield client.close();
      throw new MCPConnectionError(serverConfig.toString(), pingError);
    }
    return client;
  } catch (error) {
    if (error instanceof MCPConnectionError) {
      throw error;
    }
    throw new MCPConnectionError(serverConfig.toString(), error);
  }
});

// lib/v3/mcp/utils.ts
var resolveTools = (clients, userTools) => __async(null, null, function* () {
  const tools = __spreadValues({}, userTools);
  for (const client of clients) {
    let clientInstance;
    if (typeof client === "string") {
      clientInstance = yield connectToMCPServer(client);
    } else {
      clientInstance = client;
    }
    let nextCursor = void 0;
    do {
      const clientTools = yield clientInstance.listTools({
        cursor: nextCursor
      });
      for (const tool21 of clientTools.tools) {
        tools[tool21.name] = {
          description: tool21.description,
          inputSchema: jsonSchemaToZod(tool21.inputSchema),
          execute: (input) => __async(null, null, function* () {
            const result = yield clientInstance.callTool({
              name: tool21.name,
              arguments: input
            });
            return result;
          })
        };
      }
      nextCursor = clientTools.nextCursor;
    } while (nextCursor);
  }
  return tools;
});

// lib/v3/types/public/agent.ts
var AVAILABLE_CUA_MODELS = [
  "openai/computer-use-preview",
  "openai/computer-use-preview-2025-03-11",
  "anthropic/claude-3-7-sonnet-latest",
  "anthropic/claude-opus-4-5-20251101",
  "anthropic/claude-haiku-4-5-20251001",
  "anthropic/claude-sonnet-4-20250514",
  "anthropic/claude-sonnet-4-5-20250929",
  "google/gemini-2.5-computer-use-preview-10-2025",
  "microsoft/fara-7b"
];

// lib/v3/types/public/api.ts
var api_exports = {};
__export(api_exports, {
  ActOptionsSchema: () => ActOptionsSchema,
  ActRequestSchema: () => ActRequestSchema,
  ActResponseSchema: () => ActResponseSchema,
  ActResultDataSchema: () => ActResultDataSchema,
  ActResultSchema: () => ActResultSchema,
  ActionSchema: () => ActionSchema,
  AgentActionSchema: () => AgentActionSchema,
  AgentConfigSchema: () => AgentConfigSchema,
  AgentExecuteOptionsSchema: () => AgentExecuteOptionsSchema,
  AgentExecuteRequestSchema: () => AgentExecuteRequestSchema,
  AgentExecuteResponseSchema: () => AgentExecuteResponseSchema,
  AgentExecuteResultSchema: () => AgentExecuteResultSchema,
  AgentResultDataSchema: () => AgentResultDataSchema,
  AgentUsageSchema: () => AgentUsageSchema,
  BrowserConfigSchema: () => BrowserConfigSchema,
  BrowserbaseBrowserSettingsSchema: () => BrowserbaseBrowserSettingsSchema,
  BrowserbaseContextSchema: () => BrowserbaseContextSchema,
  BrowserbaseFingerprintSchema: () => BrowserbaseFingerprintSchema,
  BrowserbaseFingerprintScreenSchema: () => BrowserbaseFingerprintScreenSchema,
  BrowserbaseProxyConfigSchema: () => BrowserbaseProxyConfigSchema,
  BrowserbaseProxyGeolocationSchema: () => BrowserbaseProxyGeolocationSchema,
  BrowserbaseSessionCreateParamsSchema: () => BrowserbaseSessionCreateParamsSchema,
  BrowserbaseViewportSchema: () => BrowserbaseViewportSchema,
  ErrorResponseSchema: () => ErrorResponseSchema,
  ExternalProxyConfigSchema: () => ExternalProxyConfigSchema,
  ExtractOptionsSchema: () => ExtractOptionsSchema,
  ExtractRequestSchema: () => ExtractRequestSchema,
  ExtractResponseSchema: () => ExtractResponseSchema,
  ExtractResultSchema: () => ExtractResultSchema,
  LocalBrowserLaunchOptionsSchema: () => LocalBrowserLaunchOptionsSchema,
  ModelConfigObjectSchema: () => ModelConfigObjectSchema,
  ModelConfigSchema: () => ModelConfigSchema,
  ModelNameSchema: () => ModelNameSchema,
  NavigateOptionsSchema: () => NavigateOptionsSchema,
  NavigateRequestSchema: () => NavigateRequestSchema,
  NavigateResponseSchema: () => NavigateResponseSchema,
  NavigateResultSchema: () => NavigateResultSchema,
  ObserveOptionsSchema: () => ObserveOptionsSchema,
  ObserveRequestSchema: () => ObserveRequestSchema,
  ObserveResponseSchema: () => ObserveResponseSchema,
  ObserveResultSchema: () => ObserveResultSchema,
  Operations: () => Operations,
  ProxyConfigSchema: () => ProxyConfigSchema,
  ReplayActionSchema: () => ReplayActionSchema,
  ReplayPageSchema: () => ReplayPageSchema,
  ReplayResponseSchema: () => ReplayResponseSchema,
  ReplayResultSchema: () => ReplayResultSchema,
  SessionEndResponseSchema: () => SessionEndResponseSchema,
  SessionEndResultSchema: () => SessionEndResultSchema,
  SessionHeadersSchema: () => SessionHeadersSchema,
  SessionIdParamsSchema: () => SessionIdParamsSchema,
  SessionStartRequestSchema: () => SessionStartRequestSchema,
  SessionStartResponseSchema: () => SessionStartResponseSchema,
  SessionStartResultSchema: () => SessionStartResultSchema,
  StreamEventLogDataSchema: () => StreamEventLogDataSchema,
  StreamEventSchema: () => StreamEventSchema,
  StreamEventStatusSchema: () => StreamEventStatusSchema,
  StreamEventSystemDataSchema: () => StreamEventSystemDataSchema,
  StreamEventTypeSchema: () => StreamEventTypeSchema,
  TokenUsageSchema: () => TokenUsageSchema,
  openApiLinks: () => openApiLinks,
  openApiSecuritySchemes: () => openApiSecuritySchemes
});
var import_v4107 = require("zod/v4");
var LocalBrowserLaunchOptionsSchema = import_v4107.z.object({
  args: import_v4107.z.array(import_v4107.z.string()).optional(),
  executablePath: import_v4107.z.string().optional(),
  userDataDir: import_v4107.z.string().optional(),
  preserveUserDataDir: import_v4107.z.boolean().optional(),
  headless: import_v4107.z.boolean().optional(),
  devtools: import_v4107.z.boolean().optional(),
  chromiumSandbox: import_v4107.z.boolean().optional(),
  ignoreDefaultArgs: import_v4107.z.union([import_v4107.z.boolean(), import_v4107.z.array(import_v4107.z.string())]).optional(),
  proxy: import_v4107.z.object({
    server: import_v4107.z.string(),
    bypass: import_v4107.z.string().optional(),
    username: import_v4107.z.string().optional(),
    password: import_v4107.z.string().optional()
  }).optional(),
  locale: import_v4107.z.string().optional(),
  viewport: import_v4107.z.object({ width: import_v4107.z.number(), height: import_v4107.z.number() }).optional(),
  deviceScaleFactor: import_v4107.z.number().optional(),
  hasTouch: import_v4107.z.boolean().optional(),
  ignoreHTTPSErrors: import_v4107.z.boolean().optional(),
  cdpUrl: import_v4107.z.string().optional(),
  connectTimeoutMs: import_v4107.z.number().optional(),
  downloadsPath: import_v4107.z.string().optional(),
  acceptDownloads: import_v4107.z.boolean().optional()
}).strict().meta({ id: "LocalBrowserLaunchOptions" });
var ModelNameSchema = import_v4107.z.string().meta({
  id: "ModelName",
  description: "Model name string with provider prefix (e.g., 'openai/gpt-5-nano', 'anthropic/claude-4.5-opus')",
  match: /^(openai|anthropic|google|microsoft)\/.+$/,
  example: "openai/gpt-5-nano"
});
var ModelConfigObjectSchema = import_v4107.z.object({
  provider: import_v4107.z.enum(["openai", "anthropic", "google", "microsoft"]).optional().meta({
    description: "AI provider for the model (or provide a baseURL endpoint instead)",
    example: "openai"
  }),
  modelName: import_v4107.z.string().meta({
    description: "Model name string without prefix (e.g., 'gpt-5-nano', 'claude-4.5-opus')",
    example: "gpt-5-nano"
  }),
  apiKey: import_v4107.z.string().optional().meta({
    description: "API key for the model provider",
    example: "sk-some-openai-api-key"
  }),
  baseURL: import_v4107.z.string().url().optional().meta({
    description: "Base URL for the model provider",
    example: "https://api.openai.com/v1"
  })
}).meta({ id: "ModelConfigObject" });
var ModelConfigSchema = import_v4107.z.union([ModelNameSchema, ModelConfigObjectSchema]).meta({ id: "ModelConfig" });
var ActionSchema = import_v4107.z.object({
  selector: import_v4107.z.string().meta({
    description: "CSS selector or XPath for the element",
    example: "[data-testid='submit-button']"
  }),
  description: import_v4107.z.string().meta({
    description: "Human-readable description of the action",
    example: "Click the submit button"
  }),
  backendNodeId: import_v4107.z.number().optional().meta({
    description: "Backend node ID for the element"
  }),
  method: import_v4107.z.string().optional().meta({
    description: "The method to execute (click, fill, etc.)",
    example: "click"
  }),
  arguments: import_v4107.z.array(import_v4107.z.string()).optional().meta({
    description: "Arguments to pass to the method",
    example: ["Hello World"]
  })
}).meta({
  id: "Action",
  description: "Action object returned by observe and used by act"
});
var SessionIdParamsSchema = import_v4107.z.object({
  id: import_v4107.z.string().meta({
    description: "Unique session identifier",
    example: "c4dbf3a9-9a58-4b22-8a1c-9f20f9f9e123"
  })
}).strict().meta({ id: "SessionIdParams" });
var BrowserConfigSchema = import_v4107.z.object({
  type: import_v4107.z.enum(["local", "browserbase"]).optional().meta({
    description: "Browser type to use",
    example: "local"
  }),
  cdpUrl: import_v4107.z.string().optional().meta({
    description: "Chrome DevTools Protocol URL for connecting to existing browser",
    example: "ws://localhost:9222"
  }),
  launchOptions: LocalBrowserLaunchOptionsSchema.optional()
}).meta({ id: "BrowserConfig" });
var SessionHeadersSchema = import_v4107.z.object({
  "x-stream-response": import_v4107.z.enum(["true", "false"]).optional().meta({
    description: "Whether to stream the response via SSE",
    example: "true"
  }),
  "x-language": import_v4107.z.enum(["typescript", "python", "playground"]).optional().meta({
    description: "Client SDK language",
    example: "typescript"
  }),
  "x-sdk-version": import_v4107.z.string().optional().meta({
    description: "Version of the Stagehand SDK",
    example: "3.0.6"
  }),
  "x-sent-at": import_v4107.z.string().datetime().optional().meta({
    description: "ISO timestamp when request was sent",
    example: "2025-01-15T10:30:00Z"
  })
}).meta({ id: "SessionHeaders" });
var wrapResponse = (resultSchema, name) => import_v4107.z.object({
  success: import_v4107.z.boolean().meta({
    description: "Indicates whether the request was successful"
  }),
  data: resultSchema
}).meta({ id: name });
var ErrorResponseSchema = import_v4107.z.object({
  success: import_v4107.z.literal(false),
  error: import_v4107.z.string(),
  code: import_v4107.z.string().optional()
}).strict().meta({ id: "ErrorResponse" });
var BrowserbaseViewportSchema = import_v4107.z.object({
  width: import_v4107.z.number().optional(),
  height: import_v4107.z.number().optional()
}).meta({ id: "BrowserbaseViewport" });
var BrowserbaseFingerprintScreenSchema = import_v4107.z.object({
  maxHeight: import_v4107.z.number().optional(),
  maxWidth: import_v4107.z.number().optional(),
  minHeight: import_v4107.z.number().optional(),
  minWidth: import_v4107.z.number().optional()
}).meta({ id: "BrowserbaseFingerprintScreen" });
var BrowserbaseFingerprintSchema = import_v4107.z.object({
  browsers: import_v4107.z.array(import_v4107.z.enum(["chrome", "edge", "firefox", "safari"])).optional(),
  devices: import_v4107.z.array(import_v4107.z.enum(["desktop", "mobile"])).optional(),
  httpVersion: import_v4107.z.enum(["1", "2"]).optional(),
  locales: import_v4107.z.array(import_v4107.z.string()).optional(),
  operatingSystems: import_v4107.z.array(import_v4107.z.enum(["android", "ios", "linux", "macos", "windows"])).optional(),
  screen: BrowserbaseFingerprintScreenSchema.optional()
}).meta({ id: "BrowserbaseFingerprint" });
var BrowserbaseContextSchema = import_v4107.z.object({
  id: import_v4107.z.string(),
  persist: import_v4107.z.boolean().optional()
}).meta({ id: "BrowserbaseContext" });
var BrowserbaseBrowserSettingsSchema = import_v4107.z.object({
  advancedStealth: import_v4107.z.boolean().optional(),
  blockAds: import_v4107.z.boolean().optional(),
  context: BrowserbaseContextSchema.optional(),
  extensionId: import_v4107.z.string().optional(),
  fingerprint: BrowserbaseFingerprintSchema.optional(),
  logSession: import_v4107.z.boolean().optional(),
  recordSession: import_v4107.z.boolean().optional(),
  solveCaptchas: import_v4107.z.boolean().optional(),
  viewport: BrowserbaseViewportSchema.optional()
}).meta({ id: "BrowserbaseBrowserSettings" });
var BrowserbaseProxyGeolocationSchema = import_v4107.z.object({
  country: import_v4107.z.string(),
  city: import_v4107.z.string().optional(),
  state: import_v4107.z.string().optional()
}).meta({ id: "BrowserbaseProxyGeolocation" });
var BrowserbaseProxyConfigSchema = import_v4107.z.object({
  type: import_v4107.z.literal("browserbase"),
  domainPattern: import_v4107.z.string().optional(),
  geolocation: BrowserbaseProxyGeolocationSchema.optional()
}).meta({ id: "BrowserbaseProxyConfig" });
var ExternalProxyConfigSchema = import_v4107.z.object({
  type: import_v4107.z.literal("external"),
  server: import_v4107.z.string(),
  domainPattern: import_v4107.z.string().optional(),
  username: import_v4107.z.string().optional(),
  password: import_v4107.z.string().optional()
}).meta({ id: "ExternalProxyConfig" });
var ProxyConfigSchema = import_v4107.z.discriminatedUnion("type", [
  BrowserbaseProxyConfigSchema,
  ExternalProxyConfigSchema
]).meta({ id: "ProxyConfig" });
var BrowserbaseSessionCreateParamsSchema = import_v4107.z.object({
  projectId: import_v4107.z.string().optional(),
  browserSettings: BrowserbaseBrowserSettingsSchema.optional(),
  extensionId: import_v4107.z.string().optional(),
  keepAlive: import_v4107.z.boolean().optional(),
  proxies: import_v4107.z.union([import_v4107.z.boolean(), import_v4107.z.array(ProxyConfigSchema)]).optional(),
  region: import_v4107.z.enum(["us-west-2", "us-east-1", "eu-central-1", "ap-southeast-1"]).optional(),
  timeout: import_v4107.z.number().optional(),
  userMetadata: import_v4107.z.record(import_v4107.z.string(), import_v4107.z.unknown()).optional()
}).meta({ id: "BrowserbaseSessionCreateParams" });
var SessionStartRequestSchema = import_v4107.z.object({
  modelName: import_v4107.z.string().meta({
    description: "Model name to use for AI operations",
    example: "gpt-4o"
  }),
  domSettleTimeoutMs: import_v4107.z.number().optional().meta({
    description: "Timeout in ms to wait for DOM to settle",
    example: 5e3
  }),
  verbose: import_v4107.z.union([import_v4107.z.literal(0), import_v4107.z.literal(1), import_v4107.z.literal(2)]).optional().meta({
    description: "Logging verbosity level (0=quiet, 1=normal, 2=debug)",
    example: 1,
    override: ({ jsonSchema: jsonSchema3 }) => {
      delete jsonSchema3.anyOf;
      delete jsonSchema3.allOf;
      delete jsonSchema3.oneOf;
      jsonSchema3.type = "number";
      jsonSchema3.enum = [0, 1, 2];
    }
  }),
  systemPrompt: import_v4107.z.string().optional().meta({
    description: "Custom system prompt for AI operations"
  }),
  browserbaseSessionCreateParams: BrowserbaseSessionCreateParamsSchema.optional(),
  browser: BrowserConfigSchema.optional(),
  selfHeal: import_v4107.z.boolean().optional().meta({
    description: "Enable self-healing for failed actions",
    example: true
  }),
  browserbaseSessionID: import_v4107.z.string().optional().meta({
    description: "Existing Browserbase session ID to resume"
  }),
  // experimental is a V3 field but doesn't need to go over the wire - included because wire type imports options type
  experimental: import_v4107.z.boolean().optional(),
  // V2 compatibility fields - only included because the server imports this type and supports V2
  // should never be used in v3 clients or v3-only server implementations
  waitForCaptchaSolves: import_v4107.z.boolean().optional().meta({
    description: "Wait for captcha solves (deprecated, v2 only)"
  }),
  actTimeoutMs: import_v4107.z.number().optional().meta({
    description: "Timeout in ms for act operations (deprecated, v2 only)"
  })
}).meta({ id: "SessionStartRequest" });
var SessionStartResultSchema = import_v4107.z.object({
  sessionId: import_v4107.z.string().meta({
    description: "Unique Browserbase session identifier",
    example: "c4dbf3a9-9a58-4b22-8a1c-9f20f9f9e123"
  }),
  cdpUrl: import_v4107.z.string().nullish().meta({
    description: "CDP WebSocket URL for connecting to the Browserbase cloud browser (present when available)",
    example: "wss://connect.browserbase.com/?signingKey=abc123"
  }),
  available: import_v4107.z.boolean()
}).meta({ id: "SessionStartResult" });
var SessionStartResponseSchema = wrapResponse(
  SessionStartResultSchema,
  "SessionStartResponse"
);
var SessionEndResultSchema = import_v4107.z.object({}).strict().meta({ id: "SessionEndResult" });
var SessionEndResponseSchema = import_v4107.z.object({
  success: import_v4107.z.boolean().meta({
    description: "Indicates whether the request was successful"
  })
}).strict().meta({ id: "SessionEndResponse" });
var ActOptionsSchema = import_v4107.z.object({
  model: ModelConfigSchema.optional(),
  variables: import_v4107.z.record(import_v4107.z.string(), import_v4107.z.string()).optional().meta({
    description: "Variables to substitute in the action instruction",
    example: { username: "john_doe" }
  }),
  timeout: import_v4107.z.number().optional().meta({
    description: "Timeout in ms for the action",
    example: 3e4
  })
}).optional().meta({ id: "ActOptions" });
var ActRequestSchema = import_v4107.z.object({
  input: import_v4107.z.string().or(ActionSchema).meta({
    description: "Natural language instruction or Action object",
    example: "Click the login button"
  }),
  options: ActOptionsSchema,
  frameId: import_v4107.z.string().optional().meta({
    description: "Target frame ID for the action"
  }),
  streamResponse: import_v4107.z.boolean().optional().meta({
    description: "Whether to stream the response via SSE",
    example: true
  })
}).meta({ id: "ActRequest" });
var ActResultDataSchema = import_v4107.z.object({
  success: import_v4107.z.boolean().meta({
    description: "Whether the action completed successfully",
    example: true
  }),
  message: import_v4107.z.string().meta({
    description: "Human-readable result message",
    example: "Successfully clicked the login button"
  }),
  actionDescription: import_v4107.z.string().meta({
    description: "Description of the action that was performed",
    example: "Clicked button with text 'Login'"
  }),
  actions: import_v4107.z.array(ActionSchema).meta({
    description: "List of actions that were executed"
  })
}).meta({ id: "ActResultData" });
var ActResultSchema = import_v4107.z.object({
  result: ActResultDataSchema,
  actionId: import_v4107.z.string().optional().meta({
    description: "Action ID for tracking"
  })
}).meta({ id: "ActResult" });
var ActResponseSchema = wrapResponse(ActResultSchema, "ActResponse");
var ExtractOptionsSchema = import_v4107.z.object({
  model: ModelConfigSchema.optional(),
  timeout: import_v4107.z.number().optional().meta({
    description: "Timeout in ms for the extraction",
    example: 3e4
  }),
  selector: import_v4107.z.string().optional().meta({
    description: "CSS selector to scope extraction to a specific element",
    example: "#main-content"
  })
}).optional().meta({ id: "ExtractOptions" });
var ExtractRequestSchema = import_v4107.z.object({
  instruction: import_v4107.z.string().optional().meta({
    description: "Natural language instruction for what to extract",
    example: "Extract all product names and prices from the page"
  }),
  schema: import_v4107.z.record(import_v4107.z.string(), import_v4107.z.unknown()).optional().meta({
    description: "JSON Schema defining the structure of data to extract"
  }),
  options: ExtractOptionsSchema,
  frameId: import_v4107.z.string().optional().meta({
    description: "Target frame ID for the extraction"
  }),
  streamResponse: import_v4107.z.boolean().optional().meta({
    description: "Whether to stream the response via SSE",
    example: true
  })
}).meta({ id: "ExtractRequest" });
var ExtractResultSchema = import_v4107.z.object({
  result: import_v4107.z.unknown().meta({
    description: "Extracted data matching the requested schema"
  }),
  actionId: import_v4107.z.string().optional().meta({
    description: "Action ID for tracking"
  })
}).meta({ id: "ExtractResult" });
var ExtractResponseSchema = wrapResponse(
  ExtractResultSchema,
  "ExtractResponse"
);
var ObserveOptionsSchema = import_v4107.z.object({
  model: ModelConfigSchema.optional(),
  timeout: import_v4107.z.number().optional().meta({
    description: "Timeout in ms for the observation",
    example: 3e4
  }),
  selector: import_v4107.z.string().optional().meta({
    description: "CSS selector to scope observation to a specific element",
    example: "nav"
  })
}).optional().meta({ id: "ObserveOptions" });
var ObserveRequestSchema = import_v4107.z.object({
  instruction: import_v4107.z.string().optional().meta({
    description: "Natural language instruction for what actions to find",
    example: "Find all clickable navigation links"
  }),
  options: ObserveOptionsSchema,
  frameId: import_v4107.z.string().optional().meta({
    description: "Target frame ID for the observation"
  }),
  streamResponse: import_v4107.z.boolean().optional().meta({
    description: "Whether to stream the response via SSE",
    example: true
  })
}).meta({ id: "ObserveRequest" });
var ObserveResultSchema = import_v4107.z.object({
  result: import_v4107.z.array(ActionSchema),
  actionId: import_v4107.z.string().optional().meta({
    description: "Action ID for tracking"
  })
}).meta({ id: "ObserveResult" });
var ObserveResponseSchema = wrapResponse(
  ObserveResultSchema,
  "ObserveResponse"
);
var AgentConfigSchema = import_v4107.z.object({
  provider: import_v4107.z.enum(["openai", "anthropic", "google", "microsoft"]).optional().meta({
    description: "AI provider for the agent (legacy, use model: openai/gpt-5-nano instead)",
    example: "openai"
  }),
  model: ModelConfigSchema.optional(),
  systemPrompt: import_v4107.z.string().optional().meta({
    description: "Custom system prompt for the agent"
  }),
  cua: import_v4107.z.boolean().optional().meta({
    description: "Enable Computer Use Agent mode",
    example: true
  })
}).meta({ id: "AgentConfig" });
var AgentActionSchema = import_v4107.z.object({
  type: import_v4107.z.string().meta({
    description: "Type of action taken",
    example: "click"
  }),
  reasoning: import_v4107.z.string().optional().meta({
    description: "Agent's reasoning for taking this action"
  }),
  taskCompleted: import_v4107.z.boolean().optional(),
  action: import_v4107.z.string().optional(),
  timeMs: import_v4107.z.number().optional().meta({
    description: "Time taken for this action in ms"
  }),
  pageText: import_v4107.z.string().optional(),
  pageUrl: import_v4107.z.string().optional(),
  instruction: import_v4107.z.string().optional()
}).passthrough().meta({ id: "AgentAction" });
var AgentUsageSchema = import_v4107.z.object({
  input_tokens: import_v4107.z.number().meta({ example: 1500 }),
  output_tokens: import_v4107.z.number().meta({ example: 250 }),
  reasoning_tokens: import_v4107.z.number().optional(),
  cached_input_tokens: import_v4107.z.number().optional(),
  inference_time_ms: import_v4107.z.number().meta({ example: 2500 })
}).meta({ id: "AgentUsage" });
var AgentResultDataSchema = import_v4107.z.object({
  success: import_v4107.z.boolean().meta({
    description: "Whether the agent completed successfully",
    example: true
  }),
  message: import_v4107.z.string().meta({
    description: "Summary of what the agent accomplished",
    example: "Successfully logged in and navigated to dashboard"
  }),
  actions: import_v4107.z.array(AgentActionSchema),
  completed: import_v4107.z.boolean().meta({
    description: "Whether the agent finished its task",
    example: true
  }),
  metadata: import_v4107.z.record(import_v4107.z.string(), import_v4107.z.unknown()).optional(),
  usage: AgentUsageSchema.optional()
}).meta({ id: "AgentResultData" });
var AgentExecuteOptionsSchema = import_v4107.z.object({
  instruction: import_v4107.z.string().meta({
    description: "Natural language instruction for the agent",
    example: "Log in with username 'demo' and password 'test123', then navigate to settings"
  }),
  maxSteps: import_v4107.z.number().optional().meta({
    description: "Maximum number of steps the agent can take",
    example: 20
  }),
  highlightCursor: import_v4107.z.boolean().optional().meta({
    description: "Whether to visually highlight the cursor during execution",
    example: true
  })
}).meta({ id: "AgentExecuteOptions" });
var AgentExecuteRequestSchema = import_v4107.z.object({
  agentConfig: AgentConfigSchema,
  executeOptions: AgentExecuteOptionsSchema,
  frameId: import_v4107.z.string().optional().meta({
    description: "Target frame ID for the agent"
  }),
  streamResponse: import_v4107.z.boolean().optional().meta({
    description: "Whether to stream the response via SSE",
    example: true
  })
}).meta({ id: "AgentExecuteRequest" });
var AgentExecuteResultSchema = import_v4107.z.object({
  result: AgentResultDataSchema
}).meta({ id: "AgentExecuteResult" });
var AgentExecuteResponseSchema = wrapResponse(
  AgentExecuteResultSchema,
  "AgentExecuteResponse"
);
var NavigateOptionsSchema = import_v4107.z.object({
  referer: import_v4107.z.string().optional().meta({
    description: "Referer header to send with the request"
  }),
  timeout: import_v4107.z.number().optional().meta({
    description: "Timeout in ms for the navigation",
    example: 3e4
  }),
  waitUntil: import_v4107.z.enum(["load", "domcontentloaded", "networkidle"]).optional().meta({
    description: "When to consider navigation complete",
    example: "networkidle"
  })
}).optional().meta({ id: "NavigateOptions" });
var NavigateRequestSchema = import_v4107.z.object({
  url: import_v4107.z.string().meta({
    description: "URL to navigate to",
    example: "https://example.com"
  }),
  options: NavigateOptionsSchema,
  frameId: import_v4107.z.string().optional().meta({
    description: "Target frame ID for the navigation"
  }),
  streamResponse: import_v4107.z.boolean().optional().meta({
    description: "Whether to stream the response via SSE",
    example: true
  })
}).meta({ id: "NavigateRequest" });
var NavigateResultSchema = import_v4107.z.object({
  // SerializableResponse from types/private/api.ts - no Zod schema available
  // as it wraps complex devtools-protocol types (Protocol.Network.Response)
  result: import_v4107.z.unknown().nullable().meta({
    description: "Navigation response (Playwright Response object or null)"
  }),
  actionId: import_v4107.z.string().optional().meta({
    description: "Action ID for tracking"
  })
}).meta({ id: "NavigateResult" });
var NavigateResponseSchema = wrapResponse(
  NavigateResultSchema,
  "NavigateResponse"
);
var TokenUsageSchema = import_v4107.z.object({
  inputTokens: import_v4107.z.number().optional(),
  outputTokens: import_v4107.z.number().optional(),
  reasoningTokens: import_v4107.z.number().optional(),
  cachedInputTokens: import_v4107.z.number().optional(),
  timeMs: import_v4107.z.number().optional()
}).meta({ id: "TokenUsage" });
var ReplayActionSchema = import_v4107.z.object({
  method: import_v4107.z.string().optional(),
  tokenUsage: TokenUsageSchema.optional()
}).meta({ id: "ReplayAction" });
var ReplayPageSchema = import_v4107.z.object({
  actions: import_v4107.z.array(ReplayActionSchema).optional()
}).meta({ id: "ReplayPage" });
var ReplayResultSchema = import_v4107.z.object({
  pages: import_v4107.z.array(ReplayPageSchema).optional()
}).meta({ id: "ReplayResult" });
var ReplayResponseSchema = wrapResponse(
  ReplayResultSchema,
  "ReplayResponse"
);
var StreamEventStatusSchema = import_v4107.z.enum(["starting", "connected", "running", "finished", "error"]).meta({
  id: "StreamEventStatus",
  description: "Current status of the streaming operation"
});
var StreamEventTypeSchema = import_v4107.z.enum(["system", "log"]).meta({
  id: "StreamEventType",
  description: "Type of stream event - system events or log messages"
});
var StreamEventSystemDataSchema = import_v4107.z.object({
  status: StreamEventStatusSchema,
  result: import_v4107.z.unknown().optional().meta({
    description: "Operation result (present when status is 'finished')"
  }),
  error: import_v4107.z.string().optional().meta({
    description: "Error message (present when status is 'error')"
  })
}).meta({ id: "StreamEventSystemData" });
var StreamEventLogDataSchema = import_v4107.z.object({
  status: import_v4107.z.literal("running"),
  message: import_v4107.z.string().meta({
    description: "Log message from the operation"
  })
}).meta({ id: "StreamEventLogData" });
var StreamEventSchema = import_v4107.z.object({
  data: import_v4107.z.union([StreamEventSystemDataSchema, StreamEventLogDataSchema]),
  type: StreamEventTypeSchema,
  id: import_v4107.z.string().uuid().meta({
    description: "Unique identifier for this event",
    example: "c4dbf3a9-9a58-4b22-8a1c-9f20f9f9e123"
  })
}).meta({
  id: "StreamEvent",
  description: "Server-Sent Event emitted during streaming responses. Events are sent as `data: <JSON>\\n\\n`. Key order: data (with status first), type, id."
});
var openApiSecuritySchemes = {
  BrowserbaseApiKey: {
    type: "apiKey",
    in: "header",
    name: "x-bb-api-key",
    description: "Browserbase API key for authentication"
  },
  BrowserbaseProjectId: {
    type: "apiKey",
    in: "header",
    name: "x-bb-project-id",
    description: "Browserbase project ID"
  },
  ModelApiKey: {
    type: "apiKey",
    in: "header",
    name: "x-model-api-key",
    description: "API key for the AI model provider (OpenAI, Anthropic, etc.)"
  }
};
var openApiLinks = {
  SessionAct: {
    operationId: "SessionAct",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Perform an action on the session"
  },
  SessionExtract: {
    operationId: "SessionExtract",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Extract data from the session"
  },
  SessionObserve: {
    operationId: "SessionObserve",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Observe available actions on the session"
  },
  SessionNavigate: {
    operationId: "SessionNavigate",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Navigate to a URL in the session"
  },
  SessionAgentExecute: {
    operationId: "SessionAgentExecute",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Execute an agent on the session"
  },
  SessionReplay: {
    operationId: "SessionReplay",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "Replay session metrics"
  },
  SessionEnd: {
    operationId: "SessionEnd",
    parameters: { id: "$response.body#/data/sessionId" },
    description: "End the session and release resources"
  }
};
var Operations = {
  SessionStart: {
    operationId: "SessionStart",
    summary: "Start a new browser session",
    description: "Creates a new browser session with the specified configuration. Returns a session ID used for all subsequent operations."
  },
  SessionEnd: {
    operationId: "SessionEnd",
    summary: "End a browser session",
    description: "Terminates the browser session and releases all associated resources."
  },
  SessionAct: {
    operationId: "SessionAct",
    summary: "Perform an action",
    description: "Executes a browser action using natural language instructions or a predefined Action object."
  },
  SessionExtract: {
    operationId: "SessionExtract",
    summary: "Extract data from the page",
    description: "Extracts structured data from the current page using AI-powered analysis."
  },
  SessionObserve: {
    operationId: "SessionObserve",
    summary: "Observe available actions",
    description: "Identifies and returns available actions on the current page that match the given instruction."
  },
  SessionNavigate: {
    operationId: "SessionNavigate",
    summary: "Navigate to a URL",
    description: "Navigates the browser to the specified URL."
  },
  SessionAgentExecute: {
    operationId: "SessionAgentExecute",
    summary: "Execute an AI agent",
    description: "Runs an autonomous AI agent that can perform complex multi-step browser tasks."
  },
  SessionReplay: {
    operationId: "SessionReplay",
    summary: "Replay session metrics",
    description: "Retrieves replay metrics for a session."
  }
};

// lib/v3/types/public/apiErrors.ts
var StagehandAPIError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var StagehandAPIUnauthorizedError = class extends StagehandAPIError {
  constructor(message) {
    super(message || "Unauthorized request");
  }
};
var StagehandHttpError = class extends StagehandAPIError {
  constructor(message) {
    super(message);
  }
};
var StagehandServerError = class extends StagehandAPIError {
  constructor(message) {
    super(message);
  }
};
var StagehandResponseBodyError = class extends StagehandAPIError {
  constructor() {
    super("Response body is null");
  }
};
var StagehandResponseParseError = class extends StagehandAPIError {
  constructor(message) {
    super(message);
  }
};

// lib/v3/types/public/logs.ts
var LOG_LEVEL_NAMES = {
  0: "error",
  1: "info",
  2: "debug"
};

// lib/v3/types/public/options.ts
var localBrowserLaunchOptionsSchema = LocalBrowserLaunchOptionsSchema;

// lib/v3/types/public/page.ts
init_consoleMessage();
init_response2();

// lib/v3/types/public/index.ts
init_sdkErrors();

// examples/external_clients/aisdk.ts
var import_ai22 = require("ai");
var AISdkClient2 = class extends LLMClient {
  constructor({ model }) {
    super(model.modelId);
    this.type = "aisdk";
    this.model = model;
  }
  createChatCompletion(_0) {
    return __async(this, arguments, function* ({
      options
    }) {
      var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j;
      const formattedMessages = options.messages.map(
        (message) => {
          if (Array.isArray(message.content)) {
            if (message.role === "system") {
              const systemMessage = {
                role: "system",
                content: message.content.map((c) => "text" in c ? c.text : "").join("\n")
              };
              return systemMessage;
            }
            const contentParts = message.content.map((content) => {
              if ("image_url" in content) {
                const imageContent = {
                  type: "image",
                  image: content.image_url.url
                };
                return imageContent;
              } else {
                const textContent = {
                  type: "text",
                  text: content.text
                };
                return textContent;
              }
            });
            if (message.role === "user") {
              const userMessage = {
                role: "user",
                content: contentParts
              };
              return userMessage;
            } else {
              const textOnlyParts = contentParts.map((part) => ({
                type: "text",
                text: part.type === "image" ? "[Image]" : part.text
              }));
              const assistantMessage = {
                role: "assistant",
                content: textOnlyParts
              };
              return assistantMessage;
            }
          }
          return {
            role: message.role,
            content: message.content
          };
        }
      );
      if (options.response_model) {
        const response2 = yield (0, import_ai22.generateObject)({
          model: this.model,
          messages: formattedMessages,
          schema: options.response_model.schema
        });
        return {
          data: response2.object,
          usage: {
            prompt_tokens: (_a4 = response2.usage.inputTokens) != null ? _a4 : 0,
            completion_tokens: (_b = response2.usage.outputTokens) != null ? _b : 0,
            reasoning_tokens: (_c = response2.usage.reasoningTokens) != null ? _c : 0,
            cached_input_tokens: (_d2 = response2.usage.cachedInputTokens) != null ? _d2 : 0,
            total_tokens: (_e = response2.usage.totalTokens) != null ? _e : 0
          }
        };
      }
      const tools = {};
      for (const rawTool of options.tools) {
        tools[rawTool.name] = {
          description: rawTool.description,
          inputSchema: rawTool.parameters
        };
      }
      const response = yield (0, import_ai22.generateText)({
        model: this.model,
        messages: formattedMessages,
        tools
      });
      return {
        data: response.text,
        usage: {
          prompt_tokens: (_f = response.usage.inputTokens) != null ? _f : 0,
          completion_tokens: (_g = response.usage.outputTokens) != null ? _g : 0,
          reasoning_tokens: (_h = response.usage.reasoningTokens) != null ? _h : 0,
          cached_input_tokens: (_i = response.usage.cachedInputTokens) != null ? _i : 0,
          total_tokens: (_j = response.usage.totalTokens) != null ? _j : 0
        }
      };
    });
  }
};

// lib/v3/understudy/context.ts
init_logger();

// lib/v3/understudy/cdp.ts
var import_ws = __toESM(require("ws"));
var CdpConnection = class _CdpConnection {
  constructor(ws) {
    this.nextId = 1;
    this.inflight = /* @__PURE__ */ new Map();
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.sessions = /* @__PURE__ */ new Map();
    /** Maps sessionId -> targetId (1:1 mapping) */
    this.sessionToTarget = /* @__PURE__ */ new Map();
    this.id = null;
    // root
    this.transportCloseHandlers = /* @__PURE__ */ new Set();
    this.ws = ws;
    this.ws.on("close", (code, reason) => {
      const why = `socket-close code=${code} reason=${String(reason || "")}`;
      this.emitTransportClosed(why);
    });
    this.ws.on("error", (err) => {
      var _a4;
      const why = `socket-error ${(_a4 = err == null ? void 0 : err.message) != null ? _a4 : String(err)}`;
      this.emitTransportClosed(why);
    });
    this.ws.on("message", (data) => this.onMessage(data.toString()));
  }
  onTransportClosed(handler) {
    this.transportCloseHandlers.add(handler);
  }
  offTransportClosed(handler) {
    this.transportCloseHandlers.delete(handler);
  }
  emitTransportClosed(why) {
    for (const h2 of this.transportCloseHandlers) {
      try {
        h2(why);
      } catch (e2) {
      }
    }
  }
  static connect(wsUrl) {
    return __async(this, null, function* () {
      const ws = new import_ws.default(wsUrl);
      yield new Promise((resolve3, reject) => {
        ws.once("open", () => resolve3());
        ws.once("error", (e2) => reject(e2));
      });
      return new _CdpConnection(ws);
    });
  }
  enableAutoAttach() {
    return __async(this, null, function* () {
      yield this.send("Target.setAutoAttach", {
        autoAttach: true,
        flatten: true,
        waitForDebuggerOnStart: false,
        filter: [
          { type: "worker", exclude: true },
          { type: "shared_worker", exclude: true },
          { type: "service_worker", exclude: true }
        ]
      });
      yield this.send("Target.setDiscoverTargets", { discover: true });
    });
  }
  send(method, params) {
    return __async(this, null, function* () {
      var _a4, _b;
      const id = this.nextId++;
      const payload = { id, method, params };
      const stack = (_a4 = new Error().stack) == null ? void 0 : _a4.split("\n").slice(1, 4).join("\n");
      const p = new Promise((resolve3, reject) => {
        this.inflight.set(id, {
          resolve: resolve3,
          reject,
          sessionId: null,
          method,
          params,
          stack,
          ts: Date.now()
        });
      });
      (_b = this.cdpLogger) == null ? void 0 : _b.call(this, { method, params, targetId: null });
      this.ws.send(JSON.stringify(payload));
      return p;
    });
  }
  on(event, handler) {
    var _a4;
    const set = (_a4 = this.eventHandlers.get(event)) != null ? _a4 : /* @__PURE__ */ new Set();
    set.add(handler);
    this.eventHandlers.set(event, set);
  }
  off(event, handler) {
    const set = this.eventHandlers.get(event);
    if (set) set.delete(handler);
  }
  close() {
    return __async(this, null, function* () {
      yield new Promise((resolve3) => {
        this.ws.once("close", () => resolve3());
        this.ws.close();
      });
    });
  }
  getSession(sessionId) {
    return this.sessions.get(sessionId);
  }
  attachToTarget(targetId) {
    return __async(this, null, function* () {
      const { sessionId } = yield this.send(
        "Target.attachToTarget",
        { targetId, flatten: true }
      );
      let session = this.sessions.get(sessionId);
      if (!session) {
        session = new CdpSession(this, sessionId);
        this.sessions.set(sessionId, session);
      }
      this.sessionToTarget.set(sessionId, targetId);
      return session;
    });
  }
  getTargets() {
    return __async(this, null, function* () {
      const res = yield this.send("Target.getTargets");
      return res.targetInfos;
    });
  }
  onMessage(json) {
    var _a4;
    const msg = JSON.parse(json);
    if ("id" in msg) {
      const rec = this.inflight.get(msg.id);
      if (!rec) return;
      this.inflight.delete(msg.id);
      if ("error" in msg && msg.error) {
        rec.reject(new Error(`${msg.error.code} ${msg.error.message}`));
      } else {
        rec.resolve(msg.result);
      }
      return;
    }
    if ("method" in msg) {
      if (msg.method === "Target.attachedToTarget") {
        const p = msg.params;
        if (!this.sessions.has(p.sessionId)) {
          this.sessions.set(p.sessionId, new CdpSession(this, p.sessionId));
        }
        this.sessionToTarget.set(p.sessionId, p.targetInfo.targetId);
      } else if (msg.method === "Target.detachedFromTarget") {
        const p = msg.params;
        for (const [id, entry] of this.inflight.entries()) {
          if (entry.sessionId === p.sessionId) {
            entry.reject(new Error("CDP session detached"));
            this.inflight.delete(id);
          }
        }
        this.sessions.delete(p.sessionId);
        this.sessionToTarget.delete(p.sessionId);
      } else if (msg.method === "Target.targetDestroyed") {
        const p = msg.params;
        for (const [sessionId2, targetId2] of this.sessionToTarget.entries()) {
          if (targetId2 === p.targetId) {
            this.sessionToTarget.delete(sessionId2);
            break;
          }
        }
      }
      const { method, params, sessionId } = msg;
      const targetId = this.sessionToTarget.get(sessionId) || sessionId;
      (_a4 = this.cdpEventLogger) == null ? void 0 : _a4.call(this, { method, params, targetId });
      if (sessionId) {
        const session = this.sessions.get(sessionId);
        session == null ? void 0 : session.dispatch(method, params);
      } else {
        const handlers = this.eventHandlers.get(method);
        if (handlers) for (const h2 of handlers) h2(params);
      }
    }
  }
  _sendViaSession(sessionId, method, params) {
    var _a4, _b, _c;
    const id = this.nextId++;
    const payload = { id, method, params, sessionId };
    const stack = (_a4 = new Error().stack) == null ? void 0 : _a4.split("\n").slice(1, 4).join("\n");
    const p = new Promise((resolve3, reject) => {
      this.inflight.set(id, {
        resolve: resolve3,
        reject,
        sessionId,
        method,
        params,
        stack,
        ts: Date.now()
      });
    });
    const targetId = (_b = this.sessionToTarget.get(sessionId)) != null ? _b : null;
    (_c = this.cdpLogger) == null ? void 0 : _c.call(this, { method, params, targetId });
    this.ws.send(JSON.stringify(payload));
    return p;
  }
  _onSessionEvent(sessionId, event, handler) {
    var _a4;
    const key = `${sessionId}:${event}`;
    const set = (_a4 = this.eventHandlers.get(key)) != null ? _a4 : /* @__PURE__ */ new Set();
    set.add(handler);
    this.eventHandlers.set(key, set);
  }
  _offSessionEvent(sessionId, event, handler) {
    const key = `${sessionId}:${event}`;
    const set = this.eventHandlers.get(key);
    if (set) set.delete(handler);
  }
  _dispatchToSession(sessionId, event, params) {
    const key = `${sessionId}:${event}`;
    const handlers = this.eventHandlers.get(key);
    if (handlers) for (const h2 of handlers) h2(params);
  }
};
var CdpSession = class {
  constructor(root, id) {
    this.root = root;
    this.id = id;
  }
  send(method, params) {
    return this.root._sendViaSession(this.id, method, params);
  }
  on(event, handler) {
    this.root._onSessionEvent(this.id, event, handler);
  }
  off(event, handler) {
    this.root._offSessionEvent(this.id, event, handler);
  }
  close() {
    return __async(this, null, function* () {
      yield this.root.send("Target.detachFromTarget", {
        sessionId: this.id
      });
    });
  }
  dispatch(event, params) {
    this.root._dispatchToSession(this.id, event, params);
  }
};

// lib/v3/understudy/context.ts
init_page();

// lib/v3/understudy/piercer.ts
init_logger();

// lib/v3/dom/build/scriptV3Content.ts
var v3ScriptContent = '(()=>{function b(_={}){let S=n=>{let{hostToRoot:l}=n,m=t=>{let o=[];if(t instanceof Document)return t.documentElement&&o.push(t.documentElement),o;if(t instanceof ShadowRoot||t instanceof DocumentFragment)return o.push(...Array.from(t.children)),o;if(t instanceof Element){o.push(...Array.from(t.children));let a=t.shadowRoot;a&&o.push(...Array.from(a.children));let r=l.get(t);return r&&o.push(...Array.from(r.children)),o}return o},v=t=>{let o=[],a=[...m(t)];for(;a.length;){let r=a.shift();o.push(r),a.push(...m(r))}return o},y=t=>{let o=String(t||"").trim();if(!o)return null;let a=o.replace(/^xpath=/i,""),r=[];{let e=0;for(;e<a.length;){let d="child";a.startsWith("//",e)?(d="desc",e+=2):a[e]==="/"&&(d="child",e+=1);let h=e;for(;e<a.length&&a[e]!=="/";)e++;let u=a.slice(h,e).trim();if(!u)continue;let p=u.match(/^(.*?)(\\[(\\d+)\\])?$/u),i=(p?.[1]??u).trim(),c=p?.[3]?Math.max(1,Number(p[3])):null,R=i===""?"*":i.toLowerCase();r.push({axis:d,raw:u,tag:R,index:c})}}n.debug&&console.info("[v3-piercer][resolve] start",{url:location.href,steps:r.map(e=>({axis:e.axis,raw:e.raw,tag:e.tag,index:e.index}))});let g=[document];for(let e of r){let d=e.index,h=null;for(let u of g){let p=e.axis==="child"?m(u):v(u),i=[];for(let c of p)(e.tag==="*"||c.localName===e.tag)&&i.push(c);if(n.debug&&console.info("[v3-piercer][resolve] step",{axis:e.axis,tag:e.tag,index:d,poolCount:p.length,matchesCount:i.length}),!!i.length){if(d!=null){let c=d-1;h=c>=0&&c<i.length?i[c]:null}else h=i[0];if(h)break}}if(!h)return n.debug&&console.info("[v3-piercer][resolve] no-match",{step:e.raw}),null;g=[h]}let E=g.length?g[0]:null;return n.debug&&console.info("[v3-piercer][resolve] done",{found:!!E,tag:E?.localName??""}),E};window.__stagehandV3__={getClosedRoot:t=>l.get(t),stats:()=>({installed:!0,url:location.href,isTop:window.top===window,open:n.openCount,closed:n.closedCount}),resolveSimpleXPath:y}},f=Element.prototype.attachShadow;if(f.__v3Patched&&f.__v3State){f.__v3State.debug=!0,S(f.__v3State);return}let s={hostToRoot:new WeakMap,openCount:0,closedCount:0,debug:!0},x=f,w=function(n){let l=n?.mode??"open",m=x.call(this,n);try{s.hostToRoot.set(this,m),l==="closed"?s.closedCount++:s.openCount++,s.debug&&console.info("[v3-piercer] attachShadow",{tag:this.tagName?.toLowerCase()??"",mode:l,url:location.href})}catch{}return m};if(w.__v3Patched=!0,w.__v3State=s,Object.defineProperty(Element.prototype,"attachShadow",{configurable:!0,writable:!0,value:w}),_.tagExisting)try{let n=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT);for(;n.nextNode();){let l=n.currentNode;l.shadowRoot&&(s.hostToRoot.set(l,l.shadowRoot),s.openCount++)}}catch{}window.__stagehandV3Injected=!0,S(s),s.debug&&console.info("[v3-piercer] installed",{url:location.href,isTop:window.top===window,readyState:document.readyState})}b({debug:!0,tagExisting:!1});})();\n';

// lib/v3/dom/build/reRenderScriptContent.ts
var reRenderScriptContent = '(()=>{function s(){try{let o=window.__stagehandV3__;if(!o||typeof o.getClosedRoot!="function")return;let t=[],r=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT);for(;r.nextNode();){let e=r.currentNode,n=e.tagName?.toLowerCase()??"";if(!n.includes("-")||typeof customElements?.get!="function"||!customElements.get(n))continue;let c=!!e.shadowRoot,i=!!o.getClosedRoot(e);c||i||t.push(e)}for(let e of t)try{let n=e.cloneNode(!0);e.replaceWith(n)}catch{}o.stats&&t.length&&console.info("[v3-piercer] rerender",{count:t.length})}catch(o){console.info("[v3-piercer] rerender error",{message:String(o??"")})}}s();})();\n';

// lib/v3/understudy/piercer.ts
function installV3PiercerIntoSession(session) {
  return __async(this, null, function* () {
    var _a4, _b;
    const pageEnabled = yield session.send("Page.enable").then(() => true).catch(() => false);
    if (!pageEnabled) return false;
    yield session.send("Runtime.enable").catch(() => {
    });
    try {
      yield session.send(
        "Page.addScriptToEvaluateOnNewDocument",
        { source: v3ScriptContent, runImmediately: true }
      );
    } catch (e2) {
      const msg = String((_b = (_a4 = e2 == null ? void 0 : e2.message) != null ? _a4 : e2) != null ? _b : "");
      if (msg.includes("Session with given id not found")) return false;
    }
    yield session.send("Runtime.evaluate", {
      expression: v3ScriptContent,
      returnByValue: true,
      awaitPromise: true
    }).catch(() => {
    });
    yield session.send("Runtime.evaluate", {
      expression: reRenderScriptContent,
      returnByValue: true,
      awaitPromise: false
    }).catch(() => {
    });
    return true;
  });
}

// lib/v3/understudy/context.ts
init_executionContextRegistry();
init_initScripts();
init_sdkErrors();
function isTopLevelPage(info) {
  const ti = info;
  return info.type === "page" && ti.subtype !== "iframe";
}
var V3Context = class _V3Context {
  constructor(conn, env = "LOCAL", apiClient = null, localBrowserLaunchOptions = null) {
    this.conn = conn;
    this.env = env;
    this.apiClient = apiClient;
    this.localBrowserLaunchOptions = localBrowserLaunchOptions;
    this._piercerInstalled = /* @__PURE__ */ new Set();
    // Timestamp for most recent popup/open signal
    this._lastPopupSignalAt = 0;
    this._sessionInit = /* @__PURE__ */ new Set();
    this.pagesByTarget = /* @__PURE__ */ new Map();
    this.mainFrameToTarget = /* @__PURE__ */ new Map();
    this.sessionOwnerPage = /* @__PURE__ */ new Map();
    this.frameOwnerPage = /* @__PURE__ */ new Map();
    this.pendingOopifByMainFrame = /* @__PURE__ */ new Map();
    this.createdAtByTarget = /* @__PURE__ */ new Map();
    this.typeByTarget = /* @__PURE__ */ new Map();
    this._pageOrder = [];
    this.pendingCreatedTargetUrl = /* @__PURE__ */ new Map();
    this.initScripts = [];
  }
  sessionKey(session) {
    var _a4;
    return (_a4 = session.id) != null ? _a4 : "root";
  }
  /**
   * Create a Context for a given CDP websocket URL and bootstrap target wiring.
   */
  static create(wsUrl, opts) {
    return __async(this, null, function* () {
      var _a4, _b, _c;
      const conn = yield CdpConnection.connect(wsUrl);
      const ctx = new _V3Context(
        conn,
        (_a4 = opts == null ? void 0 : opts.env) != null ? _a4 : "LOCAL",
        (_b = opts == null ? void 0 : opts.apiClient) != null ? _b : null,
        (_c = opts == null ? void 0 : opts.localBrowserLaunchOptions) != null ? _c : null
      );
      yield ctx.bootstrap();
      yield ctx.waitForFirstTopLevelPage(5e3);
      return ctx;
    });
  }
  /**
   * Wait until at least one top-level Page has been created and registered.
   * We poll internal maps that bootstrap/onAttachedToTarget populate.
   */
  waitForFirstTopLevelPage(timeoutMs) {
    return __async(this, null, function* () {
      const deadline = Date.now() + timeoutMs;
      while (Date.now() < deadline) {
        for (const [tid, ttype] of this.typeByTarget) {
          if (ttype === "page") {
            const p = this.pagesByTarget.get(tid);
            if (p) return;
          }
        }
        yield new Promise((r2) => setTimeout(r2, 25));
      }
      throw new TimeoutError(
        "waitForFirstTopLevelPage (no top-level Page)",
        timeoutMs
      );
    });
  }
  waitForInitialTopLevelTargets(targetIds, timeoutMs = 3e3) {
    return __async(this, null, function* () {
      if (!targetIds.length) return;
      const pending = new Set(targetIds);
      const deadline = Date.now() + timeoutMs;
      while (pending.size && Date.now() < deadline) {
        for (const tid of Array.from(pending)) {
          if (this.pagesByTarget.has(tid)) {
            pending.delete(tid);
          }
        }
        if (!pending.size) return;
        yield new Promise((r2) => setTimeout(r2, 25));
      }
      if (pending.size) {
        v3Logger({
          category: "ctx",
          message: "Timed out waiting for existing top-level targets to attach",
          level: 2,
          auxiliary: {
            remainingTargets: {
              value: JSON.stringify(Array.from(pending)),
              type: "object"
            }
          }
        });
      }
    });
  }
  ensurePiercer(session) {
    return __async(this, null, function* () {
      const key = this.sessionKey(session);
      if (this._piercerInstalled.has(key)) return true;
      const installed = yield installV3PiercerIntoSession(session);
      if (installed) {
        this._piercerInstalled.add(key);
      }
      return installed;
    });
  }
  /** Mark a page target as the most-recent one (active). */
  _pushActive(tid) {
    const i2 = this._pageOrder.indexOf(tid);
    if (i2 !== -1) this._pageOrder.splice(i2, 1);
    this._pageOrder.push(tid);
  }
  /** Remove a page target from the recency list (used on close). */
  _removeFromOrder(tid) {
    const i2 = this._pageOrder.indexOf(tid);
    if (i2 !== -1) this._pageOrder.splice(i2, 1);
  }
  /** Return the current active Page (most-recent page that still exists). */
  activePage() {
    var _a4;
    for (let i2 = this._pageOrder.length - 1; i2 >= 0; i2--) {
      const tid = this._pageOrder[i2];
      const p = this.pagesByTarget.get(tid);
      if (p) return p;
      this._pageOrder.splice(i2, 1);
    }
    let newestTid;
    let newestTs = -1;
    for (const [tid] of this.pagesByTarget) {
      const ts = (_a4 = this.createdAtByTarget.get(tid)) != null ? _a4 : 0;
      if (ts > newestTs) {
        newestTs = ts;
        newestTid = tid;
      }
    }
    return newestTid ? this.pagesByTarget.get(newestTid) : void 0;
  }
  /** Explicitly mark a known Page as the most-recent active page (and focus it). */
  setActivePage(page) {
    let targetId = page.targetId();
    if (this.pagesByTarget.get(targetId) !== page) {
      const lookup = this.findTargetIdByPage(page);
      if (!lookup) {
        v3Logger({
          category: "ctx",
          message: "setActivePage called with unknown Page",
          level: 2,
          auxiliary: {
            targetId: { value: String(targetId), type: "string" }
          }
        });
        return;
      }
      targetId = lookup;
    }
    this._pushActive(targetId);
    void this.conn.send("Target.activateTarget", { targetId }).catch(() => {
    });
  }
  addInitScript(script, arg) {
    return __async(this, null, function* () {
      const source = yield normalizeInitScriptSource(script, arg);
      this.initScripts.push(source);
      const pages = this.pages();
      yield Promise.all(pages.map((page) => page.registerInitScript(source)));
    });
  }
  /**
   * Return top-level `Page`s (oldest  newest). OOPIF targets are not included.
   */
  pages() {
    var _a4;
    const rows = [];
    for (const [tid, page] of this.pagesByTarget) {
      if (this.typeByTarget.get(tid) === "page") {
        rows.push({ tid, page, created: (_a4 = this.createdAtByTarget.get(tid)) != null ? _a4 : 0 });
      }
    }
    rows.sort((a, b) => a.created - b.created);
    return rows.map((r2) => r2.page);
  }
  applyInitScriptsToPage(page) {
    return __async(this, null, function* () {
      for (const source of this.initScripts) {
        yield page.registerInitScript(source);
      }
    });
  }
  /**
   * Resolve an owning `Page` by the **top-level main frame id**.
   * Note: child (OOPIF) roots are intentionally not present in this mapping.
   */
  resolvePageByMainFrameId(frameId) {
    const targetId = this.mainFrameToTarget.get(frameId);
    return targetId ? this.pagesByTarget.get(targetId) : void 0;
  }
  /**
   * Serialize the full frame tree for a given top-level main frame id.
   */
  getFullFrameTreeByMainFrameId(rootMainFrameId) {
    return __async(this, null, function* () {
      const owner = this.resolvePageByMainFrameId(rootMainFrameId);
      if (!owner) throw new PageNotFoundError(`mainFrameId=${rootMainFrameId}`);
      return owner.asProtocolFrameTree(rootMainFrameId);
    });
  }
  /**
   * Create a new top-level page (tab) with the given URL and return its Page object.
   * Waits until the target is attached and registered.
   */
  newPage(url = "about:blank") {
    return __async(this, null, function* () {
      const { targetId } = yield this.conn.send(
        "Target.createTarget",
        { url }
      );
      this.pendingCreatedTargetUrl.set(targetId, url);
      yield this.conn.send("Target.activateTarget", { targetId }).catch(() => {
      });
      const deadline = Date.now() + 5e3;
      while (Date.now() < deadline) {
        const page = this.pagesByTarget.get(targetId);
        if (page) return page;
        yield new Promise((r2) => setTimeout(r2, 25));
      }
      throw new TimeoutError(`newPage: target not attached (${targetId})`, 5e3);
    });
  }
  /**
   * Close CDP and clear all mappings. Best-effort cleanup.
   */
  close() {
    return __async(this, null, function* () {
      yield this.conn.close();
      this.pagesByTarget.clear();
      this.mainFrameToTarget.clear();
      this.sessionOwnerPage.clear();
      this.frameOwnerPage.clear();
      this.pendingOopifByMainFrame.clear();
      this.createdAtByTarget.clear();
      this.typeByTarget.clear();
      this.pendingCreatedTargetUrl.clear();
    });
  }
  /**
   * Bootstrap target lifecycle:
   * - Attach to existing targets.
   * - Attach on `Target.targetCreated` (fallback for OOPIFs).
   * - Handle auto-attach events.
   * - Clean up on detach/destroy.
   */
  bootstrap() {
    return __async(this, null, function* () {
      this.conn.on(
        "Target.attachedToTarget",
        (evt) => __async(this, null, function* () {
          yield this.onAttachedToTarget(evt.targetInfo, evt.sessionId);
        })
      );
      this.conn.on(
        "Target.detachedFromTarget",
        (evt) => {
          var _a4;
          this.onDetachedFromTarget(evt.sessionId, (_a4 = evt.targetId) != null ? _a4 : null);
        }
      );
      this.conn.on(
        "Target.targetDestroyed",
        (evt) => {
          this.cleanupByTarget(evt.targetId);
        }
      );
      this.conn.on(
        "Target.targetCreated",
        (evt) => __async(this, null, function* () {
          const info = evt.targetInfo;
          if (info.type === "worker" || info.type === "service_worker" || info.type === "shared_worker") {
            return;
          }
          const ti = info;
          if (info.type === "page" && ((ti == null ? void 0 : ti.openerId) || (ti == null ? void 0 : ti.openerFrameId))) {
            this._notePopupSignal();
          }
          try {
            yield this.conn.attachToTarget(info.targetId);
          } catch (e2) {
          }
        })
      );
      yield this.conn.enableAutoAttach();
      const targets = yield this.conn.getTargets();
      for (const t2 of targets) {
        if (t2.attached) continue;
        try {
          yield this.conn.attachToTarget(t2.targetId);
        } catch (e2) {
        }
      }
      const topLevelTargetIds = targets.filter((t2) => isTopLevelPage(t2)).map((t2) => t2.targetId);
      yield this.waitForInitialTopLevelTargets(topLevelTargetIds);
    });
  }
  /**
   * Handle a newly attached target (top-level or potential OOPIF):
   * - Enable Page domain and lifecycle events.
   * - If top-level  create Page, wire listeners, resume.
   * - Else  probe child root frame id via `Page.getFrameTree` and adopt immediately
   *   if the parent is known; otherwise stage until parent `frameAttached`.
   * - Resume the target only after listeners are wired.
   */
  onAttachedToTarget(info, sessionId) {
    return __async(this, null, function* () {
      var _a4;
      const session = this.conn.getSession(sessionId);
      if (!session) return;
      if (this._sessionInit.has(sessionId)) return;
      this._sessionInit.add(sessionId);
      yield session.send("Runtime.runIfWaitingForDebugger").catch(() => {
      });
      executionContexts.attachSession(session);
      const piercerReady = yield this.ensurePiercer(session);
      if (!piercerReady) return;
      yield session.send("Page.setLifecycleEventsEnabled", { enabled: true }).catch(() => {
      });
      if (isTopLevelPage(info)) {
        const page = yield Page.create(
          this.conn,
          session,
          info.targetId,
          this.apiClient,
          this.localBrowserLaunchOptions,
          this.env === "BROWSERBASE"
        );
        this.wireSessionToOwnerPage(sessionId, page);
        this.pagesByTarget.set(info.targetId, page);
        this.mainFrameToTarget.set(page.mainFrameId(), info.targetId);
        this.sessionOwnerPage.set(sessionId, page);
        this.frameOwnerPage.set(page.mainFrameId(), page);
        this.typeByTarget.set(info.targetId, "page");
        if (!this.createdAtByTarget.has(info.targetId)) {
          this.createdAtByTarget.set(info.targetId, Date.now());
        }
        const pendingSeedUrl = this.pendingCreatedTargetUrl.get(info.targetId);
        this.pendingCreatedTargetUrl.delete(info.targetId);
        page.seedCurrentUrl((_a4 = pendingSeedUrl != null ? pendingSeedUrl : info.url) != null ? _a4 : "");
        this._pushActive(info.targetId);
        this.installFrameEventBridges(sessionId, page);
        yield this.applyInitScriptsToPage(page);
        return;
      }
      try {
        const { frameTree } = yield session.send(
          "Page.getFrameTree"
        );
        const childMainId = frameTree.frame.id;
        let owner = this.frameOwnerPage.get(childMainId);
        if (!owner) {
          for (const p of this.pagesByTarget.values()) {
            const tree = p.asProtocolFrameTree(p.mainFrameId());
            const has = (function find(n) {
              var _a5;
              if (n.frame.id === childMainId) return true;
              for (const c of (_a5 = n.childFrames) != null ? _a5 : []) if (find(c)) return true;
              return false;
            })(tree);
            if (has) {
              owner = p;
              break;
            }
          }
        }
        if (owner) {
          owner.adoptOopifSession(session, childMainId);
          this.sessionOwnerPage.set(sessionId, owner);
          this.installFrameEventBridges(sessionId, owner);
          void executionContexts.waitForMainWorld(session, childMainId).catch(() => {
          });
        } else {
          this.pendingOopifByMainFrame.set(childMainId, sessionId);
        }
      } catch (e2) {
      }
    });
  }
  /**
   * Detach handler:
   * - Remove child session ownership and prune its subtree.
   * - If a top-level target, cleanup its `Page` and mappings.
   * - Drop any staged child for this session.
   */
  onDetachedFromTarget(sessionId, targetId) {
    const owner = this.sessionOwnerPage.get(sessionId);
    if (owner) {
      owner.detachOopifSession(sessionId);
      this.sessionOwnerPage.delete(sessionId);
    }
    if (targetId && this.pagesByTarget.has(targetId)) {
      this.cleanupByTarget(targetId);
    }
    for (const [fid, sid] of Array.from(
      this.pendingOopifByMainFrame.entries()
    )) {
      if (sid === sessionId) this.pendingOopifByMainFrame.delete(fid);
    }
  }
  /**
   * Cleanup a top-level Page by target id, removing its root and staged children.
   */
  cleanupByTarget(targetId) {
    const page = this.pagesByTarget.get(targetId);
    if (!page) return;
    const mainId = page.mainFrameId();
    this.mainFrameToTarget.delete(mainId);
    this.frameOwnerPage.delete(mainId);
    for (const [sid, p] of Array.from(this.sessionOwnerPage.entries())) {
      if (p === page) this.sessionOwnerPage.delete(sid);
    }
    for (const [fid] of Array.from(this.pendingOopifByMainFrame.entries())) {
      const owner = this.frameOwnerPage.get(fid);
      if (!owner || owner === page) this.pendingOopifByMainFrame.delete(fid);
    }
    this._removeFromOrder(targetId);
    this.pagesByTarget.delete(targetId);
    this.createdAtByTarget.delete(targetId);
    this.typeByTarget.delete(targetId);
    this.pendingCreatedTargetUrl.delete(targetId);
  }
  /**
   * Wire Page-domain frame events for a session into the owning Page & mappings.
   * We forward the *emitting session* with every event so Page can stamp ownership precisely.
   */
  installFrameEventBridges(sessionId, owner) {
    const session = this.conn.getSession(sessionId);
    if (!session) return;
    session.on(
      "Page.frameAttached",
      (evt) => {
        const { frameId, parentFrameId } = evt;
        owner.onFrameAttached(frameId, parentFrameId != null ? parentFrameId : null, session);
        const pendingChildSessionId = this.pendingOopifByMainFrame.get(frameId);
        if (pendingChildSessionId) {
          const child = this.conn.getSession(pendingChildSessionId);
          if (child) {
            owner.adoptOopifSession(child, frameId);
            this.sessionOwnerPage.set(child.id, owner);
            this.installFrameEventBridges(pendingChildSessionId, owner);
          }
          this.pendingOopifByMainFrame.delete(frameId);
        }
        this.frameOwnerPage.set(frameId, owner);
        if (!parentFrameId) {
          const newRoot = owner.mainFrameId();
          const topTargetId = this.findTargetIdByPage(owner);
          if (topTargetId) {
            this.mainFrameToTarget.set(newRoot, topTargetId);
          }
          this.frameOwnerPage.set(newRoot, owner);
        }
      }
    );
    session.on(
      "Page.frameDetached",
      (evt) => {
        var _a4;
        owner.onFrameDetached(evt.frameId, (_a4 = evt.reason) != null ? _a4 : "remove");
        if (evt.reason !== "swap") {
          this.frameOwnerPage.delete(evt.frameId);
        }
      }
    );
    session.on(
      "Page.frameNavigated",
      (evt) => {
        owner.onFrameNavigated(evt.frame, session);
      }
    );
    session.on(
      "Page.navigatedWithinDocument",
      (evt) => {
        owner.onNavigatedWithinDocument(evt.frameId, evt.url, session);
      }
    );
    session.on("Page.windowOpen", () => {
      this._notePopupSignal();
    });
  }
  /**
   * Register that a session belongs to a Page (used by event routing).
   */
  wireSessionToOwnerPage(sessionId, owner) {
    this.sessionOwnerPage.set(sessionId, owner);
  }
  /**
   * Utility: reverse-lookup the top-level target id that owns a given Page.
   */
  findTargetIdByPage(page) {
    for (const [tid, p] of this.pagesByTarget) {
      if (p === page) return tid;
    }
    return void 0;
  }
  _notePopupSignal() {
    this._lastPopupSignalAt = Date.now();
  }
  /**
   * Await the current active page, waiting briefly if a popup/open was just triggered.
   * Normal path returns immediately; popup path waits up to timeoutMs for the new page.
   */
  awaitActivePage(timeoutMs) {
    return __async(this, null, function* () {
      var _a4;
      const defaultTimeout = this.env === "BROWSERBASE" ? 4e3 : 2e3;
      timeoutMs = timeoutMs != null ? timeoutMs : defaultTimeout;
      const recentWindowMs = this.env === "BROWSERBASE" ? 1e3 : 300;
      const now2 = Date.now();
      const hasRecentPopup = now2 - this._lastPopupSignalAt <= recentWindowMs;
      const immediate = this.activePage();
      if (!hasRecentPopup && immediate) return immediate;
      const deadline = now2 + timeoutMs;
      while (Date.now() < deadline) {
        let newestTid;
        let newestTs = -1;
        for (const [tid] of this.pagesByTarget) {
          const ts = (_a4 = this.createdAtByTarget.get(tid)) != null ? _a4 : 0;
          if (ts > newestTs) {
            newestTs = ts;
            newestTid = tid;
          }
        }
        if (newestTid) {
          const p = this.pagesByTarget.get(newestTid);
          if (p && newestTs >= this._lastPopupSignalAt) return p;
        }
        yield new Promise((r2) => setTimeout(r2, 25));
      }
      if (immediate) return immediate;
      throw new PageNotFoundError("awaitActivePage: no page available");
    });
  }
};

// lib/modelUtils.ts
function splitModelName(model) {
  const firstSlashIndex = model.indexOf("/");
  const provider = model.substring(0, firstSlashIndex);
  const modelName = model.substring(firstSlashIndex + 1);
  return { provider, modelName };
}
function resolveModel(model) {
  const modelString = typeof model === "string" ? model : model.modelName;
  const clientOptions = typeof model === "string" ? {} : (() => {
    const _a4 = model, { modelName: _ } = _a4, rest = __objRest(_a4, ["modelName"]);
    return rest;
  })();
  const hasExplicitProvider = clientOptions.provider !== void 0;
  let provider;
  let parsedModelName;
  if (hasExplicitProvider) {
    provider = clientOptions.provider;
    parsedModelName = modelString;
  } else {
    const split = splitModelName(modelString);
    provider = split.provider;
    parsedModelName = split.modelName;
  }
  const isCua = hasExplicitProvider || AVAILABLE_CUA_MODELS.includes(modelString);
  return {
    provider,
    modelName: parsedModelName,
    clientOptions,
    isCua
  };
}

// lib/v3/api.ts
var import_fetch_cookie = __toESM(require("fetch-cookie"));
init_version();
var StagehandAPIClient = class {
  constructor({ apiKey, projectId, logger }) {
    this.apiKey = apiKey;
    this.projectId = projectId;
    this.logger = logger;
    this.fetchWithCookies = (0, import_fetch_cookie.default)(fetch);
  }
  init(_0) {
    return __async(this, arguments, function* ({
      modelName,
      modelApiKey,
      domSettleTimeoutMs,
      verbose,
      systemPrompt,
      selfHeal,
      browserbaseSessionCreateParams,
      browserbaseSessionID
      // browser,  TODO for local browsers
    }) {
      var _a4;
      if (!modelApiKey) {
        throw new StagehandAPIError("modelApiKey is required");
      }
      this.modelApiKey = modelApiKey;
      this.modelProvider = (modelName == null ? void 0 : modelName.includes("/")) ? modelName.split("/")[0] : void 0;
      const region = browserbaseSessionCreateParams == null ? void 0 : browserbaseSessionCreateParams.region;
      if (region && region !== "us-west-2") {
        return { sessionId: browserbaseSessionID != null ? browserbaseSessionID : null, available: false };
      }
      this.logger({
        category: "init",
        message: "Creating new browserbase session...",
        level: 1
      });
      const requestBody = {
        modelName,
        domSettleTimeoutMs,
        verbose,
        systemPrompt,
        selfHeal,
        browserbaseSessionCreateParams,
        browserbaseSessionID
        // browser, TODO: only send when connected to local fastify
      };
      const sessionResponse = yield this.request("/sessions/start", {
        method: "POST",
        body: JSON.stringify(requestBody)
      });
      if (sessionResponse.status === 401) {
        throw new StagehandAPIUnauthorizedError(
          "Unauthorized. Ensure you provided a valid API key."
        );
      } else if (sessionResponse.status !== 200) {
        const errorText = yield sessionResponse.text();
        this.logger({
          category: "api",
          message: `API error (${sessionResponse.status}): ${errorText}`,
          level: 0
        });
        throw new StagehandHttpError(`Unknown error: ${sessionResponse.status}`);
      }
      const sessionResponseBody = yield sessionResponse.json();
      if (sessionResponseBody.success === false) {
        throw new StagehandAPIError(sessionResponseBody.message);
      }
      if (!((_a4 = sessionResponseBody.data) == null ? void 0 : _a4.available) && browserbaseSessionID) {
        sessionResponseBody.data.sessionId = browserbaseSessionID;
      }
      this.sessionId = sessionResponseBody.data.sessionId;
      return sessionResponseBody.data;
    });
  }
  act(_0) {
    return __async(this, arguments, function* ({
      input,
      options,
      frameId
    }) {
      let wireOptions;
      if (options) {
        const _a4 = options, { page: _ } = _a4, restOptions = __objRest(_a4, ["page"]);
        if (Object.keys(restOptions).length > 0) {
          if (restOptions.model) {
            restOptions.model = this.prepareModelConfig(restOptions.model);
          }
          wireOptions = restOptions;
        }
      }
      const requestBody = {
        input,
        options: wireOptions,
        frameId
      };
      return this.execute({
        method: "act",
        args: requestBody
      });
    });
  }
  extract(_0) {
    return __async(this, arguments, function* ({
      instruction,
      schema: zodSchema3,
      options,
      frameId
    }) {
      const jsonSchema3 = zodSchema3 ? toJsonSchema(zodSchema3) : void 0;
      let wireOptions;
      if (options) {
        const _a4 = options, { page: _ } = _a4, restOptions = __objRest(_a4, ["page"]);
        if (Object.keys(restOptions).length > 0) {
          if (restOptions.model) {
            restOptions.model = this.prepareModelConfig(restOptions.model);
          }
          wireOptions = restOptions;
        }
      }
      const requestBody = {
        instruction,
        schema: jsonSchema3,
        options: wireOptions,
        frameId
      };
      return this.execute({
        method: "extract",
        args: requestBody
      });
    });
  }
  observe(_0) {
    return __async(this, arguments, function* ({
      instruction,
      options,
      frameId
    }) {
      let wireOptions;
      if (options) {
        const _a4 = options, { page: _ } = _a4, restOptions = __objRest(_a4, ["page"]);
        if (Object.keys(restOptions).length > 0) {
          if (restOptions.model) {
            restOptions.model = this.prepareModelConfig(restOptions.model);
          }
          wireOptions = restOptions;
        }
      }
      const requestBody = {
        instruction,
        options: wireOptions,
        frameId
      };
      return this.execute({
        method: "observe",
        args: requestBody
      });
    });
  }
  goto(url, options, frameId) {
    return __async(this, null, function* () {
      const requestBody = { url, options, frameId };
      return this.execute({
        method: "navigate",
        args: requestBody
      });
    });
  }
  agentExecute(agentConfig, executeOptions, frameId) {
    return __async(this, null, function* () {
      if (agentConfig.integrations && agentConfig.integrations.length > 0) {
        throw new ExperimentalNotConfiguredError("MCP integrations");
      }
      let wireExecuteOptions;
      if (typeof executeOptions === "string") {
        wireExecuteOptions = { instruction: executeOptions };
      } else if (executeOptions.page) {
        const _a4 = executeOptions, { page: _ } = _a4, rest = __objRest(_a4, ["page"]);
        wireExecuteOptions = rest;
      } else {
        wireExecuteOptions = executeOptions;
      }
      const requestBody = {
        agentConfig,
        executeOptions: wireExecuteOptions,
        frameId
      };
      return this.execute({
        method: "agentExecute",
        args: requestBody
      });
    });
  }
  end() {
    return __async(this, null, function* () {
      const url = `/sessions/${this.sessionId}/end`;
      const response = yield this.request(url, {
        method: "POST"
      });
      return response;
    });
  }
  getReplayMetrics() {
    return __async(this, null, function* () {
      if (!this.sessionId) {
        throw new StagehandAPIError("sessionId is required to fetch metrics.");
      }
      const response = yield this.request(`/sessions/${this.sessionId}/replay`, {
        method: "GET"
      });
      if (response.status !== 200) {
        const errorText = yield response.text();
        this.logger({
          category: "api",
          message: `Failed to fetch metrics. Status ${response.status}: ${errorText}`,
          level: 0
        });
        throw new StagehandHttpError(
          `Failed to fetch metrics with status ${response.status}: ${errorText}`
        );
      }
      const data = yield response.json();
      if (!data.success) {
        const errorData = data;
        throw new StagehandAPIError(
          `Failed to fetch metrics: ${errorData.error || "Unknown error"}`
        );
      }
      const apiData = data.data || {};
      const metrics = {
        actPromptTokens: 0,
        actCompletionTokens: 0,
        actReasoningTokens: 0,
        actCachedInputTokens: 0,
        actInferenceTimeMs: 0,
        extractPromptTokens: 0,
        extractCompletionTokens: 0,
        extractReasoningTokens: 0,
        extractCachedInputTokens: 0,
        extractInferenceTimeMs: 0,
        observePromptTokens: 0,
        observeCompletionTokens: 0,
        observeReasoningTokens: 0,
        observeCachedInputTokens: 0,
        observeInferenceTimeMs: 0,
        agentPromptTokens: 0,
        agentCompletionTokens: 0,
        agentReasoningTokens: 0,
        agentCachedInputTokens: 0,
        agentInferenceTimeMs: 0,
        totalPromptTokens: 0,
        totalCompletionTokens: 0,
        totalReasoningTokens: 0,
        totalCachedInputTokens: 0,
        totalInferenceTimeMs: 0
      };
      const pages = apiData.pages || [];
      for (const page of pages) {
        const actions = page.actions || [];
        for (const action of actions) {
          const method = (action.method || "").toLowerCase();
          const tokenUsage = action.tokenUsage;
          if (tokenUsage) {
            const inputTokens = tokenUsage.inputTokens || 0;
            const outputTokens = tokenUsage.outputTokens || 0;
            const reasoningTokens = tokenUsage.reasoningTokens || 0;
            const cachedInputTokens = tokenUsage.cachedInputTokens || 0;
            const timeMs = tokenUsage.timeMs || 0;
            if (method === "act") {
              metrics.actPromptTokens += inputTokens;
              metrics.actCompletionTokens += outputTokens;
              metrics.actReasoningTokens += reasoningTokens;
              metrics.actCachedInputTokens += cachedInputTokens;
              metrics.actInferenceTimeMs += timeMs;
            } else if (method === "extract") {
              metrics.extractPromptTokens += inputTokens;
              metrics.extractCompletionTokens += outputTokens;
              metrics.extractReasoningTokens += reasoningTokens;
              metrics.extractCachedInputTokens += cachedInputTokens;
              metrics.extractInferenceTimeMs += timeMs;
            } else if (method === "observe") {
              metrics.observePromptTokens += inputTokens;
              metrics.observeCompletionTokens += outputTokens;
              metrics.observeReasoningTokens += reasoningTokens;
              metrics.observeCachedInputTokens += cachedInputTokens;
              metrics.observeInferenceTimeMs += timeMs;
            } else if (method === "agent") {
              metrics.agentPromptTokens += inputTokens;
              metrics.agentCompletionTokens += outputTokens;
              metrics.agentReasoningTokens += reasoningTokens;
              metrics.agentCachedInputTokens += cachedInputTokens;
              metrics.agentInferenceTimeMs += timeMs;
            }
            metrics.totalPromptTokens += inputTokens;
            metrics.totalCompletionTokens += outputTokens;
            metrics.totalReasoningTokens += reasoningTokens;
            metrics.totalCachedInputTokens += cachedInputTokens;
            metrics.totalInferenceTimeMs += timeMs;
          }
        }
      }
      return metrics;
    });
  }
  /**
   * Prepares a model configuration for the API payload by ensuring the `apiKey`
   * is included. If the model is passed as a string, converts it to an object
   * with `modelName` and `apiKey`.
   *
   * In API mode, we only attempt to load an API key from env vars when the
   * model provider differs from the one used to init the session.
   */
  prepareModelConfig(model) {
    var _a4, _b, _c;
    if (typeof model === "string") {
      const provider = model.includes("/") ? model.split("/")[0] : void 0;
      const apiKey = provider && provider !== this.modelProvider ? (_a4 = loadApiKeyFromEnv(provider, this.logger)) != null ? _a4 : this.modelApiKey : this.modelApiKey;
      return {
        modelName: model,
        apiKey
      };
    }
    if (!model.apiKey) {
      const provider = ((_b = model.modelName) == null ? void 0 : _b.includes("/")) ? model.modelName.split("/")[0] : void 0;
      const apiKey = provider && provider !== this.modelProvider ? (_c = loadApiKeyFromEnv(provider, this.logger)) != null ? _c : this.modelApiKey : this.modelApiKey;
      return __spreadProps(__spreadValues({}, model), {
        apiKey
      });
    }
    return model;
  }
  execute(_0) {
    return __async(this, arguments, function* ({
      method,
      args,
      params
    }) {
      const urlParams = new URLSearchParams(params);
      const queryString = urlParams.toString();
      const url = `/sessions/${this.sessionId}/${method}${queryString ? `?${queryString}` : ""}`;
      const response = yield this.request(url, {
        method: "POST",
        body: JSON.stringify(args)
      });
      if (!response.ok) {
        const errorBody = yield response.text();
        throw new StagehandHttpError(
          `HTTP error! status: ${response.status}, body: ${errorBody}`
        );
      }
      if (!response.body) {
        throw new StagehandResponseBodyError();
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { value, done } = yield reader.read();
        if (done && !buffer) {
          throw new StagehandServerError(
            "Stream ended without completion signal"
          );
        }
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;
          try {
            const eventData = JSON.parse(line.slice(6));
            if (eventData.type === "system") {
              if (eventData.data.status === "error") {
                const { error: errorMsg } = eventData.data;
                throw new Error(errorMsg);
              }
              if (eventData.data.status === "finished") {
                return eventData.data.result;
              }
            } else if (eventData.type === "log") {
              const msg = eventData.data.message;
              if ((msg == null ? void 0 : msg.message) === "Connecting to local browser") {
                continue;
              }
              this.logger(eventData.data.message);
            }
          } catch (e2) {
            if (e2 instanceof Error && !(e2 instanceof SyntaxError)) {
              throw e2;
            }
            const errorMessage = e2 instanceof Error ? e2.message : String(e2);
            this.logger({
              category: "api",
              message: `Failed to parse SSE event: ${errorMessage}`,
              level: 0
            });
            throw new StagehandResponseParseError(
              `Failed to parse server response: ${errorMessage}`
            );
          }
        }
        if (done) {
          if (buffer.trim() && buffer.startsWith("data: ")) {
            try {
              const eventData = JSON.parse(buffer.slice(6));
              if (eventData.type === "system" && eventData.data.status === "finished") {
                return eventData.data.result;
              }
            } catch (e2) {
              this.logger({
                category: "api",
                message: `Incomplete data in final buffer: ${buffer.substring(0, 100)}`,
                level: 0
              });
            }
          }
          throw new StagehandServerError(
            "Stream ended without completion signal"
          );
        }
      }
    });
  }
  request(path8, options) {
    return __async(this, null, function* () {
      var _a4;
      const defaultHeaders = {
        "x-bb-api-key": this.apiKey,
        "x-bb-project-id": this.projectId,
        "x-bb-session-id": this.sessionId,
        // we want real-time logs, so we stream the response
        "x-stream-response": "true",
        "x-model-api-key": this.modelApiKey,
        "x-sent-at": (/* @__PURE__ */ new Date()).toISOString(),
        "x-language": "typescript",
        "x-sdk-version": STAGEHAND_VERSION
      };
      if (options.method === "POST" && options.body) {
        defaultHeaders["Content-Type"] = "application/json";
      }
      const response = yield this.fetchWithCookies(
        `${(_a4 = process.env.STAGEHAND_API_URL) != null ? _a4 : "https://api.stagehand.browserbase.com/v1"}${path8}`,
        __spreadProps(__spreadValues({}, options), {
          headers: __spreadValues(__spreadValues({}, defaultHeaders), options.headers)
        })
      );
      return response;
    });
  }
};

// lib/v3/agent/utils/validateExperimentalFeatures.ts
init_sdkErrors();
function validateExperimentalFeatures(options) {
  const { isExperimental, agentConfig, executeOptions, isStreaming } = options;
  const isCuaMode = (agentConfig == null ? void 0 : agentConfig.mode) === "cua" || (agentConfig == null ? void 0 : agentConfig.cua) === true;
  if (isCuaMode) {
    const unsupportedFeatures = [];
    if (agentConfig == null ? void 0 : agentConfig.stream) {
      unsupportedFeatures.push("streaming");
    }
    if (executeOptions == null ? void 0 : executeOptions.signal) {
      unsupportedFeatures.push("abort signal");
    }
    if (executeOptions == null ? void 0 : executeOptions.messages) {
      unsupportedFeatures.push("message continuation");
    }
    if ((executeOptions == null ? void 0 : executeOptions.excludeTools) && executeOptions.excludeTools.length > 0) {
      unsupportedFeatures.push("excludeTools");
    }
    if (unsupportedFeatures.length > 0) {
      throw new StagehandInvalidArgumentError(
        `${unsupportedFeatures.join(", ")} ${unsupportedFeatures.length === 1 ? "is" : "are"} not supported with CUA (Computer Use Agent) mode.`
      );
    }
  }
  if (isExperimental) return;
  const features = [];
  const hasIntegrations = (agentConfig == null ? void 0 : agentConfig.integrations) && agentConfig.integrations.length > 0;
  const hasTools = (agentConfig == null ? void 0 : agentConfig.tools) && Object.keys(agentConfig.tools).length > 0;
  if (hasIntegrations || hasTools) {
    features.push("MCP integrations and custom tools");
  }
  if (!isCuaMode && (isStreaming || (agentConfig == null ? void 0 : agentConfig.stream))) {
    features.push("streaming");
  }
  if (executeOptions && !isCuaMode) {
    if (executeOptions.callbacks) {
      features.push("callbacks");
    }
    if (executeOptions.signal) {
      features.push("abort signal");
    }
    if (executeOptions.messages) {
      features.push("message continuation");
    }
    if (executeOptions.excludeTools && executeOptions.excludeTools.length > 0) {
      features.push("excludeTools");
    }
  }
  if (features.length > 0) {
    throw new ExperimentalNotConfiguredError(`Agent ${features.join(", ")}`);
  }
}

// lib/v3/v3.ts
init_flowLogger();
init_sdkErrors();
var DEFAULT_MODEL_NAME = "openai/gpt-4.1-mini";
var DEFAULT_VIEWPORT2 = { width: 1288, height: 711 };
function resolveModelConfiguration(model) {
  if (!model) {
    return { modelName: DEFAULT_MODEL_NAME };
  }
  if (typeof model === "string") {
    return { modelName: model };
  }
  if (model && typeof model === "object") {
    const _a4 = model, { modelName } = _a4, clientOptions = __objRest(_a4, ["modelName"]);
    if (!modelName) {
      throw new StagehandInvalidArgumentError(
        "model.modelName is required when providing client options."
      );
    }
    return {
      modelName,
      clientOptions
    };
  }
  return { modelName: DEFAULT_MODEL_NAME };
}
import_dotenv.default.config({ path: ".env" });
var _observe_dec, _extract_dec, _act_dec, _init2;
_act_dec = [logStagehandStep("Stagehand.act", "ACT")], _extract_dec = [logStagehandStep("Stagehand.extract", "EXTRACT")], _observe_dec = [logStagehandStep("Stagehand.observe", "OBSERVE")];
var _V3 = class _V3 {
  constructor(opts) {
    __runInitializers(_init2, 5, this);
    this.opts = void 0;
    this.state = { kind: "UNINITIALIZED" };
    this.actHandler = null;
    this.extractHandler = null;
    this.observeHandler = null;
    this.ctx = null;
    this.llmClient = void 0;
    /**
     * Event bus for internal communication.
     * Emits events like 'screenshot' when screenshots are captured during agent execution.
     */
    this.bus = new import_events2.EventEmitter();
    this.modelName = void 0;
    this.modelClientOptions = void 0;
    this.llmProvider = void 0;
    this.overrideLlmClients = /* @__PURE__ */ new Map();
    this.domSettleTimeoutMs = void 0;
    this._isClosing = false;
    this.browserbaseSessionId = void 0;
    this.browserbaseSessionUrl = void 0;
    this.browserbaseDebugUrl = void 0;
    this._onCdpClosed = (why) => {
      if (this.state.kind === "BROWSERBASE") {
        void this._logBrowserbaseSessionStatus();
      }
      this._immediateShutdown(`CDP transport closed: ${why}`).catch(() => {
      });
    };
    this.experimental = false;
    this.logInferenceToFile = false;
    this.disableAPI = false;
    this.externalLogger = void 0;
    this.verbose = 1;
    this.stagehandLogger = void 0;
    this._history = [];
    this.instanceId = void 0;
    this.cacheStorage = void 0;
    this.actCache = void 0;
    this.agentCache = void 0;
    this.apiClient = null;
    this.stagehandMetrics = {
      actPromptTokens: 0,
      actCompletionTokens: 0,
      actReasoningTokens: 0,
      actCachedInputTokens: 0,
      actInferenceTimeMs: 0,
      extractPromptTokens: 0,
      extractCompletionTokens: 0,
      extractReasoningTokens: 0,
      extractCachedInputTokens: 0,
      extractInferenceTimeMs: 0,
      observePromptTokens: 0,
      observeCompletionTokens: 0,
      observeReasoningTokens: 0,
      observeCachedInputTokens: 0,
      observeInferenceTimeMs: 0,
      agentPromptTokens: 0,
      agentCompletionTokens: 0,
      agentReasoningTokens: 0,
      agentCachedInputTokens: 0,
      agentInferenceTimeMs: 0,
      totalPromptTokens: 0,
      totalCompletionTokens: 0,
      totalReasoningTokens: 0,
      totalCachedInputTokens: 0,
      totalInferenceTimeMs: 0
    };
    var _a4, _b, _c, _d2;
    _V3._installProcessGuards();
    this.externalLogger = opts.logger;
    this.verbose = (_a4 = opts.verbose) != null ? _a4 : 1;
    this.instanceId = (0, import_uuid6.v7)();
    const loggerOptions = {
      pretty: true,
      level: "info"
      // Most permissive - filtering happens at instance level
    };
    if (opts.disablePino !== void 0) {
      loggerOptions.usePino = !opts.disablePino;
    }
    this.stagehandLogger = new StagehandLogger(loggerOptions, opts.logger);
    this.stagehandLogger.setVerbosity(this.verbose);
    try {
      if (this.externalLogger) {
        bindInstanceLogger(this.instanceId, this.externalLogger);
      } else {
        bindInstanceLogger(this.instanceId, (line) => {
          this.stagehandLogger.log(line);
        });
      }
    } catch (e2) {
    }
    const { modelName, clientOptions } = resolveModelConfiguration(opts.model);
    this.modelName = modelName;
    this.experimental = (_b = opts.experimental) != null ? _b : false;
    this.logInferenceToFile = (_c = opts.logInferenceToFile) != null ? _c : false;
    this.llmProvider = new LLMProvider(this.logger);
    this.domSettleTimeoutMs = opts.domSettleTimeout;
    this.disableAPI = (_d2 = opts.disableAPI) != null ? _d2 : false;
    const baseClientOptions = clientOptions ? __spreadValues({}, clientOptions) : {};
    if (opts.llmClient) {
      this.llmClient = opts.llmClient;
      this.modelClientOptions = baseClientOptions;
      this.disableAPI = true;
    } else {
      let apiKey = baseClientOptions.apiKey;
      if (!apiKey) {
        try {
          apiKey = loadApiKeyFromEnv(
            this.modelName.split("/")[0],
            // "openai", "anthropic", etc
            this.logger
          );
        } catch (error) {
          this.logger({
            category: "init",
            message: `Error loading API key for model ${this.modelName}: ${error}. Continuing without LLM client.`,
            level: 0
          });
          throw error;
        }
      }
      this.modelClientOptions = __spreadProps(__spreadValues({}, baseClientOptions), {
        apiKey
      });
      this.llmClient = this.llmProvider.getClient(
        this.modelName,
        this.modelClientOptions,
        { experimental: this.experimental, disableAPI: this.disableAPI }
      );
    }
    this.cacheStorage = CacheStorage.create(opts.cacheDir, this.logger, {
      label: "cache directory"
    });
    this.actCache = new ActCache({
      storage: this.cacheStorage,
      logger: this.logger,
      getActHandler: () => this.actHandler,
      getDefaultLlmClient: () => this.resolveLlmClient(),
      domSettleTimeoutMs: this.domSettleTimeoutMs
    });
    this.agentCache = new AgentCache({
      storage: this.cacheStorage,
      logger: this.logger,
      getActHandler: () => this.actHandler,
      getContext: () => this.ctx,
      getDefaultLlmClient: () => this.resolveLlmClient(),
      getBaseModelName: () => this.modelName,
      getSystemPrompt: () => opts.systemPrompt,
      domSettleTimeoutMs: this.domSettleTimeoutMs,
      act: this.act.bind(this)
    });
    this.opts = opts;
    SessionFileLogger.init(this.instanceId, opts);
    _V3._instances.add(this);
  }
  get browserbaseSessionID() {
    return this.browserbaseSessionId;
  }
  get browserbaseSessionURL() {
    return this.browserbaseSessionUrl;
  }
  get browserbaseDebugURL() {
    return this.browserbaseDebugUrl;
  }
  /**
   * Returns true if the browser is running on Browserbase.
   */
  get isBrowserbase() {
    return this.state.kind === "BROWSERBASE";
  }
  /**
   * Async property for metrics so callers can `await v3.metrics`.
   * When using API mode, fetches metrics from the API. Otherwise returns local metrics.
   */
  get metrics() {
    if (this.apiClient) {
      return this.apiClient.getReplayMetrics().catch((error) => {
        this.logger({
          category: "metrics",
          message: `Failed to fetch metrics from API: ${error}`,
          level: 0
        });
        return this.stagehandMetrics;
      });
    }
    return Promise.resolve(this.stagehandMetrics);
  }
  resolveLlmClient(model) {
    if (!model) {
      return this.llmClient;
    }
    let modelName;
    let clientOptions;
    if (typeof model === "string") {
      modelName = model;
    } else {
      const _a4 = model, { modelName: overrideModelName } = _a4, rest = __objRest(_a4, ["modelName"]);
      modelName = overrideModelName;
      clientOptions = rest;
    }
    if (modelName === this.modelName && (!clientOptions || Object.keys(clientOptions).length === 0)) {
      return this.llmClient;
    }
    const overrideProvider = String(modelName).split("/")[0];
    const baseProvider = String(this.modelName).split("/")[0];
    const mergedOptions = __spreadValues(__spreadValues({}, overrideProvider === baseProvider ? this.modelClientOptions : {}), clientOptions != null ? clientOptions : {});
    const providerKey = overrideProvider;
    if (!mergedOptions.apiKey) {
      const apiKey = loadApiKeyFromEnv(providerKey, this.logger);
      if (apiKey) {
        mergedOptions.apiKey = apiKey;
      }
    }
    const cacheKey = JSON.stringify({
      modelName,
      clientOptions: mergedOptions
    });
    const cached = this.overrideLlmClients.get(cacheKey);
    if (cached) {
      return cached;
    }
    const client = this.llmProvider.getClient(
      modelName,
      mergedOptions,
      { experimental: this.experimental, disableAPI: this.disableAPI }
    );
    this.overrideLlmClients.set(cacheKey, client);
    return client;
  }
  beginAgentReplayRecording() {
    this.agentCache.beginRecording();
  }
  endAgentReplayRecording() {
    return this.agentCache.endRecording();
  }
  discardAgentReplayRecording() {
    this.agentCache.discardRecording();
  }
  isAgentReplayRecording() {
    return this.agentCache.isRecording();
  }
  isAgentReplayActive() {
    return this.agentCache.isReplayActive();
  }
  recordAgentReplayStep(step) {
    this.agentCache.recordStep(step);
  }
  /**
   * Async property for history so callers can `await v3.history`.
   * Returns a frozen copy to avoid external mutation.
   */
  get history() {
    return Promise.resolve(Object.freeze([...this._history]));
  }
  addToHistory(method, parameters, result) {
    this._history.push({
      method,
      parameters,
      result: result != null ? result : null,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  updateMetrics(functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) {
    switch (functionName) {
      case "ACT" /* ACT */:
        this.stagehandMetrics.actPromptTokens += promptTokens;
        this.stagehandMetrics.actCompletionTokens += completionTokens;
        this.stagehandMetrics.actReasoningTokens += reasoningTokens;
        this.stagehandMetrics.actCachedInputTokens += cachedInputTokens;
        this.stagehandMetrics.actInferenceTimeMs += inferenceTimeMs;
        break;
      case "EXTRACT" /* EXTRACT */:
        this.stagehandMetrics.extractPromptTokens += promptTokens;
        this.stagehandMetrics.extractCompletionTokens += completionTokens;
        this.stagehandMetrics.extractReasoningTokens += reasoningTokens;
        this.stagehandMetrics.extractCachedInputTokens += cachedInputTokens;
        this.stagehandMetrics.extractInferenceTimeMs += inferenceTimeMs;
        break;
      case "OBSERVE" /* OBSERVE */:
        this.stagehandMetrics.observePromptTokens += promptTokens;
        this.stagehandMetrics.observeCompletionTokens += completionTokens;
        this.stagehandMetrics.observeReasoningTokens += reasoningTokens;
        this.stagehandMetrics.observeCachedInputTokens += cachedInputTokens;
        this.stagehandMetrics.observeInferenceTimeMs += inferenceTimeMs;
        break;
      case "AGENT" /* AGENT */:
        this.stagehandMetrics.agentPromptTokens += promptTokens;
        this.stagehandMetrics.agentCompletionTokens += completionTokens;
        this.stagehandMetrics.agentReasoningTokens += reasoningTokens;
        this.stagehandMetrics.agentCachedInputTokens += cachedInputTokens;
        this.stagehandMetrics.agentInferenceTimeMs += inferenceTimeMs;
        break;
    }
    this.updateTotalMetrics(
      promptTokens,
      completionTokens,
      reasoningTokens,
      cachedInputTokens,
      inferenceTimeMs
    );
  }
  updateTotalMetrics(promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) {
    this.stagehandMetrics.totalPromptTokens += promptTokens;
    this.stagehandMetrics.totalCompletionTokens += completionTokens;
    this.stagehandMetrics.totalReasoningTokens += reasoningTokens;
    this.stagehandMetrics.totalCachedInputTokens += cachedInputTokens;
    this.stagehandMetrics.totalInferenceTimeMs += inferenceTimeMs;
  }
  _immediateShutdown(reason) {
    return __async(this, null, function* () {
      try {
        this.logger({
          category: "v3",
          message: `initiating shutdown \u2192 ${reason}`,
          level: 0
        });
      } catch (e2) {
      }
      try {
        this.logger({
          category: "v3",
          message: `closing resources \u2192 ${reason}`,
          level: 0
        });
        yield this.close({ force: true });
      } catch (e2) {
      }
    });
  }
  static _installProcessGuards() {
    if (_V3._processGuardsInstalled) return;
    _V3._processGuardsInstalled = true;
    const shutdownAllImmediate = (reason) => __async(null, null, function* () {
      const instances2 = Array.from(_V3._instances);
      yield Promise.all(instances2.map((i2) => i2._immediateShutdown(reason)));
    });
    import_process2.default.once("SIGINT", () => {
      v3Logger({
        category: "v3",
        message: "SIGINT: initiating shutdown",
        level: 0
      });
      for (const instance of _V3._instances) {
        if (instance.apiClient) {
          void instance.apiClient.end();
          return;
        }
      }
      void shutdownAllImmediate("signal SIGINT");
    });
    import_process2.default.once("SIGTERM", () => {
      v3Logger({
        category: "v3",
        message: "SIGTERM: initiating shutdown",
        level: 0
      });
      for (const instance of _V3._instances) {
        if (instance.apiClient) {
          void instance.apiClient.end();
          return;
        }
      }
      void shutdownAllImmediate("signal SIGTERM");
    });
    import_process2.default.once("uncaughtException", (err) => {
      v3Logger({
        category: "v3",
        message: "uncaughtException",
        level: 0,
        auxiliary: { err: { value: String(err), type: "string" } }
      });
    });
    import_process2.default.once("unhandledRejection", (reason) => {
      v3Logger({
        category: "v3",
        message: "unhandledRejection",
        level: 0,
        auxiliary: { reason: { value: String(reason), type: "string" } }
      });
    });
  }
  /**
   * Entrypoint: initializes handlers, launches Chrome or Browserbase,
   * and sets up a CDP context.
   */
  init() {
    return __async(this, null, function* () {
      try {
        return yield withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
          var _a4, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
          this.actHandler = new ActHandler(
            this.llmClient,
            this.modelName,
            this.modelClientOptions,
            (model) => this.resolveLlmClient(model),
            (_a4 = this.opts.systemPrompt) != null ? _a4 : "",
            this.logInferenceToFile,
            (_b = this.opts.selfHeal) != null ? _b : true,
            (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) => this.updateMetrics(
              functionName,
              promptTokens,
              completionTokens,
              reasoningTokens,
              cachedInputTokens,
              inferenceTimeMs
            ),
            this.domSettleTimeoutMs
          );
          this.extractHandler = new ExtractHandler(
            this.llmClient,
            this.modelName,
            this.modelClientOptions,
            (model) => this.resolveLlmClient(model),
            (_c = this.opts.systemPrompt) != null ? _c : "",
            this.logInferenceToFile,
            this.experimental,
            (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) => this.updateMetrics(
              functionName,
              promptTokens,
              completionTokens,
              reasoningTokens,
              cachedInputTokens,
              inferenceTimeMs
            )
          );
          this.observeHandler = new ObserveHandler(
            this.llmClient,
            this.modelName,
            this.modelClientOptions,
            (model) => this.resolveLlmClient(model),
            (_d2 = this.opts.systemPrompt) != null ? _d2 : "",
            this.logInferenceToFile,
            this.experimental,
            (functionName, promptTokens, completionTokens, reasoningTokens, cachedInputTokens, inferenceTimeMs) => this.updateMetrics(
              functionName,
              promptTokens,
              completionTokens,
              reasoningTokens,
              cachedInputTokens,
              inferenceTimeMs
            )
          );
          if (this.opts.env === "LOCAL") {
            const envHeadless = import_process2.default.env.HEADLESS;
            if (envHeadless !== void 0) {
              const normalized = envHeadless.trim().toLowerCase();
              if (normalized !== "true") {
                delete import_process2.default.env.HEADLESS;
              }
            }
            const lbo = (_e = this.opts.localBrowserLaunchOptions) != null ? _e : {};
            if (lbo.cdpUrl) {
              this.logger({
                category: "init",
                message: "Connecting to local browser",
                level: 1
              });
              this.ctx = yield V3Context.create(lbo.cdpUrl, {
                env: "LOCAL"
              });
              const logCtx2 = SessionFileLogger.getContext();
              this.ctx.conn.cdpLogger = (info) => SessionFileLogger.logCdpCallEvent(info, logCtx2);
              this.ctx.conn.cdpEventLogger = (info) => SessionFileLogger.logCdpMessageEvent(info, logCtx2);
              this.ctx.conn.onTransportClosed(this._onCdpClosed);
              this.state = {
                kind: "LOCAL",
                // no LaunchedChrome when attaching externally; create a stub kill
                chrome: {
                  kill: () => __async(this, null, function* () {
                  })
                },
                ws: lbo.cdpUrl
              };
              this.resetBrowserbaseSessionMetadata();
              yield this._applyPostConnectLocalOptions(lbo);
              return;
            }
            this.logger({
              category: "init",
              message: "Launching local browser",
              level: 1
            });
            let userDataDir = lbo.userDataDir;
            let createdTemp = false;
            if (!userDataDir) {
              const base = import_path6.default.join(import_os2.default.tmpdir(), "stagehand-v3");
              import_fs8.default.mkdirSync(base, { recursive: true });
              userDataDir = import_fs8.default.mkdtempSync(import_path6.default.join(base, "profile-"));
              createdTemp = true;
            }
            const defaults2 = [
              "--remote-allow-origins=*",
              "--no-first-run",
              "--no-default-browser-check",
              "--disable-dev-shm-usage",
              "--site-per-process"
            ];
            let chromeFlags = [];
            const ignore = lbo.ignoreDefaultArgs;
            if (ignore === true) {
              chromeFlags = [];
            } else if (Array.isArray(ignore)) {
              chromeFlags = defaults2.filter(
                (f3) => !ignore.some((ex) => f3.includes(ex))
              );
            } else {
              chromeFlags = [...defaults2];
            }
            if (lbo.devtools) chromeFlags.push("--auto-open-devtools-for-tabs");
            if (lbo.locale) chromeFlags.push(`--lang=${lbo.locale}`);
            if (!lbo.viewport) {
              lbo.viewport = DEFAULT_VIEWPORT2;
            }
            if (((_f = lbo.viewport) == null ? void 0 : _f.width) && ((_g = lbo.viewport) == null ? void 0 : _g.height)) {
              chromeFlags.push(
                `--window-size=${lbo.viewport.width},${lbo.viewport.height + 87}`
                // Added pixels to the window to account for the address bar
              );
            }
            if (typeof lbo.deviceScaleFactor === "number") {
              chromeFlags.push(
                `--force-device-scale-factor=${Math.max(0.1, lbo.deviceScaleFactor)}`
              );
            }
            if (lbo.hasTouch) chromeFlags.push("--touch-events=enabled");
            if (lbo.ignoreHTTPSErrors)
              chromeFlags.push("--ignore-certificate-errors");
            if ((_h = lbo.proxy) == null ? void 0 : _h.server)
              chromeFlags.push(`--proxy-server=${lbo.proxy.server}`);
            if ((_i = lbo.proxy) == null ? void 0 : _i.bypass)
              chromeFlags.push(`--proxy-bypass-list=${lbo.proxy.bypass}`);
            if (Array.isArray(lbo.args)) chromeFlags.push(...lbo.args);
            const { ws, chrome } = yield launchLocalChrome({
              chromePath: lbo.executablePath,
              chromeFlags,
              headless: lbo.headless,
              userDataDir,
              connectTimeoutMs: lbo.connectTimeoutMs
            });
            this.ctx = yield V3Context.create(ws, {
              env: "LOCAL",
              localBrowserLaunchOptions: lbo
            });
            const logCtx = SessionFileLogger.getContext();
            this.ctx.conn.cdpLogger = (info) => SessionFileLogger.logCdpCallEvent(info, logCtx);
            this.ctx.conn.cdpEventLogger = (info) => SessionFileLogger.logCdpMessageEvent(info, logCtx);
            this.ctx.conn.onTransportClosed(this._onCdpClosed);
            this.state = {
              kind: "LOCAL",
              chrome,
              ws,
              userDataDir,
              createdTempProfile: createdTemp,
              preserveUserDataDir: !!lbo.preserveUserDataDir
            };
            this.resetBrowserbaseSessionMetadata();
            yield this._applyPostConnectLocalOptions(lbo);
            return;
          }
          if (this.opts.env === "BROWSERBASE") {
            const { apiKey, projectId } = this.requireBrowserbaseCreds();
            if (!apiKey || !projectId) {
              throw new MissingEnvironmentVariableError(
                "BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID",
                "Browserbase environment"
              );
            }
            this.logger({
              category: "init",
              message: "Starting browserbase session",
              level: 1
            });
            if (!this.disableAPI && !this.experimental) {
              this.apiClient = new StagehandAPIClient({
                apiKey,
                projectId,
                logger: this.logger
              });
              const createSessionPayload = __spreadProps(__spreadValues({
                projectId: (_k = (_j = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _j.projectId) != null ? _k : projectId
              }, this.opts.browserbaseSessionCreateParams), {
                browserSettings: __spreadProps(__spreadValues({}, (_m = (_l = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _l.browserSettings) != null ? _m : {}), {
                  viewport: (_p = (_o = (_n = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _n.browserSettings) == null ? void 0 : _o.viewport) != null ? _p : { width: 1288, height: 711 }
                }),
                userMetadata: __spreadProps(__spreadValues({}, (_r = (_q = this.opts.browserbaseSessionCreateParams) == null ? void 0 : _q.userMetadata) != null ? _r : {}), {
                  stagehand: "true"
                })
              });
              const { sessionId: sessionId2, available } = yield this.apiClient.init({
                modelName: this.modelName,
                modelApiKey: this.modelClientOptions.apiKey,
                domSettleTimeoutMs: this.domSettleTimeoutMs,
                verbose: this.verbose,
                systemPrompt: this.opts.systemPrompt,
                selfHeal: this.opts.selfHeal,
                browserbaseSessionCreateParams: createSessionPayload,
                browserbaseSessionID: this.opts.browserbaseSessionID
              });
              if (!available) {
                this.apiClient = null;
              }
              this.opts.browserbaseSessionID = sessionId2;
            }
            const { ws, sessionId, bb } = yield createBrowserbaseSession(
              apiKey,
              projectId,
              this.opts.browserbaseSessionCreateParams,
              this.opts.browserbaseSessionID
            );
            this.ctx = yield V3Context.create(ws, {
              env: "BROWSERBASE",
              apiClient: this.apiClient
            });
            const logCtx = SessionFileLogger.getContext();
            this.ctx.conn.cdpLogger = (info) => SessionFileLogger.logCdpCallEvent(info, logCtx);
            this.ctx.conn.cdpEventLogger = (info) => SessionFileLogger.logCdpMessageEvent(info, logCtx);
            this.ctx.conn.onTransportClosed(this._onCdpClosed);
            this.state = { kind: "BROWSERBASE", sessionId, ws, bb };
            this.browserbaseSessionId = sessionId;
            yield this._ensureBrowserbaseDownloadsEnabled();
            const resumed = !!this.opts.browserbaseSessionID;
            let debugUrl;
            try {
              const dbg = yield bb.sessions.debug(sessionId);
              debugUrl = dbg == null ? void 0 : dbg.debuggerUrl;
            } catch (e2) {
            }
            const sessionUrl = `https://www.browserbase.com/sessions/${sessionId}`;
            this.browserbaseSessionUrl = sessionUrl;
            this.browserbaseDebugUrl = debugUrl;
            try {
              this.logger({
                category: "init",
                message: resumed ? this.apiClient ? "Browserbase session started" : "Browserbase session resumed" : "Browserbase session started",
                level: 1,
                auxiliary: __spreadProps(__spreadValues({
                  sessionUrl: { value: sessionUrl, type: "string" }
                }, debugUrl && {
                  debugUrl: { value: debugUrl, type: "string" }
                }), {
                  sessionId: { value: sessionId, type: "string" }
                })
              });
            } catch (e2) {
            }
            return;
          }
          const neverEnv = this.opts.env;
          throw new StagehandInitError(`Unsupported env: ${neverEnv}`);
        }));
      } catch (error) {
        if (this.externalLogger) {
          try {
            unbindInstanceLogger(this.instanceId);
          } catch (e2) {
          }
        }
        throw error;
      }
    });
  }
  /** Apply post-connect local browser options that require CDP. */
  _applyPostConnectLocalOptions(lbo) {
    return __async(this, null, function* () {
      var _a4;
      try {
        if (lbo.downloadsPath || lbo.acceptDownloads !== void 0) {
          const behavior = lbo.acceptDownloads === false ? "deny" : "allow";
          yield (_a4 = this.ctx) == null ? void 0 : _a4.conn.send("Browser.setDownloadBehavior", {
            behavior,
            downloadPath: lbo.downloadsPath,
            eventsEnabled: true
          }).catch(() => {
          });
        }
      } catch (e2) {
      }
    });
  }
  _ensureBrowserbaseDownloadsEnabled() {
    return __async(this, null, function* () {
      var _a4;
      const conn = (_a4 = this.ctx) == null ? void 0 : _a4.conn;
      if (!conn) return;
      try {
        yield conn.send("Browser.setDownloadBehavior", {
          behavior: "allow",
          downloadPath: "downloads",
          eventsEnabled: true
        });
      } catch (e2) {
      }
    });
  }
  resetBrowserbaseSessionMetadata() {
    this.browserbaseSessionId = void 0;
    this.browserbaseSessionUrl = void 0;
    this.browserbaseDebugUrl = void 0;
  }
  act(input, options) {
    return __async(this, null, function* () {
      return yield withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
        if (!this.actHandler) throw new StagehandNotInitializedError("act()");
        let actResult;
        if (isObserveResult(input)) {
          const v3Page = yield this.resolvePage(options == null ? void 0 : options.page);
          const selector = input.selector;
          if (this.apiClient) {
            actResult = yield this.apiClient.act({
              input,
              options,
              frameId: v3Page.mainFrameId()
            });
          } else {
            const effectiveTimeoutMs = typeof (options == null ? void 0 : options.timeout) === "number" && options.timeout > 0 ? options.timeout : void 0;
            const ensureTimeRemaining = createTimeoutGuard(
              effectiveTimeoutMs,
              (ms) => new ActTimeoutError(ms)
            );
            actResult = yield this.actHandler.takeDeterministicAction(
              __spreadProps(__spreadValues({}, input), { selector }),
              v3Page,
              this.domSettleTimeoutMs,
              this.resolveLlmClient(options == null ? void 0 : options.model),
              ensureTimeRemaining,
              options == null ? void 0 : options.variables
            );
          }
          this.addToHistory(
            "act",
            {
              observeResult: input
            },
            actResult
          );
          return actResult;
        }
        if (typeof input !== "string" || !input.trim()) {
          throw new StagehandInvalidArgumentError(
            "act(): instruction string is required unless passing an Action"
          );
        }
        const page = yield this.resolvePage(options == null ? void 0 : options.page);
        let actCacheContext = null;
        const canUseCache = typeof input === "string" && !this.isAgentReplayRecording() && this.actCache.enabled;
        if (canUseCache) {
          actCacheContext = yield this.actCache.prepareContext(
            input,
            page,
            options == null ? void 0 : options.variables
          );
          if (actCacheContext) {
            const cachedResult = yield this.actCache.tryReplay(
              actCacheContext,
              page,
              options == null ? void 0 : options.timeout
            );
            if (cachedResult) {
              this.addToHistory(
                "act",
                {
                  instruction: input,
                  variables: options == null ? void 0 : options.variables,
                  timeout: options == null ? void 0 : options.timeout,
                  cacheHit: true
                },
                cachedResult
              );
              return cachedResult;
            }
          }
        }
        const handlerParams = {
          instruction: input,
          page,
          variables: options == null ? void 0 : options.variables,
          timeout: options == null ? void 0 : options.timeout,
          model: options == null ? void 0 : options.model
        };
        if (this.apiClient) {
          const frameId = page.mainFrameId();
          actResult = yield this.apiClient.act({ input, options, frameId });
        } else {
          actResult = yield this.actHandler.act(handlerParams);
        }
        this.addToHistory(
          "act",
          {
            instruction: input,
            variables: options == null ? void 0 : options.variables,
            timeout: options == null ? void 0 : options.timeout
          },
          actResult
        );
        if (actCacheContext && actResult.success && Array.isArray(actResult.actions) && actResult.actions.length > 0) {
          yield this.actCache.store(actCacheContext, actResult);
        }
        return actResult;
      }));
    });
  }
  extract(a, b, c) {
    return __async(this, null, function* () {
      return yield withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
        if (!this.extractHandler) {
          throw new StagehandNotInitializedError("extract()");
        }
        let instruction;
        let schema;
        let options;
        if (typeof a === "string") {
          instruction = a;
          const isZodSchema = (val) => !!val && typeof val === "object" && "parse" in val && "safeParse" in val;
          if (isZodSchema(b)) {
            schema = b;
            options = c;
          } else {
            options = b;
          }
        } else {
          options = a || void 0;
        }
        if (!instruction && schema) {
          throw new StagehandInvalidArgumentError(
            "extract(): schema provided without instruction"
          );
        }
        const effectiveSchema = instruction && !schema ? defaultExtractSchema : schema;
        const page = yield this.resolvePage(options == null ? void 0 : options.page);
        const handlerParams = {
          instruction,
          schema: effectiveSchema,
          model: options == null ? void 0 : options.model,
          timeout: options == null ? void 0 : options.timeout,
          selector: options == null ? void 0 : options.selector,
          page
        };
        let result;
        if (this.apiClient) {
          const frameId = page.mainFrameId();
          result = yield this.apiClient.extract({
            instruction: handlerParams.instruction,
            schema: handlerParams.schema,
            options,
            frameId
          });
        } else {
          result = yield this.extractHandler.extract(handlerParams);
        }
        const historySchemaDescriptor = effectiveSchema ? toJsonSchema(effectiveSchema) : void 0;
        this.addToHistory(
          "extract",
          {
            instruction,
            selector: options == null ? void 0 : options.selector,
            timeout: options == null ? void 0 : options.timeout,
            schema: historySchemaDescriptor
          },
          result
        );
        return result;
      }));
    });
  }
  observe(a, b) {
    return __async(this, null, function* () {
      return yield withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
        if (!this.observeHandler) {
          throw new StagehandNotInitializedError("observe()");
        }
        let instruction;
        let options;
        if (typeof a === "string") {
          instruction = a;
          options = b;
        } else {
          options = a;
        }
        const page = yield this.resolvePage(options == null ? void 0 : options.page);
        const handlerParams = {
          instruction,
          model: options == null ? void 0 : options.model,
          timeout: options == null ? void 0 : options.timeout,
          selector: options == null ? void 0 : options.selector,
          page
        };
        let results;
        if (this.apiClient) {
          const frameId = page.mainFrameId();
          results = yield this.apiClient.observe({
            instruction,
            options,
            frameId
          });
        } else {
          results = yield this.observeHandler.observe(handlerParams);
        }
        this.addToHistory(
          "observe",
          {
            instruction,
            timeout: options == null ? void 0 : options.timeout
          },
          results
        );
        return results;
      }));
    });
  }
  /** Return the browser-level CDP WebSocket endpoint. */
  connectURL() {
    if (this.state.kind === "UNINITIALIZED") {
      throw new StagehandNotInitializedError("connectURL()");
    }
    return this.state.ws;
  }
  /** Expose the current CDP-backed context. */
  get context() {
    return this.ctx;
  }
  /** Best-effort cleanup of context and launched resources. */
  close(opts) {
    return __async(this, null, function* () {
      var _a4, _b, _c, _d2;
      if (this.apiClient) {
        yield this.apiClient.end();
      }
      if (this._isClosing && !(opts == null ? void 0 : opts.force)) return;
      this._isClosing = true;
      try {
        try {
          yield SessionFileLogger.close();
        } catch (e2) {
        }
        try {
          if (((_a4 = this.ctx) == null ? void 0 : _a4.conn) && this._onCdpClosed) {
            (_c = (_b = this.ctx.conn).offTransportClosed) == null ? void 0 : _c.call(_b, this._onCdpClosed);
          }
        } catch (e2) {
        }
        try {
          yield (_d2 = this.ctx) == null ? void 0 : _d2.close();
        } catch (e2) {
        }
        if (this.state.kind === "LOCAL") {
          try {
            yield this.state.chrome.kill();
          } catch (e2) {
          }
          try {
            if (this.state.createdTempProfile && !this.state.preserveUserDataDir && this.state.userDataDir) {
              import_fs8.default.rmSync(this.state.userDataDir, { recursive: true, force: true });
            }
          } catch (e2) {
          }
        }
      } finally {
        this.state = { kind: "UNINITIALIZED" };
        this.ctx = null;
        this._isClosing = false;
        this.resetBrowserbaseSessionMetadata();
        try {
          unbindInstanceLogger(this.instanceId);
        } catch (e2) {
        }
        try {
          this.bus.removeAllListeners();
        } catch (e2) {
        }
        this._history = [];
        this.actHandler = null;
        this.extractHandler = null;
        this.observeHandler = null;
        _V3._instances.delete(this);
      }
    });
  }
  /** Guard: ensure Browserbase credentials exist in options. */
  requireBrowserbaseCreds() {
    var _a4, _b;
    let { apiKey, projectId } = this.opts;
    if (!apiKey)
      apiKey = (_a4 = import_process2.default.env.BROWSERBASE_API_KEY) != null ? _a4 : import_process2.default.env.BB_API_KEY;
    if (!projectId)
      projectId = (_b = import_process2.default.env.BROWSERBASE_PROJECT_ID) != null ? _b : import_process2.default.env.BB_PROJECT_ID;
    if (!apiKey || !projectId) {
      const missing = [];
      if (!apiKey) missing.push("BROWSERBASE_API_KEY");
      if (!projectId) missing.push("BROWSERBASE_PROJECT_ID");
      throw new MissingEnvironmentVariableError(
        missing.join(", "),
        "Browserbase"
      );
    }
    this.opts.apiKey = apiKey;
    this.opts.projectId = projectId;
    this.logger({
      category: "init",
      message: "Using Browserbase credentials",
      level: 1
    });
    return { apiKey, projectId };
  }
  get logger() {
    return (logLine) => {
      var _a4;
      const line = __spreadProps(__spreadValues({}, logLine), { level: (_a4 = logLine.level) != null ? _a4 : 1 });
      this.stagehandLogger.log(line);
    };
  }
  /**
   * Normalize a Playwright/Puppeteer page object into its top frame id,
   * so handlers can resolve it to a `Page` within our V3Context.
   */
  resolveTopFrameId(page) {
    return __async(this, null, function* () {
      if (this.isPlaywrightPage(page)) {
        const cdp = yield page.context().newCDPSession(page);
        const { frameTree } = yield cdp.send("Page.getFrameTree");
        return frameTree.frame.id;
      }
      if (this.isPatchrightPage(page)) {
        const cdp = yield page.context().newCDPSession(page);
        const { frameTree } = yield cdp.send("Page.getFrameTree");
        return frameTree.frame.id;
      }
      if (this.isPuppeteerPage(page)) {
        const cdp = yield page.createCDPSession();
        const { frameTree } = yield cdp.send("Page.getFrameTree");
        this.logger({
          category: "v3",
          message: "Puppeteer frame id",
          level: 2,
          auxiliary: { frameId: { value: frameTree.frame.id, type: "string" } }
        });
        return frameTree.frame.id;
      }
      throw new StagehandInvalidArgumentError(
        "Unsupported page object passed to V3.act()"
      );
    });
  }
  isPlaywrightPage(p) {
    return typeof p === "object" && p !== null && typeof p.context === "function";
  }
  isPatchrightPage(p) {
    return typeof p === "object" && p !== null && typeof p.context === "function";
  }
  isPuppeteerPage(p) {
    return typeof p === "object" && p !== null && typeof p.target === "function";
  }
  /** Resolve an external page reference or fall back to the active V3 page. */
  resolvePage(page) {
    return __async(this, null, function* () {
      if (page) {
        return yield this.normalizeToV3Page(page);
      }
      const ctx = this.ctx;
      if (!ctx) {
        throw new StagehandNotInitializedError("resolvePage()");
      }
      return yield ctx.awaitActivePage();
    });
  }
  normalizeToV3Page(input) {
    return __async(this, null, function* () {
      if (input instanceof (yield Promise.resolve().then(() => (init_page(), page_exports))).Page) {
        return input;
      }
      if (this.isPlaywrightPage(input)) {
        const frameId = yield this.resolveTopFrameId(input);
        const page = this.ctx.resolvePageByMainFrameId(frameId);
        if (!page)
          throw new StagehandInitError(
            "Failed to resolve V3 Page from Playwright page."
          );
        return page;
      }
      if (this.isPatchrightPage(input)) {
        const frameId = yield this.resolveTopFrameId(input);
        const page = this.ctx.resolvePageByMainFrameId(frameId);
        if (!page)
          throw new StagehandInitError(
            "Failed to resolve V3 Page from Patchright page."
          );
        return page;
      }
      if (this.isPuppeteerPage(input)) {
        const frameId = yield this.resolveTopFrameId(input);
        const page = this.ctx.resolvePageByMainFrameId(frameId);
        if (!page)
          throw new StagehandInitError(
            "Failed to resolve V3 Page from Puppeteer page."
          );
        return page;
      }
      throw new StagehandInvalidArgumentError("Unsupported page object.");
    });
  }
  _logBrowserbaseSessionStatus() {
    return __async(this, null, function* () {
      var _a4;
      if (this.state.kind !== "BROWSERBASE") {
        return;
      }
      try {
        const snapshot = yield this.state.bb.sessions.retrieve(
          this.state.sessionId
        );
        if (!(snapshot == null ? void 0 : snapshot.status)) return;
        const sessionId = (_a4 = snapshot.id) != null ? _a4 : this.state.sessionId;
        const message = snapshot.status === "TIMED_OUT" ? `Browserbase session timed out (sessionId: ${sessionId})` : `Browserbase session status: ${snapshot.status}`;
        this.logger({
          category: "v3",
          message,
          level: 0
        });
      } catch (e2) {
      }
    });
  }
  /**
   * Prepares shared context for agent execution (both execute and stream).
   * Extracts duplicated setup logic into a single helper.
   */
  prepareAgentExecution(options, instructionOrOptions, agentConfigSignature) {
    return __async(this, null, function* () {
      var _a4, _b;
      const tools = (options == null ? void 0 : options.integrations) ? yield resolveTools(options.integrations, options.tools) : (_a4 = options == null ? void 0 : options.tools) != null ? _a4 : {};
      const agentLlmClient = (options == null ? void 0 : options.model) ? this.resolveLlmClient(options.model) : this.llmClient;
      const handler = new V3AgentHandler(
        this,
        this.logger,
        agentLlmClient,
        typeof (options == null ? void 0 : options.executionModel) === "string" ? options.executionModel : (_b = options == null ? void 0 : options.executionModel) == null ? void 0 : _b.modelName,
        options == null ? void 0 : options.systemPrompt,
        tools,
        options == null ? void 0 : options.mode
      );
      const resolvedOptions = typeof instructionOrOptions === "string" ? { instruction: instructionOrOptions } : instructionOrOptions;
      const callbacksWithSafety = resolvedOptions.callbacks;
      if (callbacksWithSafety == null ? void 0 : callbacksWithSafety.onSafetyConfirmation) {
        throw new StagehandInvalidArgumentError(
          'onSafetyConfirmation callback is only supported when using mode: "cua" agents.'
        );
      }
      if (resolvedOptions.page) {
        const normalizedPage = yield this.normalizeToV3Page(resolvedOptions.page);
        this.ctx.setActivePage(normalizedPage);
      }
      const instruction = resolvedOptions.instruction.trim();
      const sanitizedOptions = this.agentCache.sanitizeExecuteOptions(resolvedOptions);
      const cacheContext = this.agentCache.shouldAttemptCache(instruction) ? yield this.agentCache.prepareContext({
        instruction,
        options: sanitizedOptions,
        configSignature: agentConfigSignature,
        page: yield this.ctx.awaitActivePage()
      }) : null;
      return { handler, resolvedOptions, instruction, cacheContext };
    });
  }
  agent(options) {
    var _a4, _b, _c, _d2;
    const isCuaMode = (options == null ? void 0 : options.mode) === "cua" || (options == null ? void 0 : options.cua) === true;
    if ((options == null ? void 0 : options.cua) === true) {
      this.logger({
        category: "agent",
        message: `[DEPRECATED] The "cua: true" option is deprecated. Use "mode: 'cua'" instead. This option will be removed in a future version.`,
        level: 0
      });
      console.warn(
        `[Stagehand] DEPRECATED: The "cua: true" option is deprecated. Use "mode: 'cua'" instead.`
      );
    }
    this.logger({
      category: "agent",
      message: "Creating v3 agent instance",
      level: 1,
      auxiliary: __spreadValues({
        cua: { value: isCuaMode ? "true" : "false", type: "boolean" },
        mode: { value: (_a4 = options == null ? void 0 : options.mode) != null ? _a4 : "dom", type: "string" },
        model: (options == null ? void 0 : options.model) ? typeof (options == null ? void 0 : options.model) === "string" ? { value: options.model, type: "string" } : { value: options.model.modelName, type: "string" } : { value: this.llmClient.modelName, type: "string" },
        systemPrompt: { value: (_b = options == null ? void 0 : options.systemPrompt) != null ? _b : "", type: "string" },
        tools: { value: JSON.stringify((_c = options == null ? void 0 : options.tools) != null ? _c : {}), type: "object" }
      }, (options == null ? void 0 : options.integrations) && {
        integrations: {
          value: JSON.stringify(options.integrations),
          type: "object"
        }
      })
    });
    if (isCuaMode) {
      validateExperimentalFeatures({
        isExperimental: this.experimental,
        agentConfig: options
      });
      const modelToUse = (options == null ? void 0 : options.model) || __spreadValues({
        modelName: this.modelName
      }, this.modelClientOptions);
      const { modelName, isCua, clientOptions } = resolveModel(modelToUse);
      if (!isCua) {
        throw new CuaModelRequiredError(AVAILABLE_CUA_MODELS);
      }
      const agentConfigSignature2 = this.agentCache.buildConfigSignature(options);
      return {
        execute: (instructionOrOptions) => __async(this, null, function* () {
          return withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
            var _a5, _b2;
            validateExperimentalFeatures({
              isExperimental: this.experimental,
              agentConfig: options,
              executeOptions: typeof instructionOrOptions === "object" ? instructionOrOptions : null
            });
            SessionFileLogger.logAgentTaskStarted({
              invocation: "Agent.execute",
              args: [instructionOrOptions]
            });
            const tools = (options == null ? void 0 : options.integrations) ? yield resolveTools(options.integrations, options.tools) : (_a5 = options == null ? void 0 : options.tools) != null ? _a5 : {};
            const handler = new V3CuaAgentHandler(
              this,
              this.logger,
              {
                modelName,
                clientOptions,
                userProvidedInstructions: (_b2 = options.systemPrompt) != null ? _b2 : `You are a helpful assistant that can use a web browser.
Do not ask follow up questions, the user will trust your judgement.`
              },
              tools
            );
            const resolvedOptions = typeof instructionOrOptions === "string" ? { instruction: instructionOrOptions } : instructionOrOptions;
            if (resolvedOptions.page) {
              const normalizedPage = yield this.normalizeToV3Page(
                resolvedOptions.page
              );
              this.ctx.setActivePage(normalizedPage);
            }
            const instruction = resolvedOptions.instruction.trim();
            const sanitizedOptions = this.agentCache.sanitizeExecuteOptions(resolvedOptions);
            let cacheContext = null;
            if (this.agentCache.shouldAttemptCache(instruction)) {
              const startPage = yield this.ctx.awaitActivePage();
              cacheContext = yield this.agentCache.prepareContext({
                instruction,
                options: sanitizedOptions,
                configSignature: agentConfigSignature2,
                page: startPage
              });
              if (cacheContext) {
                const replayed = yield this.agentCache.tryReplay(cacheContext);
                if (replayed) {
                  SessionFileLogger.logAgentTaskCompleted({ cacheHit: true });
                  return replayed;
                }
              }
            }
            let agentSteps = [];
            const recording = !!cacheContext;
            if (recording) {
              this.beginAgentReplayRecording();
            }
            let result;
            try {
              if (this.apiClient && !this.experimental) {
                const page = yield this.ctx.awaitActivePage();
                result = yield this.apiClient.agentExecute(
                  options,
                  resolvedOptions,
                  page.mainFrameId()
                );
              } else {
                result = yield handler.execute(instructionOrOptions);
              }
              if (recording) {
                agentSteps = this.endAgentReplayRecording();
              }
              if (cacheContext && result.success && agentSteps.length > 0) {
                yield this.agentCache.store(cacheContext, agentSteps, result);
              }
              return result;
            } catch (err) {
              if (recording) this.discardAgentReplayRecording();
              throw err;
            } finally {
              if (recording) {
                this.discardAgentReplayRecording();
              }
              SessionFileLogger.logAgentTaskCompleted();
            }
          }));
        })
      };
    }
    const agentConfigSignature = this.agentCache.buildConfigSignature(options);
    const isStreaming = (_d2 = options == null ? void 0 : options.stream) != null ? _d2 : false;
    return {
      execute: (instructionOrOptions) => __async(this, null, function* () {
        return withInstanceLogContext(this.instanceId, () => __async(this, null, function* () {
          validateExperimentalFeatures({
            isExperimental: this.experimental,
            agentConfig: options,
            executeOptions: typeof instructionOrOptions === "object" ? instructionOrOptions : null,
            isStreaming
          });
          SessionFileLogger.logAgentTaskStarted({
            invocation: "Agent.execute",
            args: [instructionOrOptions]
          });
          if (isStreaming) {
            const { handler: handler2, resolvedOptions: resolvedOptions2, cacheContext: cacheContext2 } = yield this.prepareAgentExecution(
              options,
              instructionOrOptions,
              agentConfigSignature
            );
            if (cacheContext2) {
              const replayed = yield this.agentCache.tryReplayAsStream(cacheContext2);
              if (replayed) {
                SessionFileLogger.logAgentTaskCompleted({ cacheHit: true });
                return replayed;
              }
            }
            const streamResult = yield handler2.stream(
              resolvedOptions2
            );
            if (cacheContext2) {
              const wrappedStream = this.agentCache.wrapStreamForCaching(
                cacheContext2,
                streamResult,
                () => this.beginAgentReplayRecording(),
                () => this.endAgentReplayRecording(),
                () => this.discardAgentReplayRecording()
              );
              SessionFileLogger.logAgentTaskCompleted();
              return wrappedStream;
            }
            SessionFileLogger.logAgentTaskCompleted();
            return streamResult;
          }
          const { handler, resolvedOptions, cacheContext } = yield this.prepareAgentExecution(
            options,
            instructionOrOptions,
            agentConfigSignature
          );
          if (cacheContext) {
            const replayed = yield this.agentCache.tryReplay(cacheContext);
            if (replayed) {
              SessionFileLogger.logAgentTaskCompleted({ cacheHit: true });
              return replayed;
            }
          }
          let agentSteps = [];
          const recording = !!cacheContext;
          if (recording) {
            this.beginAgentReplayRecording();
          }
          let result;
          try {
            if (this.apiClient && !this.experimental) {
              const page = yield this.ctx.awaitActivePage();
              result = yield this.apiClient.agentExecute(
                options != null ? options : {},
                resolvedOptions,
                page.mainFrameId()
              );
            } else {
              result = yield handler.execute(
                resolvedOptions
              );
            }
            if (recording) {
              agentSteps = this.endAgentReplayRecording();
            }
            if (cacheContext && result.success && agentSteps.length > 0) {
              yield this.agentCache.store(cacheContext, agentSteps, result);
            }
            return result;
          } catch (err) {
            if (recording) this.discardAgentReplayRecording();
            throw err;
          } finally {
            if (recording) {
              this.discardAgentReplayRecording();
            }
            SessionFileLogger.logAgentTaskCompleted();
          }
        }));
      })
    };
  }
};
_init2 = __decoratorStart(null);
__decorateElement(_init2, 1, "act", _act_dec, _V3);
__decorateElement(_init2, 1, "extract", _extract_dec, _V3);
__decorateElement(_init2, 1, "observe", _observe_dec, _V3);
__decoratorMetadata(_init2, _V3);
_V3._processGuardsInstalled = false;
_V3._instances = /* @__PURE__ */ new Set();
var V3 = _V3;
function isObserveResult(v) {
  return !!v && typeof v === "object" && "selector" in v;
}

// lib/v3Evaluator.ts
var import_dotenv2 = __toESM(require("dotenv"));
var import_zod23 = require("zod");
init_sdkErrors();
import_dotenv2.default.config();
var EvaluationSchema = import_zod23.z.object({
  evaluation: import_zod23.z.enum(["YES", "NO"]),
  reasoning: import_zod23.z.string()
});
var BatchEvaluationSchema = import_zod23.z.array(EvaluationSchema);
var V3Evaluator = class {
  constructor(v3, modelName, modelClientOptions) {
    this.silentLogger = () => {
    };
    this.v3 = v3;
    this.modelName = modelName || "google/gemini-2.5-flash";
    this.modelClientOptions = modelClientOptions || {
      apiKey: process.env.GEMINI_API_KEY || process.env.GOOGLE_GENERATIVE_AI_API_KEY || ""
    };
  }
  getClient() {
    const provider = new LLMProvider(this.v3.logger);
    return provider.getClient(this.modelName, this.modelClientOptions);
  }
  ask(options) {
    return __async(this, null, function* () {
      const {
        question,
        answer,
        screenshot = true,
        systemPrompt,
        screenshotDelayMs = 250,
        agentReasoning
      } = options;
      if (!question)
        throw new StagehandInvalidArgumentError(
          "Question cannot be an empty string"
        );
      if (!answer && !screenshot)
        throw new StagehandInvalidArgumentError(
          "Either answer (text) or screenshot must be provided"
        );
      if (Array.isArray(screenshot)) {
        return this._evaluateWithMultipleScreenshots({
          question,
          screenshots: screenshot,
          systemPrompt,
          agentReasoning
        });
      }
      const defaultSystemPrompt = `You are an expert evaluator that confidently returns YES or NO based on if the original goal was achieved. You have access to  ${screenshot ? "a screenshot" : "the agents reasoning and actions throughout the task"} that you can use to evaluate the tasks completion. Provide detailed reasoning for your answer.
          Today's date is ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`;
      yield new Promise((r2) => setTimeout(r2, screenshotDelayMs));
      let imageBuffer;
      if (screenshot) {
        const page = yield this.v3.context.awaitActivePage();
        imageBuffer = yield page.screenshot({ fullPage: false });
      }
      const llmClient = this.getClient();
      const response = yield llmClient.createChatCompletion({
        logger: this.silentLogger,
        options: {
          messages: [
            { role: "system", content: systemPrompt || defaultSystemPrompt },
            {
              role: "user",
              content: [
                {
                  type: "text",
                  text: agentReasoning ? `Question: ${question}

Agent's reasoning and actions taken:
${agentReasoning}` : question
                },
                ...screenshot && imageBuffer ? [
                  {
                    type: "image_url",
                    image_url: {
                      url: `data:image/jpeg;base64,${imageBuffer.toString("base64")}`
                    }
                  }
                ] : [],
                ...answer ? [{ type: "text", text: `the answer is ${answer}` }] : []
              ]
            }
          ],
          response_model: { name: "EvaluationResult", schema: EvaluationSchema }
        }
      });
      try {
        const result = response.data;
        return { evaluation: result.evaluation, reasoning: result.reasoning };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
          evaluation: "INVALID",
          reasoning: `Failed to get structured response: ${errorMessage}`
        };
      }
    });
  }
  batchAsk(options) {
    return __async(this, null, function* () {
      const {
        questions,
        screenshot = true,
        systemPrompt = "You are an expert evaluator that returns YES or NO with a concise reasoning.",
        screenshotDelayMs = 250
      } = options;
      if (!(questions == null ? void 0 : questions.length))
        throw new StagehandInvalidArgumentError(
          "Questions array cannot be empty"
        );
      yield new Promise((r2) => setTimeout(r2, screenshotDelayMs));
      let imageBuffer;
      if (screenshot) {
        const page = yield this.v3.context.awaitActivePage();
        imageBuffer = yield page.screenshot({ fullPage: false });
      }
      const llmClient = this.getClient();
      const formatted = questions.map(
        (item, i2) => `${i2 + 1}. ${item.question}${item.answer ? `
   Answer: ${item.answer}` : ""}`
      ).join("\n\n");
      const response = yield llmClient.createChatCompletion({
        logger: this.silentLogger,
        options: {
          messages: [
            {
              role: "system",
              content: `${systemPrompt}

You will be given multiple questions${screenshot ? " with a screenshot" : ""}. ${questions.some((q) => q.answer) ? "Some questions include answers to evaluate." : ""} Answer each question by returning an object in the specified JSON format. Return a single JSON array containing one object for each question in the order they were asked.`
            },
            {
              role: "user",
              content: [
                { type: "text", text: formatted },
                ...screenshot && imageBuffer ? [
                  {
                    type: "image_url",
                    image_url: {
                      url: `data:image/jpeg;base64,${imageBuffer.toString("base64")}`
                    }
                  }
                ] : []
              ]
            }
          ],
          response_model: {
            name: "BatchEvaluationResult",
            schema: BatchEvaluationSchema
          }
        }
      });
      try {
        const results = response.data;
        return results.map((r2) => ({
          evaluation: r2.evaluation,
          reasoning: r2.reasoning
        }));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return questions.map(() => ({
          evaluation: "INVALID",
          reasoning: `Failed to get structured response: ${errorMessage}`
        }));
      }
    });
  }
  _evaluateWithMultipleScreenshots(options) {
    return __async(this, null, function* () {
      const {
        question,
        screenshots,
        agentReasoning,
        systemPrompt = `You are an expert evaluator that confidently returns YES or NO given a question and multiple screenshots showing the progression of a task.
        ${agentReasoning ? "You also have access to the agent's detailed reasoning and thought process throughout the task." : ""}
        Analyze ALL screenshots to understand the complete journey. Look for evidence of task completion across all screenshots, not just the last one.
        Success criteria may appear at different points in the sequence (confirmation messages, intermediate states, etc).
        ${agentReasoning ? "The agent's reasoning provides crucial context about what actions were attempted, what was observed, and the decision-making process. Use this alongside the visual evidence to make a comprehensive evaluation." : ""}
        Today's date is ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`
      } = options;
      if (!question)
        throw new StagehandInvalidArgumentError(
          "Question cannot be an empty string"
        );
      if (!screenshots || screenshots.length === 0)
        throw new StagehandInvalidArgumentError(
          "At least one screenshot must be provided"
        );
      const llmClient = this.getClient();
      const imageContents = screenshots.map((s2) => ({
        type: "image_url",
        image_url: { url: `data:image/jpeg;base64,${s2.toString("base64")}` }
      }));
      const response = yield llmClient.createChatCompletion({
        logger: this.silentLogger,
        options: {
          messages: [
            { role: "system", content: systemPrompt },
            {
              role: "user",
              content: [
                {
                  type: "text",
                  text: agentReasoning ? `Question: ${question}

Agent's reasoning and actions throughout the task:
${agentReasoning}

I'm providing ${screenshots.length} screenshots showing the progression of the task. Please analyze both the agent's reasoning and all screenshots to determine if the task was completed successfully.` : `${question}

I'm providing ${screenshots.length} screenshots showing the progression of the task. Please analyze all of them to determine if the task was completed successfully.`
                },
                ...imageContents
              ]
            }
          ],
          response_model: { name: "EvaluationResult", schema: EvaluationSchema }
        }
      });
      try {
        const result = response.data;
        return { evaluation: result.evaluation, reasoning: result.reasoning };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
          evaluation: "INVALID",
          reasoning: `Failed to get structured response: ${errorMessage}`
        };
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AISdkClient,
  AVAILABLE_CUA_MODELS,
  ActTimeoutError,
  AgentAbortError,
  AgentProvider,
  AgentScreenshotProviderError,
  AnnotatedScreenshotText,
  Api,
  BrowserbaseSessionNotFoundError,
  CaptchaTimeoutError,
  ConnectionTimeoutError,
  ConsoleMessage,
  ContentFrameNotFoundError,
  CreateChatCompletionResponseError,
  CuaModelRequiredError,
  ElementNotVisibleError,
  ExperimentalApiConflictError,
  ExperimentalNotConfiguredError,
  ExtractTimeoutError,
  HandlerNotInitializedError,
  InvalidAISDKModelFormatError,
  LLMClient,
  LLMResponseError,
  LOG_LEVEL_NAMES,
  MCPConnectionError,
  MissingEnvironmentVariableError,
  MissingLLMConfigurationError,
  ObserveTimeoutError,
  PageNotFoundError,
  Response,
  ResponseBodyError,
  ResponseParseError,
  Stagehand,
  StagehandAPIError,
  StagehandAPIUnauthorizedError,
  StagehandClickError,
  StagehandClosedError,
  StagehandDefaultError,
  StagehandDomProcessError,
  StagehandElementNotFoundError,
  StagehandEnvironmentError,
  StagehandError,
  StagehandEvalError,
  StagehandHttpError,
  StagehandIframeError,
  StagehandInitError,
  StagehandInvalidArgumentError,
  StagehandMissingArgumentError,
  StagehandNotInitializedError,
  StagehandResponseBodyError,
  StagehandResponseParseError,
  StagehandServerError,
  StagehandShadowRootMissingError,
  StagehandShadowSegmentEmptyError,
  StagehandShadowSegmentNotFoundError,
  StreamingCallbacksInNonStreamingModeError,
  TimeoutError,
  UnsupportedAISDKModelProviderError,
  UnsupportedModelError,
  UnsupportedModelProviderError,
  V3,
  V3Evaluator,
  V3FunctionName,
  XPathResolutionError,
  ZodSchemaValidationError,
  connectToMCPServer,
  defaultExtractSchema,
  getZodType,
  injectUrls,
  isRunningInBun,
  isZod3Schema,
  isZod4Schema,
  jsonSchemaToZod,
  loadApiKeyFromEnv,
  localBrowserLaunchOptionsSchema,
  modelToAgentProviderMap,
  pageTextSchema,
  providerEnvVarMap,
  toGeminiSchema,
  toJsonSchema,
  transformSchema,
  trimTrailingTextNode,
  validateZodSchema
});
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.es2018.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

fetch-blob/index.js:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

formdata-polyfill/esm.min.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-domexception/index.js:
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

gtoken/build/cjs/src/index.cjs:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

lighthouse-logger/index.js:
  (**
   * @license
   * Copyright 2016 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

chrome-launcher/dist/utils.js:
chrome-launcher/dist/flags.js:
  (**
   * @license Copyright 2017 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
   * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
   *)

chrome-launcher/dist/chrome-finder.js:
chrome-launcher/dist/random-port.js:
chrome-launcher/dist/chrome-launcher.js:
  (**
   * @license Copyright 2016 Google Inc. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
   * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
   *)
*/
