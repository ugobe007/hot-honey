// src/edge/google-vertex-provider-edge.ts
import { resolve as resolve4 } from "@ai-sdk/provider-utils";

// src/google-vertex-provider.ts
import { GoogleGenerativeAILanguageModel } from "@ai-sdk/google/internal";
import {
  generateId,
  loadSetting,
  resolve as resolve3,
  withoutTrailingSlash,
  withUserAgentSuffix
} from "@ai-sdk/provider-utils";

// src/version.ts
var VERSION = true ? "3.0.97" : "0.0.0-test";

// src/google-vertex-embedding-model.ts
import {
  TooManyEmbeddingValuesForCallError
} from "@ai-sdk/provider";
import {
  combineHeaders,
  createJsonResponseHandler,
  postJsonToApi,
  resolve,
  parseProviderOptions
} from "@ai-sdk/provider-utils";
import { z as z3 } from "zod/v4";

// src/google-vertex-error.ts
import { createJsonErrorResponseHandler } from "@ai-sdk/provider-utils";
import { z } from "zod/v4";
var googleVertexErrorDataSchema = z.object({
  error: z.object({
    code: z.number().nullable(),
    message: z.string(),
    status: z.string()
  })
});
var googleVertexFailedResponseHandler = createJsonErrorResponseHandler(
  {
    errorSchema: googleVertexErrorDataSchema,
    errorToMessage: (data) => data.error.message
  }
);

// src/google-vertex-embedding-options.ts
import { z as z2 } from "zod/v4";
var googleVertexEmbeddingProviderOptions = z2.object({
  /**
   * Optional. Optional reduced dimension for the output embedding.
   * If set, excessive values in the output embedding are truncated from the end.
   */
  outputDimensionality: z2.number().optional(),
  /**
   * Optional. Specifies the task type for generating embeddings.
   * Supported task types:
   * - SEMANTIC_SIMILARITY: Optimized for text similarity.
   * - CLASSIFICATION: Optimized for text classification.
   * - CLUSTERING: Optimized for clustering texts based on similarity.
   * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
   * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
   * - QUESTION_ANSWERING: Optimized for answering questions.
   * - FACT_VERIFICATION: Optimized for verifying factual information.
   * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
   */
  taskType: z2.enum([
    "SEMANTIC_SIMILARITY",
    "CLASSIFICATION",
    "CLUSTERING",
    "RETRIEVAL_DOCUMENT",
    "RETRIEVAL_QUERY",
    "QUESTION_ANSWERING",
    "FACT_VERIFICATION",
    "CODE_RETRIEVAL_QUERY"
  ]).optional(),
  /**
   * Optional. The title of the document being embedded.
   * Only valid when task_type is set to 'RETRIEVAL_DOCUMENT'.
   * Helps the model produce better embeddings by providing additional context.
   */
  title: z2.string().optional(),
  /**
   * Optional. When set to true, input text will be truncated. When set to false,
   * an error is returned if the input text is longer than the maximum length supported by the model. Defaults to true.
   */
  autoTruncate: z2.boolean().optional()
});

// src/google-vertex-embedding-model.ts
var GoogleVertexEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a;
    const googleOptions = (_a = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleVertexEmbeddingProviderOptions
    })) != null ? _a : {};
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const mergedHeaders = combineHeaders(
      await resolve(this.config.headers),
      headers
    );
    const url = `${this.config.baseURL}/models/${this.modelId}:predict`;
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi({
      url,
      headers: mergedHeaders,
      body: {
        instances: values.map((value) => ({
          content: value,
          task_type: googleOptions.taskType,
          title: googleOptions.title
        })),
        parameters: {
          outputDimensionality: googleOptions.outputDimensionality,
          autoTruncate: googleOptions.autoTruncate
        }
      },
      failedResponseHandler: googleVertexFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        googleVertexTextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.predictions.map(
        (prediction) => prediction.embeddings.values
      ),
      usage: {
        tokens: response.predictions.reduce(
          (tokenCount, prediction) => tokenCount + prediction.embeddings.statistics.token_count,
          0
        )
      },
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var googleVertexTextEmbeddingResponseSchema = z3.object({
  predictions: z3.array(
    z3.object({
      embeddings: z3.object({
        values: z3.array(z3.number()),
        statistics: z3.object({
          token_count: z3.number()
        })
      })
    })
  )
});

// src/google-vertex-image-model.ts
import {
  combineHeaders as combineHeaders2,
  createJsonResponseHandler as createJsonResponseHandler2,
  parseProviderOptions as parseProviderOptions2,
  postJsonToApi as postJsonToApi2,
  resolve as resolve2
} from "@ai-sdk/provider-utils";
import { z as z4 } from "zod/v4";
var GoogleVertexImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    // https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api#parameter_list
    this.maxImagesPerCall = 4;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a, _b, _c, _d, _e, _f, _g;
    const warnings = [];
    if (size != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "size",
        details: "This model does not support the `size` option. Use `aspectRatio` instead."
      });
    }
    const vertexImageOptions = await parseProviderOptions2({
      provider: "vertex",
      providerOptions,
      schema: vertexImageProviderOptionsSchema
    });
    const body = {
      instances: [{ prompt }],
      parameters: {
        sampleCount: n,
        ...aspectRatio != null ? { aspectRatio } : {},
        ...seed != null ? { seed } : {},
        ...vertexImageOptions != null ? vertexImageOptions : {}
      }
    };
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: `${this.config.baseURL}/models/${this.modelId}:predict`,
      headers: combineHeaders2(await resolve2(this.config.headers), headers),
      body,
      failedResponseHandler: googleVertexFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(
        vertexImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: (_e = (_d = response.predictions) == null ? void 0 : _d.map(
        ({ bytesBase64Encoded }) => bytesBase64Encoded
      )) != null ? _e : [],
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      },
      providerMetadata: {
        vertex: {
          images: (_g = (_f = response.predictions) == null ? void 0 : _f.map((prediction) => {
            const {
              // normalize revised prompt property
              prompt: revisedPrompt
            } = prediction;
            return { ...revisedPrompt != null && { revisedPrompt } };
          })) != null ? _g : []
        }
      }
    };
  }
};
var vertexImageResponseSchema = z4.object({
  predictions: z4.array(
    z4.object({
      bytesBase64Encoded: z4.string(),
      mimeType: z4.string(),
      prompt: z4.string().nullish()
    })
  ).nullish()
});
var vertexImageProviderOptionsSchema = z4.object({
  negativePrompt: z4.string().nullish(),
  personGeneration: z4.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
  safetySetting: z4.enum([
    "block_low_and_above",
    "block_medium_and_above",
    "block_only_high",
    "block_none"
  ]).nullish(),
  addWatermark: z4.boolean().nullish(),
  storageUri: z4.string().nullish(),
  sampleImageSize: z4.enum(["1K", "2K"]).nullish()
});

// src/google-vertex-tools.ts
import { googleTools } from "@ai-sdk/google/internal";
var googleVertexTools = {
  googleSearch: googleTools.googleSearch,
  enterpriseWebSearch: googleTools.enterpriseWebSearch,
  googleMaps: googleTools.googleMaps,
  urlContext: googleTools.urlContext,
  fileSearch: googleTools.fileSearch,
  codeExecution: googleTools.codeExecution,
  vertexRagStore: googleTools.vertexRagStore
};

// src/google-vertex-provider.ts
function createVertex(options = {}) {
  const loadVertexProject = () => loadSetting({
    settingValue: options.project,
    settingName: "project",
    environmentVariableName: "GOOGLE_VERTEX_PROJECT",
    description: "Google Vertex project"
  });
  const loadVertexLocation = () => loadSetting({
    settingValue: options.location,
    settingName: "location",
    environmentVariableName: "GOOGLE_VERTEX_LOCATION",
    description: "Google Vertex location"
  });
  const loadBaseURL = () => {
    var _a;
    const region = loadVertexLocation();
    const project = loadVertexProject();
    const baseHost = `${region === "global" ? "" : region + "-"}aiplatform.googleapis.com`;
    return (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : `https://${baseHost}/v1beta1/projects/${project}/locations/${region}/publishers/google`;
  };
  const createConfig = (name) => {
    const getHeaders = async () => {
      var _a;
      const originalHeaders = await resolve3((_a = options.headers) != null ? _a : {});
      return withUserAgentSuffix(
        originalHeaders,
        `ai-sdk/google-vertex/${VERSION}`
      );
    };
    return {
      provider: `google.vertex.${name}`,
      headers: getHeaders,
      fetch: options.fetch,
      baseURL: loadBaseURL()
    };
  };
  const createChatModel = (modelId) => {
    var _a;
    return new GoogleGenerativeAILanguageModel(modelId, {
      ...createConfig("chat"),
      generateId: (_a = options.generateId) != null ? _a : generateId,
      supportedUrls: () => ({
        "*": [
          // HTTP URLs:
          /^https?:\/\/.*$/,
          // Google Cloud Storage URLs:
          /^gs:\/\/.*$/
        ]
      })
    });
  };
  const createEmbeddingModel = (modelId) => new GoogleVertexEmbeddingModel(modelId, createConfig("embedding"));
  const createImageModel = (modelId) => new GoogleVertexImageModel(modelId, createConfig("image"));
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Vertex AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = googleVertexTools;
  return provider;
}

// src/edge/google-vertex-auth-edge.ts
import {
  loadOptionalSetting,
  loadSetting as loadSetting2,
  withUserAgentSuffix as withUserAgentSuffix2,
  getRuntimeEnvironmentUserAgent
} from "@ai-sdk/provider-utils";
var loadCredentials = async () => {
  try {
    return {
      clientEmail: loadSetting2({
        settingValue: void 0,
        settingName: "clientEmail",
        environmentVariableName: "GOOGLE_CLIENT_EMAIL",
        description: "Google client email"
      }),
      privateKey: loadSetting2({
        settingValue: void 0,
        settingName: "privateKey",
        environmentVariableName: "GOOGLE_PRIVATE_KEY",
        description: "Google private key"
      }),
      privateKeyId: loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "GOOGLE_PRIVATE_KEY_ID"
      })
    };
  } catch (error) {
    throw new Error(`Failed to load Google credentials: ${error.message}`);
  }
};
var base64url = (str) => {
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
};
var importPrivateKey = async (pemKey) => {
  const pemHeader = "-----BEGIN PRIVATE KEY-----";
  const pemFooter = "-----END PRIVATE KEY-----";
  const pemContents = pemKey.replace(pemHeader, "").replace(pemFooter, "").replace(/\s/g, "");
  const binaryString = atob(pemContents);
  const binaryData = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    binaryData[i] = binaryString.charCodeAt(i);
  }
  return await crypto.subtle.importKey(
    "pkcs8",
    binaryData,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    true,
    ["sign"]
  );
};
var buildJwt = async (credentials) => {
  const now = Math.floor(Date.now() / 1e3);
  const header = {
    alg: "RS256",
    typ: "JWT"
  };
  if (credentials.privateKeyId) {
    header.kid = credentials.privateKeyId;
  }
  const payload = {
    iss: credentials.clientEmail,
    scope: "https://www.googleapis.com/auth/cloud-platform",
    aud: "https://oauth2.googleapis.com/token",
    exp: now + 3600,
    iat: now
  };
  const privateKey = await importPrivateKey(credentials.privateKey);
  const signingInput = `${base64url(JSON.stringify(header))}.${base64url(
    JSON.stringify(payload)
  )}`;
  const encoder = new TextEncoder();
  const data = encoder.encode(signingInput);
  const signature = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    privateKey,
    data
  );
  const signatureBase64 = base64url(
    String.fromCharCode(...new Uint8Array(signature))
  );
  return `${base64url(JSON.stringify(header))}.${base64url(
    JSON.stringify(payload)
  )}.${signatureBase64}`;
};
async function generateAuthToken(credentials) {
  try {
    const creds = credentials || await loadCredentials();
    const jwt = await buildJwt(creds);
    const response = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: withUserAgentSuffix2(
        { "Content-Type": "application/x-www-form-urlencoded" },
        `ai-sdk/google-vertex/${VERSION}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: new URLSearchParams({
        grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
        assertion: jwt
      })
    });
    if (!response.ok) {
      throw new Error(`Token request failed: ${response.statusText}`);
    }
    const data = await response.json();
    return data.access_token;
  } catch (error) {
    throw error;
  }
}

// src/edge/google-vertex-provider-edge.ts
function createVertex2(options = {}) {
  return createVertex({
    ...options,
    headers: async () => ({
      Authorization: `Bearer ${await generateAuthToken(
        options.googleCredentials
      )}`,
      ...await resolve4(options.headers)
    })
  });
}
var vertex = createVertex2();
export {
  createVertex2 as createVertex,
  vertex
};
//# sourceMappingURL=index.mjs.map