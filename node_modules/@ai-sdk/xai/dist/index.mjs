// src/xai-provider.ts
import {
  OpenAICompatibleImageModel
} from "@ai-sdk/openai-compatible";
import {
  NoSuchModelError
} from "@ai-sdk/provider";
import {
  generateId,
  loadApiKey,
  withoutTrailingSlash,
  withUserAgentSuffix
} from "@ai-sdk/provider-utils";

// src/xai-chat-language-model.ts
import {
  combineHeaders,
  createEventSourceResponseHandler,
  createJsonResponseHandler,
  parseProviderOptions,
  postJsonToApi
} from "@ai-sdk/provider-utils";
import { z as z3 } from "zod/v4";

// src/convert-to-xai-chat-messages.ts
import {
  UnsupportedFunctionalityError
} from "@ai-sdk/provider";
import { convertToBase64 } from "@ai-sdk/provider-utils";
function convertToXaiChatMessages(prompt) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}

// src/get-response-metadata.ts
function getResponseMetadata({
  id,
  model,
  created,
  created_at
}) {
  const unixTime = created != null ? created : created_at;
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: unixTime != null ? new Date(unixTime * 1e3) : void 0
  };
}

// src/map-xai-finish-reason.ts
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}

// src/xai-chat-options.ts
import { z } from "zod/v4";
var webSourceSchema = z.object({
  type: z.literal("web"),
  country: z.string().length(2).optional(),
  excludedWebsites: z.array(z.string()).max(5).optional(),
  allowedWebsites: z.array(z.string()).max(5).optional(),
  safeSearch: z.boolean().optional()
});
var xSourceSchema = z.object({
  type: z.literal("x"),
  excludedXHandles: z.array(z.string()).optional(),
  includedXHandles: z.array(z.string()).optional(),
  postFavoriteCount: z.number().int().optional(),
  postViewCount: z.number().int().optional(),
  /**
   * @deprecated use `includedXHandles` instead
   */
  xHandles: z.array(z.string()).optional()
});
var newsSourceSchema = z.object({
  type: z.literal("news"),
  country: z.string().length(2).optional(),
  excludedWebsites: z.array(z.string()).max(5).optional(),
  safeSearch: z.boolean().optional()
});
var rssSourceSchema = z.object({
  type: z.literal("rss"),
  links: z.array(z.string().url()).max(1)
  // currently only supports one RSS link
});
var searchSourceSchema = z.discriminatedUnion("type", [
  webSourceSchema,
  xSourceSchema,
  newsSourceSchema,
  rssSourceSchema
]);
var xaiProviderOptions = z.object({
  reasoningEffort: z.enum(["low", "high"]).optional(),
  /**
   * Whether to enable parallel function calling during tool use.
   * When true, the model can call multiple functions in parallel.
   * When false, the model will call functions sequentially.
   * Defaults to true.
   */
  parallel_function_calling: z.boolean().optional(),
  searchParameters: z.object({
    /**
     * search mode preference
     * - "off": disables search completely
     * - "auto": model decides whether to search (default)
     * - "on": always enables search
     */
    mode: z.enum(["off", "auto", "on"]),
    /**
     * whether to return citations in the response
     * defaults to true
     */
    returnCitations: z.boolean().optional(),
    /**
     * start date for search data (ISO8601 format: YYYY-MM-DD)
     */
    fromDate: z.string().optional(),
    /**
     * end date for search data (ISO8601 format: YYYY-MM-DD)
     */
    toDate: z.string().optional(),
    /**
     * maximum number of search results to consider
     * defaults to 20
     */
    maxSearchResults: z.number().min(1).max(50).optional(),
    /**
     * data sources to search from.
     * defaults to [{ type: 'web' }, { type: 'x' }] if not specified.
     *
     * @example
     * sources: [{ type: 'web', country: 'US' }, { type: 'x' }]
     */
    sources: z.array(searchSourceSchema).optional()
  }).optional()
});

// src/xai-error.ts
import { createJsonErrorResponseHandler } from "@ai-sdk/provider-utils";
import { z as z2 } from "zod/v4";
var xaiErrorDataSchema = z2.object({
  error: z2.object({
    message: z2.string(),
    type: z2.string().nullish(),
    param: z2.any().nullish(),
    code: z2.union([z2.string(), z2.number()]).nullish()
  })
});
var xaiFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});

// src/xai-prepare-tools.ts
import {
  UnsupportedFunctionalityError as UnsupportedFunctionalityError2
} from "@ai-sdk/provider";
function prepareTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      xaiTools2.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools2,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError2({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/xai-chat-language-model.ts
var XaiChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    seed,
    responseFormat,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a, _b, _c;
    const warnings = [];
    const options = (_a = await parseProviderOptions({
      provider: "xai",
      providerOptions,
      schema: xaiProviderOptions
    })) != null ? _a : {};
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
    warnings.push(...messageWarnings);
    const {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = prepareTools({
      tools,
      toolChoice
    });
    warnings.push(...toolWarnings);
    const baseArgs = {
      // model id
      model: this.modelId,
      // standard generation settings
      max_completion_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      seed,
      reasoning_effort: options.reasoningEffort,
      // parallel function calling
      parallel_function_calling: options.parallel_function_calling,
      // response format
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: {
          name: (_b = responseFormat.name) != null ? _b : "response",
          schema: responseFormat.schema,
          strict: true
        }
      } : { type: "json_object" } : void 0,
      // search parameters
      search_parameters: options.searchParameters ? {
        mode: options.searchParameters.mode,
        return_citations: options.searchParameters.returnCitations,
        from_date: options.searchParameters.fromDate,
        to_date: options.searchParameters.toDate,
        max_search_results: options.searchParameters.maxSearchResults,
        sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
          var _a2;
          return {
            type: source.type,
            ...source.type === "web" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              allowed_websites: source.allowedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "x" && {
              excluded_x_handles: source.excludedXHandles,
              included_x_handles: (_a2 = source.includedXHandles) != null ? _a2 : source.xHandles,
              post_favorite_count: source.postFavoriteCount,
              post_view_count: source.postViewCount
            },
            ...source.type === "news" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "rss" && {
              links: source.links
            }
          };
        })
      } : void 0,
      // messages in xai format
      messages,
      // tools in xai format
      tools: xaiTools2,
      tool_choice: xaiToolChoice
    };
    return {
      args: baseArgs,
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e;
    const { args: body, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        xaiChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    if (choice.message.content != null && choice.message.content.length > 0) {
      let text = choice.message.content;
      const lastMessage = body.messages[body.messages.length - 1];
      if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text === lastMessage.content) {
        text = "";
      }
      if (text.length > 0) {
        content.push({ type: "text", text });
      }
    }
    if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
      content.push({
        type: "reasoning",
        text: choice.message.reasoning_content
      });
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    if (response.citations != null) {
      for (const url of response.citations) {
        content.push({
          type: "source",
          sourceType: "url",
          id: this.config.generateId(),
          url
        });
      }
    }
    return {
      content,
      finishReason: mapXaiFinishReason(choice.finish_reason),
      usage: {
        inputTokens: response.usage.prompt_tokens,
        outputTokens: response.usage.completion_tokens,
        totalTokens: response.usage.total_tokens,
        reasoningTokens: (_c = (_b = response.usage.completion_tokens_details) == null ? void 0 : _b.reasoning_tokens) != null ? _c : void 0,
        cachedInputTokens: (_e = (_d = response.usage.prompt_tokens_details) == null ? void 0 : _d.cached_tokens) != null ? _e : void 0
      },
      request: { body },
      response: {
        ...getResponseMetadata(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a;
    const { args, warnings } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      stream_options: {
        include_usage: true
      }
    };
    const { responseHeaders, value: response } = await postJsonToApi({
      url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(xaiChatChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0,
      reasoningTokens: void 0,
      cachedInputTokens: void 0
    };
    let isFirstChunk = true;
    const contentBlocks = {};
    const lastReasoningDeltas = {};
    const self = this;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a2, _b, _c, _d;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isFirstChunk) {
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata(value)
              });
              isFirstChunk = false;
            }
            if (value.citations != null) {
              for (const url of value.citations) {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: self.config.generateId(),
                  url
                });
              }
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.total_tokens;
              usage.reasoningTokens = (_b = (_a2 = value.usage.completion_tokens_details) == null ? void 0 : _a2.reasoning_tokens) != null ? _b : void 0;
              usage.cachedInputTokens = (_d = (_c = value.usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : void 0;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapXaiFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const choiceIndex = choice.index;
            if (delta.content != null && delta.content.length > 0) {
              const textContent = delta.content;
              const lastMessage = body.messages[body.messages.length - 1];
              if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                return;
              }
              const blockId = `text-${value.id || choiceIndex}`;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "text" };
                controller.enqueue({
                  type: "text-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "text-delta",
                id: blockId,
                delta: textContent
              });
            }
            if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
              const blockId = `reasoning-${value.id || choiceIndex}`;
              if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                return;
              }
              lastReasoningDeltas[blockId] = delta.reasoning_content;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "reasoning" };
                controller.enqueue({
                  type: "reasoning-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: blockId,
                delta: delta.reasoning_content
              });
            }
            if (delta.tool_calls != null) {
              for (const toolCall of delta.tool_calls) {
                const toolCallId = toolCall.id;
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCallId,
                  toolName: toolCall.function.name
                });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCallId,
                  delta: toolCall.function.arguments
                });
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCallId
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId,
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
              }
            }
          },
          flush(controller) {
            for (const [blockId, block] of Object.entries(contentBlocks)) {
              controller.enqueue({
                type: block.type === "text" ? "text-end" : "reasoning-end",
                id: blockId
              });
            }
            controller.enqueue({ type: "finish", finishReason, usage });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var xaiUsageSchema = z3.object({
  prompt_tokens: z3.number(),
  completion_tokens: z3.number(),
  total_tokens: z3.number(),
  prompt_tokens_details: z3.object({
    text_tokens: z3.number().nullish(),
    audio_tokens: z3.number().nullish(),
    image_tokens: z3.number().nullish(),
    cached_tokens: z3.number().nullish()
  }).nullish(),
  completion_tokens_details: z3.object({
    reasoning_tokens: z3.number().nullish(),
    audio_tokens: z3.number().nullish(),
    accepted_prediction_tokens: z3.number().nullish(),
    rejected_prediction_tokens: z3.number().nullish()
  }).nullish()
});
var xaiChatResponseSchema = z3.object({
  id: z3.string().nullish(),
  created: z3.number().nullish(),
  model: z3.string().nullish(),
  choices: z3.array(
    z3.object({
      message: z3.object({
        role: z3.literal("assistant"),
        content: z3.string().nullish(),
        reasoning_content: z3.string().nullish(),
        tool_calls: z3.array(
          z3.object({
            id: z3.string(),
            type: z3.literal("function"),
            function: z3.object({
              name: z3.string(),
              arguments: z3.string()
            })
          })
        ).nullish()
      }),
      index: z3.number(),
      finish_reason: z3.string().nullish()
    })
  ),
  object: z3.literal("chat.completion"),
  usage: xaiUsageSchema,
  citations: z3.array(z3.string().url()).nullish()
});
var xaiChatChunkSchema = z3.object({
  id: z3.string().nullish(),
  created: z3.number().nullish(),
  model: z3.string().nullish(),
  choices: z3.array(
    z3.object({
      delta: z3.object({
        role: z3.enum(["assistant"]).optional(),
        content: z3.string().nullish(),
        reasoning_content: z3.string().nullish(),
        tool_calls: z3.array(
          z3.object({
            id: z3.string(),
            type: z3.literal("function"),
            function: z3.object({
              name: z3.string(),
              arguments: z3.string()
            })
          })
        ).nullish()
      }),
      finish_reason: z3.string().nullish(),
      index: z3.number()
    })
  ),
  usage: xaiUsageSchema.nullish(),
  citations: z3.array(z3.string().url()).nullish()
});

// src/responses/xai-responses-language-model.ts
import {
  combineHeaders as combineHeaders2,
  createEventSourceResponseHandler as createEventSourceResponseHandler2,
  createJsonResponseHandler as createJsonResponseHandler2,
  parseProviderOptions as parseProviderOptions2,
  postJsonToApi as postJsonToApi2
} from "@ai-sdk/provider-utils";

// src/responses/xai-responses-api.ts
import { z as z4 } from "zod/v4";
var annotationSchema = z4.union([
  z4.object({
    type: z4.literal("url_citation"),
    url: z4.string(),
    title: z4.string().optional()
  }),
  z4.object({
    type: z4.string()
  })
]);
var messageContentPartSchema = z4.object({
  type: z4.string(),
  text: z4.string().optional(),
  logprobs: z4.array(z4.any()).optional(),
  annotations: z4.array(annotationSchema).optional()
});
var reasoningSummaryPartSchema = z4.object({
  type: z4.string(),
  text: z4.string()
});
var toolCallSchema = z4.object({
  name: z4.string().optional(),
  arguments: z4.string().optional(),
  input: z4.string().optional(),
  call_id: z4.string().optional(),
  id: z4.string(),
  status: z4.string(),
  action: z4.any().optional()
});
var outputItemSchema = z4.discriminatedUnion("type", [
  z4.object({
    type: z4.literal("web_search_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("x_search_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("code_interpreter_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("code_execution_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("view_image_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("view_x_video_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("custom_tool_call"),
    ...toolCallSchema.shape
  }),
  z4.object({
    type: z4.literal("message"),
    role: z4.string(),
    content: z4.array(messageContentPartSchema),
    id: z4.string(),
    status: z4.string()
  }),
  z4.object({
    type: z4.literal("function_call"),
    name: z4.string(),
    arguments: z4.string(),
    call_id: z4.string(),
    id: z4.string()
  }),
  z4.object({
    type: z4.literal("reasoning"),
    id: z4.string(),
    summary: z4.array(reasoningSummaryPartSchema),
    status: z4.string()
  })
]);
var xaiResponsesUsageSchema = z4.object({
  input_tokens: z4.number(),
  output_tokens: z4.number(),
  total_tokens: z4.number().optional(),
  input_tokens_details: z4.object({
    cached_tokens: z4.number().optional()
  }).optional(),
  output_tokens_details: z4.object({
    reasoning_tokens: z4.number().optional()
  }).optional(),
  num_sources_used: z4.number().optional(),
  num_server_side_tools_used: z4.number().optional()
});
var xaiResponsesResponseSchema = z4.object({
  id: z4.string().nullish(),
  created_at: z4.number().nullish(),
  model: z4.string().nullish(),
  object: z4.literal("response"),
  output: z4.array(outputItemSchema),
  usage: xaiResponsesUsageSchema,
  status: z4.string()
});
var xaiResponsesChunkSchema = z4.union([
  z4.object({
    type: z4.literal("response.created"),
    response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
  }),
  z4.object({
    type: z4.literal("response.in_progress"),
    response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
  }),
  z4.object({
    type: z4.literal("response.output_item.added"),
    item: outputItemSchema,
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.output_item.done"),
    item: outputItemSchema,
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.content_part.added"),
    item_id: z4.string(),
    output_index: z4.number(),
    content_index: z4.number(),
    part: messageContentPartSchema
  }),
  z4.object({
    type: z4.literal("response.content_part.done"),
    item_id: z4.string(),
    output_index: z4.number(),
    content_index: z4.number(),
    part: messageContentPartSchema
  }),
  z4.object({
    type: z4.literal("response.output_text.delta"),
    item_id: z4.string(),
    output_index: z4.number(),
    content_index: z4.number(),
    delta: z4.string(),
    logprobs: z4.array(z4.any()).optional()
  }),
  z4.object({
    type: z4.literal("response.output_text.done"),
    item_id: z4.string(),
    output_index: z4.number(),
    content_index: z4.number(),
    text: z4.string(),
    logprobs: z4.array(z4.any()).optional(),
    annotations: z4.array(annotationSchema).optional()
  }),
  z4.object({
    type: z4.literal("response.output_text.annotation.added"),
    item_id: z4.string(),
    output_index: z4.number(),
    content_index: z4.number(),
    annotation_index: z4.number(),
    annotation: annotationSchema
  }),
  z4.object({
    type: z4.literal("response.reasoning_summary_part.added"),
    item_id: z4.string(),
    output_index: z4.number(),
    summary_index: z4.number(),
    part: reasoningSummaryPartSchema
  }),
  z4.object({
    type: z4.literal("response.reasoning_summary_part.done"),
    item_id: z4.string(),
    output_index: z4.number(),
    summary_index: z4.number(),
    part: reasoningSummaryPartSchema
  }),
  z4.object({
    type: z4.literal("response.reasoning_summary_text.delta"),
    item_id: z4.string(),
    output_index: z4.number(),
    summary_index: z4.number(),
    delta: z4.string()
  }),
  z4.object({
    type: z4.literal("response.reasoning_summary_text.done"),
    item_id: z4.string(),
    output_index: z4.number(),
    summary_index: z4.number(),
    text: z4.string()
  }),
  z4.object({
    type: z4.literal("response.web_search_call.in_progress"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.web_search_call.searching"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.web_search_call.completed"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.x_search_call.in_progress"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.x_search_call.searching"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.x_search_call.completed"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_execution_call.in_progress"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_execution_call.executing"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_execution_call.completed"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_interpreter_call.in_progress"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_interpreter_call.executing"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.code_interpreter_call.completed"),
    item_id: z4.string(),
    output_index: z4.number()
  }),
  z4.object({
    type: z4.literal("response.done"),
    response: xaiResponsesResponseSchema
  }),
  z4.object({
    type: z4.literal("response.completed"),
    response: xaiResponsesResponseSchema
  })
]);

// src/responses/map-xai-responses-finish-reason.ts
function mapXaiResponsesFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "completed":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}

// src/responses/xai-responses-options.ts
import { z as z5 } from "zod/v4";
var xaiResponsesProviderOptions = z5.object({
  /**
   * Constrains how hard a reasoning model thinks before responding.
   * Possible values are `low` (uses fewer reasoning tokens), `medium` and `high` (uses more reasoning tokens).
   */
  reasoningEffort: z5.enum(["low", "medium", "high"]).optional(),
  /**
   * Whether to store the input message(s) and model response for later retrieval.
   * @default true
   */
  store: z5.boolean().optional(),
  /**
   * The ID of the previous response from the model.
   */
  previousResponseId: z5.string().optional()
});

// src/responses/convert-to-xai-responses-input.ts
async function convertToXaiResponsesInput({
  prompt
}) {
  var _a, _b, _c, _d;
  const input = [];
  const inputWarnings = [];
  for (const message of prompt) {
    switch (message.role) {
      case "system": {
        input.push({
          role: "system",
          content: message.content
        });
        break;
      }
      case "user": {
        let userContent = "";
        for (const block of message.content) {
          switch (block.type) {
            case "text": {
              userContent += block.text;
              break;
            }
            case "file": {
              inputWarnings.push({
                type: "other",
                message: `xAI Responses API does not support ${block.type} in user messages`
              });
              break;
            }
            default: {
              const _exhaustiveCheck = block;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in user messages"
              });
            }
          }
        }
        input.push({
          role: "user",
          content: userContent
        });
        break;
      }
      case "assistant": {
        for (const part of message.content) {
          switch (part.type) {
            case "text": {
              const id = typeof ((_b = (_a = part.providerOptions) == null ? void 0 : _a.xai) == null ? void 0 : _b.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                role: "assistant",
                content: part.text,
                id
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted) {
                break;
              }
              const id = typeof ((_d = (_c = part.providerOptions) == null ? void 0 : _c.xai) == null ? void 0 : _d.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                type: "function_call",
                id: id != null ? id : part.toolCallId,
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                status: "completed"
              });
              break;
            }
            case "tool-result": {
              break;
            }
            case "reasoning":
            case "file": {
              inputWarnings.push({
                type: "other",
                message: `xAI Responses API does not support ${part.type} in assistant messages`
              });
              break;
            }
            default: {
              const _exhaustiveCheck = part;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in assistant messages"
              });
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of message.content) {
          const output = part.output;
          let outputValue;
          switch (output.type) {
            case "text":
            case "error-text":
              outputValue = output.value;
              break;
            case "json":
            case "error-json":
              outputValue = JSON.stringify(output.value);
              break;
            case "content":
              outputValue = output.value.map((item) => {
                if (item.type === "text") {
                  return item.text;
                }
                return "";
              }).join("");
              break;
            default: {
              const _exhaustiveCheck = output;
              outputValue = "";
            }
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: outputValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = message;
        inputWarnings.push({
          type: "other",
          message: "unsupported message role"
        });
      }
    }
  }
  return { input, inputWarnings };
}

// src/responses/xai-responses-prepare-tools.ts
import {
  UnsupportedFunctionalityError as UnsupportedFunctionalityError3
} from "@ai-sdk/provider";
import { validateTypes } from "@ai-sdk/provider-utils";

// src/tool/web-search.ts
import {
  createProviderDefinedToolFactoryWithOutputSchema,
  lazySchema,
  zodSchema
} from "@ai-sdk/provider-utils";
import { z as z6 } from "zod/v4";
var webSearchArgsSchema = lazySchema(
  () => zodSchema(
    z6.object({
      allowedDomains: z6.array(z6.string()).max(5).optional(),
      excludedDomains: z6.array(z6.string()).max(5).optional(),
      enableImageUnderstanding: z6.boolean().optional()
    })
  )
);
var webSearchOutputSchema = lazySchema(
  () => zodSchema(
    z6.object({
      query: z6.string(),
      sources: z6.array(
        z6.object({
          title: z6.string(),
          url: z6.string(),
          snippet: z6.string()
        })
      )
    })
  )
);
var webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.web_search",
  name: "web_search",
  inputSchema: lazySchema(() => zodSchema(z6.object({}))),
  outputSchema: webSearchOutputSchema
});
var webSearch = (args = {}) => webSearchToolFactory(args);

// src/tool/x-search.ts
import {
  createProviderDefinedToolFactoryWithOutputSchema as createProviderDefinedToolFactoryWithOutputSchema2,
  lazySchema as lazySchema2,
  zodSchema as zodSchema2
} from "@ai-sdk/provider-utils";
import { z as z7 } from "zod/v4";
var xSearchArgsSchema = lazySchema2(
  () => zodSchema2(
    z7.object({
      allowedXHandles: z7.array(z7.string()).max(10).optional(),
      excludedXHandles: z7.array(z7.string()).max(10).optional(),
      fromDate: z7.string().optional(),
      toDate: z7.string().optional(),
      enableImageUnderstanding: z7.boolean().optional(),
      enableVideoUnderstanding: z7.boolean().optional()
    })
  )
);
var xSearchOutputSchema = lazySchema2(
  () => zodSchema2(
    z7.object({
      query: z7.string(),
      posts: z7.array(
        z7.object({
          author: z7.string(),
          text: z7.string(),
          url: z7.string(),
          likes: z7.number()
        })
      )
    })
  )
);
var xSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema2({
  id: "xai.x_search",
  name: "x_search",
  inputSchema: lazySchema2(() => zodSchema2(z7.object({}))),
  outputSchema: xSearchOutputSchema
});
var xSearch = (args = {}) => xSearchToolFactory(args);

// src/responses/xai-responses-prepare-tools.ts
async function prepareResponsesTools({
  tools,
  toolChoice
}) {
  const normalizedTools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (normalizedTools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  const toolByName = /* @__PURE__ */ new Map();
  for (const tool of normalizedTools) {
    toolByName.set(tool.name, tool);
    if (tool.type === "provider-defined") {
      switch (tool.id) {
        case "xai.web_search": {
          const args = await validateTypes({
            value: tool.args,
            schema: webSearchArgsSchema
          });
          xaiTools2.push({
            type: "web_search",
            allowed_domains: args.allowedDomains,
            excluded_domains: args.excludedDomains,
            enable_image_understanding: args.enableImageUnderstanding
          });
          break;
        }
        case "xai.x_search": {
          const args = await validateTypes({
            value: tool.args,
            schema: xSearchArgsSchema
          });
          xaiTools2.push({
            type: "x_search",
            allowed_x_handles: args.allowedXHandles,
            excluded_x_handles: args.excludedXHandles,
            from_date: args.fromDate,
            to_date: args.toDate,
            enable_image_understanding: args.enableImageUnderstanding,
            enable_video_understanding: args.enableVideoUnderstanding
          });
          break;
        }
        case "xai.code_execution": {
          xaiTools2.push({
            type: "code_interpreter"
          });
          break;
        }
        case "xai.view_image": {
          xaiTools2.push({
            type: "view_image"
          });
          break;
        }
        case "xai.view_x_video": {
          xaiTools2.push({
            type: "view_x_video"
          });
          break;
        }
        case "xai.file_search": {
          xaiTools2.push({
            type: "file_search"
          });
          break;
        }
        case "xai.mcp": {
          xaiTools2.push({
            type: "mcp"
          });
          break;
        }
        default: {
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
        }
      }
    } else {
      xaiTools2.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool": {
      const selectedTool = toolByName.get(toolChoice.toolName);
      if (selectedTool == null) {
        return {
          tools: xaiTools2,
          toolChoice: void 0,
          toolWarnings
        };
      }
      if (selectedTool.type === "provider-defined") {
        switch (selectedTool.id) {
          case "xai.web_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "web_search" },
              toolWarnings
            };
          case "xai.x_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "x_search" },
              toolWarnings
            };
          case "xai.code_execution":
            return {
              tools: xaiTools2,
              toolChoice: { type: "code_interpreter" },
              toolWarnings
            };
          case "xai.view_image":
            return {
              tools: xaiTools2,
              toolChoice: { type: "view_image" },
              toolWarnings
            };
          case "xai.view_x_video":
            return {
              tools: xaiTools2,
              toolChoice: { type: "view_x_video" },
              toolWarnings
            };
          case "xai.file_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "file_search" },
              toolWarnings
            };
          case "xai.mcp":
            return {
              tools: xaiTools2,
              toolChoice: { type: "mcp" },
              toolWarnings
            };
          default:
            toolWarnings.push({ type: "unsupported-tool", tool: selectedTool });
            return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
        }
      }
      return {
        tools: xaiTools2,
        toolChoice: { type: "function", name: selectedTool.name },
        toolWarnings
      };
    }
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError3({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/responses/xai-responses-language-model.ts
var XaiResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    stopSequences,
    seed,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    const options = (_a = await parseProviderOptions2({
      provider: "xai",
      providerOptions,
      schema: xaiResponsesProviderOptions
    })) != null ? _a : {};
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const webSearchToolName = (_b = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.web_search"
    )) == null ? void 0 : _b.name;
    const xSearchToolName = (_c = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.x_search"
    )) == null ? void 0 : _c.name;
    const codeExecutionToolName = (_d = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.code_execution"
    )) == null ? void 0 : _d.name;
    const { input, inputWarnings } = await convertToXaiResponsesInput({
      prompt,
      store: true
    });
    warnings.push(...inputWarnings);
    const {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = await prepareResponsesTools({
      tools,
      toolChoice
    });
    warnings.push(...toolWarnings);
    const baseArgs = {
      model: this.modelId,
      input,
      max_output_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      seed,
      ...options.reasoningEffort != null && {
        reasoning: { effort: options.reasoningEffort }
      },
      ...options.store === false && {
        store: options.store,
        include: ["reasoning.encrypted_content"]
      },
      ...options.previousResponseId != null && {
        previous_response_id: options.previousResponseId
      }
    };
    if (xaiTools2 && xaiTools2.length > 0) {
      baseArgs.tools = xaiTools2;
    }
    if (xaiToolChoice != null) {
      baseArgs.tool_choice = xaiToolChoice;
    }
    return {
      args: baseArgs,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const {
      args: body,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi2({
      url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/responses`,
      headers: combineHeaders2(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(
        xaiResponsesResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    const webSearchSubTools = [
      "web_search",
      "web_search_with_snippets",
      "browse_page"
    ];
    const xSearchSubTools = [
      "x_user_search",
      "x_keyword_search",
      "x_semantic_search",
      "x_thread_fetch"
    ];
    for (const part of response.output) {
      if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call") {
        let toolName = (_b = part.name) != null ? _b : "";
        if (webSearchSubTools.includes((_c = part.name) != null ? _c : "")) {
          toolName = webSearchToolName != null ? webSearchToolName : "web_search";
        } else if (xSearchSubTools.includes((_d = part.name) != null ? _d : "")) {
          toolName = xSearchToolName != null ? xSearchToolName : "x_search";
        } else if (part.name === "code_execution") {
          toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
        }
        const toolInput = part.type === "custom_tool_call" ? (_e = part.input) != null ? _e : "" : (_f = part.arguments) != null ? _f : "";
        content.push({
          type: "tool-call",
          toolCallId: part.id,
          toolName,
          input: toolInput,
          providerExecuted: true
        });
        continue;
      }
      switch (part.type) {
        case "message": {
          for (const contentPart of part.content) {
            if (contentPart.text) {
              content.push({
                type: "text",
                text: contentPart.text
              });
            }
            if (contentPart.annotations) {
              for (const annotation of contentPart.annotations) {
                if (annotation.type === "url_citation" && "url" in annotation) {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: this.config.generateId(),
                    url: annotation.url,
                    title: (_g = annotation.title) != null ? _g : annotation.url
                  });
                }
              }
            }
          }
          break;
        }
        case "function_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: part.name,
            input: part.arguments
          });
          break;
        }
        default: {
          break;
        }
      }
    }
    return {
      content,
      finishReason: mapXaiResponsesFinishReason(response.status),
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        totalTokens: response.usage.total_tokens,
        reasoningTokens: (_h = response.usage.output_tokens_details) == null ? void 0 : _h.reasoning_tokens
      },
      request: { body },
      response: {
        ...getResponseMetadata(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a;
    const {
      args,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true
    };
    const { responseHeaders, value: response } = await postJsonToApi2({
      url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/responses`,
      headers: combineHeaders2(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler2(
        xaiResponsesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    const contentBlocks = {};
    const seenToolCalls = /* @__PURE__ */ new Set();
    const self = this;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const event = chunk.value;
            if (event.type === "response.created" || event.type === "response.in_progress") {
              if (isFirstChunk) {
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata(event.response)
                });
                isFirstChunk = false;
              }
              return;
            }
            if (event.type === "response.reasoning_summary_part.added") {
              const blockId = `reasoning-${event.item_id}`;
              controller.enqueue({
                type: "reasoning-start",
                id: blockId
              });
            }
            if (event.type === "response.reasoning_summary_text.delta") {
              const blockId = `reasoning-${event.item_id}`;
              controller.enqueue({
                type: "reasoning-delta",
                id: blockId,
                delta: event.delta
              });
              return;
            }
            if (event.type === "response.reasoning_summary_text.done") {
              const blockId = `reasoning-${event.item_id}`;
              controller.enqueue({
                type: "reasoning-end",
                id: blockId
              });
            }
            if (event.type === "response.output_text.delta") {
              const blockId = `text-${event.item_id}`;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "text" };
                controller.enqueue({
                  type: "text-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "text-delta",
                id: blockId,
                delta: event.delta
              });
              return;
            }
            if (event.type === "response.output_text.done") {
              if (event.annotations) {
                for (const annotation of event.annotations) {
                  if (annotation.type === "url_citation" && "url" in annotation) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: self.config.generateId(),
                      url: annotation.url,
                      title: (_a2 = annotation.title) != null ? _a2 : annotation.url
                    });
                  }
                }
              }
              return;
            }
            if (event.type === "response.output_text.annotation.added") {
              const annotation = event.annotation;
              if (annotation.type === "url_citation" && "url" in annotation) {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: self.config.generateId(),
                  url: annotation.url,
                  title: (_b = annotation.title) != null ? _b : annotation.url
                });
              }
              return;
            }
            if (event.type === "response.done" || event.type === "response.completed") {
              const response2 = event.response;
              if (response2.usage) {
                usage.inputTokens = response2.usage.input_tokens;
                usage.outputTokens = response2.usage.output_tokens;
                usage.totalTokens = response2.usage.total_tokens;
                usage.reasoningTokens = (_c = response2.usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens;
              }
              if (response2.status) {
                finishReason = mapXaiResponsesFinishReason(response2.status);
              }
              return;
            }
            if (event.type === "response.output_item.added" || event.type === "response.output_item.done") {
              const part = event.item;
              if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call") {
                if (!seenToolCalls.has(part.id)) {
                  seenToolCalls.add(part.id);
                  const webSearchSubTools = [
                    "web_search",
                    "web_search_with_snippets",
                    "browse_page"
                  ];
                  const xSearchSubTools = [
                    "x_user_search",
                    "x_keyword_search",
                    "x_semantic_search",
                    "x_thread_fetch"
                  ];
                  let toolName = (_d = part.name) != null ? _d : "";
                  if (webSearchSubTools.includes((_e = part.name) != null ? _e : "")) {
                    toolName = webSearchToolName != null ? webSearchToolName : "web_search";
                  } else if (xSearchSubTools.includes((_f = part.name) != null ? _f : "")) {
                    toolName = xSearchToolName != null ? xSearchToolName : "x_search";
                  } else if (part.name === "code_execution") {
                    toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
                  }
                  const toolInput = part.type === "custom_tool_call" ? (_g = part.input) != null ? _g : "" : (_h = part.arguments) != null ? _h : "";
                  controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: part.id,
                    delta: toolInput
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: part.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName,
                    input: toolInput,
                    providerExecuted: true
                  });
                }
                return;
              }
              if (part.type === "message") {
                for (const contentPart of part.content) {
                  if (contentPart.text && contentPart.text.length > 0) {
                    const blockId = `text-${part.id}`;
                    if (contentBlocks[blockId] == null) {
                      contentBlocks[blockId] = { type: "text" };
                      controller.enqueue({
                        type: "text-start",
                        id: blockId
                      });
                    }
                    controller.enqueue({
                      type: "text-delta",
                      id: blockId,
                      delta: contentPart.text
                    });
                  }
                  if (contentPart.annotations) {
                    for (const annotation of contentPart.annotations) {
                      if (annotation.type === "url_citation" && "url" in annotation) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: self.config.generateId(),
                          url: annotation.url,
                          title: (_i = annotation.title) != null ? _i : annotation.url
                        });
                      }
                    }
                  }
                }
              } else if (part.type === "function_call") {
                if (!seenToolCalls.has(part.call_id)) {
                  seenToolCalls.add(part.call_id);
                  controller.enqueue({
                    type: "tool-input-start",
                    id: part.call_id,
                    toolName: part.name
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: part.call_id,
                    delta: part.arguments
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: part.call_id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: part.call_id,
                    toolName: part.name,
                    input: part.arguments
                  });
                }
              }
            }
          },
          flush(controller) {
            for (const [blockId, block] of Object.entries(contentBlocks)) {
              if (block.type === "text") {
                controller.enqueue({
                  type: "text-end",
                  id: blockId
                });
              }
            }
            controller.enqueue({ type: "finish", finishReason, usage });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};

// src/tool/code-execution.ts
import { createProviderDefinedToolFactoryWithOutputSchema as createProviderDefinedToolFactoryWithOutputSchema3 } from "@ai-sdk/provider-utils";
import { z as z8 } from "zod/v4";
var codeExecutionOutputSchema = z8.object({
  output: z8.string().describe("the output of the code execution"),
  error: z8.string().optional().describe("any error that occurred")
});
var codeExecutionToolFactory = createProviderDefinedToolFactoryWithOutputSchema3({
  id: "xai.code_execution",
  name: "code_execution",
  inputSchema: z8.object({}).describe("no input parameters"),
  outputSchema: codeExecutionOutputSchema
});
var codeExecution = (args = {}) => codeExecutionToolFactory(args);

// src/tool/view-image.ts
import { createProviderDefinedToolFactoryWithOutputSchema as createProviderDefinedToolFactoryWithOutputSchema4 } from "@ai-sdk/provider-utils";
import { z as z9 } from "zod/v4";
var viewImageOutputSchema = z9.object({
  description: z9.string().describe("description of the image"),
  objects: z9.array(z9.string()).optional().describe("objects detected in the image")
});
var viewImageToolFactory = createProviderDefinedToolFactoryWithOutputSchema4({
  id: "xai.view_image",
  name: "view_image",
  inputSchema: z9.object({}).describe("no input parameters"),
  outputSchema: viewImageOutputSchema
});
var viewImage = (args = {}) => viewImageToolFactory(args);

// src/tool/view-x-video.ts
import { createProviderDefinedToolFactoryWithOutputSchema as createProviderDefinedToolFactoryWithOutputSchema5 } from "@ai-sdk/provider-utils";
import { z as z10 } from "zod/v4";
var viewXVideoOutputSchema = z10.object({
  transcript: z10.string().optional().describe("transcript of the video"),
  description: z10.string().describe("description of the video content"),
  duration: z10.number().optional().describe("duration in seconds")
});
var viewXVideoToolFactory = createProviderDefinedToolFactoryWithOutputSchema5({
  id: "xai.view_x_video",
  name: "view_x_video",
  inputSchema: z10.object({}).describe("no input parameters"),
  outputSchema: viewXVideoOutputSchema
});
var viewXVideo = (args = {}) => viewXVideoToolFactory(args);

// src/tool/index.ts
var xaiTools = {
  codeExecution,
  viewImage,
  viewXVideo,
  webSearch,
  xSearch
};

// src/version.ts
var VERSION = true ? "2.0.43" : "0.0.0-test";

// src/xai-provider.ts
var xaiErrorStructure = {
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function createXai(options = {}) {
  var _a;
  const baseURL = withoutTrailingSlash(
    (_a = options.baseURL) != null ? _a : "https://api.x.ai/v1"
  );
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "XAI_API_KEY",
        description: "xAI API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/xai/${VERSION}`
  );
  const createChatLanguageModel = (modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const createResponsesLanguageModel = (modelId) => {
    return new XaiResponsesLanguageModel(modelId, {
      provider: "xai.responses",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  };
  const createImageModel = (modelId) => {
    return new OpenAICompatibleImageModel(modelId, {
      provider: "xai.image",
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  };
  const provider = (modelId) => createChatLanguageModel(modelId);
  provider.specificationVersion = "v2";
  provider.languageModel = createChatLanguageModel;
  provider.chat = createChatLanguageModel;
  provider.responses = createResponsesLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = createImageModel;
  provider.image = createImageModel;
  provider.tools = xaiTools;
  return provider;
}
var xai = createXai();
export {
  VERSION,
  codeExecution,
  createXai,
  viewImage,
  viewXVideo,
  webSearch,
  xSearch,
  xai,
  xaiTools
};
//# sourceMappingURL=index.mjs.map